(*===========================================================================*)
(*
 * CIL Module for splitting device drivers into a user-component and a
 * kernel-component, aka, "the beast". This assumes as input a completely
 * colored call-graph.
 *
 * This is the most complex file in our tool. Most of the complexity is in
 * the marshaling/demarshaling functions, which, though conceptually simple,
 * have to check for a *lot* of cases.
 *
 * Vinod Ganapathy <vg@cs.wisc.edu>, September 28, 2006.
 *)
(*===========================================================================*)

(* Desirable code cleanup activities:
 * 1. This file has gotten too big. An ideal way to restructure it might be
 *    to move marshaling code generation to another module, and have only
 *    the top-level splitting functions in this file.
 *
 *)
(*===========================================================================*)

open Cil
open Str
open Scanf
open Utils_dri
open Marshannot_dri (* Marshaannot: Support for marhsaling annotations *)
open Cgcomp_dri    (* Callgraph: we need this to find interface functions *)
open Costgraph_dri (* Costgraph: do we need this here? *)
open Marshal_dri   (* Marshaling analysis *)

(* The name of the function to lookup pointers in the hashtable *)
(* This will have to be set to different values, based upon whether
 * we're generating code in the user side or in the kernel side *)
let nooks_ptrlookup_fn = ref "DUMMY_pointer_lookup_function"

(* The name of the function used to explicitly allocate memory for
 * arrays. This again will have to be set to different values based
 * upon whether we're generating the kerndriver or the userdriver *)
let nooks_arrayalloc_fn = ref "DUMMY_array_alloc_function"

(* The name of the function used to register functions whose addresses
 * are taken with the object tracker *)
let nooks_registerfn_fn = ref "DUMMY_registerfn_function"

(* The name of the function used to store addresses of offsets into
 * structures. *)
let nooks_storeoffset_fn = ref "DUMMY_store_offset"

(* 64-bit Zero Integer *)
let zero64 = (Int64.of_int 0)

(* The same thing in expression form for unsigned zero64 *)
let zero64Uexp = Const(CInt64(zero64,IUInt,None))

(* The same thing in expression form, this time, signed *)
let zero64Sexp = (integer 0) (* Const(CInt64(zero64,IInt,None)) *)

(* Minus One *)
let minusone_exp = (integer (0 - 1))

(* Threshold_stackdepth: is the threshold of recursion of the marshaling
 * function that we can see before we report an infinite loop
 * ath_pci really does require a depth of 25 in order to marshal everything
 * without falsely detecting a loop.
 *)
let threshold_stackdepth = ref 25

(* User or Kern annotations for each function *)
let annotations : (string, string) Hashtbl.t = (Hashtbl.create 117)

(* List of functions implemented in Java *)
let java_funcs : string list ref = ref []

(* Hashtable storing varinfo->fundec mapping. Used in splitter_user *)
let varinfo_fundec : (varinfo, fundec) Hashtbl.t = (Hashtbl.create 117)

(* Hashtable storing the varinfos of functions that are called *)
let called_fun_varinfo : (varinfo, int) Hashtbl.t = (Hashtbl.create 117)

(* Functions that do not matter for splitting. User and Kernel can have
   individual copies of these functions.  By default we keep the prototype,
   If the function is also listed in the "delete_proto" list, then we remove
   the prototype as well.
*)
let nonstubbed_functions: (string, bool) Hashtbl.t = (Hashtbl.create 117)
let nonstubbed_functions_delete_proto: (string, bool) Hashtbl.t = (Hashtbl.create 117)

(* Names of interface functions. Only these need to be stubbed and exported *)
let interface_functions: (string, bool) Hashtbl.t = (Hashtbl.create 117)

(* Names and varinfos of functions that do not have fundecs *)
let funcs_with_no_fundecs: (string, varinfo) Hashtbl.t = (Hashtbl.create 117)

(* A hashtable that stores temprorary variables that have been generated so
   far *)
let temporary_variables: (string, varinfo) Hashtbl.t = (Hashtbl.create 117)

(* A hashtable that stores global variables that have been generated so far *)
let genglobal_variables: (string, varinfo) Hashtbl.t = (Hashtbl.create 117)

(* Marshaling stack: keeps track of the types being marshaled *)
let marshstack = ref []

(* Are we currently in a recursive access? *)
let rec_access = ref false

(* Declare the C struct for struct marshret_struct, the structure that we
 * use as a return value from our marshwrap functions. It contains a voidptr,
 * pointing to the buffer that stores the marshaled information, and an int,
 * which is a length field indicating the length of the voidptr. The variable
 * below is just the compinfo. We've to add this to the globals of the program
 * using GCompTags *)
let struct_marshret_buf = "buf"
let struct_marshret_len = "len"

let func_cons_struct_marshret (c: compinfo) =
  begin
    let field1 = (struct_marshret_buf, voidPtrType, None, [], locUnknown) in
    let field2 = (struct_marshret_len, intType, None, [], locUnknown) in
    [field1; field2]
  end

let struct_marshret_compinfo =
  (mkCompInfo true "marshret_struct" func_cons_struct_marshret [])

let marshret_buf = (getCompField struct_marshret_compinfo struct_marshret_buf)
let marshret_len = (getCompField struct_marshret_compinfo struct_marshret_len)


(* Declare the C struct for struct req_args, the structure that is used by
 * the unblock_user_thread function. It contains a function_id (int), a pointer
 * to the buffer that stores marshaled information (voidptr), and a length
 * field (int) *)
let struct_reqargs_funcid = "function_id"
let struct_reqargs_data = "data"
let struct_reqargs_length = "length"

let func_cons_struct_reqargs (c: compinfo) =
  begin
    let field1 = (struct_reqargs_funcid, intType, None, [], locUnknown) in
    let field2 = (struct_reqargs_data, voidPtrType, None, [], locUnknown) in
    let field3 = (struct_reqargs_length, intType, None, [], locUnknown) in
    [field1; field2; field3]
  end

let struct_reqargs_compinfo =
  (mkCompInfo true "req_args" func_cons_struct_reqargs [])
let struct_reqargs_typ = (TComp(struct_reqargs_compinfo, []))

let reqargs_funcid = (getCompField struct_reqargs_compinfo struct_reqargs_funcid)
let reqargs_data =   (getCompField struct_reqargs_compinfo struct_reqargs_data)
let reqargs_length = (getCompField struct_reqargs_compinfo struct_reqargs_length)

(* The name of the function to unblock the user thread *)
let unblock_user_thread_function_name = "unblock_user_thread"

(* The name of the function called by the userdaemon to call into the kernel *)
let disp_kern_function_name = "disp_kern"

(* Create and return the funcdec of the unblock_user_thread function *)
let get_unblock_user_thread_fundec () : fundec =
  begin
    let unblock_user_thread_fundec = (emptyFunction unblock_user_thread_function_name) in
    let unblock_user_thread_function_typ = TFun(voidType, Some([]), false, []) in
    (setFunctionType unblock_user_thread_fundec unblock_user_thread_function_typ);
    (ignore
       (makeFormalVar unblock_user_thread_fundec
          "rqargs"
          (TPtr(struct_reqargs_typ, []))));
    unblock_user_thread_fundec.svar.vstorage <- Extern;
    unblock_user_thread_fundec;
  end

let unblock_user_thread_function_typ () : typ =
  begin
    let unblock_user_thread_fundec = (get_unblock_user_thread_fundec()) in
    unblock_user_thread_fundec.svar.vtype;
  end

(* Create and return the fundec of the disp_kern function *)
let get_disp_kern_fundec () : fundec =
  begin
    let disp_kern_fundec = (emptyFunction disp_kern_function_name) in
    let disp_kern_function_typ = TFun(voidType, Some([]), false, []) in
    (setFunctionType disp_kern_fundec disp_kern_function_typ);
    (ignore
       (makeFormalVar disp_kern_fundec
          "rqargs"
          (TPtr(struct_reqargs_typ, []))));
    disp_kern_fundec.svar.vstorage <- Extern;
    disp_kern_fundec;
  end

let disp_kern_function_typ () : typ =
  begin
    let disp_kern_fundec = (get_disp_kern_fundec()) in
    disp_kern_fundec.svar.vtype;
  end

(* Utilities *)
let create_array_typ (t: typ) (l: int) : typ =
  begin
    (TArray(t, Some((integer l)), []));
  end

(* Get a hash value for a function name. This is used as its ID *)
let get_function_id (fname: string) : int = (Hashtbl.hash fname)

(* Get a hash value for a variable name *)
(*let get_lval_id (lv: lval) : int = (Hashtbl.hash lv) *)
let get_lval_id (lv: lval) : int = (Hashtbl.hash (lval_tostring lv))

(* Get a varinfo from an lval. Do this only if the lval has no offset.
 * Error otherwise *)
let obtain_varinfo_from_lval (lv: lval) : varinfo =
  begin
    let retval = ref (makeVarinfo true "dummy" intType) in
    let lvstr = (lval_tostring lv) in
    let (lh, off) = lv in
    (match off with
       | NoOffset ->
           (match lh with
              | Var(v) -> retval := v;
              | Mem(_) -> fatal ["obtain_varinfo_from_lval error 1"; lvstr];
           );
       | _ -> fatal ["obtain_varinfo_from_lval error 2"; lvstr];
    );
    !retval;
  end

(* Create an expression list from formal parameters *)
let expify_formals (formals: varinfo list) : exp list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length formals) - 1 do
      let ith = (List.nth formals i) in
      let ith_exp = (Lval(Var(ith),NoOffset)) in
      retval := (List.append !retval [ith_exp]);
    done;
    !retval;
  end

(* Ensure that the formals in an input fundec have names *)
let ensure_formals_have_names (fdec: fundec) : unit =
  begin
    let formals = fdec.sformals in
    let newformals = ref [] in
    let need_to_replace = ref false in
    for i = 0 to (List.length formals) - 1 do
      let ith = (List.nth formals i) in
      if (String.compare ith.vname "") = 0
      then begin
        ith.vname <- ("arg" ^ (itoa i));
        need_to_replace := true;
      end;
      newformals := (List.append !newformals [ith]);
    done;
    if (!need_to_replace = true)
    then (setFormals fdec !newformals);
  end

(* Strip the marshwrap_prefix from an input string *)
let strip_marshwrap_prefix (s: string) : string =
  begin
    let marshwrap_prefix_len = (String.length marshwrap_prefix) in
    let s_len = (String.length s) in
    let marshwrap_prefix_regexp = (Str.regexp marshwrap_prefix) in
    if (Str.string_match marshwrap_prefix_regexp s 0) = false
    then fatal["Cannot strip marshwrap_prefix in "; s];
    try
      (String.sub s marshwrap_prefix_len (s_len - marshwrap_prefix_len));
    with Invalid_argument(_) -> fatal[""];
  end

(* True if the string contains marshwrap_prefix, false otherwise. *)
let contains_marshwrap_prefix (s: string) : bool =
  begin
    let marshwrap_prefix_regexp = (Str.regexp marshwrap_prefix) in
    (Str.string_match marshwrap_prefix_regexp s 0);
  end

(** There is a list of functions that need not be split. That is, the user
 * space and kernel space each get a copy of this function. There is no need
 * to rename such functions. Should I rename this function?  The answer here
 * is true if it is not contained in nonstubbed_functions *)
let should_split (fnm: string) : bool =
  begin
    (* First see if the function is in the hash table *)
    try (ignore (Hashtbl.find nonstubbed_functions fnm)); false;
    with Not_found ->
      (* If it's not, then this is probably a normal function,
         unless it has a Java_ or Nonstub prefix, which means we
         added it specifically to deal with some Java problem, e.g.
         bit-field manipulations which XDR doesn't support, or
         for rich annotations, e.g. exp(test("blah"))
      *)
      (* So, we return true if we are supposed to generate
         marshaling code, false otherwise.  If the function
         begins with Java_/Nonstub, then we don't want to to
         generate marshaling code *)
      let java_prefix_regexp = Str.regexp "Java_" in
      let nonstub_prefix_regexp = Str.regexp "Nonstub_" in
      let sym_prefix_regexp = Str.regexp "Sym_" in
      let microdrivers_prefix_regexp = Str.regexp "MICRODRIVERS__" in
      not ((Str.string_match java_prefix_regexp fnm 0) ||
             (Str.string_match nonstub_prefix_regexp fnm 0) ||
             (Str.string_match sym_prefix_regexp fnm 0) ||
             (Str.string_match microdrivers_prefix_regexp fnm 0)
          );
  end

(** Return true if this is an interface function *)
let is_interface_function (fnm: string) : bool =
  begin
    try (ignore (Hashtbl.find interface_functions fnm)); true
    with Not_found -> (false);
  end


(*---------------------------------------------------------------------------*)
(* Utility functions that are used by both the marshaler and the demarshaler *)

(** Resolve an opaque formal parameter of a function. This function will check
 * that there is only one resolved type for the formal parameter. If there is
 * more than one resolved type, then it will emit a warning. This is simply a
 * helper function to traverse resform and return the list of types.
 *
 * NOTE: If there is a warning, this means that we must inspect it to resolve
 * the parameter appropriately, possibly replicating the function, specializing
 * it to each callsite.
 *)
let resolve_opaque_formal (v: varinfo)
    (fdec: fundec)
    (resform: (string, (int * varinfo * typ)) Hashtbl.t)
    : typ list =
  begin
    let ret = ref [] in
    let fname = ref fdec.svar.vname in
    let resl = (Hashtbl.find_all resform !fname) in
    for i = 0 to (List.length resl) - 1 do
      let (ithloc,ithvinfo,ithtyp) = (List.nth resl i) in
      ret := ithtyp::!ret;
    done;
    (* If the pointer does not resolve to exactly one target, check annotations *)
    if (List.length !ret) <> 1 then begin
      if (Marshannot_dri.is_opaque v.vtype) then
        ret := [(Marshannot_dri.resolve_opaque_with_annot v.vtype)];
    end;
    (* Still okay *)
    if (List.length !ret) > 1
    then (addwarn ["Formal"; v.vname; "of"; !fname; "resolves to >1 type"]);
    (* Not okay. This means that we potentially cannot generate any marshaling
     * code. At all places where a formal does not resolve, we must still
     * generate code to marshal/unmarshal the pointer itself. *)
    if (List.length !ret) = 0
    then (addwarn ["Formal"; v.vname; "of"; !fname; "does not resolve!"]);
    !ret;
  end

(** Resolve an opaque field of a struct. This will check that there is only one
 * resolved type for the field. If there are multiple, a warning will be
 * emitted. This is simply a helper function to traverse resfld and return the
 * list of types.
 *
 * NOTE: If there is a warning, this means that we must inspect it to resolve
 * the parameter appropriately, possibly replicating the function, specializing
 * it to each callsite. *)
let resolve_opaque_field (fdec: fundec)
    (resfld: (string, (typ * fieldinfo * typ)) Hashtbl.t)
    (t_comp: typ)
    (field: fieldinfo) : typ list =
  begin
    let ret = ref [] in
    let resl = (list_bindings resfld) in
    for i = 0 to (List.length resl) - 1 do
      let (ithtyp,ithfieldinfo,ithrestyp) = (List.nth resl i) in
      if (String.compare (typ_tostring_noattr t_comp) (typ_tostring_noattr ithtyp)) = 0 &&
        (String.compare field.fname ithfieldinfo.fname) = 0
      then ret := ithrestyp::!ret;
    done;
    (* If the pointer resolves to <> 1 target, check annotations *)
    if (List.length !ret) <> 1 then begin
      if (Marshannot_dri.is_opaque field.ftype) then
        ret := [(Marshannot_dri.resolve_opaque_with_annot field.ftype)];
    end;
    (* This case is unacceptable.  It means we have a void pointer that
       resolves to more than one type.  We can generate marshaling code,
       but this almost certainly represents an error, especially if the types
       are of a different size. *)
    if (List.length !ret) > 1
    then fatal (List.append
                  ["Field"; field.fname; "of"; (typ_tostring_noattr t_comp);
                   "resolved to"; (Printf.sprintf "%d" (List.length !ret));
                   "types in"; fdec.svar.vname; ".  Types include"]
                  (List.map (function param -> (Printf.sprintf "\"%s\"" param)) (List.map (typ_tostring) !ret))
               );
    (* Vinod says:
     * Not okay. This means that we potentially cannot generate any marshaling
     * code. We MUST resolve fields of data structures, either automatically,
     * or via annotations.
     *
     * Matt says:
     * What if it's IOMEM annotated?  We shouldn't be dereferencing it then.
     * What if it really is opaque, and we never dereference it?
     *)
    if (List.length !ret) = 0
    then (addwarn ["CHECK: PREVIOUSLY FATAL ERROR Field"; field.fname; "of"; (typ_tostring_noattr t_comp);
                 "did not resolve in"; fdec.svar.vname; ".  ";
                 "This means we have a void * that did not resolve to a type.  ";
                 "Are you using this variable anywhere?  No marshaling code is generated for it."]);
    !ret;
  end

(** Just get the names of the fields accessed. Return value will not
 * have repeated entries. It includes the type of access by the
 * function, either read, write, or arith.  If a given variable is
 * accessed via read and write, we include only the "write" access.
 * Only if a variable is "read" only, do we return "read."
 *
 * Note that we return a mixture of "write" and "arith."  We'll assume
 * these are equivalent in terms of what needs to be done.
 *)
let get_fields_accessed (ptg_query_result: (typ * string * string) list) :
    (typ * string * string) list =
  begin
    let nh : (string, (typ * string * string)) Hashtbl.t = (Hashtbl.create 5) in
    for i = 0 to (List.length ptg_query_result) - 1 do
      let ith = (List.nth ptg_query_result i) in
      let (ithtyp, ithfield, ithaccess) = ith in
      let hashkey = (typ_tostring_noattr ithtyp) ^ ithfield in

      if (String.compare ithaccess "read ") = 0 then
          (* Only add a "read" access if there is no access
             already present in the return *)
        add_if nh hashkey ith
      else
        begin
          (* Always add a "write", "arith", or any other
             exotic access (e.g. res_deref).

             Delete any existing entry if it's present.
          *)
          if (Hashtbl.mem nh hashkey) = true then
            (Hashtbl.remove nh hashkey);
          (Hashtbl.add nh hashkey ith)
        end
    done;
    let unordered = (list_bindings nh) in
    let ordered = (order_field_accesses unordered) in
    ordered;
  end

(** Get temporary variable: Both the marshaler and demarshaler may need
 * temporary variables. Get the temporary variable corresponding to an
 * lval. If no such temporary exists, manufacture one and return it
 * The first argument denotes the function's fundec, and the second
 * argument denotes the lval corresponding to which we want a temporary
 * The third one denotes the type of the lval. An optional HINT is to
 * be supplied to generate a variable name. *)
let get_temporary_variable (fdec: fundec)
    (lvopt: lval option)
    (t: typ)
    (hint: string) : varinfo =
  begin
    let lvalname = ref "" in
    (match lvopt with
       | Some(lv) -> lvalname := (lval_tostring lv);
       | None -> ();
    );
    let hashkey = fdec.svar.vname ^ hint ^ (typ_tostring_noattr t) ^ !lvalname in
    (try
       (Hashtbl.find temporary_variables hashkey);
     with Not_found -> (
       let newtempvar = (makeTempVar fdec ~name:(hint) t) in
       (Hashtbl.add temporary_variables hashkey newtempvar);
       newtempvar;
     ));
  end

(** Get local variable: Like get_temporary_variable, but exact name is used *)
let get_local_variable (fdec: fundec)
    (t: typ)
    (name: string) : varinfo =
  begin
    let hashkey = fdec.svar.vname ^ name ^ (typ_tostring_noattr t) in
    (try
       (Hashtbl.find temporary_variables hashkey);
     with Not_found -> (
       let newtempvar = (makeLocalVar fdec name t) in
       (Hashtbl.add temporary_variables hashkey newtempvar);
       newtempvar;
     ));
  end

(** Get global variable *)
let get_global_variable (t: typ)
    (hint: string) : varinfo =
  begin
    let hashkey = hint ^ (typ_tostring_noattr t) in
    (try
       (Hashtbl.find genglobal_variables hashkey);
     with Not_found -> (
       let newglobal = (makeGlobalVar hint t) in
       (Hashtbl.add genglobal_variables hashkey newglobal);
       newglobal;
     ));
  end

(** underef_lval: Take an LVAL of the form *p, and extract p. Only supports
 * *p's where p is an LVAL. Abort otherwise. No offsets allowed, as that does
 * not make sense for the context in which this function is supposed to be
 * used. *)
let underef_lval (lv: lval) : lval option =
  begin
    let retval = ref None in
    let (lh, off) = lv in
    (match lh with
       | Var(_) ->
           retval := None;
           (addwarn ["underef_lval: Nothing to underef"; (lval_tostring lv)]);
       | Mem(e) ->
           (match e with
              | Lval(elv) -> retval := Some(elv);
              | _ ->  retval := None;
                  let lval_str = (lval_tostring lv) in
                  (addwarn ["underef_lval: You passed me an exp that I don't support"; lval_str]);
           );
    );
    (* If the offset is NoOffset, we return a meaninful value. Else None *)
    (match off with
       | NoOffset -> ();
       | _ -> retval := None;
           let lval_str = (lval_tostring lv) in
           ((addwarn ["underef_lval: Passed an LVAL with an offset.";
                      "I don't understand what this means"; lval_str]));
    );
    !retval;
  end

(*---------------------------------------------------------------------------*)

let push_marshstack (s: string) =
  marshstack := (List.append [s] !marshstack)

let pop_marshstack () : unit =
  try
    marshstack := (List.tl !marshstack);
  with Failure("tl") -> fatal ["Attempt to pop an empty stack"];;

let is_on_marshstack (s: string) = (List.mem s !marshstack)

let marshstack_len () : int = (List.length !marshstack)

let set_recaccess() = rec_access := true
let clear_recaccess() = rec_access := false
let is_recaccess() = !rec_access

(**---------------------------------------------------------------------------*)
(** Marshaling code generator implementation *)

(* funcname is one of:
 * UP_MARSH_SEM - Allows the user daemon to continue
 * ACQUIRE_REC_LOCK - Acquires the recursive lock to prevent multiple kernel
 *   threads from executing in the userdaemon.
 * RELEASE_REC_LOCK - Releases the recursive lock.
*)
let generate_sync_call (funcname : string) : stmt list =
  begin
    let syncfuncname = funcname in
    let syncfundec = (emptyFunction syncfuncname) in
    let syncfunc = (expify_fundec syncfundec) in
    let call_syncfunc = Call(None, syncfunc, [], locUnknown) in
    let stmt_call_syncfunc = (mkStmt (Instr [call_syncfunc])) in
    [stmt_call_syncfunc];
  end

(** generate_get_container: This is borrowed from the code in the LInux kernel.
 * Inputs are: (1) an LVAL denoting a pointer to the member, (2) type of the
 * container struct, and (3) name of the member within the struct. Produce the
 * code produced by container_of. The fundec is the function in which we must
 * place the code. Conlv is the variable that is the container.*)
let generate_get_container_code (fdec: fundec)
    (ptr: lval)
    (contype: typ)
    (conlv: lval)
    (memopt: fieldinfo option) : stmt list =
  begin
    let retstmts = ref [] in
    (match memopt with
       | None -> retstmts := [];
       | Some(mem) ->
           let mptr_typ = (TPtr(mem.ftype, [])) in
           let mptr_var = (get_temporary_variable fdec None mptr_typ "__mptr") in
           let mptr_lv = (lvalify_varinfo mptr_var) in
           let mptr_exp = (expify_lval mptr_lv) in
           let set_mptr = (Set(mptr_lv, (expify_lval ptr), locUnknown)) in
           let stmt_set_mptr = (mkStmt (Instr [set_mptr])) in
           let nullexp_contype = (mkCast zero64Uexp contype) in
           let nullexp_mem = (mkMem nullexp_contype (Field(mem, NoOffset))) in
           let addrof_nullexp_mem = (mkAddrOf nullexp_mem) in
           let addrof_nullexp_mem_cast = (mkCast addrof_nullexp_mem uintType) in
           let mptr_cast = (mkCast mptr_exp charPtrType) in
           let calc_cont = (BinOp(MinusPP, mptr_cast, addrof_nullexp_mem_cast, voidPtrType)) in
           let cast_calc_cont = (mkCast calc_cont contype) in
           let set_contlv = (Set(conlv, cast_calc_cont, locUnknown)) in
           let stmt_set_contlv = (mkStmt (Instr [set_contlv])) in
           retstmts := [stmt_set_mptr; stmt_set_contlv];
    );
    !retstmts;
  end

(** generate_fillmarshbuf_ptr: Generate marshaling code filling up the
 * marshaling buffer with the value of a pointer. If we have a
 * OFFSETPTR pointer, then we generate marshaling code filling the
 * marshaling buffer with the integer value of the offset instead.  *)
let generate_fillmarshbuf_ptr (fdec: fundec)
    (tomarshal: lval)
    (tomarshal_typ: typ)
    (bufvar : varinfo)
    (currsize: varinfo) : stmt list =
  begin
    let marshptr_func_name = "fill_marshbuf_ptr" in
    let marshptr_fundec = (emptyFunction marshptr_func_name) in
    let marshptr_func = (expify_fundec marshptr_fundec) in
    let tgt_buf = (expify_lval (lvalify_varinfo bufvar)) in
    let currsize_var = mkAddrOf (lvalify_varinfo currsize) in
    let src_buf = (mkAddrOf tomarshal) in
    let argslist = [tgt_buf; currsize_var; src_buf] in
    let retval = (Some((lvalify_varinfo bufvar))) in
    let call_marshptr_func = Call(retval, marshptr_func, argslist, locUnknown) in
    let stmt_marshptr_call = (mkStmt (Instr [call_marshptr_func])) in
    [stmt_marshptr_call];
  end

(**---------------------------------------------------------------------------*)
(** Demarshaling code generator implementation *)

(** generate_nooks_arrayalloc_call:
 * Generate the call to allocate space for an array. The inputs to this
 * function are (i) lv: an Lval representing the pointer to the head of
 * of the array, which may be changed by the alloc call; (ii) size: a
 * varinfo, that stores the number of elements in the array; and (iii)
 * a type, representing the type of each element in the array.
 *)
let generate_nooks_arrayalloc_call (arrhd: lval)
    (size: exp)
    (elemtyp: typ)
    (storerange: bool) : stmt =
  begin
    let nooks_arrayalloc_fundec = (emptyFunction !nooks_arrayalloc_fn) in
    let nooks_arrayalloc_func = (expify_fundec nooks_arrayalloc_fundec) in
    let addrof_arrhd_exp = (mkCast (mkAddrOf arrhd) voidPtrType) in
    let length_arr_exp = size in
    let sizeof_typ = (SizeOf(elemtyp)) in
    let rangestore = ref (integer 0) in
    if storerange = true then rangestore := (integer 1);
    let argslist = [addrof_arrhd_exp; length_arr_exp; sizeof_typ; !rangestore] in
    let call_nooks_arrayalloc_func =
      Call(None, nooks_arrayalloc_func, argslist, locUnknown) in
    let stmt_call_nooks_arrayalloc_func =
      (mkStmt (Instr [call_nooks_arrayalloc_func])) in
    stmt_call_nooks_arrayalloc_func;
  end

(** Generate storeoffset call:
 * Generate the call to register an offset into the object tracker. The
 * inputs to the function are (i) lv: representing the head of the structure.
 * (ii) fieldinfo: the fieldinfo of the structure whose offset we want to
 * register, and (iii) the function inside which we want to place this code
 *)
let generate_storeoffset_call (lv: lval)
    (finfo: fieldinfo)
    (fdec: fundec) : stmt list =
  begin
    let retval = ref [] in
    let addrof_lv = (mkAddrOf lv) in
    let lvfinfo = (add_field_to_lval lv finfo) in
    let addrof_lvfinfo = (mkAddrOf lvfinfo) in
    let tmp_lv = (get_temporary_variable fdec None voidPtrType "tmp_lv") in
    let tmp_lvfinfo = (get_temporary_variable fdec None voidPtrType "tmp_fld") in
    let set_tmp_lv = Set((lvalify_varinfo tmp_lv), addrof_lv, locUnknown) in
    let stmt_set_tmp_lv = (mkStmt (Instr [set_tmp_lv])) in
    let set_tmp_lvf = Set((lvalify_varinfo tmp_lvfinfo), addrof_lvfinfo, locUnknown) in
    let stmt_set_tmp_lvf = (mkStmt (Instr [set_tmp_lvf])) in
    let fldoff = BinOp(MinusPP, (expify_lval (lvalify_varinfo tmp_lvfinfo)),
                       (expify_lval (lvalify_varinfo tmp_lv)) , TInt(IUInt,[])) in
    let sizeoflv = SizeOf(finfo.ftype) in
    let argslist = [addrof_lv; fldoff; sizeoflv] in
    let storeoff_func_name = nooks_storeoffset_fn in
    let storeoff_fundec = (emptyFunction !storeoff_func_name) in
    let storeoff_func = (expify_fundec storeoff_fundec) in
    let call_storeoff_func = Call(None, storeoff_func, argslist, locUnknown) in
    let stmt_call_storeoff_func = (mkStmt (Instr [call_storeoff_func])) in
    retval := (List.append !retval [stmt_set_tmp_lvf]);
    retval := (List.append !retval [stmt_set_tmp_lv]);
    retval := (List.append !retval [stmt_call_storeoff_func]);
    !retval;
  end

(** generate_fetchmarshbuf_ptr:
 * Generate demarshaling code fetching the value of a pointer from the
 * marshaling buffer. If the todemarshal variable has a const annotation,
 * we skip over the statement that assigns the demarshaled value to the
 * todemarshal variable.
 *)
let generate_fetchmarshbuf_ptr (fdec: fundec)
    (todemarshal: lval)
    (todemarshal_typ: typ)
    (bufvar: varinfo)
    (currsize: varinfo) : stmt list =
  begin
    let demarshptr_func_name = "fetch_marshbuf_ptr" in
    let demarshptr_fundec = (emptyFunction demarshptr_func_name) in
    let demarshptr_func = (expify_fundec demarshptr_fundec) in
    let src_buf = (expify_lval (lvalify_varinfo bufvar)) in
    let currsize_var = mkAddrOf (lvalify_varinfo currsize) in
    let retval = (mkAddrOf todemarshal) in
    let cast_pointerpointer = TPtr (TPtr (TVoid ([]), []), []) in
    let retval_cast = mkCast retval cast_pointerpointer in
    let sizeof_targetobj = (SizeOf(deref_ptr_typ todemarshal_typ)) in (* Added, see below *)
    let argslist = [src_buf; currsize_var; retval_cast; sizeof_targetobj] in
    let call_demarshptr_func = Call(None, demarshptr_func, argslist, locUnknown) in
    let stmt_demarshptr_call = (mkStmt (Instr [call_demarshptr_func])) in

    (* What should we do if we have a const pointer? *)
    (*
      if (Marshannot_dri.is_const todemarshal_typ) = true
      then [stmt_demarshptr_call; stmt_incr_currsize]
      else [stmt_incr_currsize];
    *)

    (*
      Previously, we used two separate steps: fetch the pointer
      into the final memory location, and then translate it in place.
      This leads to a problem in the case of repeated marshaling and
      demarshaling during other kernel activity: we may fetch a user
      mode pointer into some kernel structure, and then, before translation
      takes place, the kernel tries to dereference that pointer, potentially
      in the context of another process.  Obviously this is bad.

      Therefore, we replace the previous two step process with a new
      single step one, in which the fetch function is expanded to
      accomodate the information necessary for the nooks_ot_lookup
      function to execute.

      Another option would to be to generate more temporary variables
      and perform the fetch into the temporary, and then assign
      the temporary to the final location after the translation.  This
      would work too, but would require even more marshaling code.
    *)

    (*
    (* The statements below initiate a pointer translation. If pointer
       translation fails, memory of size = sizeof_targetobj is allocated *)
    let xlateptr_func_name = !nooks_ptrlookup_fn in
    let xlateptr_fundec = (emptyFunction xlateptr_func_name) in
    let xlateptr_func = (expify_fundec xlateptr_fundec) in
    let ptr2xlate = (expify_lval todemarshal) in
    let xlate_retval = (mkCast (mkAddrOf todemarshal) voidPtrType) in
    let sizeof_targetobj = (SizeOf(deref_ptr_typ todemarshal_typ)) in
    let argslist = [ptr2xlate; xlate_retval; sizeof_targetobj] in
    let call_xlateptr_func = Call(None, xlateptr_func, argslist, locUnknown) in
    let stmt_xlateptr_call = (mkStmt (Instr [call_xlateptr_func])) in
    *)

    if (isVoidType (deref_ptr_typ todemarshal_typ)) = true then
      begin
        (addwarn ["Void type passed to nooks_ot_lookup: ";
                  fdec.svar.vname; (lval_tostring todemarshal);
                  "Fix this, or you'll have a memory error at runtime"]);
      end;
    (*[stmt_demarshptr_call; stmt_xlateptr_call]; *)
    [stmt_demarshptr_call];
  end

(** generate_unified_m_dm: Generate marshaling or demarshaling code:
 *
 * Like the function generate_marshaling_code, this function generates code to
 * demarshal a value. The arguments passed to this function are:
 * (1) fdec: the fundec of the function that is currently being processed
 * (2) todemarshal: the varinfo of the variable that will get its value after
 *     we demarshal.
 * (3) field: this is an optional parameter that is passed, determining whether
 *     what we're demarshaling is a struct field.
 * (4) todemarshal_typ: the type, possibly resolved of todemarshal,
 * (5) bufvar: the varinfo of the marshbuf, that contains the flattened DSes.
 * (6) currsize: the varinfo of the variable that stores the current offset
 *     into the buffer.
 * (7) fdec_demarsh: the fundec of the function for which we're generating
 *     demarshaling code. Equivalent to the fdec2 argument of unified_dfs.
 * (8) ptg: points-to-graph obtained after marshaling analysis.
 * (9) resfld: resolved fields information, for opaque pointers.
 * (10) resform: resolved formal parameter information, for opaque pointers.
 * (11) stkdpth: stack depth, used with recursive data structures
 * (12) marshaling:  true if we are generating marhshaling code, false
 *      otherwise
 * (13) gen_kern: true if generating code in the master, false otherwise
 *
 * As output, we generate code to marshal/demarshal. We use a
 * function fill_marshbuf/fetch_marshbuf, that takes 4 parameters,
 * one of which is a void * memory blob containing
 * the data that we asked for. The arguments are:
 * (1) a void * with the buffer containing the flattened data structure.
 * (2) the current offset into the buffer.
 * (3) the size of the data that we're requesting from the buffer.
 * (4) the return buffer.
 *)
let rec generate_unified_m_dm
    (fdec: fundec)
    (to_m_dm: lval)
    (field: fieldinfo option)
    (to_m_dm_typ: typ)
    (bufvar: varinfo)
    (currsize: varinfo)
    (fdec_m_dm: fundec)
    (ptg: (string, (typ * string * string)) Hashtbl.t)
    (resfld: (string, (typ * fieldinfo * typ)) Hashtbl.t)
    (resform: (string, (int * varinfo * typ)) Hashtbl.t)
    (stkdpth: int)
    (marshaling: bool)
    (gen_kern: bool)
    : stmt list =
  begin
    let inserted_stmts = ref [] in
    let m_dm_func_name = (if marshaling then "fill_marshbuf" else "fetch_marshbuf") in
    let m_dm_fundec = (emptyFunction m_dm_func_name) in
    let m_dm_func = (expify_fundec m_dm_fundec) in
    (*let the_buf = (mkCast
                     (expify_lval (lvalify_varinfo bufvar))
                     (TPtr (TVoid ([]), []))
                  ) in*)
    let the_buf = expify_lval (lvalify_varinfo bufvar) in
    (* Buffer in/from which we marshal/demarsh data *)
    let currsize_var = (mkAddrOf (lvalify_varinfo currsize)) in

    (match to_m_dm_typ with
       | TInt(_) ->
           (* other_buf is the opposite of the_buf:  if the_buf is the target, then
              other_buf is the source.  if the_buf is the source, then other_buf is
              the target *)
           if (is_iomem to_m_dm_typ) = false then
             begin
               let other_buf = ref
                 (mkCast 
                    (mkAddrOf (add_field_to_lval_wrapper to_m_dm field))
                    (TPtr (TVoid ([]), []))
                 ) in
               (match field with
                  | Some(f) ->
                      (match f.fbitfield with
                         | Some(sz) -> (* Generate an assignment of the bitfield to an int *)
                             (* Just an integer temporary variable.  Will add just 4 bytes *)
                             let bitfldtmp = (get_temporary_variable fdec None intType "btfld") in
                             other_buf := (mkCast
                                             (mkAddrOf (lvalify_varinfo bitfldtmp))
                                             (TPtr (TVoid ([]), []))
                                          );
                             if marshaling then begin
                               let assign_bitfld_lhs = (lvalify_varinfo bitfldtmp) in
                               let assign_bitfld_rhs = (expify_lval (add_field_to_lval_wrapper to_m_dm field)) in
                               let assign_bitfld = Set(assign_bitfld_lhs, assign_bitfld_rhs, locUnknown) in
                               let stmt_assign_bitfld = (mkStmt (Instr [assign_bitfld])) in
                               inserted_stmts := [stmt_assign_bitfld];
                             end
                             else begin
                               let assign_bitfld_lhs = (add_field_to_lval_wrapper to_m_dm field) in
                               let assign_bitfld_rhs = (expify_lval (lvalify_varinfo bitfldtmp)) in
                               let assign_bitfld = Set(assign_bitfld_lhs, assign_bitfld_rhs, locUnknown) in
                               let stmt_assign_bitfld = (mkStmt (Instr [assign_bitfld])) in
                               inserted_stmts := [stmt_assign_bitfld];
                             end
                         | None -> ();
                      );
                  | None -> ();
               );
               (* Get the value of the integer *)
               let sizeof_var = (SizeOf(to_m_dm_typ)) in
               let (argslist, retval) =
                 if marshaling then
                   ([the_buf; currsize_var; !other_buf; sizeof_var],
                    (Some((lvalify_varinfo bufvar)))
                   )
                 else
                   ([the_buf; currsize_var; sizeof_var; !other_buf],
                    None
                   )
               in
               let call_m_dm_func = Call(retval, m_dm_func, argslist, locUnknown) in
               let stmt_m_dm_call = (mkStmt (Instr [call_m_dm_func])) in
               (* We might have prepared code for demarshaling bit fields. These statements
                * must precede that statement *)
               inserted_stmts :=
                 (if marshaling then
                    (List.append !inserted_stmts [stmt_m_dm_call])
                  else
                    (List.append [stmt_m_dm_call] !inserted_stmts)
                 );
               (* Is this TInt ever a pointer? If so, translate and marshal/demarshal! *)
               if (Marshannot_dri.is_ispointer to_m_dm_typ) = true then
                 begin
                   let target_typ = (Marshannot_dri.typeof_ptrtarget to_m_dm_typ) in
                   let pointer_type = (TPtr(target_typ, [])) in
                   let ptrlv = (add_field_to_lval_wrapper to_m_dm field) in
                   let m_dm_stmts = (unified_dfs ptrlv pointer_type fdec
                                       fdec_m_dm ptg resfld resform bufvar currsize
                                       stkdpth marshaling gen_kern) in
                   inserted_stmts := (List.append !inserted_stmts m_dm_stmts);
                 end;
             end
           else
             begin
               (Printf.fprintf stderr "Not marshaling: %s in %s\n" (lval_tostring to_m_dm) fdec.svar.vname);
               inserted_stmts := [];
             end
       | TArray(basetype,lengthexp,_) ->
           (* Array type *)
           (* For an array, we first note the number of elements in the array. Here, the
              length of the array is available as an exp. Then we copy that many elements
              over from the array into the buffer. We DO NOT copy the base pointer of
              the array. That will be copied from the container struct. *)
           let array_length_exp = ref (integer 0) in
           (match lengthexp with
              | Some(l) ->
                  array_length_exp := l;
              | None -> (* Read from annotations/provide manually. *)
                  (* Initialize array length to "SUPPLYME" *)
                  let unknown_prefix = (if marshaling then
                                          "SUPPLYME"
                                        else
                                          "resolved_annot_"
                                       ) in
                  let unknown_var = (get_temporary_variable fdec None intType unknown_prefix) in
                  let unknown_lval = (lvalify_varinfo unknown_var) in
                  let unknown_exp = (expify_lval unknown_lval) in
                  array_length_exp := unknown_exp;
           );
           (* Create an index variable to traverse the array *)
           let idx_var_name = "idx_arr" ^ (itoa stkdpth) in
           let idx_var = (get_temporary_variable fdec None intType idx_var_name) in
           let idx_lval = (lvalify_varinfo idx_var) in
           let idx_exp = (expify_lval idx_lval) in
           (* Create the offset into the array: i.e., (arr + idx), where arr is the
              name of the array declared as 'T arr[size]' *)
           let arrnm_lval = (add_field_to_lval_wrapper to_m_dm field) in
           let arrnm_exp = (mkAddrOrStartOf arrnm_lval) in
           let index = Index(idx_exp, NoOffset) in
           let ptrarith = addOffsetLval index arrnm_lval in
           if marshaling then
             begin
               let stmts_marshal = (unified_dfs ptrarith basetype fdec fdec_m_dm ptg
                                      resfld resform bufvar currsize (stkdpth + 1)
                                      marshaling gen_kern) in
               (* Create the loop that will traverse the array *)
               let stmts_loop = (mkForIncr ~iter:(idx_var) ~first:(zero)
                                   ~stopat:(!array_length_exp) ~incr:(one)
                                   ~body:(stmts_marshal)) in
               inserted_stmts := (List.append !inserted_stmts stmts_loop);
             end
           else
             begin
               let stmts_loopbody = ref [] in
               (* If we have a RANGESTORE array, create a mapping for each element *)
               if (Marshannot_dri.is_rangestore to_m_dm_typ) = true then begin
                 let argslist = [arrnm_exp ; idx_exp] in
                 let storeoff_func_name = nooks_storeoffset_fn in
                 let storeoff_fundec = (emptyFunction !storeoff_func_name) in
                 let storeoff_func = (expify_fundec storeoff_fundec) in
                 let call_storeoff_func = Call(None, storeoff_func, argslist, locUnknown) in
                 let stmt_call_storeoff_func = (mkStmt (Instr [call_storeoff_func])) in
                 stmts_loopbody := (List.append !stmts_loopbody [stmt_call_storeoff_func]);
               end;
               (* Create the dereference lval and demarshal element*)
               let stmts_demarshal = (unified_dfs ptrarith basetype fdec fdec_m_dm
                                        ptg resfld resform bufvar currsize (stkdpth + 1)
                                        marshaling gen_kern) in
               stmts_loopbody := (List.append !stmts_loopbody stmts_demarshal);
               (* Create the loop that will traverse the array *)
               let stmts_loop = (mkForIncr ~iter:(idx_var) ~first:(zero)
                                   ~stopat:(!array_length_exp) ~incr:(one)
                                   ~body:(!stmts_loopbody)) in
               inserted_stmts := (List.append !inserted_stmts stmts_loop);
             end
       | TNamed(tinfo,_) ->
           (* A named type. We must marshal/demarshal it appropriately. Do not (de)marshal a
              compound type as that is handled by unified_dfs. *)
           if (isCompoundType to_m_dm_typ) = false
           then begin
             let stmts_m_dm = (generate_unified_m_dm fdec to_m_dm field
                                 tinfo.ttype bufvar currsize fdec_m_dm ptg
                                 resfld resform stkdpth marshaling gen_kern) in
             inserted_stmts := stmts_m_dm;
           end else begin
             (Printf.fprintf stderr "demarsh: not handled %s in %s\n" tinfo.tname fdec.svar.vname);
             inserted_stmts := [];
           end;
       | TPtr(dtyp, al) -> ();
           (* Generic pointer type. We need to check for annotations here
            * Annotations handled here are: NULLTERM IS_CONTAINER
            * ARITH/RECURSIVE annotations are handled in the unified_dfs algorithm. *)
           (* Is this a NULLTERM string? *)
           if ((Marshannot_dri.is_nullterm to_m_dm_typ) = true)
           then begin
             (* If we are demarshaling, "other" means "target".  If we are marshaling,
                "other" means "src"
             *)
             let other_lval = (add_field_to_lval_wrapper to_m_dm field) in
             let other_buf = (mkCast
                                (expify_lval other_lval)
                                (TPtr (TVoid ([]), []))
                             ) in
             let m_dm_generate_fetch_fill = (if marshaling then generate_fillmarshbuf_ptr
                                             else generate_fetchmarshbuf_ptr) in
             (* 1. Marshal/demarshal the value of the pointer *)
             let ptr_m_dm = (m_dm_generate_fetch_fill fdec
                                 (add_field_to_lval_wrapper to_m_dm field) to_m_dm_typ bufvar currsize) in
             inserted_stmts := (List.append !inserted_stmts ptr_m_dm);
             let deref_check = BinOp(Ne, (expify_lval other_lval), zero64Uexp, intType) in
             let true_block = ref [] in
             (* 2. Compute/Demarshal the string length *)
             let strlen_var = (get_temporary_variable fdec (Some(other_lval)) intType "strlen") in
             let strlen_lval = (lvalify_varinfo strlen_var) in
             let strlen_exp = (expify_lval strlen_lval) in

             if marshaling then
               begin
                 let strlen_func_name = "strlen" in
                 let strlen_fundec = (emptyFunction strlen_func_name) in
                 let strlen_func = (expify_fundec strlen_fundec) in
                 let retval = (Some(strlen_lval)) in
                 let argslist = [other_buf] in
                 let call_strlen = Call(retval, strlen_func, argslist, locUnknown) in
                 let stmt_strlencall = (mkStmt (Instr [call_strlen])) in
                 let incr_strlen_rhs = (BinOp(PlusA, strlen_exp, one, intType)) in
                 let incr_strlen = Set(strlen_lval, incr_strlen_rhs, locUnknown) in
                 let stmt_incr = (mkStmt (Instr [incr_strlen])) in
                 true_block := (List.append !true_block [stmt_strlencall; stmt_incr]);
                 (* Marshal the string length *)
                 let retval = (Some((lvalify_varinfo bufvar))) in
                 let argslist = [the_buf; currsize_var; (mkAddrOf strlen_lval); SizeOf(intType)] in
                 let call_marshstrlen = Call(retval, m_dm_func, argslist, locUnknown) in
                 let stmt_call_marshstrlen = (mkStmt (Instr [call_marshstrlen])) in
                 true_block := (List.append !true_block [stmt_call_marshstrlen]);
               end
             else
               begin
                 let strlen_addrof = (mkAddrOf strlen_lval) in
                 let argslist = [the_buf; currsize_var; SizeOf(intType); strlen_addrof] in
                 let call_demarsh_strlen = Call(None, m_dm_func, argslist, locUnknown) in
                 let stmt_demarsh_strlen = (mkStmt (Instr [call_demarsh_strlen])) in
                 true_block := (List.append !true_block [stmt_demarsh_strlen]);
               end;

             if marshaling = false && (is_fixedarray to_m_dm_typ) = false then
               begin
                 (* Realloc the target using nooks_ot_alloc_arraymem (this is a bug fix
                  * Read that many bytes from the marshbuf
                  * and store it in the target. Do so only if the target is a non-const.
                  * If it is a const, then don't do the copy. *)
                 let stmt_realloc_array =
                   (generate_nooks_arrayalloc_call other_lval strlen_exp dtyp false) in
                 true_block := (List.append !true_block [stmt_realloc_array]);
               end
             else
               ();

             (* 3. Read bytes into newly realloced target, or marshal the string itself *)
             let strlen_mult_size_exp = (BinOp(Mult,strlen_exp,SizeOf(dtyp),intType)) in
             let (argslist, retval) =
               if marshaling then
                 ([the_buf; currsize_var; other_buf; strlen_mult_size_exp],
                  Some(lvalify_varinfo bufvar)
                 )
               else
                 ([the_buf; currsize_var; strlen_mult_size_exp; other_buf],
                  None
                 )
             in
             let call_m_dm_func = Call(retval, m_dm_func, argslist, locUnknown) in
             let stmt_m_dm_call = (mkStmt (Instr [call_m_dm_func])) in
             true_block := (List.append !true_block [stmt_m_dm_call]);

             let check_trueblock = (mkBlock !true_block) in
             let check_falseblock = (mkBlock []) in
             let check_ifstmt = If(deref_check, check_trueblock, check_falseblock ,locUnknown) in
             let stmt_check = (mkStmt check_ifstmt) in
             inserted_stmts := (List.append !inserted_stmts [stmt_check]);
           end
           else if ((Marshannot_dri.is_container to_m_dm_typ) = true) then
             begin
               (* If marshaling, other means "src".  If demarshaling, "other" means target *)
               let other_lval = (add_field_to_lval_wrapper to_m_dm field) in
               let cont_typ = TPtr((typeof_container to_m_dm_typ), []) in
               let cont_var = (get_temporary_variable fdec (Some(other_lval)) cont_typ "cont") in
               let cont_fld = (fieldof_container to_m_dm_typ) in
               let cont_lv = (lvalify_varinfo cont_var) in
               if marshaling then
                 begin
                   let stmts_get_container =
                     (generate_get_container_code fdec other_lval cont_typ cont_lv cont_fld) in
                   inserted_stmts := (List.append !inserted_stmts stmts_get_container);
                   let stmts_marshcont = (unified_dfs cont_lv cont_typ fdec fdec_m_dm
                                            ptg resfld resform bufvar currsize stkdpth
                                            marshaling gen_kern) in
                   inserted_stmts := (List.append !inserted_stmts stmts_marshcont);
                 end
               else
                 begin
                   let stmts_demarshcont = (unified_dfs cont_lv cont_typ fdec fdec_m_dm
                                              ptg resfld resform bufvar currsize stkdpth
                                              marshaling gen_kern) in
                   inserted_stmts := (List.append !inserted_stmts stmts_demarshcont);

                   (* Assign the demarshaled container's member field to the other_lval. Here,
                    * check for compatibility of types *)
		   if (isPointerType (typeOfLval cont_lv)) = false
		   then begin
		     (fatal ["Non pointer type:"; (typ_tostring_noattr cont_typ);
			     (lval_tostring cont_lv); (fdec.svar.vname)]);
		   end;
                   let cont_fld_lv = (add_field_to_lval_wrapper
                                        (mkMem (expify_lval cont_lv) NoOffset) cont_fld) in
                   let cont_fld_exp = ref (expify_lval cont_fld_lv) in
                   (* If it's not a pointer, cast to a pointer *)
                   if (isPointerType (typeOf !cont_fld_exp)) = false &&
                     (isArrayType (typeOf !cont_fld_exp)) = false then
                       begin
                         (* We don't do a mkAddrOf in case of arrays: this is the last-member
                          * is array of size 0 trick that is employed in the kernel *)
                         cont_fld_exp := (mkAddrOf cont_fld_lv);
                       end;
                   (* Check for compatibility of types *)
                   let lhs_typ_str = (typ_tostring_noattr to_m_dm_typ) in
                   let rhs_typ_str = (typ_tostring_noattr (typeOf !cont_fld_exp)) in
                   if (String.compare lhs_typ_str rhs_typ_str) <> 0 then
                     begin
                       (addwarn ["You're trying to generate an asg with incompatible types.";
                                 "Here are the details:\n"; "\tLHS (var, type)";
                                 (lval_tostring other_lval); lhs_typ_str;
                                 "\n\t RHS (var, type)";
                                 (exp_tostring !cont_fld_exp); rhs_typ_str]);
                     end;
                   let set_other_lval = Set(other_lval, !cont_fld_exp, locUnknown) in
                   let stmt_set_other_lval = (mkStmt (Instr [set_other_lval])) in
                   inserted_stmts := (List.append !inserted_stmts [stmt_set_other_lval]);
                 end
             end
           else begin
             (match dtyp with
                | TInt (kind, _) ->
                    if kind = IChar then
                      if (Marshannot_dri.is_nullterm to_m_dm_typ) = false then
                        addwarn ["Assuming standard char * pointer for "; (lval_tostring to_m_dm);
                                 " in function: "; fdec.svar.vname];
                | _ -> ()
             );

             (* TODO: More cases to handle annotations to go here. Currently none. *)
             (Printf.fprintf stderr "Demarsh: Unexpected type %s\n" (typ_tostring to_m_dm_typ));
           end;
       | TEnum(einfo,_) ->
           (* An enum type variable must have size of an integer *)
           inserted_stmts := (generate_unified_m_dm fdec to_m_dm field
                                (TInt(IInt,[])) bufvar currsize fdec_m_dm ptg
                                resfld resform stkdpth marshaling gen_kern);
       | _ -> ();
    );
    !inserted_stmts;
  end
(*---------------------------------------------------------------------------*)
(** Insert marshaling/demarshaling code at the call-site stub. Return the list of
 * statements to be inserted before the function call.
 * (1) lv: this denotes the lval of the variable to be demarshed.
 * (2) lvtype: this denotes the type of the lval.
 * (3) fdec: This corresponds to the function within the generated
 *     (de)marshaling code will be placed.
 * (4) fdec2: this denotes the fundec of the function corresponding to which
 *     we're generating (de)marshaling code. Typically fdec2 and fdec will differ
 *     when we're generating (de)marshaling code for glue functions.
 *     fdec and fdec2 are the same if we're dealing with an internal kernel
 *     function, e.g. __MARSH_WRAP__register_netdev.  They differ if we're not,
 *     e.g. e1000_blah vs __MARSH_WRAP__e1000_blah.
 * (5) ptg: points-to-graph obtained after marshaling analysis.
 * (6) resfld: resolved fields information, for opaque pointers.
 * (7) resform: resolved formal parameter information, for opaque pointers.
 * (8) m_dm_buf: the field from which we're (de)marshaling data.
 * (9) m_dm_off: the offset into the buffer from which we're (de)marshaling data.
 * (10) stkdpth: the stack depth, used during recursion
 * (11) marshaling: true if we're generating marshaling code, false if
 *      generating demarshaling code
 * (12) gen_kern: true if generating code in the master, false if
 *      generating code in the slave.
 *)
and unified_dfs (lv: lval)
    (lvtyp: typ)
    (fdec: fundec)
    (fdec2: fundec)
    (ptg: (string, (typ * string * string)) Hashtbl.t)
    (resfld: (string, (typ * fieldinfo * typ)) Hashtbl.t)
    (resform: (string, (int * varinfo * typ)) Hashtbl.t)
    (m_dm_buf: varinfo)
    (m_dm_off: varinfo)
    (stkdpth: int)
    (marshaling: bool)
    (gen_kern: bool)
    : stmt list =
  begin
    (* Check if we are potentially in an infinite loop. If in infinite loop,
       nothing is returned *)
    if (stkdpth > !threshold_stackdepth)
    then begin
      (addwarn ["Potentially an infinite loop in unified_dfs:";
                fdec.svar.vname; " "; fdec2.svar.vname; " ";
                (lval_tostring lv); " "; (typ_tostring_noattr lvtyp)]);
      [];
    end
    else if (is_on_marshstack (typ_tostring_noattr lvtyp)) = true
    then begin
      (* We now check if we're (de)marshaling a recursive structure. We stop when
       * we see a node we've visited before. *)
      (set_recaccess());
      [];
    end
    else if (is_iomem lvtyp) = true then (* MJR:  This is aggressive, but is it right? *)
      []
    else begin
      (* Type to be marshaled not on stack. Normal marshaling *)
      (* Is v a variable that we can generate (de)marshaling code for directly? *)
      let m_dm_v_stmts = (generate_unified_m_dm fdec lv None lvtyp
                                 m_dm_buf m_dm_off fdec2 ptg resfld resform
                                 stkdpth marshaling gen_kern) in
      if (List.length m_dm_v_stmts) <> 0
      then begin
        (* We must have just generated some marshaling code, so that's it *)
        let m_dm_stmts = ref [] in
        m_dm_stmts := (List.append !m_dm_stmts m_dm_v_stmts);
        !m_dm_stmts;
      end
      else if (isPointerType lvtyp) && (isVoidPtrType lvtyp) = false
      then begin
        (* List of statements for marshaling/demarshaling the value
           pointed to by the pointer. *)
        let stmts_unified_dfs = ref [] in

        (* v.vtype is a type that we do not support for marshaling/demarshaling,
         * and it is pointer type. We handle opaque pointers in a separate case. *)

        (* Are we marshaling or demarshaling? *)
        let m_dm_generate_fetch_fill = (if marshaling then generate_fillmarshbuf_ptr
                                        else generate_fetchmarshbuf_ptr) in
        (* Marshal/demarshal the value of the pointer *)
        let stmt_m_dm_ptr = (m_dm_generate_fetch_fill fdec lv lvtyp m_dm_buf m_dm_off) in

        (* Get the dereferenced type of the variable *)
        let dereftype = deref_ptr_typ lvtyp in
        (* Create a check to see that the pointer is not NULL *)
        let deref_check = BinOp(Ne, (expify_lval lv), zero64Uexp, intType) in

        (* Are we dealing with iomem? *)
        if (is_iomem lvtyp) = false then
          begin
            (*At this point, we check to see if this is an arith or a recursive pointer *)
            if ((Marshannot_dri.is_array lvtyp) = false) then
              begin
                (* Create the dereference lval *)
                let deref_lv = mkMem (expify_lval lv) NoOffset in
                (* Send the dereferenced pointer for marshaling/demarshaling *)
                stmts_unified_dfs := (unified_dfs deref_lv dereftype fdec fdec2
                                        ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                        marshaling gen_kern);
                (* If it is an arith pointer, we must copy until the end of the array *)
              end
            else if ((Marshannot_dri.is_array lvtyp) = true) then
              begin
                let var_suffix = fdec.svar.vname ^ (makevarname (lval_tostring lv)) in
                let bvname = "arraylen_" ^ var_suffix in
                let bdry_var = get_temporary_variable fdec (Some(lv)) intType bvname in
                if marshaling then begin
                  (* Marshaling *)
                  (* 1. Create the code to marshal the length of the array *)
                  let (container_lv, offset) = removeOffsetLval lv in
                  let option_container_lv = (if offset = NoOffset then None
                                             else Some(container_lv)) in
                  let vars_to_search = fdec2.sformals @ fdec2.slocals @ fdec.sformals @ fdec.slocals in
                  let len_stmtopt = Marshannot_dri.get_array_length lvtyp option_container_lv
                    vars_to_search bdry_var in
                  (match len_stmtopt with
                     | Some(len_stmt) ->
                         stmts_unified_dfs := (List.append !stmts_unified_dfs [len_stmt]);
                     | _ ->
                         bdry_var.vname <- "SUPPLYME" ^ var_suffix;
                  );
                  let stmts_marsh_bdry =
                    (generate_unified_m_dm fdec (lvalify_varinfo bdry_var) None intType
                       m_dm_buf m_dm_off fdec2 ptg resfld resform stkdpth
                       marshaling gen_kern) in
                  stmts_unified_dfs := (List.append !stmts_unified_dfs stmts_marsh_bdry);
                end
                else
                  begin
                    (* Demarshaling *)
                    (* 1. Create the code to demarshal the length of the array *)
                    let stmts_demarsh_bdry =
                      (generate_unified_m_dm fdec (lvalify_varinfo bdry_var)
                         None intType m_dm_buf m_dm_off fdec2 ptg resfld resform
                         stkdpth marshaling gen_kern) in
                    stmts_unified_dfs := (List.append !stmts_unified_dfs stmts_demarsh_bdry);
                    (* 2. Once we've fetched the size of the array, we've to communicate its
                     * size to the nooks object tracker. *)
                    let deref_type = (deref_ptr_typ lvtyp) in (* Type of individual elements *)
                    (* TODO:  What if we are generating demarshaling code for an array
                       that conincidentally is located at the start of a structure which
                       is also in the object tracker?  In this case, the array and the structure
                       have the same address, but we don't want to allocate memory in this case,
                       since the array is already a part of the structure.  e.g. the name array
                       in the net_device structure.
                    *)
                    if (Marshannot_dri.is_fixedarray lvtyp) = false then
                      begin
                        (* Only generate code for variable sized arrays.  We don't want
                           to allocate new memory if the array size is fixed *)
                        let stmt_nooks_arralloc = (generate_nooks_arrayalloc_call
                                                     lv (expify_lval (lvalify_varinfo bdry_var))
                                                     deref_type
                                                     (Marshannot_dri.is_rangestore lvtyp)) in
                        stmts_unified_dfs :=
                          (List.append !stmts_unified_dfs [stmt_nooks_arralloc]);
                      end;
                  end;

                (* 3. Create temporary variable to perform offsets. Init it to 0 *)
                (* Each level of nesting means we must create a new variable name else
                 * we'll be messing around with the values of index variables for outer
                 * loops *)
                let idx_var_name = "idx" ^ (itoa stkdpth) in
                let idx_var = (get_temporary_variable fdec None intType idx_var_name) in
                (* 4. Create the dereference lval with an offset *)
                let idx_exp = (expify_lval (lvalify_varinfo idx_var)) in
                let ptrarith = BinOp(PlusPI, (expify_lval lv), idx_exp, lvtyp)  in
                let deref_lv = mkMem ptrarith NoOffset in
                let stmts_m_dm = (unified_dfs deref_lv dereftype fdec fdec2
                                    ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                    marshaling gen_kern) in
                (* 5. Create the conditional/sentinel to break out of the loop/end
                 * traveral of the array *)
                let bdry_exp = (expify_lval (lvalify_varinfo bdry_var)) in
                (* 6. Create the loop itself *)
                let stmts_loop = (mkForIncr ~iter:(idx_var) ~first:(zero)
                                    ~stopat:(bdry_exp) ~incr:(one)
                                    ~body:(stmts_m_dm)) in
                (* 7. Finally, append everything to the marshaled statements *)
                stmts_unified_dfs := (List.append !stmts_unified_dfs stmts_loop);
              end;
          end (* End is_iomem *)
        else
          begin
            (*(Printf.fprintf stderr "Type %s is iomem\n" (typ_tostring lvtyp));*)
            stmts_unified_dfs := [];
          end;

        (* Obtain the statements to be returned *)
        (* Put the whole thing within the IF check for non-NULL if we're not
         * dealing with a recursive pointer. *)
        let true_block = !stmts_unified_dfs in
        let check_trueblock = (mkBlock true_block) in
        let check_falseblock = (mkBlock []) in
        let check_ifstmt = If(deref_check,check_trueblock,check_falseblock,locUnknown) in
        let stmt_check = (mkStmt check_ifstmt) in
        (* Return value *)
        if (List.length true_block) > 0 then
          (List.append stmt_m_dm_ptr [stmt_check])
        else
          stmt_m_dm_ptr;
      end
      (* v.vtype is a type that we do not support for marshaling, and it is
       * an opaque pointer. In this case, we derefence the pointer, and marshal
       * the dereferenced structure. In case the opaque pointer resolved to more
       * than one type, we generate code for all resolutions, and throw a warning.
       * The user has to manually prune out the unwanted marshaling code. *)
      else if (isPointerType lvtyp) && (isVoidPtrType lvtyp) = true
      then begin
        let ret_stmts = ref [] in

        (* Are we dealing with iomem? *)
        if ((is_iomem lvtyp) = false) then
          begin
            (* Get the resolved type(s) of the variable *)
            let v = (obtain_varinfo_from_lval lv) in
            let restyp_list = (resolve_opaque_formal v fdec2 resform) in
            (* Are we marshaling or demarshaling? *)
            let m_dm_generate_fetch_fill = (if marshaling then generate_fillmarshbuf_ptr
                                            else generate_fetchmarshbuf_ptr) in
            (* If we don't resolve to anything, just (de)marsh the value of the pointer *)
            if (List.length restyp_list) = 0 then
              begin
                let stmt_m_dm_ptr = (m_dm_generate_fetch_fill fdec lv lvtyp m_dm_buf m_dm_off) in
                ret_stmts := (List.append !ret_stmts stmt_m_dm_ptr);
              end;
            for i = 0 to (List.length restyp_list) - 1 do
              let ithres = (List.nth restyp_list i) in
              if (isPointerType ithres) = true then begin
                (* Fetch/Fill the value of the pointer *)
                let stmt_m_dm_ptr = (m_dm_generate_fetch_fill fdec lv ithres m_dm_buf m_dm_off) in
                (* Check that the pointer is not NULL, and
                   get the dereferenced type of the variable *)
                let dereftype = (deref_ptr_typ ithres) in
                (* TODO: Must add the code to check whether this is an arith pointer,
                 * and the appropriate marshaling code here. I'm not doing this right
                 * now because I've not encountered any opaque arith pointers *)
                (* Create a check to see that the pointer is not NULL *)
                let deref_check = BinOp(Ne, (expify_lval lv), zero64Uexp, intType) in
                (* Create the dereferenced lval, and
                 * send the pointer for marshaling/demarshaling *)
                let deref_lv = mkMem (mkCast (expify_lval lv) ithres) NoOffset in
                let stmts_unified_dfs =
                  (unified_dfs deref_lv dereftype fdec fdec2
                     ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                     marshaling gen_kern) in
                (* Put the whole thing within the IF check for non-NULL *)
                let true_block = stmts_unified_dfs in
                let check_trueblock = (mkBlock true_block) in
                let check_falseblock = (mkBlock []) in
                let check_ifstmt = If(deref_check,check_trueblock,check_falseblock,locUnknown) in
                let stmt_check = (mkStmt check_ifstmt) in
                (* Return value *)
                if (List.length true_block) > 0
                then ret_stmts := (List.append !ret_stmts (List.append stmt_m_dm_ptr [stmt_check]))
                else ret_stmts := (List.append !ret_stmts stmt_m_dm_ptr);
              end
                (* If the resolved type is not a pointer, try generating marshaling code
                   for it. If no code was generated, then raise a warning *)
              else begin
                let m_dm_v_stmts =
                  (generate_unified_m_dm fdec lv None ithres m_dm_buf m_dm_off
                     fdec2 ptg resfld resform stkdpth marshaling gen_kern) in
                if (List.length m_dm_v_stmts) <> 0
                then begin
                  ret_stmts := (List.append !ret_stmts m_dm_v_stmts);
                end else begin
                  let what_we_are_doing = (if marshaling then "marshaling" else "demarshaling") in
                  (addwarn ["This case is currently not supported in"; what_we_are_doing; "/resolve:";
                            (lval_tostring lv); (typ_tostring_noattr ithres); fdec.svar.vname; fdec2.svar.vname]);
                end;
              end;
            done;
          end
        else (* This is iomem *)
          begin
            (*(Printf.fprintf stderr "Type %s is iomem\n" (typ_tostring lvtyp));*)
          end;
        !ret_stmts;
      end

      (* v.vtype is a type that we do not support for marshaling, and it is not
       * a pointer type. If it is a compound type, extract fields and marshal/demarshal
       * each of them *)
      else if (isCompoundType lvtyp)
      then begin
        let m_dm_stmts = ref [] in
        if (is_iomem lvtyp) = false then
          begin
            let ptg_recursive = ref false in
            (* Get the fields, and marshal/demarshal them iteratively. Ensure
               we don't have repeats in the field accesses. *)
            let ptg_query_result =
              (get_fields_accessed (Hashtbl.find_all ptg (typ_tostring_noattr lvtyp))) in
            ptg_recursive := (Marshannot_dri.is_recursive_access ptg_query_result);
            if (!ptg_recursive)
            then begin
              (push_marshstack (typ_tostring_noattr lvtyp));
              (infomsg ["Pushing on stack:"; (lval_tostring lv);
                        (typ_tostring_noattr lvtyp)]);
            end;

            for i = 0 to (List.length ptg_query_result) - 1 do
              let (ithtyp,ithfield,ithaccess) = (List.nth ptg_query_result i) in
              let ithcomp = (tcomp_compinfo ithtyp) in

              (* Whether we're generating code in the kernel or user is irrelevant. *)
              (* This conditional is very subtle, because there are 2^3 = 8 distinct
                 places that marshaling/demarshaling code is generated, and we need to
                 be sure they all match up.  That is, we need to be sure that whenever
                 we marshal a value, we also demarshal it.  To reason through this,
                 I used a short test program that contained all the possibilities.  *)
              if ((String.compare ithaccess "read ") <> 0) ||
                (*(    marshaling &&     gen_kern &&     (contains_marshwrap_prefix fdec.svar.vname)) ||*)
                (    marshaling &&     gen_kern && not (contains_marshwrap_prefix fdec.svar.vname)) ||
                (*(    marshaling && not gen_kern &&     (contains_marshwrap_prefix fdec.svar.vname)) ||*)
                (    marshaling && not gen_kern && not (contains_marshwrap_prefix fdec.svar.vname)) ||
                (not marshaling &&     gen_kern &&     (contains_marshwrap_prefix fdec.svar.vname)) ||
                (*(not marshaling &&     gen_kern && not (contains_marshwrap_prefix fdec.svar.vname)) ||*)
                (not marshaling && not gen_kern &&     (contains_marshwrap_prefix fdec.svar.vname)) ||
                (*(not marshaling && not gen_kern && not (contains_marshwrap_prefix fdec.svar.vname)) ||*)
                false
              then
                (match ithcomp with
                   | Some(ithcompinfo) ->
                       begin
                         (* This will not throw an exception because ithtyp is a TComp, and
                          * our marshaling analysis will only return fields that belong to the
                          * TComp. Check if the field is a void pointer, and if so, lookup its
                          * resolved type. *)
                         let ithfieldinfo = (get_fieldinfo ithcompinfo ithfield) in
                         let ithfieldtyp = ithfieldinfo.ftype in

                         if marshaling = false then begin
                           (* If the field is one whose address is taken, or it has a
                            * STOREOFFSET annotation, then generate code to store the offset
                            * of this field. We currently do so only if the lv is of the form
                            * *PTR. *)
                           if ((Marshal_dri.is_field_addr_taken ithfieldinfo) = true) ||
                             ((Marshannot_dri.is_storeoffset ithfieldtyp) = true)
                           then begin
                             let (lh, off) = lv in
                             (match lh with
                                | Mem(_) ->
                                    let reg_offset_stmts = (generate_storeoffset_call lv ithfieldinfo fdec) in
                                    m_dm_stmts := (List.append !m_dm_stmts reg_offset_stmts);
                                | Var(_) ->
                                    (addwarn ["generating storeoffset in a case I've never seen before";
                                              "Check this case in the code that is generated. Info:";
                                              (lval_tostring lv); fdec.svar.vname; fdec2.svar.vname]);
                                    let reg_offset_stmts = (generate_storeoffset_call lv ithfieldinfo fdec) in
                                    m_dm_stmts := (List.append !m_dm_stmts reg_offset_stmts);
                             );
                           end;
                         end;

                         if (isVoidPtrType ithfieldtyp) = true
                         then begin
                           let restyp_list = (resolve_opaque_field fdec2 resfld ithtyp ithfieldinfo) in
                           for j = 0 to (List.length restyp_list) - 1 do
                             let jthres = (List.nth restyp_list j) in
                             let m_dm_v_stmts =
                               (generate_unified_m_dm fdec lv (Some(ithfieldinfo)) jthres
                                  m_dm_buf m_dm_off fdec2 ptg resfld resform stkdpth
                                  marshaling gen_kern) in
                             if (List.length m_dm_v_stmts) <> 0
                             then begin
                               m_dm_stmts := (List.append !m_dm_stmts m_dm_v_stmts);
                             end
                             else begin
                               (* Cannot marshal/demarshal this field type. *)
                               if marshaling then begin
                                 (* Cannot marshal this field type. Simply generate an assignment, and
                                  * call the marshaling function recursively. *)
                                 (* In this case, we need to generate an assignment with a cast
                                    statement resolving the field *)
                                 let lhs_var = (get_temporary_variable fdec None jthres ithfield) in
                                 (* Commented out the following because it occasionally leads to code like this:
                                    private_data13 = 0U;
                                    private_data13 = (struct ensoniq * )((private_data13->midi_output)->rmidi)->private_data;
                                 *)
                                 (*let init_instr = Set((lvalify_varinfo lhs_var), zero64Uexp, locUnknown) in
                                   let stmt_init = (mkStmt (Instr [init_instr])) in
                                 *)
                                 let cast_lhs = (lvalify_varinfo lhs_var) in
                                 let cast_rhs = (expify_lval (add_field_to_lval lv ithfieldinfo)) in
                                 let cast_rhs' = (mkCast cast_rhs jthres) in
                                 let cast_instr = Set(cast_lhs,cast_rhs',locUnknown) in
                                 let stmt_cast = (mkStmt (Instr [cast_instr])) in
                                 let stmt_marsh_lhs =
                                   (unified_dfs cast_lhs jthres fdec fdec2
                                      ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                      marshaling gen_kern) in
                                 m_dm_stmts := (List.append !m_dm_stmts ((*stmt_init::*) stmt_cast::stmt_marsh_lhs));
                               end
                               else begin
                                 (* In this case, we generate
                                  * a fetch of the pointer value. We then assign the fetched
                                  * pointer value to a temp, and then recursively demarsh the
                                  * temp *)
                                 let temp_var = (get_temporary_variable fdec None jthres ithfield) in
                                 let temp_lv = (lvalify_varinfo temp_var) in
                                 let init_instr = Set(temp_lv, zero64Uexp, locUnknown) in
                                 let stmt_init = (mkStmt (Instr [init_instr])) in
                                 let assgn_lhs = (add_field_to_lval lv ithfieldinfo) in
                                 let assgn_rhs = (expify_lval (lvalify_varinfo temp_var)) in
                                 let assgn_instr = Set(assgn_lhs, assgn_rhs, locUnknown) in
                                 let stmt_assgn = (mkStmt (Instr [assgn_instr])) in
                                 let stmt_demarsh =
                                   (unified_dfs temp_lv jthres fdec fdec2
                                      ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                      marshaling gen_kern) in
                                 m_dm_stmts := (List.append !m_dm_stmts
                                                  (List.append (stmt_init::stmt_demarsh) [stmt_assgn]));
                               end;
                             end;
                           done;
                         end
                         else begin (* Not a void pointer type *)
                           let m_dm_v_stmts =
                             (generate_unified_m_dm fdec lv (Some(ithfieldinfo))
                                ithfieldtyp m_dm_buf m_dm_off fdec2 ptg resfld resform
                                stkdpth marshaling gen_kern) in
                           if (List.length m_dm_v_stmts) <> 0
                           then begin
                             m_dm_stmts := (List.append !m_dm_stmts m_dm_v_stmts);
                           end
                           else begin
                             (* Cannot marshal/demarshal this field type. Simply call marsh/demarsh
                              * function recursively, and generate an assignment. If the address
                              * of a field is taken, then we call it on another variable.*)
                             if ((Marshal_dri.is_field_addr_taken ithfieldinfo) = true) ||
                               ((Marshannot_dri.is_storeoffset ithfieldtyp) = true)
                             then begin
                               let new_lval = (add_field_to_lval lv ithfieldinfo) in
                               let namehint = "STRUCTADDRX" ^ (makevarname (lval_tostring new_lval)) in
                               let addrof_lhs_var = (get_local_variable fdec
                                                       (TPtr(ithfieldtyp,[])) namehint) in
                               let addrof_lhs = (lvalify_varinfo addrof_lhs_var) in
                               let addrof_rhs = (mkAddrOf new_lval) in
                               let addrof_set = Set(addrof_lhs, addrof_rhs, locUnknown) in
                               let stmt_setaddrof = (mkStmt (Instr [addrof_set])) in
                               let star_addrof = (mkMem (expify_lval addrof_lhs) NoOffset) in
                               let stmt_m_dm =
                                 (unified_dfs star_addrof ithfieldtyp fdec fdec2
                                    ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                    marshaling gen_kern) in
                               if (List.length stmt_m_dm) <> 0 then
                                 m_dm_stmts := (List.append !m_dm_stmts [stmt_setaddrof]);
                               m_dm_stmts := (List.append !m_dm_stmts stmt_m_dm);
                             end else begin
                               (*Printf.fprintf stderr "Before adding field %s\n" (lval_tostring lv);*)
                               let new_lval = (add_field_to_lval lv ithfieldinfo) in
                               (*Printf.fprintf stderr "After adding field %s\n" (lval_tostring new_lval);*)
                               let stmt_m_dm =
                                 (unified_dfs new_lval ithfieldtyp fdec fdec2
                                    ptg resfld resform m_dm_buf m_dm_off (stkdpth + 1)
                                    marshaling gen_kern) in
                               m_dm_stmts := (List.append !m_dm_stmts stmt_m_dm);
                             end;
                           end;
                         end;
                       end;
                   | None -> ()
                );
            done;

            if (!ptg_recursive = true) then begin
              (pop_marshstack());
              (infomsg ["Popping from stack:"; (lval_tostring lv);
                        (typ_tostring_noattr lvtyp)]);
            end;
            (* If we had a recursive field access, then we must embed the statements
             * that we just generated within a SENTINEL-guarded while loop *)
            if (!ptg_recursive = true) && (is_recaccess() = true)
            then begin
              if marshaling then (infomsg ["Found recursive access"; fdec.svar.vname; fdec2.svar.vname]);

              let ret_stmts = ref [] in
              (* 1. Generate a statement to save the state of the LV. I automatically
               * generate a save statement for the POINTER to the LV type, as this is
               * the common case. The validity of this needs to be checked on a per-case
               * basis. We do this only if we need to restore the state later *)
              let undereflvopt = (underef_lval lv) in
              let stsv_var = ref dummyFunDec.svar in
              (match undereflvopt with
                 | Some(_) ->
                     let stsvname = "svdst" ^ (makevarname (lval_tostring lv)) in
                     let stsvtyp = (TPtr(lvtyp, [])) in
                     let addroflv = (mkAddrOf lv) in
                     stsv_var := (get_local_variable fdec stsvtyp stsvname);
                     let stsv_set = Set((lvalify_varinfo !stsv_var), addroflv, locUnknown) in
                     let stmt_stsv_set = (mkStmt (Instr [stsv_set])) in
                     ret_stmts := (List.append !ret_stmts [stmt_stsv_set]);
                 | None ->
                     (* Even in this case, let's generate a statement to save state *)
                     let stsvname = "svdst" ^ (makevarname (lval_tostring lv)) in
                     let stsvtyp = (TPtr(lvtyp, [])) in
                     let addroflv = (mkAddrOf lv) in
                     stsv_var := (get_local_variable fdec stsvtyp stsvname);
                     let stsv_set = Set((lvalify_varinfo !stsv_var), addroflv, locUnknown) in
                     let stmt_stsv_set = (mkStmt (Instr [stsv_set])) in
                     (addwarn ["You might need to replace"; (lval_tostring lv); "with"; !stsv_var.vname]);
                     ret_stmts := (List.append !ret_stmts [stmt_stsv_set]);
              );
              (* 2. Generate the statements to marshal/demarshal the fields: Done above already. *)
              (* 3. Embed (2) in a loop. Also update the state (dummy inserted) *)
              (* 3.1. Create a dummy variable to represent the sentinel *)
              let sntname = "SENTINEL" ^ (makevarname (lval_tostring lv)) in
              (*(Printf.fprintf stderr "%s\n" sntname);*)
              let snt_var = get_local_variable fdec intType sntname in
              let snt_init = Set((lvalify_varinfo snt_var), (Cil.integer 1), locUnknown) in
              let stmt_snt_init = (mkStmt (Instr [snt_init])) in
              (* 3.2. Create the conditional to break out of the loop *)
              let snt_exp = expify_lval (lvalify_varinfo snt_var) in
              (* 3.3. The last statement in the loop should be the update of the
               * SENTINEL. We generate one that sets the SENTINEL to 0 *)
              let snt_reset = Set((lvalify_varinfo snt_var), zero, locUnknown) in
              let stmt_snt_reset = (mkStmt (Instr [snt_reset])) in
              (* 3.4. Create the loop itself. *)
              let loop_body = List.append !m_dm_stmts [stmt_snt_reset] in
              let stmts_loop = mkWhile ~guard:(snt_exp) ~body:(loop_body) in
              ret_stmts := List.append !ret_stmts [stmt_snt_init];
              ret_stmts := List.append !ret_stmts stmts_loop;
              (* 4. Follow it up with a statement to restore the state of the LV *)
              (match undereflvopt with
                 | Some(undereflv) ->
                     let stsv_exp = (expify_lval (lvalify_varinfo !stsv_var)) in
                     let stsv_restore = Set(undereflv, stsv_exp, locUnknown) in
                     let stmt_stsv_restore = (mkStmt (Instr [stsv_restore])) in
                     ret_stmts := (List.append !ret_stmts [stmt_stsv_restore]);
                 | None -> ((* No need to restore state in this case *));
              );
              (clear_recaccess());
              !ret_stmts;
            end
            else begin
              !m_dm_stmts;
            end;
          end
        else
          begin
            (* This is IOMEM structure, which means we don't marshal its contents *)
            !m_dm_stmts;
          end
      end
      else begin
        (* This case is not supported. Raise a warning *)
        if (isFunctionType lvtyp) then begin
          (* (addwarn ["Function type not marshaled/demarshaled:"; (lval_tostring lv);
             (typ_tostring_noattr lvtyp); fdec.svar.vname; fdec2.svar.vname]) *)
          ();
        end else begin
          let what_we_are_doing = (if marshaling then "marshaling" else "demarshaling") in
          (addwarn ["This case is currently not supported in "; what_we_are_doing; ":";
                    (lval_tostring lv); (typ_tostring_noattr lvtyp); fdec.svar.vname;
                    fdec2.svar.vname]);
        end;
        [];
      end;
    end (* Else case of infinite loop warning *)
  end

(** gen_marshbuf_free:
 * Generate code to free the marshaling buffer. Inputs are the name of the
 * FREE function, and the varinfo of the buffer to be freed.
 *)
let gen_marshbuf_free (free_func_name: string)
    (marshbuf_varinfo: varinfo) : stmt =
  begin
    let free_fundec = (emptyFunction free_func_name) in
    let free_func = (expify_fundec free_fundec) in
    let free_argslist = [(expify_lval (lvalify_varinfo marshbuf_varinfo))] in
    let call_free_func = Call(None,free_func, free_argslist, locUnknown) in
    let stmt_call_free = (mkStmt (Instr [call_free_func])) in
    let free_check =
      BinOp(Ne, (expify_lval (lvalify_varinfo marshbuf_varinfo)), zero64Uexp, intType) in
    let free_trueblock = (mkBlock [stmt_call_free]) in
    let free_falseblock = (mkBlock []) in
    let free_ifstmt = If(free_check, free_trueblock, free_falseblock, locUnknown) in
    (mkStmt free_ifstmt);
  end

(** Figure out if we're allowed to invoke the kernel or not.
 * The issue is that with symoblic execution, we don't always want to
 * invoke the kernel.  This code will generate a return statement to
 * avoid invoking the kernel if necessary.
 * 
 * It also generates the code necessary to make the return value
 * symbolic.
 *)
let gen_disp_kern_allowed (retvar_typ: typ)
    (retvar_lval: lval option)
    (stmt_ret: stmt)
    (stub_func: fundec): stmt list = 
  begin
    let disp_kern_allowed_retval = makeLocalVar stub_func "disp_kern_allowed_retval" (TInt (IInt, [])) in
    let disp_kern_allowed_retval_lval = lvalify_varinfo disp_kern_allowed_retval in
    let disp_kern_allowed_fundec = emptyFunction "should_disp_kern" in
    let disp_kern_allowed_func = expify_fundec disp_kern_allowed_fundec in
    let disp_kern_allowed_argslist = [] in
    let disp_kern_allowed_call = Call(Some (disp_kern_allowed_retval_lval),
                                      disp_kern_allowed_func,
                                      disp_kern_allowed_argslist,
                                      locUnknown) in
    let disp_kern_allowed_call_stmt = (mkStmt (Instr [disp_kern_allowed_call])) in
    let disp_kern_allowed_check =
      BinOp(Eq, (expify_lval (lvalify_varinfo disp_kern_allowed_retval)), zero64Uexp, intType) in
    let disp_kern_retstmt = stmt_ret in

    let true_block =
      (match retvar_lval with
         | Some(ret_lval) -> 
             let klee_fundec = emptyFunction "klee_make_symbolic" in
             let klee_sizeof = SizeOf (retvar_typ) in
             let klee_name = Const(CStr(stub_func.svar.vname)) in
             let klee_argslist = [mkAddrOf ret_lval; klee_sizeof; klee_name] in
             let klee_func = expify_fundec klee_fundec in
             let klee_call = Call(None,
                                  klee_func,
                                  klee_argslist,
                                  locUnknown) in
             let klee_stmt = mkStmt (Instr [klee_call]) in
             mkBlock [klee_stmt; disp_kern_retstmt];
         | None -> 
             mkBlock [disp_kern_retstmt];
      ) in

    let false_block = mkBlock [] in
    let ifstmt = If(disp_kern_allowed_check, true_block, false_block, locUnknown) in
    [disp_kern_allowed_call_stmt; (mkStmt ifstmt)];
  end

let gen_call_interrupt_handlers (): stmt list =
  begin
    let call_irq_fundec = emptyFunction "call_interrupt_handlers" in
    let call_irq_func = expify_fundec call_irq_fundec in
    let call_irq_argslist = [] in
    let call_irq_call = Call(None,
                             call_irq_func,
                             call_irq_argslist,
                             locUnknown) in
    [mkStmt (Instr [call_irq_call])];
  end

(** gen_disploop:
 * Code that generates the body of the dispatch loop. Takes as input
 * a pointer to struct req_args.
 * Output: Generate the dispatch loop.
 *)
let gen_disploop (gen_kern: bool)
    (marshwrap_funcs: fundec list) : fundec =
  begin
    let stmts = ref [] in
    let disp_funcname = (if gen_kern then "disp_kern" else "disp_user") in
    let disp_func = (emptyFunction disp_funcname) in
    let disp_arg = (makeFormalVar disp_func "arg" (TPtr(struct_reqargs_typ, []))) in
    let star_disp_arg_lh = (Mem((expify_lval (lvalify_varinfo disp_arg)))) in
    let marshret_typ = (TComp(struct_marshret_compinfo, [])) in
    let locvar = (makeLocalVar disp_func "retval" marshret_typ) in
    let locvar_buf = (lvalify_varinfo_field locvar marshret_buf) in
    let set_locvar = Set(locvar_buf, zero64Uexp, locUnknown) in
    let stmt_set_locvar = (mkStmt (Instr [set_locvar])) in
    stmts := (List.append !stmts [stmt_set_locvar]);
    for i = 0 to (List.length marshwrap_funcs) - 1 do
      let ith = (List.nth marshwrap_funcs i) in
      let ith_stripped_name = (strip_marshwrap_prefix ith.svar.vname) in
      let funcid_lval = (star_disp_arg_lh, Field(reqargs_funcid, NoOffset)) in
      let funcid_exp = (expify_lval funcid_lval) in
      let ith_id = (get_function_id ith_stripped_name) in
      let ith_idexp = (integer ith_id) in
      let disp_check = BinOp(Eq, funcid_exp, ith_idexp, intType) in
      let callstmt_fundec = (emptyFunction ith.svar.vname) in
      let callstmt_func = (expify_fundec callstmt_fundec) in

      (* Create first parameter:  arg->data *)
      let buf_lval = (star_disp_arg_lh, Field(reqargs_data, NoOffset)) in
      let buf_exp = (expify_lval buf_lval) in

      (* Create second parameter: &retval *)
      let retval_exp = mkAddrOf (lvalify_varinfo locvar) in

      (* Make the call: __MARSH_WRAP__blah (arg->data, &retval); *)
      let argslist = [buf_exp; retval_exp] in
      let callstmt = Call(None, callstmt_func, argslist, locUnknown) in
      let stmt_callstmt = (mkStmt (Instr [callstmt])) in

      let set_arg_buf_rhs = (expify_lval (lvalify_varinfo_field locvar marshret_buf)) in
      let set_arg_buf_lhs = buf_lval in
      let set_arg_buf = Set(set_arg_buf_lhs, set_arg_buf_rhs, locUnknown) in
      let stmt_set_arg_buf = (mkStmt (Instr [set_arg_buf])) in
      let set_arg_len_rhs = (expify_lval (lvalify_varinfo_field locvar marshret_len)) in
      let len_lval = (star_disp_arg_lh, Field(reqargs_length, NoOffset)) in
      let set_arg_len_lhs = len_lval in
      let set_arg_len = Set(set_arg_len_lhs, set_arg_len_rhs, locUnknown) in
      let stmt_set_arg_len = (mkStmt (Instr [set_arg_len])) in
      let stmt_retstmt = (mkStmt (Return(None,locUnknown))) in
      let check_trueblock =
        (mkBlock [stmt_callstmt; stmt_set_arg_buf; stmt_set_arg_len; stmt_retstmt]) in
      let check_falseblock = (mkBlock []) in
      let check_ifstmt = If(disp_check,check_trueblock,check_falseblock,locUnknown) in
      let stmt_check = (mkStmt check_ifstmt) in
      stmts := (List.append !stmts [stmt_check]);
      (* TODO: This stmt on freeing the marshbuf has to be placed correctly *)
      (*
        let free_after_marsh = (gen_marshbuf_free "MARSHBUF_FREE" locvar) in
        stmts := (List.append !stmts [free_after_marsh]);
      *)
    done;
    (* If none of the above cases were taken, we have a bug. Might as well
     * cause a crash, making it easier to debug, rather than let the driver
     * fail silently *)
    let bug_func_name = "BUG_DRFACT" in
    let bug_func = (emptyFunction bug_func_name) in
    let call_bug_func = Call(None, (expify_fundec bug_func), [], locUnknown) in
    let stmt_call_bug = (mkStmt (Instr [call_bug_func])) in
    let infloop = Loop(mkBlock([stmt_call_bug]), locUnknown, None, None) in
    let stmt_infloop = (mkStmt infloop) in
    stmts := (List.append !stmts [stmt_infloop]);
    disp_func.sbody.bstmts <- !stmts;
    disp_func;
  end

(*---------------------------------------------------------------------------*)
let kernfn_already_accounted_for (funclist_defn: fundec list) (fn: varinfo) : bool =
  begin
    let fdef_matches_decl fdec = (fdec.svar.vname = fn.vname) in
    let fn_defd = (* Given a fundec, tell us if it's been declared *)
      (List.exists fdef_matches_decl funclist_defn) in
    fn_defd;
  end

(** Generates some function bodies for the kernel functions that have had
    their addresses taken in the user half of the driver, but are not interface
    functions (interface functions have been called and will get a body).
*)
let gen_dummy_bodies (funclist_defn: fundec list) (funclist_decl: varinfo list) : global list =
  begin
    let dummy_fn_list = ref [] in
    for i = 0 to (List.length funclist_decl) - 1 do
      let ith = (List.nth funclist_decl i) in
      if (kernfn_already_accounted_for funclist_defn ith) = false &&
        (is_interface_function ith.vname) == false
      then
        begin
          (* First define the function, parameters etc *)
          let dummy_fn_name = ith.vname in
          let dummy_fn = (emptyFunction dummy_fn_name) in
          (setFunctionTypeMakeFormals dummy_fn ith.vtype);
          dummy_fn_list := (List.append !dummy_fn_list [GFun (dummy_fn, locUnknown)]);
        end
    done;
    !dummy_fn_list;
  end

(* Generates a call to the nooks_ot_register_userfn function *)
let gen_register_call (fdec: exp) (fn_name : string) : stmt =
  begin
    let fn_id = (get_function_id fn_name) in
    let nooks_registerfn_funcname = !nooks_registerfn_fn in
    let nooks_registerfn_func = (emptyFunction nooks_registerfn_funcname) in
    let fnarg = fdec in
    let fncodearg = (integer fn_id) in
    let argslist = [fnarg; fncodearg] in
    let callstmt =
      Call(None, (expify_fundec nooks_registerfn_func), argslist, locUnknown) in
    let stmt_callstmt = (mkStmt (Instr [callstmt])) in
    stmt_callstmt;
  end

(** gen_registerfn:
 * The function that registers functions whose addresses are taken with the
 * object tracker. We must manually insert a call to this function at an
 * appropriate place
 *)
let gen_registerfn (funclist_defn: fundec list) (funclist_decl: varinfo list): fundec =
  begin
    let stmts = ref [] in
    let registerfn_funcname = "register_functions" in
    let registerfn_func = (emptyFunction registerfn_funcname) in
    (* Register list of functions which already have bodies *)
    for i = 0 to (List.length funclist_defn) - 1 do
      let ith = (List.nth funclist_defn i) in
      let fnarg = (expify_fundec ith) in
      let stmt_callstmt = (gen_register_call fnarg ith.svar.vname) in
      stmts := (List.append !stmts [stmt_callstmt]);
    done;

    (* Register the list of functions that we need to create bodies for.
       These are functions defined in the kernel whose addresses are taken
       on the user side *)
    for i = 0 to (List.length funclist_decl) - 1 do
      let ith = (List.nth funclist_decl i) in
      if (kernfn_already_accounted_for funclist_defn ith) = false then
        begin
          let fnarg = (expify_lval (lvalify_varinfo ith)) in
          let stmt_callstmt = (gen_register_call fnarg ith.vname) in
          stmts := (List.append !stmts [stmt_callstmt]);
        end
    done;

    registerfn_func.sbody.bstmts <- !stmts;
    registerfn_func;
  end

(*---------------------------------------------------------------------------*)
(** glob_dfs:
 * Given a global variable as input: Traverse it using DFS (and RECURSE annots
 * to break recursion) and emit a list of lvals reachable from the top-level
 * global. Examine if this is a globreg global, and only then register it *)
let rec glob_dfs (glob: lval)
    (stkdpth: int) : lval list =
  begin
    let retval = ref [] in
    if (stkdpth > !threshold_stackdepth)
    then begin
      (addwarn ["Potentially infinite loop in glob_dfs"]);
      !retval;
    end
    else begin
      let globtyp = (typeOfLval glob) in
      if (Marshannot_dri.is_globreg globtyp) then begin
      (*if true then begin*)
        retval := (List.append !retval [glob]);
        if (isCompoundType globtyp)
        then begin
          let globcomp = (tcomp_compinfo globtyp) in
          (match globcomp with
             | Some(globcompinfo) ->
                 let fieldinfolist = globcompinfo.cfields in
                 for i = 0 to (List.length fieldinfolist) - 1 do
                   let ith = (List.nth fieldinfolist i) in
                   let newlval = (add_field_to_lval glob ith) in
                   retval := (List.append !retval (glob_dfs newlval (stkdpth + 1)));
                 done;
             | None -> ();
          );
        end else if (isPointerType globtyp)
        then begin
          (* Dereference and recurse, unless of course we have a recurse type *)
          if ((Marshannot_dri.is_recursive globtyp) = false)
          then begin
            let deref_lv = (Mem((expify_lval glob)), NoOffset) in
            retval := (List.append !retval (glob_dfs deref_lv (stkdpth + 1)));
          end;
        end;
      end;
      !retval;
    end;
  end

(*---------------------------------------------------------------------------*)
(** gen_registerglob:
 * The function that registers global variables with the object tracker.
 * object tracker. We must manually insert a call to this function at an
 * appropriate place
 *)
let gen_registerglob (glist: varinfo list) : fundec =
  begin
    let stmts = ref [] in
    let registerglob_funcname = "register_globals" in
    let registerglob_func = (emptyFunction registerglob_funcname) in
    (* Register list of functions *)
    for i = 0 to (List.length glist) - 1 do
      let ith = (List.nth glist i) in
      let lval_list = (remove_repeats (glob_dfs (lvalify_varinfo ith) 0)) in
      for j = 0 to (List.length lval_list) - 1 do
        let jth = (List.nth lval_list j) in
        let jth_id = (get_lval_id jth) in
        let nooks_registerfn_funcname = !nooks_registerfn_fn in
        let nooks_registerfn_func = (emptyFunction nooks_registerfn_funcname) in
        let lvalarg = ref (expify_lval jth) in
        if (isPointerType (typeOfLval jth)) = false &&
          (isArrayType (typeOfLval jth)) = false
        then lvalarg := (mkAddrOf jth);
        let lvalcodearg = (integer jth_id) in
        let argslist = [!lvalarg; lvalcodearg] in
        let callstmt =
          Call(None, (expify_fundec nooks_registerfn_func), argslist, locUnknown) in
        let stmt_callstmt = (mkStmt (Instr [callstmt])) in
        stmts := (List.append !stmts [stmt_callstmt]);
      done
    done;
    registerglob_func.sbody.bstmts <- !stmts;
    registerglob_func;
  end


(*---------------------------------------------------------------------------*)
(* Examine the list of globals and emit a list of varinfos, representing global
 * names to be registered. Don't include functions here.
 * Propagate the "globreg" attribute so gen_registerglob generates the necessary
 * statements.
 *)
let get_globals_to_register (glist: global list) : varinfo list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length glist) - 1 do
      let ith = (List.nth glist i) in
      (match ith with
         | GVarDecl(v,_) ->
             if (isFunctionType v.vtype) = false &&
               (v.vaddrof) then
                 begin
                   retval := (List.append !retval [v]);
                   v.vtype <- typeAddAttributes [Attr("globreg", [])] v.vtype;
                   (addwarn ["Global to register:"; v.vname]);
                 end;
         | GVar(v,_,_) ->
             if (isFunctionType v.vtype) = false &&
               (v.vaddrof) then
                 begin
                   retval := (List.append !retval [v]);
                   v.vtype <- typeAddAttributes [Attr("globreg", [])] v.vtype;
                   (addwarn ["Global to register:"; v.vname]);
                 end;
         | _ -> ();
      );
    done;
    !retval;
  end

(*---------------------------------------------------------------------------*)
(* No global variables in the slave should be extern *)
let make_globals_nonextern (glist: global list) : global list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length glist) - 1 do
      let ith = (List.nth glist i) in
      (match ith with
         | GVarDecl(v,_) ->
             if (v.vstorage = Extern)
             then begin
               (addwarn ["Converting to NoStorage"; v.vname;]);
               v.vstorage <- NoStorage;
             end;
         | GVar(v,_,_) ->
             if (v.vstorage = Extern)
             then begin
               (addwarn ["Converting to NoStorage"; v.vname;]);
               v.vstorage <- NoStorage;
             end;
         | _ -> ();
      );
      retval := (List.append !retval [ith]);
    done;
    !retval;
  end

(* Delete all the specified function bodies from the list of globals.
   The idea is that these functions are defined elsewhere in user mode,
   i.e. part of the userdaemon, so it's not necessary to keep their function
   definitions in the CIL output.  This is particularly important for UML,
   because UML defines some functions like inb/outb in header files, but
   we want to use our own implementations. *)
(*let delete_nonstubs (glist: global list) : global list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length glist) - 1 do
      let ith = (List.nth glist i) in
      (match ith with
         | GFun(fdec, loc) ->
             begin
               Printf.fprintf stderr "Considering function proto: %s\n" fdec.svar.vname;
               try (ignore (Hashtbl.find nonstubbed_functions fdec.svar.vname));
                 begin
                   (* In this case, the function was on the list, so we delete it *)
                   (* The idea is to keep the prototype, delete any extra "fluff"
                      that will screw things up, and continue.  We don't want
                      to keep the body *)

                   Printf.fprintf stderr "kernel function proto: %s\n" fdec.svar.vname;

                   try (ignore (Hashtbl.find nonstubbed_functions_delete_proto fdec.svar.vname));
                     begin
                       (* In this case, we simply delete the prototype *)
                       Printf.fprintf stderr "  deleting proto %s\n" fdec.svar.vname;
                     end
                   with Not_found ->
                     begin
                       (* In this case, we have to keep the prototype. *)
                       fdec.svar.vstorage <- NoStorage; (* Get rid of inline specifically *)
                       fdec.svar.vattr <- []; (* Get rid of __always_inline__ specifically *)
                       fdec.svar.vtype <- strip_typ_attribs fdec.svar.vtype;
                       let newproto = GVarDecl(fdec.svar, loc) in
                       (*newprotos := List.append !newprotos [newproto];*)
                       retval := List.append !retval [newproto];
                     end
                 end
               with Not_found ->
                 (* In this case, the function was not on the list, so we keep it *)
                 retval := (List.append !retval [ith]);
             end
         | _ ->
             retval := (List.append !retval [ith]);
      );
    done;
    !retval;
  end
*)

(*
let delete_nonstubs (glist: global list) : global list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length glist) - 1 do
      let ith = List.nth glist i in
      (match ith with
         | GVarDecl(vi, loc) ->
             (match vi.vtype with
                | TFun (_, _, _, _) ->
                    begin
                      Printf.fprintf stderr "Considering function proto: %s\n" vi.vname;
                      try (ignore (Hashtbl.find nonstubbed_functions vi.vname));
                        begin
                          (* In this case, the function was on the list, so we delete it *)
                          (* The idea is to keep the prototype, delete any extra "fluff"
                             that will screw things up, and continue.  We don't want
                             to keep the body *)
                          Printf.fprintf stderr "kernel function proto: %s\n" vi.vname;

                          try (ignore (Hashtbl.find nonstubbed_functions_delete_proto vi.vname));
                            begin
                              (* In this case, we simply delete the prototype *)
                              Printf.fprintf stderr "  deleting proto %s\n" vi.vname;
                            end
                          with Not_found ->
                            begin
                              (* In this case, we have to keep the prototype. *)
                              vi.vstorage <- NoStorage; (* Get rid of inline specifically *)
                              vi.vattr <- []; (* Get rid of __always_inline__ specifically *)
                              vi.vtype <- strip_typ_attribs vi.vtype;
                              let newproto = GVarDecl(vi, loc) in
                              (*newprotos := List.append !newprotos [newproto];*)
                              retval := List.append !retval [newproto];
                            end
                        end
                      with Not_found ->
                        (* In this case, the function was not on the list, so we keep it *)
                        retval := List.append !retval [ith];
                    end
                | _ ->
                    retval := List.append !retval [ith];
             );
         | _ ->
             retval := List.append !retval [ith];
      );
    done;
    !retval;
  end
*)

 
let delete_nonstubs (glist: global list) : global list =
  begin
    let retval = ref [] in
    for i = 0 to (List.length glist) - 1 do
      let ith = List.nth glist i in
      (match ith with
         | GFun(fdec, loc) ->
             begin
               Printf.fprintf stderr "Considering function body: %s\n" fdec.svar.vname;
               try (ignore (Hashtbl.find nonstubbed_functions fdec.svar.vname));
                 begin
                   (* In this case, the function was on the list, so we delete it *)
                   (* The idea is to keep the prototype, delete any extra "fluff"
                      that will screw things up, and continue.  We don't want
                      to keep the body *)

                   Printf.fprintf stderr "kernel function proto: %s\n" fdec.svar.vname;

                   try (ignore (Hashtbl.find nonstubbed_functions_delete_proto fdec.svar.vname));
                     begin
                       (* In this case, we simply delete the prototype *)
                       Printf.fprintf stderr "  deleting proto %s\n" fdec.svar.vname;
                     end
                   with Not_found ->
                     begin
                       (* In this case, we have to keep the prototype. *)
                       fdec.svar.vstorage <- NoStorage; (* Get rid of inline specifically *)
                       fdec.svar.vattr <- []; (* Get rid of __always_inline__ specifically *)
                       fdec.svar.vtype <- strip_typ_attribs fdec.svar.vtype;
                       let newproto = GVarDecl(fdec.svar, loc) in
                       retval := List.append !retval [newproto];
                     end
                 end
               with Not_found ->
                 (* In this case, the function was not on the list, so we keep it *)
                 retval := (List.append !retval [ith]);
             end
         | GVarDecl(vi, loc) ->
             (match vi.vtype with
                | TFun (_, _, _, _) ->
                    begin
                      Printf.fprintf stderr "Considering function proto: %s\n" vi.vname;
                      try (ignore (Hashtbl.find nonstubbed_functions vi.vname));
                        begin
                          (* In this case, the function was on the list, so we delete it *)
                          (* The idea is to keep the prototype, delete any extra "fluff"
                             that will screw things up, and continue.  We don't want
                             to keep the body *)
                          Printf.fprintf stderr "kernel function proto: %s\n" vi.vname;

                          try (ignore (Hashtbl.find nonstubbed_functions_delete_proto vi.vname));
                            begin
                              (* In this case, we simply delete the prototype *)
                              Printf.fprintf stderr "  deleting proto %s\n" vi.vname;
                            end
                          with Not_found ->
                            begin
                              (* In this case, we have to keep the prototype. *)
                              vi.vstorage <- NoStorage; (* Get rid of inline specifically *)
                              vi.vattr <- []; (* Get rid of __always_inline__ specifically *)
                              vi.vtype <- strip_typ_attribs vi.vtype;
                              let newproto = GVarDecl(vi, loc) in
                              retval := List.append !retval [newproto];
                            end
                        end
                      with Not_found ->
                        (* In this case, the function was not on the list, so we keep it *)
                        retval := List.append !retval [ith];
                    end
                | _ ->
                    retval := List.append !retval [ith];
             );
         | _ ->
             retval := List.append !retval [ith];
      );
    done;
    !retval;
  end


(*---------------------------------------------------------------------------*)
(** Splitting algorithm implementation
 * This takes a file as input, and outputs a modification of the file, based
 * upon which portion is being generated (kernel or user portion). The idea
 * is that this analysis must be run twice: once to obtain the kernel portion,
 * which is the master and once to obtain the user portion, which is the slave.
 *)
(** splitter_unified
 * Main steps:
 * (1) To generate stubs for functions that are marked as kernel functions.
 * (2) For functions that lack a fundec, generate a function body: This is
 *     done separately in the function get_new_fundecs
*)
(**
 * Considers those functions that have the kern annotation.  For
 * those such functions that have fundecs, their function bodies are
 * replaced by a call to the function in the master.  For those such
 * functions that do not have fundecs, a function body is
 * genenerated calling the function in the kernel (with an
 * appropriate extern statement generated.  *)
(*---------------------------------------------------------------------------*)
(** splitter_unified: This generates the master or slave,
 *  i.e., code to execute on the kernel or user side. *)
class splitter_unified = object (self)
  inherit nopCilVisitor
  (** A list of marshwrap functions that have been added *)
  val mutable marshwrap_funcs : fundec list = [];
  (** A list of datastructure-specific functions that have been added *)
  val mutable ds_funcs : fundec list = [];
  (** A list of functions to make static *)
  val mutable static_funcs : fundec list = [];
  (** A list of functions to make NoStorage *)
  val mutable nostorage_funcs : fundec list = [];
  (** A temporary varinfo, storing the name of the marshaling buffer *)
  val mutable curr_marshbuf : varinfo option = None;
  (** A temporary varinfo.  When generating the master, it
   *  stores the name of the current marshaling buffer offset.
   * When generating the slave, it stores the size of the marshaling
   * buffer.
   *)
  val mutable curr_marshoff : varinfo option = None;
  (** A temporary variable, storing the current ptg *)
  val mutable curr_ptg: (string, (typ * string * string)) Hashtbl.t
    = (Hashtbl.create 5);
  (** A temporary variable, storing the current set of globals accessed *)
  val mutable curr_globs : varinfo list = [];
  (** A temporary variable, storing the current resfld *)
  val mutable curr_resfld: (string, (typ * fieldinfo * typ)) Hashtbl.t
    = (Hashtbl.create 5);
  (** A temporary variable, storing the current resform *)
  val mutable curr_resform: (string, (int * varinfo * typ)) Hashtbl.t
    = (Hashtbl.create 5);
  (** A list of non-interface functions with "kern" or "user" annotations.
   *  When generating the master, it contains those with "user" annotations.
   *  When generating the slave, it contains those with "kern" annotations. *)
  val mutable non_interface_functions: (string, fundec) Hashtbl.t
    = (Hashtbl.create 5);

  (** A list of functions whose addresses are taken. We must register these
      with the object tracker.  Includes only those functions for which
      we've encountered a function _definition_, e.g. the body.
  *)
  val mutable fn_addr_taken_defn : fundec list = [];
  (** A list of functions whose addresses are taken, but for which all we've
      observed is the _declaration_ (e.g. prototype) and not the body.
      This list may include some functions already present in the previous
      list, like those that have both a prototype and body.  If we're taking
      the address of a function that has only a prototype, then we need to
      supply the body.  Happens in the user-half with kernel functions.
  *)
  val mutable fn_addr_taken_decl : varinfo list = [];

  (** True if we are generating master code, false if we are generating slave *)
  val mutable gen_kern : bool = true;

  (* call_m_dm_in_stub: This function simply generates the temporary variables,
   * finds the list of fields to be marshaled by querying the points-to
   * graph, and calls the DFS based marshaler. Varinfos other than those
   * obtained from the arguments of the functions that need to be marshaled
   * are passed as a list. The marshaling parameter is true if we are generating
   * marshaling code, false otherwise.
   *)
  method call_m_dm_in_stub
    (f: fundec)
    (vl: varinfo list)
    (marshaling: bool)
    : stmt list =
    begin
      let ret_stmts = ref [] in
      (* If we're marshaling, we are filling a buffer.  If we are demarshaling,
         we are worrying about the offset in the existing buffer. *)
      let var_name = (if marshaling then "_buf_" else "_off_") in
      (* Create a new void * variable to store marshaled arguments *)
      let var_type = (if marshaling then voidPtrType else intType) in
      let m_dm = (get_temporary_variable f None var_type var_name) in
      (* Insert a statement initializing (de)marsh(buf/off) *)
      let init_m_dm_lhs = (lvalify_varinfo m_dm) in
      let init_m_dm_rhs = zero64Uexp in
      let init_m_dm = Set(init_m_dm_lhs,init_m_dm_rhs,locUnknown) in
      let stmts_init_m_dm = (mkStmt (Instr [init_m_dm])) in
      ret_stmts := (List.append !ret_stmts [stmts_init_m_dm]);

      let ptg = ref curr_ptg in
      (* TODO assigning to m_dm, but it should never be used in that case.  It's only
         used during marshaling.*)
      let marshoff = (if marshaling then (get_temporary_variable f None intType "_off_")
                      else m_dm) in
      if marshaling then begin
        (* Create a new variable to offset into the m_dm buffer.
         * Initialize it to 0*)
        curr_marshbuf <- Some(m_dm);
        curr_marshoff <- Some(marshoff);
        (* The initial malloc of m_dm must happen in fill_m_dm *)
        (* Insert a statement initializing marshoff *)
        let init_marshoff_lhs = (lvalify_varinfo marshoff) in
        let init_marshoff_rhs = zero64Sexp in
        let init_marshoff = Set(init_marshoff_lhs,init_marshoff_rhs,locUnknown) in
        let stmt_init_marshoff = (mkStmt (Instr [init_marshoff])) in
        ret_stmts := (List.append !ret_stmts [stmt_init_marshoff]);
        (* Get the flattened points-to graph to tell us what to marshal/demarshal *)
        ptg := Marshal_dri.get_flattened_ptg f.svar.vname false;
        (Printf.fprintf stderr "stub::::: %s %d\n" f.svar.vname (Hashtbl.length !ptg));
        curr_ptg <- !ptg;
        (* Get the globals accessed *)
        curr_globs <- (Marshal_dri.get_globals_accessed f.svar.vname);
        curr_globs <- (remove_repeats curr_globs);
      end;

      (* Now send the roots to the DFS-based marshaler *)
      (* Return variable information is stored in vl *)
      let roots = (List.append curr_globs (List.append f.sformals vl)) in
      let resfld = (if marshaling then (Marshal_dri.get_resolved_fields())
                    else curr_resfld) in
      let resform = (if marshaling then (Marshal_dri.get_resolved_formals())
                     else curr_resform) in
      if marshaling then begin
        curr_resfld <- resfld;
        curr_resform <- resform;
      end;

      for i = 0 to (List.length roots) - 1 do
        let ith = (List.nth roots i) in
        let ithlv = (lvalify_varinfo ith) in
        let ithtyp = (ith.vtype) in

        if marshaling then begin
          ret_stmts := (List.append !ret_stmts
                          (unified_dfs ithlv ithtyp f f
                             !ptg resfld resform m_dm marshoff 0
                             true gen_kern));
          end
        else begin
          (match curr_marshbuf with
             | Some(demarshbuf) ->
                 ret_stmts := (List.append !ret_stmts
                                 (unified_dfs ithlv ithtyp f f
                                    !ptg resfld resform demarshbuf m_dm 0
                                    false gen_kern));
             | None -> (fatal ["Could not find a demarshaling buffer"]);
          );
        end
      done;
      !ret_stmts;
    end

  (** stubgen_funs: Stub generation *)
  method stubgen_funs (f: fundec) : stmt list =
    begin
      (* 0. Generate the marshaling code at the call site *)
      let marshaling_code = (self#call_m_dm_in_stub f [] true) in
      (* 1. Create a new variable of the appropriate type and add it to f's slocals *)
      (* Also create the "extra" varinfo list for demarshaling *)
      let demarshlist = ref [] in
      let (ret_var_type,_,isvararg,_) = (splitFunctionType f.svar.vtype) in
      if (isvararg = true)
      then (fatal [f.svar.vname; "VARARGS not supported in stubgen_funs for fn:" ^ f.svar.vname]);
      
      let retvar_init_stmts = ref [] in
      let ret_var =
        (match ret_var_type with
           | TVoid(_) -> None;
           | _ ->
               let ret_var_varinfo = (makeTempVar f ~name:("retval") ret_var_type) in
               (* Initialize any new pointer variables to NULL *)
               (* Since this is stub generator, also sent ints to 0, so 
                  the subsequent disp_kern_allowed code works *)
               if (isPointerType ret_var_varinfo.vtype) ||
                 (isIntegralType ret_var_varinfo.vtype) then
                   begin
                     let retvar_init = Set((lvalify_varinfo ret_var_varinfo), zero64Uexp, locUnknown) in
                     let stmt_retvar_init = (mkStmt (Instr [retvar_init])) in
                     retvar_init_stmts := [stmt_retvar_init];
                   end;
               demarshlist := (List.append !demarshlist [ret_var_varinfo]);
               Some(Var(ret_var_varinfo),NoOffset)
        )
      in
      (* 3. Create the return statement *)
      let ret_stub =
        (match ret_var with
           | Some(ret_lval) -> Return(Some(expify_lval ret_lval), locUnknown);
           | None -> Return(None, locUnknown);
        ) in
      let stmt_ret = (mkStmt ret_stub) in
      let disp_kern_allowed = 
        if gen_kern = false then
          []
            (*
          gen_disp_kern_allowed ret_var_type ret_var stmt_ret f
            *)
        else
          []
      in

      (* Make sure all formal parameters have names.  Sometimes,
         the function prototype is provided without variable names--
         in these cases, we make some up. *)
      ensure_formals_have_names f;

      (* <The following code uses unlock_user_thread or disp_kern to
         call a function in the user and is the function that must be
         used with two address spaces> *)
      let switch_func = (if gen_kern then (get_unblock_user_thread_fundec()) else (get_disp_kern_fundec ())) in
      let switch_func_expr = (expify_fundec switch_func) in
      (* Create a new local variable rqarg of type req_args *)
      let rqarg_typ = struct_reqargs_typ in
      let rqarg_varinfo = (get_local_variable f rqarg_typ "rqarg") in
      (* Get the ID of the function to be called, and assign it to rqarg *)
      let tgt_funcid = (get_function_id f.svar.vname) in
      let tgt_funcid_exp = (integer tgt_funcid) in
      let stmt_setrqargfuncid = (mkStmtOneInstr
                                   (Set ((Var(rqarg_varinfo), Field(reqargs_funcid, NoOffset)),
                                         tgt_funcid_exp, locUnknown))) in
      (* Get the buffer that stores the data *)
      let curr_marshbuf_varinfo = ref dummyFunDec.svar in
      (match curr_marshbuf with
         | Some(marshbuf) -> curr_marshbuf_varinfo := marshbuf;
         | None -> (fatal ["no marshbuf found"]);
      );
      let curr_marshbuf_lval = (lvalify_varinfo !curr_marshbuf_varinfo) in
      let curr_marshbuf_exp = (expify_lval curr_marshbuf_lval) in
      let stmt_setrqargdata = (mkStmtOneInstr
                                 (Set ((Var(rqarg_varinfo), Field(reqargs_data, NoOffset)),
                                       curr_marshbuf_exp, locUnknown))) in
      (* Get the length of the buffer *)
      let curr_marshoff_varinfo = ref dummyFunDec.svar in
      (match curr_marshoff with
         | Some(marshoff) -> curr_marshoff_varinfo := marshoff;
         | None -> (fatal ["no marshoff found"]);
      );
      let curr_marshoff_lval = (lvalify_varinfo !curr_marshoff_varinfo) in
      let curr_marshoff_exp = (expify_lval curr_marshoff_lval) in
      let stmt_setrqarglength = (mkStmtOneInstr
                                   (Set ((Var(rqarg_varinfo), Field(reqargs_length, NoOffset)),
                                         curr_marshoff_exp, locUnknown))) in

      (* Create a call to unblock_user_thread/disp_kern *)
      let rqarg_lval = (lvalify_varinfo rqarg_varinfo) in
      let rqarg_exp = (mkAddrOf rqarg_lval) in
      let argslist = [rqarg_exp] in
      let call_switch_func = Call(None, switch_func_expr, argslist, locUnknown) in
      let stmt_call_switch_func = (mkStmt (Instr [call_switch_func])) in
      (* Fetch the value of rqarg.data into the marshaling buffer *)
      let rqargdata_lval = (Var(rqarg_varinfo), Field(reqargs_data, NoOffset)) in
      let stmt_getrqargdata = (mkStmtOneInstr
                                 (Set (curr_marshbuf_lval, (expify_lval rqargdata_lval), locUnknown))) in
      let stmts_switch =
        [stmt_setrqargfuncid; stmt_setrqargdata;
         stmt_setrqarglength; stmt_call_switch_func; stmt_getrqargdata] in

      (* 4. Insert the demarshaling code after the return *)
      let demarshaling_code = (self#call_m_dm_in_stub f !demarshlist false) in
      (* 5. Create the code to free the marshaling buffer *)
      let curr_marshbuf_varinfo = ref dummyFunDec.svar in
      (match curr_marshbuf with
         | Some(demarshbuf) -> curr_marshbuf_varinfo := demarshbuf;
         | None -> (fatal ["no marshbuf found"]);
      );
      (* let free_after_marsh = (gen_marshbuf_free "MARSHBUF_FREE" !curr_marshbuf_varinfo) in *)
      let free_after_demarsh = (gen_marshbuf_free "DEMARSHBUF_FREE" !curr_marshbuf_varinfo) in
      (* 6. Create the list of statements to return *)
      let ret_stmts = ref [] in
      if gen_kern then begin
        let down_rec_lock_stmts = generate_sync_call "ACQUIRE_REC_LOCK" in
        ret_stmts := List.append !ret_stmts down_rec_lock_stmts;
      end;
      ret_stmts := (List.append !ret_stmts !retvar_init_stmts);
      ret_stmts := (List.append !ret_stmts disp_kern_allowed);
      ret_stmts := (List.append !ret_stmts marshaling_code);
      ret_stmts := (List.append !ret_stmts stmts_switch);
      (* XXX   ret_stmts := (List.append !ret_stmts [free_after_marsh]); *)
      ret_stmts := (List.append !ret_stmts demarshaling_code);
      ret_stmts := (List.append !ret_stmts [free_after_demarsh]);
      if gen_kern then begin
        let up_marshsem_stmts = generate_sync_call "UP_MARSH_SEM" in
        ret_stmts := List.append !ret_stmts up_marshsem_stmts;
        let up_rec_lock_stmts = generate_sync_call "RELEASE_REC_LOCK" in
        ret_stmts := List.append !ret_stmts up_rec_lock_stmts;
      end;
      ret_stmts := (List.append !ret_stmts [stmt_ret]);
      !ret_stmts;
    end

  (* In a marshwrap function, this code generates the actual call to the function
     being wrapped.  This call takes place between the demarshaling code at the
     start of the function, and the marshaling code at the end of the function.
     Furthermore, this code deals with the Java if-statement feature, so we can
     easily regenerate the split and regain all our Java functionality. *)
  method gen_marshwrap_call
    (callargs : varinfo list ref)
    (fdec_name : string)
    (fdec_type : typ)
    (marshwrap_func : fundec) : (stmt list * varinfo option) =
    let trueblock_stmts = ref [] in
    let falseblock_stmts = ref [] in

    (* First, deal with the true block, which is env == NULL *)
    let (ret_var_type,_,_,_) = splitFunctionType fdec_type in
    let (ret_varinfo_opt, ret_var_opt) =
      match ret_var_type with
        | TVoid(_) -> None, None;
        | _ ->
            let ret_var_varinfo = makeTempVar marshwrap_func ~name:("retval") ret_var_type in
            (* Initialize any new pointer variables to NULL *)
            if isPointerType ret_var_varinfo.vtype then begin
              let retvar_init = Set((lvalify_varinfo ret_var_varinfo), zero64Uexp, locUnknown) in
              let stmt_retvar_init = mkStmt (Instr [retvar_init]) in
              trueblock_stmts := List.append !trueblock_stmts [stmt_retvar_init];
              falseblock_stmts := List.append !falseblock_stmts [stmt_retvar_init];
            end;
            Some(ret_var_varinfo), Some (Var(ret_var_varinfo),NoOffset);
    in
    (* First generate the function call to the original C function.
       This function call gets added to the trueblock of the if statement.
    *)
    let callfdec_fundec = emptyFunction fdec_name in
    let callfdec_func = expify_fundec callfdec_fundec in
    let argslist = expify_formals !callargs in
    let callfdec = Call(ret_var_opt, callfdec_func, argslist, locUnknown) in
    let stmt_callfdec = mkStmt (Instr [callfdec]) in
    trueblock_stmts := List.append !trueblock_stmts [stmt_callfdec];

    (!trueblock_stmts, ret_varinfo_opt);

  (** add_marshwrap_function: Add a marshaling wrapper for "interface"
   * functions that are implemented in the user space, or a marshaling
   * wrapper for functions with no fundec defined in the kernel.
   *)
  method add_marshwrap_function
    (fdec_fundec_opt : fundec option)
    (vinfo_opt : varinfo option)
      : fundec =
    begin
      let stmts = ref [] in
      let newroots = ref [] in
      let callargs = ref [] in
      let (name, marshwrap_funcname, marshwrap_func, fdec, fdec_typ, nofundec) =
        match fdec_fundec_opt with
          | None ->
              (match vinfo_opt with
                 | None ->
                     fatal ["Error add_marshwrap_function, specify one of the two params"]
                 | Some (vinfo) ->
                     let marshwrap_funcname = marshwrap_prefix ^ vinfo.vname in
                     let marshwrap_func = emptyFunction marshwrap_funcname in
                     (vinfo.vname, marshwrap_funcname, marshwrap_func,
                      marshwrap_func, vinfo.vtype, true)
              );
          | Some (fdec_fundec) ->
              (match vinfo_opt with
                 | None ->
                     let marshwrap_funcname = marshwrap_prefix ^ fdec_fundec.svar.vname in
                     let marshwrap_func = emptyFunction marshwrap_funcname in
                     (fdec_fundec.svar.vname, marshwrap_funcname, marshwrap_func,
                      fdec_fundec, fdec_fundec.svar.vtype, false)
                 | Some (vinfo) ->
                     fatal ["Error add_marshwrap_function, specify one of the two params"]
              );
      in
      let marshwrap_rettyp = TVoid([]) in
      let marshwrap_typsig = TFun(marshwrap_rettyp, Some([]), false, []) in
      (setFunctionType marshwrap_func marshwrap_typsig);
      (* Add __MARSH_WRAP__ function parameters *)
      let marshwrap_arg_buf = (makeFormalVar marshwrap_func "_buf_" voidPtrType) in
      let marshwrap_arg_ret = (makeFormalVar marshwrap_func "_ret_" 
                                 (TPtr (TComp(struct_marshret_compinfo, []), []))
                              ) in
      (* 1. Create a new local variable to store offsets *)
      let offvar = (makeLocalVar marshwrap_func "_off_" intType) in
      (* 1.1. Create a new local variable of type struct marshret_struct *)
      (*let marshwrap_ret = (makeLocalVar marshwrap_func "_ret_" marshwrap_rettyp) in*)
      (* 2. Create an initialization for this variable *)
      let init_offvar_lhs = (lvalify_varinfo offvar) in
      let init_offvar_rhs = zero64Sexp in
      let init_offvar = Set(init_offvar_lhs, init_offvar_rhs, locUnknown) in
      let stmt_init_offvar = (mkStmt (Instr [init_offvar])) in
      stmts := (List.append !stmts [stmt_init_offvar]);
      (* 3. Demarsh the roots *)
      (* 3.1 Get the ptg *)
      let ptg = Marshal_dri.get_flattened_ptg name false in
      (Printf.fprintf stderr "marshwrap::::: %s %d\n" name (Hashtbl.length ptg));
      let resfld = (Marshal_dri.get_resolved_fields()) in
      let resform = (Marshal_dri.get_resolved_formals()) in
      let globs = (Marshal_dri.get_globals_accessed name) in
      let globs = (remove_repeats globs) in
      (* 3.2 Demarsh globals first *)
      for i = 0 to (List.length globs) - 1 do
        let ith = (List.nth globs i) in
        newroots := (List.append !newroots [ith]);
        let ithlv = (lvalify_varinfo ith) in
        (* Use the marshbuf formal param during demarshaling *)
        stmts := (List.append !stmts
                    (unified_dfs ithlv ith.vtype marshwrap_func fdec
                       ptg resfld resform marshwrap_arg_buf offvar 0
                       false gen_kern));
      done;
      (* 3.3 For each formal variable of fdec, create a new local variable the
         new function. *)
      if nofundec = false then
        let roots = fdec.sformals in
        for i = 0 to (List.length roots) - 1 do
          let ith = List.nth roots i in
          let newvar = makeLocalVar marshwrap_func ith.vname ith.vtype in
          (* Initialize any new pointer variables to NULL *)
          if (isPointerType newvar.vtype) then begin
            let newvar_init = Set((lvalify_varinfo newvar), zero64Uexp, locUnknown) in
            let  stmt_newvar_init = (mkStmt (Instr [newvar_init])) in
            stmts := (List.append !stmts [stmt_newvar_init]);
          end;
          newroots := (List.append !newroots [newvar]);
          callargs := (List.append !callargs [newvar]);
          let newvarlv = (lvalify_varinfo newvar) in
          let newvartyp = (newvar.vtype) in
          (* Use the marshbuf formal param during demarshaling *)
          stmts := (List.append !stmts
                      (unified_dfs newvarlv newvartyp marshwrap_func fdec
                         ptg resfld resform marshwrap_arg_buf offvar 0
                         false gen_kern));
        done;
      else
        begin
          (* In this case, we don't have any varinfos, so we have to construct
             them on the basis of the type definition *)
          let (_,argsopt,_,_) = splitFunctionType fdec_typ in
          let roots = Cil.argsToList argsopt in
          for i = 0 to (List.length roots) - 1 do
            let formalname = ref "" in
            let (ithstr,ithtyp,ithattr) = (List.nth roots i) in
            formalname := ithstr;
            if (String.compare !formalname "") = 0
            then formalname := ("arg" ^ (itoa i));
            let newvar = (makeLocalVar marshwrap_func !formalname ithtyp) in
            (* Initialize any new pointer variables to NULL *)
            if (isPointerType newvar.vtype) then begin
              let newvar_init = Set((lvalify_varinfo newvar), zero64Uexp, locUnknown) in
              let stmt_newvar_init = (mkStmt (Instr [newvar_init])) in
              stmts := (List.append !stmts [stmt_newvar_init]);
            end;
            newroots := (List.append !newroots [newvar]);
            callargs := (List.append !callargs [newvar]);
            let newvarlv = (lvalify_varinfo newvar) in
            let newvartyp = (newvar.vtype) in
            (* Use the marshbuf formal param during demarshaling *)
            stmts := (List.append !stmts
                        (unified_dfs newvarlv newvartyp marshwrap_func marshwrap_func
                           ptg resfld resform marshwrap_arg_buf offvar 0
                           false gen_kern));
          done;
        end;
      let free_after_demarsh = (gen_marshbuf_free "DEMARSHBUF_FREE2" marshwrap_arg_buf) in
      stmts := List.append !stmts [free_after_demarsh];
      (* 4. Call the function itself over here. *)
      let (stmts_new, retval_vi_opt) = self#gen_marshwrap_call
        callargs name fdec_typ marshwrap_func in
      stmts := List.append !stmts stmts_new;
      (match retval_vi_opt with
         | None -> ()
         | Some (retval_vi) -> newroots := List.append !newroots [retval_vi]
      );
      (* 4.1 Call interrupt handlers *)
      if gen_kern = false then 
        stmts := List.append !stmts (gen_call_interrupt_handlers ());

      (* 5. Initialize the offset once again *)
      stmts := List.append !stmts [stmt_init_offvar];

      (* 6. Generate the marshaling code here. We've added the globals and
       * the return variable to newroots, so they will be automatically
       * marshaled at this point. *)
      for i = 0 to (List.length !newroots) - 1 do
        let ith = (List.nth !newroots i) in
        let ithlv = (lvalify_varinfo ith) in
        let ithtyp = (ith.vtype) in
        (* Marshal here *)
        stmts := List.append !stmts
          (unified_dfs ithlv ithtyp marshwrap_func fdec
             ptg resfld resform marshwrap_arg_buf offvar 0
             true gen_kern);
      done;
      (* 7. The return value is the structure marshret_struct. Initialize it
         appropriately at this point and return it. *)
      let star_marshwrap_arg_ret = (Mem((expify_lval (lvalify_varinfo marshwrap_arg_ret)))) in

      (* 7.1 Do _ret_->buf = _buf_. *)
      let marshwrap_arg_buf_exp = expify_lval (lvalify_varinfo marshwrap_arg_buf) in
      let buffield = marshret_buf in
      let star_marshwrap_arg_ret_buf = (star_marshwrap_arg_ret, Field(buffield, NoOffset)) in
      let stmt_setbuf = (mkStmtOneInstr (Set (star_marshwrap_arg_ret_buf, marshwrap_arg_buf_exp, locUnknown))) in

      let offvar_exp = expify_lval (lvalify_varinfo offvar) in
      let lenfield = marshret_len in
      let star_marshwrap_arg_ret_len = (star_marshwrap_arg_ret, Field(lenfield, NoOffset)) in
      let stmt_setlen = (mkStmtOneInstr (Set (star_marshwrap_arg_ret_len, offvar_exp, locUnknown))) in

      stmts := List.append !stmts [stmt_setbuf; stmt_setlen];

      (*
        let free_after_marsh = (gen_marshbuf_free "MARSHBUF_FREE" marshwrap_arg_buf) in
        stmts := (List.append !stmts [free_after_marsh]);
      *)
      marshwrap_func.sbody.bstmts <- !stmts;
      marshwrap_func;
    end

  (* User mode specific.
   * Creates new fundecs for functions that are called in the slave (user
   * daemon), but do not have fundecs. The transformation is as follows:
   * For each function USER_FOO called in the user-daemon:
   *      XFORM := ADD a body of the form USER_FOO(X) { FOO(X) },
   * and to add this to the globals of the file. This method just creates
   * the toplevel fundec for the function without the fundec, and calls
   * user_stubgen to generate the body. *)
  method user_add_new_fundecs (f: file) : unit =
    begin
      (* NOTE: The computation of called_but_no_fundec can be replaced with
       * the 'funcs_with_no_fundecs' *)
      (* Note2:  Tried it, but didn't work *)
      (*let called_but_no_fundec = (list_bindings funcs_with_no_fundecs) in*)
      let called_but_no_fundec = ref [] in
      let called_fun_varinfo_list = (list_keys called_fun_varinfo) in
      for i = 0 to (List.length called_fun_varinfo_list) - 1 do
        let ith = (List.nth called_fun_varinfo_list i) in
        try
          (ignore (Hashtbl.find varinfo_fundec ith));
        with Not_found -> (
          if (isFunctionType ith.vtype) = true
          then begin
            called_but_no_fundec := ith::!called_but_no_fundec;
          end else begin
            (warning ["Not a function: "; ith.vname]);
          end;
        );
      done;

      (* For each function that is called, but does not have a fundec, create a
         fundec for that function with the same type signature *)
      for i = 0 to (List.length !called_but_no_fundec) - 1 do
        let ith = (List.nth !called_but_no_fundec i) in
        let new_func_name = ith.vname in
        (* Don't add anything if the function is on our list
           of those not to bother with, e.g. sprintf *)
        if (should_split new_func_name) = true then
          begin
            let new_fundec = (emptyFunction new_func_name) in
            new_fundec.svar.vtype <- ith.vtype;
            new_fundec.svar.vglob <- true;
            new_fundec.svar.vdecl <- locUnknown;
            new_fundec.svar.vaddrof <- false;
            new_fundec.svar.vreferenced <- false;
            (* Create the formal parameters for this fundec *)
            let (_,argsopt,_,_) = (splitFunctionType new_fundec.svar.vtype) in
            (match argsopt with
               | Some(al) ->
                   for j = 0 to (List.length al) - 1 do
                     let (jthstr,jthtyp,jthattr) = (List.nth al j) in
                     let newformal = (makeFormalVar new_fundec jthstr jthtyp) in
                     newformal.vattr <- jthattr;
                   done;
               | None -> ();
            );
            Printf.fprintf stderr "Setting up function %s\n" new_func_name;
            setFunctionType new_fundec ith.vtype;

            (* Previously, the newly added function needed to be static.
               However, now that we are merging CIL output with the original
               kernel code in user space, we don't need or want these new
               functions to be static. *)
            (* static_funcs <- (add_to_list new_fundec static_funcs); *)
            let (_,_,isvararg,_) = (splitFunctionType new_fundec.svar.vtype) in
            if (isvararg = false)
            then
              let new_stmts = (self#stubgen_funs new_fundec) in
              new_fundec.sbody.bstmts <- new_stmts;
            else
              fatal ["VARARGS not supported in stubgen_funs: " ^ new_fundec.svar.vname];
            infomsg ["Adding fundec for"; ith.vname];
            f.globals <- (List.append f.globals [GFun(new_fundec,locUnknown)]);
          end
      done;
    end

  (** We also need a vinst to consider functions that are called but that
   * don't have a fundec - because they do not have an implementation here,
   * e.g., things like _spin_lock, _spin_lock_irqsave etc., that are
   * implemented elsewhere in the kernel. These are "extern" functions.
   * This is used only in user-space.
   *)
  method vinst (i: instr) : instr list visitAction =
    begin
      if (gen_kern = false) then
        (match i with
           | Call(_,callexpr,argslist,_) ->
               (match callexpr with
                  | Lval(Var(vi), NoOffset) ->
                      (* Previously we forced all functions on boundaries to be
                         static? In user mode, this doesn't seem like it matters--
                         who cares if we're exporting symbols?

                         Making these static causes problems with Java code,
                         since we really want to be able to access pretty much
                         everything from Java, and if some things are static,
                         the Java code is effectively locked out.
                      *)
                      (*if ((should_split vi.vname) = true) then
                        vi.vstorage <- Static;
                      *)
                      (add_if called_fun_varinfo vi 1);
                      DoChildren;
                  | _ -> DoChildren;
               );
           | _ -> DoChildren;
        )
      else
        DoChildren;
    end

  (** Used to find functions implemented in the kernel
      whose addresses are taken in the user.  We need to provide stub
      functions for these. and register them in the OT.
  *)
  method vglob (g: global) : global list visitAction =
    begin
      (match g with
         | GVarDecl(vi, _) ->
             (match vi.vtype with
                | TFun (a1, a2, a3, a4) ->
                    if (vi.vaddrof = true) then
                      begin
                        fn_addr_taken_decl <- (List.append fn_addr_taken_decl [vi]);
                      end;
                | _ -> ();
             );
         | GFun(fdec, _) ->
             if (fdec.svar.vaddrof) then
               fn_addr_taken_defn <- (List.append fn_addr_taken_defn [fdec]);
         | _ -> ();
      );
         DoChildren;
    end

  (** Main visitor method for same_address_space xform that visits each
   * function. Leaves functions in kernel space untouched. User functions
   * are stubbed. Formally, the transformation that the kernel vfunc
   * implements is:
   *
   * if foo has "kern" annotation
   *      XFORM := foo(X){Body} -> foo(X){Body}
   * if foo has "user" annotation
   *      XFORM := foo(X){Body} -> foo(X){return __stub__foo(X)}
   *
   * For user-mode vfunc, the transformation is:
   * if foo has "kern" annotation
   *     XFORM := __stub__foo(X){Body} -> __stub__foo(X){call foo}
   * if foo has "user" annotation
   *     XFORM := __stub__foo(X){Body} -> __stub__foo(X){Body}
   * For "user" annotation functions that are interface functions,
   *     __stub__foo(X){body} ADD __marshwrap__foo(X){demarsh,call,marsh}
   *)
  method vfunc (f: fundec) : fundec visitAction =
    begin
      (* Formerly done in a separate pass.  We'll use varinfo_fundec
       * in later steps.  Obtains a varinfo->fundec mapping. Useful to
       * find which variables have fundecs and which do not *)
      if (gen_kern = false) then (add_if varinfo_fundec f.svar f);

      (* Check and split *)
      if (should_split f.svar.vname) = true
      then begin
        try begin
          let annot = (Hashtbl.find annotations f.svar.vname) in
          let basic_annot_name = (if gen_kern then "kern" else "user") in
          let complex_annot_name = (if gen_kern then "user" else "kern") in
          if annot = basic_annot_name then
            begin
              (* kern: If the kernel function is an interface function and could be
                 called by the user-space, do not make it static. Otherwise, make it
                 static. Leave untouched otherwise. *)
              (* user: If it is an interface function, do not make it static. *)
              if (is_interface_function f.svar.vname) = true
              then begin
                Printf.fprintf stderr "adding %s to interface\n" f.svar.vname;
                nostorage_funcs <- add_to_list f nostorage_funcs;
                (* Only add marshwraps for non-vararg functions *)
                if gen_kern then
                  let result = self#add_marshwrap_function (Some (f)) None in
                  marshwrap_funcs <- add_to_list result marshwrap_funcs;
                else
                  let result = self#add_marshwrap_function (Some (f)) None in
                  marshwrap_funcs <- add_to_list result marshwrap_funcs;
              end;
              DoChildren;
            end
          else begin
            (* annot = kern: Change function body to have a call to the function in the
             * kernel side *)
            (* annot = user: Generate stub. *)
            if annot = complex_annot_name then begin
              (* Interface functions that are implemented in the user-level
                 are stubbed. The stub name should be made static. *)
              (* Only if the current function is an interface function we should
                 replace it's body with a stub. Else, we leave the body as is. *)
              if (gen_kern) then
                begin
                  if (is_interface_function f.svar.vname) = true then
                    begin
                      f.slocals <- [];
                      f.sbody.bstmts <- (self#stubgen_funs f);
                      ChangeTo(f);
                    end
                  else begin
                    (Hashtbl.add non_interface_functions f.svar.vname f);
                    (* Change made on 28 Dec 2006.
                       f.sbody.bstmts <- (self#stubgen_funs f);
                       ChangeTo(f);
                    *)
                    DoChildren;
                  end;
                  (* other: Unknown *)
                end
              else begin
                if (is_interface_function f.svar.vname) = true then
                  begin
                    (* If its address is taken, it should not be a static function *)
                    if (f.svar.vaddrof = true)
                    then nostorage_funcs <- (add_to_list f nostorage_funcs);
                    f.sbody.bstmts <- (self#stubgen_funs f);
                    ChangeTo(f);
                  end
                else begin
                  (Hashtbl.add non_interface_functions f.svar.vname f);
                  DoChildren;
                end;
              end;
            end
            else begin
              fatal ["Unknown"];
            end;
          end;
        end
        with Not_found -> (
          fatal ["Fatal error in vfunc in splitter_kern"];
        );
      end
      else begin
        DoChildren;
      end;
    end;

  (****************************************************************************)
  (* In this section we have the code for adding per-datastructure marshaling
     functions.  The idea behind these functions is the following:
     In user mode, we have a stub.  This stub takes one parameter:  the data
     structure we want to marshal, e.g. netdevice.
     In kernel mode, we have another stub.  This stub demarshals everything
     into kernel memory.

     These functions do NOT perform control transfer!  They only
     marshal/demarshal the data structure in question.
  *)
  (* Generate a function to marshal each interesting datastructure.
   * Interesting data structures include any that we already access
   * from user mode. *)
  method add_sync_functions (f: file) : unit =
    let ptg = Marshal_dri.get_flattened_ptg "perform_full_sync" true in
    let datastructure_list : (string * typ) list ref = ref [("blah", TVoid([]))] in
    let datastructure_elt (ptgnode_key : string) (ptgnode_value : (typ * string * string)) =
      let (ds_typ,_,_) = ptgnode_value in
      let already_exists = List.mem (ptgnode_key, ds_typ) !datastructure_list in
      let ds_typ_str = ptgnode_key in
      if already_exists = false then
        begin
          datastructure_list := !datastructure_list @ [ds_typ_str, ds_typ];
          Printf.fprintf stderr "Type: %s\n" ptgnode_key;
        end
    in
    Hashtbl.iter datastructure_elt ptg;
    (* At this point, the datastructure_list contains a bunch of
       strings representing the type of interest, as well as
       the typs themselves.
    *)
    (* The next task is to create a pair of function bodies,
       one for marshaling data from user to kernel, and one for
       kernel to user.
    *)
    let add_functions (ds_typ_str, ds_typ) =
      (* Add a single function body *)
      let add_one_function name ds_typ m_dm =
        let fn_typ = TFun (TVoid ([]), None, false, []) in
        let vi = makeGlobalVar name fn_typ in
        let newmarshwrap = self#add_ds_function vi ds_typ m_dm in
        ds_funcs <- add_to_list newmarshwrap ds_funcs
      in
      if gen_kern then
        begin
          add_one_function (makevarname ("ds_from_user_" ^ ds_typ_str)) ds_typ false;
          add_one_function (makevarname ("ds_to_user_" ^ ds_typ_str)) ds_typ true;
        end
      else
        begin
          add_one_function (makevarname ("ds_from_kern_" ^ ds_typ_str)) ds_typ false;
          add_one_function (makevarname ("ds_to_kern_" ^ ds_typ_str)) ds_typ true;
        end
    in
    List.iter add_functions !datastructure_list;

  (**
   * add_ds_function:  Add datastructure-specific function.
   * The purpose of this function is to either marshl or demarshal
   * a specific data structure.
   *
   * Note that the current implementation generates a standalone block
   * of marshaling code.  This is no good in the case that one data
   * structure contains a pointer to another data structure, e.g.
   * a net_device pointing to an rtl8139_private, or whatever, because
   * large chunks of the marshaling code will be redundant.
   *
   * I think the eventual goal here is to generate marshaling code like
   * this:
   * - Two functions per data structure, one for marshaling and one for
   *   demarshaling.
   * - Call the datastructure-specific function for any members contained
   *   within the outer structure.
   * - Add dynamic recursion detection:  This is important!  If we call
   *   other datastructure-specific marshaling functions recursively,
   *   then the static recursion detection is inadequate.
   *
   *   This dynamic recursion detection would have to take place in both
   *   user mode and kernel mode to work, because both sides would have
   *   to know when they've already seen a given pointer.
   * - After the previous three bullets are implemented, then it would
   *   be necessary to change the existing code generation routines
   *   in order to call these functions instead of generating the full
   *   set of marshaling code.
   *)
  method add_ds_function
    (vinfo : varinfo)
    (ds_typ : typ)
    (m_dm : bool) : fundec =
    begin
      let stmts = ref [] in
      let name = vinfo.vname in
      let marshwrap_funcname = vinfo.vname in
      let marshwrap_func = emptyFunction marshwrap_funcname in
      let marshwrap_buf = makeFormalVar marshwrap_func "_buf_" (TPtr (voidPtrType, [])) in
      let marshwrap_off = makeFormalVar marshwrap_func "orig_off" (TPtr (intType, [])) in
      let ds_arg = makeFormalVar marshwrap_func "data" (TPtr ((TPtr (ds_typ, [])), [])) in

      (* Set up the dereferenced copies of each of the variables. *)
      let deref_marshwrap_buf = makeLocalVar marshwrap_func "_deref_buf_" voidPtrType in
      let deref_ds_arg = makeLocalVar marshwrap_func "deref_data" (TPtr (ds_typ, [])) in
      let offvar = makeLocalVar marshwrap_func "_off_" intType in

      let init_var lhs rhs =
        begin
          let init_var_lhs = lhs in
          let init_var_rhs = rhs in
          let init_var = Set(init_var_lhs, init_var_rhs, locUnknown) in
          let stmt_init_var = mkStmt (Instr [init_var]) in
          stmts := List.append !stmts [stmt_init_var];
        end
      in
      let viAddrOfToLval vi = mkMem (expify_lval (lvalify_varinfo vi)) NoOffset in
      let viAddrOfToExp vi = expify_lval (viAddrOfToLval vi) in
      init_var (lvalify_varinfo deref_marshwrap_buf) (viAddrOfToExp marshwrap_buf);
      init_var (lvalify_varinfo deref_ds_arg) (viAddrOfToExp ds_arg);
      init_var (lvalify_varinfo offvar) (viAddrOfToExp marshwrap_off);

      (* 3. Demarsh the roots *)
      (* 3.1 Get the ptg *)
      let ptg = Marshal_dri.get_flattened_ptg name true in
      Printf.fprintf stderr "marshwrap::::: %s %d\n" name (Hashtbl.length ptg);
      let resfld = Marshal_dri.get_resolved_fields() in
      let resform = Marshal_dri.get_resolved_formals() in

      let newvarlv = lvalify_varinfo deref_ds_arg in
      let newvartyp = deref_ds_arg.vtype in
      (* Use the marshbuf formal param during demarshaling *)
      let m_dm_stmts = unified_dfs newvarlv newvartyp marshwrap_func marshwrap_func
        ptg resfld resform deref_marshwrap_buf offvar 0 m_dm gen_kern in
      stmts := List.append !stmts m_dm_stmts;

      (* Set orig_off and _buf_ so caller knows where we're at *)
      init_var (viAddrOfToLval marshwrap_off) (expify_lval (lvalify_varinfo offvar));
      init_var (viAddrOfToLval marshwrap_buf) (expify_lval (lvalify_varinfo deref_marshwrap_buf));

      marshwrap_func.sbody.bstmts <- !stmts;
      marshwrap_func;
    end


  (* Top-level function for the kernel *)
  method top_level_kernel (f: file) : unit =
    begin
      gen_kern <- true;
      (visitCilFile (self :> cilVisitor) f);
      for i = 0 to (List.length nostorage_funcs) - 1 do
        let ith = (List.nth nostorage_funcs i) in
        ith.svar.vstorage <- NoStorage;
      done;

      (* Add a prototype for the unblock_user_thread function *)
      let unblock_ut_fundec = (get_unblock_user_thread_fundec()) in
      let unblock_ut_varinfo = unblock_ut_fundec.svar in
      f.globals <-
        (List.append [GVarDecl((unblock_ut_varinfo),locUnknown)] f.globals);
      (* Add a declaration for the req_args structure that we defined *)
      f.globals <-
        (List.append [GCompTag(struct_reqargs_compinfo,locUnknown)] f.globals);
      (* Add a declaration for the marshret structure that we defined *)
      f.globals <-
        (List.append [GCompTag(struct_marshret_compinfo,locUnknown)] f.globals);

      (* Add a marshwrap function for nofundec functions. Exclude VARARG
         fucntions from this, as they have a different function for marshwrap
         generation. *)
      let nofundecs = (list_bindings funcs_with_no_fundecs) in
      for i = 0 to (List.length nofundecs) - 1 do
        let ith = (List.nth nofundecs i) in
        if (is_interface_function ith.vname) = false then
          add_if interface_functions ith.vname true;
        let newmarshwrap = self#add_marshwrap_function None (Some (ith)) in
        (* Without this test, we get code for sprintf.  sprintf
           is a kernel function, and we don't a fundec.
           It's also listed in our "no stub" table.
        *)
        if (should_split ith.vname) = true then
          marshwrap_funcs <- add_to_list newmarshwrap marshwrap_funcs;
      done;

      (* Add functions for marshaling individual data structures *)
      (*self#add_sync_functions f;*)

      (* Add all marshwrap functions to globals *)
      for i = 0 to (List.length marshwrap_funcs) - 1 do
        let ith = (List.nth marshwrap_funcs i) in
        f.globals <- (List.append f.globals [GFun(ith,locUnknown)]);
      done;
      (* Add all data-structure specific functions to globals *)
      for i = 0 to (List.length ds_funcs) - 1 do
        let ith = (List.nth ds_funcs i) in
        f.globals <- (List.append f.globals [GFun(ith,locUnknown)]);
      done;
      (* Generate the disploop function *)
      let disploop = (gen_disploop gen_kern marshwrap_funcs) in
      f.globals <- (List.append f.globals [GFun(disploop,locUnknown)]);
      (* Generate the registration function *)
      let registerfn = (gen_registerfn fn_addr_taken_defn fn_addr_taken_decl) in
      f.globals <- (List.append f.globals [GFun(registerfn,locUnknown)]);
      (* Generate the list of globals to be registered *)
      let globals_to_register = (get_globals_to_register f.globals) in
      let registerglob = (gen_registerglob globals_to_register) in
      f.globals <- (List.append f.globals [GFun(registerglob,locUnknown)]);

      (* NOTE: The following is an optimization that removes unwanted stubs
       * i.e., those that are never called, from the kernel. I am commenting
       * this code now to retain these stubs, because it gives us flexibility
       * during development and debugging
       *)
      (* Remove the non_interface_functions from the kernel's code *)
      let newglobals = ref [] in
      for i = 0 to (List.length f.globals) - 1 do
        let ith = (List.nth f.globals i) in
        match ith with
          | GFun(fdec,_) ->
              (try
                 ignore (Hashtbl.find non_interface_functions fdec.svar.vname);
                 Printf.fprintf stderr "removing %s from kern\n" fdec.svar.vname;
               with Not_found -> (newglobals := (List.append !newglobals [ith])));
          | _ -> newglobals := List.append !newglobals [ith];
      done;
      f.globals <- !newglobals;
    end

  (** Top-level function to implement user pass 2 *)
  method top_level_user (f: file) : unit =
    begin
      gen_kern <- false;

      (* Delete all non-stub function bodies.  By definition, they should not
         be defined, as we are defining them ourselves *)
      f.globals <- delete_nonstubs f.globals;

      (visitCilFile (self :> cilVisitor) f);
      (self#user_add_new_fundecs f);
      for i = 0 to (List.length static_funcs) - 1 do
        let ith = (List.nth static_funcs i) in
        ith.svar.vstorage <- Static;
      done;
      for i = 0 to (List.length nostorage_funcs) - 1 do
        let ith = (List.nth nostorage_funcs i) in
        ith.svar.vstorage <- NoStorage;
      done;

      (* Add a prototype for the disp_kern function *)
      let disp_kern_fundec = (get_disp_kern_fundec()) in
      let disp_kern_varinfo = disp_kern_fundec.svar in
      f.globals <-
        (List.append [GVarDecl((disp_kern_varinfo),locUnknown)] f.globals);
      (* Add a declaration for the req_args structure that we defined *)
      (* Not sure if we need this declaration in the user-daemon, but it's
         harmless to have it there, so put it anyway *)
      f.globals <-
        (List.append [GCompTag(struct_reqargs_compinfo,locUnknown)] f.globals);
      (* Add a declaration for the marshret structure that we defined *)
      f.globals <-
        (List.append [GCompTag(struct_marshret_compinfo,locUnknown)] f.globals);

      (* Add all marshwrap functions to globals *)
      for i = 0 to (List.length marshwrap_funcs) - 1 do
        let ith = (List.nth marshwrap_funcs i) in
        f.globals <- (List.append f.globals [GFun(ith,locUnknown)]);
      done;
      (* Add all data-structure specific functions to globals *)
      for i = 0 to (List.length ds_funcs) - 1 do
        let ith = (List.nth ds_funcs i) in
        f.globals <- (List.append f.globals [GFun(ith,locUnknown)]);
      done;
      (* Add the dispatch loop function *)
      let disploop = (gen_disploop gen_kern marshwrap_funcs) in
      f.globals <- (List.append f.globals [GFun(disploop,locUnknown)]);
      (* Add the function registration function *)
      let registerfn = (gen_registerfn fn_addr_taken_defn fn_addr_taken_decl) in
      f.globals <- (List.append f.globals [GFun(registerfn,locUnknown)]);
      (* Add the bodies of functions whose addresses are taken but for which
         we don't have a definition, e.g. kernel functions *)
      let kernel_fn_dummies = (gen_dummy_bodies fn_addr_taken_defn fn_addr_taken_decl) in
      f.globals <- (List.append f.globals kernel_fn_dummies);
      (* Generate the list of globals to be registered *)
      let globals_to_register = (get_globals_to_register f.globals) in
      let registerglob = (gen_registerglob globals_to_register) in
      f.globals <- (List.append f.globals [GFun(registerglob,locUnknown)]);
      (* Previously, we thought that globals that have the GLOBREG annotation
         must not be externs in slave *)
      (* In fact, it seems as though no globals in the slave should have
         extern *)
      f.globals <- (make_globals_nonextern f.globals);
    end
end

(** Populate Java functions using the input file given to us *)
let populate_java_funcs (filename: string) : string list =
  begin
    let newlist = ref [] in
    let enter_function (funname: string) = (newlist := !newlist @ [funname]); Printf.fprintf stderr "%s\n" funname; in
    if filename = "" then fatal ["Filename not given\n%!"];
    Printf.fprintf stderr "** Reading file %s **\n%!" filename;
    try
      let instream = open_in_gen [Open_rdonly] 0 filename in
      try
        while true do
          let currline = (input_line instream) in
          if (is_comment currline) = false then
            try
              Scanf.sscanf currline "%s" enter_function;
            with Scan_failure(s) -> warning ["Error populating java functions"];
        done;
        !newlist;
      with End_of_file ->
        close_in instream;
        !newlist;
    with Sys_error(error) ->
      fatal ["Cannot open java functions file\n%!"];
  end

(*---------------------------------------------------------------------------*)
(** Populate the list of functions that can exist separately in user
 * and kernel space. These include built-in GCC functions, library
 * functions and any other functions that can be implemented in
 * user-space. These functions will not be added to called_fun_varinfo
 * of split-user analysis, and so will not be considered as candidates
 * for which a new fundec is introduced (as a stub) *)
let populate_nonstubbed_functions() : unit =
  begin
    let make_nonstub_raw (fnnm: string) (delete_proto: bool) =
      begin
        Printf.fprintf stderr "make nonstub: %s %b\n" fnnm delete_proto;
        add_if nonstubbed_functions fnnm true;
        if delete_proto then add_if nonstubbed_functions_delete_proto fnnm true;
      end
    in
    let make_nonstub_delete_proto (fnnm: string) = make_nonstub_raw fnnm true in
    let make_nonstub_keep_proto (fnnm: string) = make_nonstub_raw fnnm false in

    (* <GCC BUILT-IN FUNCTIONS> *)
    let builtins = (list_keys gccBuiltins) in
    for i = 0 to (List.length builtins) - 1
    do
      let ith = (List.nth builtins i) in
      (make_nonstub_keep_proto ith);
    done;
    (* </GCC BUILT-IN FUNCTIONS> *)

    (* <MORE BUILT-IN FUNCTIONS> *)
    (make_nonstub_keep_proto "__builtin_expect");
    (make_nonstub_keep_proto "__builtin_memcmp");
    (* </MORE BUILT-IN FUNCTIONS> *)

    (* <FUNCTIONS IMPLEMENTED IN LIBRARIES> *)
    (* string functions *)
    (make_nonstub_keep_proto "strcpy");
    (make_nonstub_keep_proto "strncpy");
    (make_nonstub_keep_proto "strcat");
    (make_nonstub_keep_proto "strncat");
    (make_nonstub_keep_proto "strcmp");
    (make_nonstub_keep_proto "strncmp");
    (make_nonstub_keep_proto "strchr");
    (make_nonstub_keep_proto "strrchr");
    (make_nonstub_keep_proto "strlen");
    (make_nonstub_keep_proto "strnlen");
    (make_nonstub_keep_proto "strstr");
    (make_nonstub_keep_proto "strlcpy");
    (make_nonstub_keep_proto "strlcat");
    (make_nonstub_keep_proto "strnicmp");
    (make_nonstub_keep_proto "strnchr");
    (make_nonstub_keep_proto "strpbrk");
    (make_nonstub_keep_proto "strsep");
    (make_nonstub_keep_proto "strspn");
    (make_nonstub_keep_proto "strcspn");
    (make_nonstub_delete_proto "strtoul");
    (* Basic bit operations *)
    (make_nonstub_delete_proto "clear_bit");
    (make_nonstub_delete_proto "set_bit");
    (make_nonstub_delete_proto "test_and_set_bit");
    (make_nonstub_delete_proto "test_and_clear_bit");
    (make_nonstub_delete_proto "__xchg");
    (* printing and scanning functions *)
    (make_nonstub_delete_proto "uprintk");  (* LLVM workaround *)
    (make_nonstub_delete_proto "mprintk");  (* LLVM workaround *)
    (make_nonstub_delete_proto "snd_mprintk");  (* LLVM workaround *)
    (make_nonstub_keep_proto "printf");
    (make_nonstub_delete_proto "fprintf");
    (make_nonstub_delete_proto "sprintf");
    (make_nonstub_keep_proto "vsprintf");
    (make_nonstub_keep_proto "snprintf");
    (make_nonstub_keep_proto "vsnprintf");
    (make_nonstub_keep_proto "scnprintf");
    (make_nonstub_keep_proto "vscnprintf");
    (make_nonstub_keep_proto "sscanf");
    (make_nonstub_keep_proto "vsscanf");
    (* memcpy functions *)
    (make_nonstub_keep_proto "memcpy");
    (make_nonstub_keep_proto "memset");
    (make_nonstub_delete_proto "__memcpy");
    (make_nonstub_delete_proto "memscan");
    (make_nonstub_delete_proto "__constant_memcpy");
    (make_nonstub_delete_proto "__constant_c_memset");
    (make_nonstub_delete_proto "__constant_c_and_count_memcpy");
    (make_nonstub_delete_proto "__constant_c_and_count_memset");
    (make_nonstub_delete_proto "__memset_generic");
    (* </FUNCTIONS IMPLEMENTED IN LIBRARIES> *)

    (* Synchronization *)
    (make_nonstub_delete_proto "__spin_lock_init");
    (make_nonstub_delete_proto "spin_lock_init");
    (make_nonstub_delete_proto "_spin_lock");
    (make_nonstub_delete_proto "spin_lock");
    (make_nonstub_delete_proto "_spin_lock_bh");
    (make_nonstub_delete_proto "spin_lock_bh");
    (make_nonstub_delete_proto "_spin_lock_irqsave");
    (make_nonstub_delete_proto "spin_lock_irqsave");
    (make_nonstub_delete_proto "_spin_lock_irq");
    (make_nonstub_delete_proto "spin_lock_irq");
    (make_nonstub_delete_proto "_spin_unlock");
    (make_nonstub_delete_proto "spin_unlock");
    (make_nonstub_delete_proto "_spin_unlock_bh");
    (make_nonstub_delete_proto "spin_unlock_bh");
    (make_nonstub_delete_proto "_spin_unlock_irqrestore");
    (make_nonstub_delete_proto "spin_unlock_irqrestore");
    (make_nonstub_delete_proto "_spin_unlock_irq");
    (make_nonstub_delete_proto "spin_unlock_irq");
    (make_nonstub_delete_proto "__mutex_init");
    (make_nonstub_delete_proto "mutex_init");
    (make_nonstub_delete_proto "mutex_lock");
    (make_nonstub_delete_proto "mutex_lock_interruptible");
    (make_nonstub_delete_proto "mutex_unlock");

    (* BOGUS FUNCTIONS *)
(*(make_nonstub_keep_proto "MICRODRIVERS__DUMMY");*)

    (make_nonstub_keep_proto "malloc");
    (make_nonstub_keep_proto "free");

    (* For User-mode Linux/symbolic execution *)
    (make_nonstub_keep_proto "klee_define_fixed_object");
    (make_nonstub_keep_proto "klee_make_symbolic");
    (make_nonstub_keep_proto "klee_range");
    (make_nonstub_keep_proto "klee_int");
    (make_nonstub_keep_proto "klee_silent_exit");
    (make_nonstub_keep_proto "klee_abort");
    (make_nonstub_keep_proto "klee_get_obj_size");
    (make_nonstub_keep_proto "klee_print_expr");
    (make_nonstub_keep_proto "klee_choose");
    (make_nonstub_keep_proto "klee_is_symbolic");
    (make_nonstub_keep_proto "klee_assume");
    (make_nonstub_keep_proto "klee_warning");
    (make_nonstub_keep_proto "klee_warning_once");
    (make_nonstub_keep_proto "klee_prefer_cex");
    (make_nonstub_keep_proto "klee_mark_global");
    (make_nonstub_keep_proto "klee_get_value");
    (make_nonstub_keep_proto "klee_check_memory_access");
    (make_nonstub_keep_proto "klee_set_forking");
    (make_nonstub_keep_proto "klee_alias_function");

    (* Functions that we handle via allocation wrappers *)
    (make_nonstub_keep_proto "dma_alloc_coherent");
    (make_nonstub_keep_proto "dma_free_coherent");
    (make_nonstub_keep_proto "alloc_etherdev");
    (make_nonstub_keep_proto "alloc_etherdev_mq");
    (*(make_nonstub_keep_proto "netdev_alloc_skb");*)
    (*(make_nonstub_keep_proto "__netdev_alloc_skb");*)
    (make_nonstub_keep_proto "free_netdev");
    (make_nonstub_keep_proto "__kzalloc");
    (make_nonstub_keep_proto "__ioremap");
    (make_nonstub_keep_proto "__kmalloc");
    (make_nonstub_keep_proto "vmalloc");
    (make_nonstub_keep_proto "snd_dma_alloc_pages");
    (make_nonstub_keep_proto "kfree");

    (* Also handled like allocation wrappers, since these
       are so rare, and supporting varargs adds significant
       complexity *)
    (make_nonstub_keep_proto "printk");
    (make_nonstub_keep_proto "snd_iprintf");
    (make_nonstub_keep_proto "warn_slowpath");

    (* These functions can be included in user space once we get permissions to
       read and write to the device using the iopl system call. We should
       potentially include all the functions from arch/i386/kernel/io.c *)
    (make_nonstub_delete_proto "inb");
    (make_nonstub_delete_proto "outb");
    (make_nonstub_delete_proto "inw");
    (make_nonstub_delete_proto "outw");
    (make_nonstub_delete_proto "inl");
    (make_nonstub_delete_proto "outl");
    (make_nonstub_keep_proto "readb");
    (make_nonstub_keep_proto "writeb");
    (make_nonstub_keep_proto "readw");
    (make_nonstub_keep_proto "writew");
    (make_nonstub_keep_proto "readl");
    (make_nonstub_keep_proto "writel");
    (make_nonstub_keep_proto "readq");
    (make_nonstub_keep_proto "writeq");
    (make_nonstub_delete_proto "request_irq");
    (make_nonstub_delete_proto "free_irq");

    (* USB-specific functions *)
    (make_nonstub_keep_proto "uhci_to_hcd");
    (make_nonstub_keep_proto "hcd_to_uhci");

    (* Ugh *)
    (*(make_nonstub_delete_proto "current_thread_info");*)
    (make_nonstub_delete_proto "schedule");

    (* LLVM Symbolic USB functions *)
    (make_nonstub_delete_proto "usb_buffer_alloc");
    (make_nonstub_delete_proto "usb_buffer_free");

    (make_nonstub_delete_proto "usb_sg_wait");
    (make_nonstub_delete_proto "usb_sg_cancel");
    (make_nonstub_delete_proto "usb_sg_init");

    (make_nonstub_delete_proto "usb_free_urb");
    (make_nonstub_delete_proto "usb_alloc_urb");
    (make_nonstub_delete_proto "usb_kill_urb");
    (make_nonstub_delete_proto "usb_unlink_urb");

(*
    (make_nonstub_delete_proto "usb_lock_device_for_reset");
    (make_nonstub_delete_proto "usb_reset_device");
*)

    (make_nonstub_delete_proto "usb_control_msg");
    (make_nonstub_delete_proto "usb_interrupt_msg");
    (make_nonstub_delete_proto "usb_bulk_msg");
    (make_nonstub_delete_proto "usb_submit_urb");

    (* 8390-specific functions *)
    (*(make_nonstub_keep_proto "netdev_priv");*)
    (*(make_nonstub_keep_proto "netdev_priv_mjr");*)

    (* Forcedeth-specific functions *)
    (make_nonstub_keep_proto "pci_push");
    (make_nonstub_keep_proto "get_hwbase");
    (make_nonstub_keep_proto "get_nvpriv");

    (* psmouse-base-specific functions *)
    (make_nonstub_keep_proto "serio_get_drvdata");

  (* </ADD MORE FUNCTIONS OF YOUR CHOICE HERE> *)
  (*
    let not_renaming_list = (list_keys nonstubbed_functions) in
    (announcemsg
    (List.append ["Not renaming the following functions"] not_renaming_list));
  *)
  end

(*---------------------------------------------------------------------------*)
(** Populate the list of functions with no fundecs *)
let populate_funcs_with_no_fundecs (vinfol: varinfo list) : unit =
  begin
    for i = 0 to (List.length vinfol) - 1 do
      let ith = (List.nth vinfol i) in
      (add_if funcs_with_no_fundecs ith.vname ith);
    done;
  end


(** Populate the list of interface functions. An interface function is a
 * function
 * - with "user" annotation that is called by a function with "kern"
 *   annotation, or
 * - with "kern" annotation that is called by a function with "user"
 *   annotation, or
 * - with no callers (roots), AND a "user" annotation, or
 * - whose addresse is taken, AND have "user" annotation (these denote
 *   functions exported to the kernel), or
 * - that does not have a "fundec". These functions are always interface
 *   functions because they must be "kern" functions and could potentially
 *   be called by "user" functions.
 *
 * Identifying interface functions serves two goals:
 * (1) Only these functions need a stub generated for them.
 * (2) Only these functions need be exported.
 *)
let populate_interface_functions (f: file) : unit =
  begin
    let cgbuild = (Cgcomp_dri.callgraph_build f false) in
    let fullcg = cgbuild.fullcg in
    let nofundecs = cgbuild.funcs_with_no_fundecs in
    (populate_funcs_with_no_fundecs nofundecs);

    (try
       let cgnodenames = (list_keys fullcg) in
       for i = 0 to (List.length cgnodenames) - 1 do
         let ith = (List.nth cgnodenames i) in
         let ithnode = (Hashtbl.find fullcg ith) in
         let ithcallers = ithnode.cnCallers in
         let ithcallernames = (list_keys ithcallers) in
         let ithannot= ref "" in
         (try
            ithannot := (Hashtbl.find annotations ith);
          with Not_found -> (fatal ["Annotation not found 1:"; ith]));
         (* Address taken? Then i/f function *)
         if (ithnode.cnInfo.vaddrof = true) &&
           (String.compare !ithannot "user") = 0
         then (add_if interface_functions ith true);
         (* No parents, and user annotation? Then i/f function *)
         if ((List.length ithcallernames) = 0) &&
           (String.compare !ithannot "user") = 0
         then (add_if interface_functions ith true);
         (* Checking parents *)
         for j = 0 to (List.length ithcallernames) - 1 do
           let jth = (List.nth ithcallernames j) in
           Printf.fprintf stderr "Annotations debug (TODO) - %s\n" jth;

           (try
              let ithannot = (Hashtbl.find annotations ith) in
              let jthannot = (Hashtbl.find annotations jth) in
              (* If ithannot is not equal to it's callee's annot,
                 i.e., jthannot, then ith is an interface function *)
              if (String.compare ithannot jthannot) <> 0
              then (add_if interface_functions ith true);
            with Not_found -> ((fatal ["Annotation not found 2: "; jth; ", other: "; ith])));
         done;
       done;
     with Not_found -> (
       (fatal ["Failure in Hashtbl.find in for loop"]);
     ));

    (* Functions with no fundecs become interface functions, provided
     * that they are not one of the supported vararg functions. *)
    for i = 0 to (List.length nofundecs) - 1 do
      let ith = (List.nth nofundecs i) in
      if (is_interface_function ith.vname) = false then
        (add_if interface_functions ith.vname true);
    done;

    let listkeys = (list_keys interface_functions) in
    for i = 0 to (List.length listkeys) - 1 do
      let ith = (List.nth listkeys i) in
      (Printf.fprintf stderr "Interface function %s: Annotation is %s\n"
         ith (Hashtbl.find annotations ith));
    done;
  end

(*---------------------------------------------------------------------------*)
(** make_constants_modifiable:
 * This is a transformation that converts constant arguments in function calls
 * notably string constants, into calls with variables instead. The variables
 * are new globals, and are intialized with the string constant. This
 * transformation allows us to write into these globals without suffering a
 * segmentation fault
 *)
class modif_const = object (self)
  inherit nopCilVisitor
  val mutable added_globals : global list = [];

  method replace_strconst_with_global (s: string) : varinfo =
    begin
      let varinitinfo : initinfo = { init = None; } in
      let newglobnm = "str_" ^
        (Int64.to_string (Int64.of_int (Hashtbl.hash s))) in
      let strlen = ((String.length s) + 1) in
      let globtyp = (create_array_typ (TInt(IChar, [])) strlen) in
      let newglob = (get_global_variable globtyp newglobnm) in
      let varinit = (SingleInit(Const(CStr(s)))) in
      varinitinfo.init <- Some(varinit);
      added_globals <-
        (List.append added_globals [GVar(newglob,varinitinfo,locUnknown)]);
      newglob;
    end

  method analyze_expr_for_constants (e: exp) : exp =
    begin
      match e with
        | Const(con) ->
            (match con with
               | CStr(constr) ->
                   let newglob = (self#replace_strconst_with_global constr) in
                   expify_lval (lvalify_varinfo newglob);
               | _ -> e;
            );
        | SizeOfE(e') ->
            SizeOfE(self#analyze_expr_for_constants e');
        | AlignOfE(e') ->
            AlignOfE(self#analyze_expr_for_constants e');
        | UnOp(op,e',t) ->
            UnOp(op, (self#analyze_expr_for_constants e'), t);
        | BinOp(op,e1,e2,t) ->
            BinOp(op, (self#analyze_expr_for_constants e1),
                  (self#analyze_expr_for_constants e2), t);
        | CastE(t,e') ->
            CastE(t,(self#analyze_expr_for_constants e'));
        | _ -> e;
    end

  (* Visit each Call and Set instruction and replace string constants
   * with a newly manufactured global *)
  method vinst (i: instr) : instr list visitAction =
    match i with
      | Call(lvopt, callexp, argslist, loc) ->
          let newargslist = ref [] in
          for i = 0 to (List.length argslist) - 1 do
            let ith = (List.nth argslist i) in
            let newith = (self#analyze_expr_for_constants ith) in
            newargslist := (List.append !newargslist [newith]);
          done;
          let newcall = Call(lvopt, callexp, !newargslist, loc) in
          ChangeTo([newcall]);
      | Set(lv, e, loc) ->
          let newe = (self#analyze_expr_for_constants e) in
          let newset = Set(lv, newe, loc) in
          ChangeTo([newset]);
      | _ -> DoChildren;

  (* Visit each global initializer and replace string constants with
   * newly manufactured globals *)
  method handleinit(i: init) : init =
    match i with
      | SingleInit(e) ->
          let newe = (self#analyze_expr_for_constants e) in
          SingleInit(newe);
      | CompoundInit(t, il) ->
          let newil = ref [] in
          for i = 0 to (List.length il) - 1 do
            let ith = (List.nth il i) in
            let (off, oldi) = ith in
            let newi = (self#handleinit oldi) in
            newil := (List.append !newil [(off, newi)]);
          done;
          CompoundInit(t, !newil);

  method vinit (v: varinfo) (o: offset) (i: init) : init visitAction =
    ChangeTo((self#handleinit i));

  (* Top level *)
  method top_level (f: file) : unit =
    begin
      (visitCilFile (self :> cilVisitor) f);
      added_globals <- (remove_repeats added_globals);
      f.globals <- (List.append added_globals f.globals);
    end
end


(*---------------------------------------------------------------------------*)
(** Main function to call the splitter. *)
let do_splitting (f: file)
    (annot_file: string)
    (java_input: string)
    (dowhat: string) : unit =
  begin
    Utils_dri.populate_annotations annotations annot_file;
    if (java_input <> "sym") then (java_funcs := populate_java_funcs java_input);
    populate_nonstubbed_functions();
    populate_interface_functions f;

    (* Transform all string constants into modifiable variables *)
    let obj_modif_const: modif_const = (new modif_const) in
    obj_modif_const#top_level f;

    match dowhat with
      | "produce-kern" ->
          nooks_ptrlookup_fn := "nooks_ot_lookup_kern_w";
          nooks_arrayalloc_fn := "nooks_ot_alloc_arraymem_kern_w";
          nooks_registerfn_fn := "nooks_ot_register_kernfn_w";
          nooks_storeoffset_fn := "nooks_ot_storeoffset_kern_w";
          let obj_kern : splitter_unified = (new splitter_unified) in
          (obj_kern#top_level_kernel f);
          (infomsg ["Produced kernel side of the split."]);
      | "produce-user" ->
          nooks_ptrlookup_fn := "nooks_ot_lookup_user";
          nooks_arrayalloc_fn := "nooks_ot_alloc_arraymem_user";
          nooks_registerfn_fn := "nooks_ot_register_userfn";
          nooks_storeoffset_fn := "nooks_ot_storeoffset_user";
          (* Pass 2: Stub functions that appear in the kernel and that are
             implemented in this file *)
          let obj_user : splitter_unified = (new splitter_unified) in
          (obj_user#top_level_user f);
          (infomsg ["Produced user side of the split"]);
      | _ -> (fatal ["Unknown"]);
  end
