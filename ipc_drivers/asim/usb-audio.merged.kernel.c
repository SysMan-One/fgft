/* Generated by CIL v. 1.4.0 */
/* print_CIL_Input is true */

//#line  17 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
//#line  18 "include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
//#line  20 "include/asm-generic/int-ll64.h"
typedef short __s16;
//#line  21 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
//#line  23 "include/asm-generic/int-ll64.h"
typedef int __s32;
//#line  24 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
//#line  27 "include/asm-generic/int-ll64.h"
typedef long long __s64;
//#line  28 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
//#line  40 "include/asm-generic/int-ll64.h"
typedef signed char s8;
//#line  41 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
//#line  44 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
//#line  47 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
//#line  49 "include/asm-generic/int-ll64.h"
typedef long long s64;
//#line  50 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/types.h"
typedef unsigned short umode_t;
//#line  28 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/types.h"
typedef u64 dma_addr_t;
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
//#line  12 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_nlink_t;
//#line  13 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_off_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
//#line  16 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
//#line  17 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
//#line  18 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
//#line  19 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
//#line  23 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
//#line  24 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
//#line  25 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
//#line  32 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
//#line  41 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
//#line  42 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
//#line  16 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
//#line  19 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
//#line  21 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
//#line  22 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
//#line  23 "include/linux/types.h"
typedef __kernel_off_t off_t;
//#line  24 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
//#line  28 "include/linux/types.h"
typedef __kernel_timer_t timer_t;
//#line  29 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
//#line  35 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
//#line  36 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
//#line  57 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
//#line  66 "include/linux/types.h"
typedef __kernel_size_t size_t;
//#line  71 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
//#line  81 "include/linux/types.h"
typedef __kernel_time_t time_t;
//#line  86 "include/linux/types.h"
typedef __kernel_clock_t clock_t;
//#line  110 "include/linux/types.h"
typedef __s8 int8_t;
//#line  112 "include/linux/types.h"
typedef __s16 int16_t;
//#line  113 "include/linux/types.h"
typedef __u32 u_int32_t;
//#line  114 "include/linux/types.h"
typedef __s32 int32_t;
//#line  118 "include/linux/types.h"
typedef __u8 uint8_t;
//#line  119 "include/linux/types.h"
typedef __u16 uint16_t;
//#line  120 "include/linux/types.h"
typedef __u32 uint32_t;
//#line  145 "include/linux/types.h"
typedef unsigned long sector_t;
//#line  146 "include/linux/types.h"
typedef unsigned long blkcnt_t;
//#line  175 "include/linux/types.h"
typedef __u16 __le16;
//#line  186 "include/linux/types.h"
typedef unsigned int gfp_t;
//#line  187 "include/linux/types.h"
typedef unsigned int fmode_t;
//#line  197 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
//#line  197 "include/linux/types.h"
typedef struct __anonstruct_atomic_t_7 atomic_t;
//#line  202 "include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long volatile   counter ;
};
//#line  202 "include/linux/types.h"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
//#line  59 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/alternative.h"
struct module;
//#line  7 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct task_struct;
//#line  8
struct mm_struct;
//#line  98 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
//#line  141 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_9 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/math_emu.h"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_9 __annonCompField4 ;
};
//#line  43 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
//#line  105 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
//#line  10 "include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
//#line  114 "include/linux/kernel.h"
struct completion;
//#line  208
struct pid;
//#line  80 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page_64.h"
typedef unsigned long pgdval_t;
//#line  81 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page_64.h"
typedef unsigned long pgprotval_t;
//#line  83
struct page;
//#line  56 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page.h"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
//#line  56 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page.h"
typedef struct __anonstruct_pgd_t_13 pgd_t;
//#line  57 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page.h"
struct __anonstruct_pgprot_t_14 {
   pgprotval_t pgprot ;
};
//#line  57 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page.h"
typedef struct __anonstruct_pgprot_t_14 pgprot_t;
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_18 {
   unsigned int a ;
   unsigned int b ;
};
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_19 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/desc_defs.h"
union __anonunion____missing_field_name_17 {
   struct __anonstruct____missing_field_name_18 __annonCompField6 ;
   struct __anonstruct____missing_field_name_19 __annonCompField7 ;
};
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/desc_defs.h"
struct desc_struct {
   union __anonunion____missing_field_name_17 __annonCompField8 ;
} __attribute__((__packed__)) ;
//#line  34 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/ds.h"
struct ds_context;
//#line  36
struct bts_tracer;
//#line  10 "include/linux/personality.h"
struct exec_domain;
//#line  88
struct map_segment;
//#line  88 "include/linux/personality.h"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
//#line  144 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((255UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
//#line  144 "include/linux/cpumask.h"
typedef struct cpumask cpumask_t;
//#line  252 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct thread_struct;
//#line  289 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_28 {
   u64 rip ;
   u64 rdp ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_29 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_27 {
   struct __anonstruct____missing_field_name_28 __annonCompField9 ;
   struct __anonstruct____missing_field_name_29 __annonCompField10 ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
union __anonunion____missing_field_name_30 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_27 __annonCompField11 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_30 __annonCompField12 ;
} __attribute__((__aligned__(16))) ;
//#line  340 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
//#line  360 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
//#line  366 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
} __attribute__((__packed__, __aligned__(64))) ;
//#line  372 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
//#line  386
struct kmem_cache;
//#line  391 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   struct ds_context *ds_ctx ;
   unsigned int bts_ovfl_signal ;
};
//#line  593 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_31 {
   unsigned long seg ;
};
//#line  593 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/processor.h"
typedef struct __anonstruct_mm_segment_t_31 mm_segment_t;
//#line  19 "include/linux/list.h"
struct list_head {
   struct list_head * __attribute__((__recursive__)) next ;
   struct list_head * __attribute__((__recursive__)) prev ;
};
//#line  540
struct hlist_node;
//#line  540 "include/linux/list.h"
struct hlist_head {
   struct hlist_node *first ;
};
//#line  544 "include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
//#line  12 "include/linux/thread_info.h"
struct timespec;
//#line  13
struct compat_timespec;
//#line  18 "include/linux/thread_info.h"
struct __anonstruct____missing_field_name_33 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
//#line  18 "include/linux/thread_info.h"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
//#line  18 "include/linux/thread_info.h"
struct __anonstruct_nanosleep_35 {
   clockid_t index ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
//#line  18
struct pollfd;
//#line  18 "include/linux/thread_info.h"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
//#line  18 "include/linux/thread_info.h"
union __anonunion____missing_field_name_32 {
   struct __anonstruct____missing_field_name_33 __annonCompField13 ;
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
//#line  18 "include/linux/thread_info.h"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField14 ;
};
//#line  23 "include/asm-generic/atomic.h"
typedef atomic64_t atomic_long_t;
//#line  26 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
};
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/spinlock_types.h"
typedef struct raw_spinlock raw_spinlock_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_37 {
   unsigned int lock ;
};
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/spinlock_types.h"
typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
//#line  13 "include/linux/lockdep.h"
struct lockdep_map;
//#line  7 "include/linux/stacktrace.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
//#line  68 "include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
//#line  72 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
//#line  81 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[9] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
};
//#line  166 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache ;
   char const   *name ;
};
//#line  206 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
};
//#line  20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_38 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  20 "include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_38 spinlock_t;
//#line  36 "include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_39 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  36 "include/linux/spinlock_types.h"
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
//#line  28 "include/linux/wait.h"
struct __wait_queue;
//#line  28 "include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
//#line  32 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
//#line  50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
//#line  54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
//#line  92 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_41 {
   unsigned long bits[(((unsigned long )(1 << 6) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
//#line  92 "include/linux/nodemask.h"
typedef struct __anonstruct_nodemask_t_41 nodemask_t;
//#line  48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
//#line  67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct mutex *lock ;
   void *magic ;
};
//#line  17 "include/linux/rwsem.h"
struct rw_semaphore;
//#line  31 "include/linux/rwsem-spinlock.h"
struct rw_semaphore {
   __s32 activity ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
//#line  749 "include/linux/mmzone.h"
struct file;
//#line  37 "include/linux/pm.h"
struct device;
//#line  39 "include/linux/pm.h"
struct pm_message {
   int event ;
};
//#line  39 "include/linux/pm.h"
typedef struct pm_message pm_message_t;
//#line  170 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
//#line  308
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
//#line  318 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_90 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/mmu.h"
typedef struct __anonstruct_mm_context_t_90 mm_context_t;
//#line  8 "include/linux/gfp.h"
struct vm_area_struct;
//#line  14 "include/linux/time.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
//#line  46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
//#line  59 "include/linux/ktime.h"
typedef union ktime ktime_t;
//#line  9 "include/linux/timer.h"
struct tvec_base;
//#line  11 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   void *data ;
   struct tvec_base *base ;
};
//#line  182
struct hrtimer;
//#line  183
enum hrtimer_restart;
//#line  16 "include/linux/workqueue.h"
struct work_struct;
//#line  25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
   struct lockdep_map lockdep_map ;
};
//#line  39 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
//#line  20 "include/linux/sysfs.h"
struct kobject;
//#line  28 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
//#line  34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
//#line  77 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
//#line  82
struct sysfs_dirent;
//#line  21 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
//#line  59 "include/linux/kobject.h"
struct kset;
//#line  59
struct kobj_type;
//#line  59 "include/linux/kobject.h"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
//#line  104 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
//#line  110 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
//#line  117 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
//#line  151 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
//#line  35 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
//#line  46 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
//#line  63 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
//#line  70 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[255] ;
};
//#line  98 "include/linux/mod_devicetable.h"
struct snd_usb_audio_quirk;
//#line  99 "include/linux/mod_devicetable.h"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   struct snd_usb_audio_quirk *driver_info ;
};
//#line  215 "include/linux/usb/ch9.h"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
//#line  269 "include/linux/usb/ch9.h"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
//#line  306 "include/linux/usb/ch9.h"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
//#line  324 "include/linux/usb/ch9.h"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
//#line  403 "include/linux/usb/ch9.h"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
//#line  571
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_VARIABLE = 4
} ;
//#line  578
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_UNAUTHENTICATED = 3,
    USB_STATE_RECONNECTING = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
//#line  99 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
//#line  99 "include/linux/capability.h"
typedef struct kernel_cap_struct kernel_cap_t;
//#line  553
struct dentry;
//#line  100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
//#line  14 "include/linux/prio_tree.h"
struct prio_tree_node;
//#line  14 "include/linux/prio_tree.h"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
//#line  20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
//#line  28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
//#line  25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
//#line  22 "include/linux/mm_types.h"
struct address_space;
//#line  27 "include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
//#line  39 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_99 {
   u16 inuse ;
   u16 objects ;
};
//#line  39 "include/linux/mm_types.h"
union __anonunion____missing_field_name_98 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_99 __annonCompField15 ;
};
//#line  39 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_101 {
   unsigned long private ;
   struct address_space *mapping ;
};
//#line  39 "include/linux/mm_types.h"
union __anonunion____missing_field_name_100 {
   struct __anonstruct____missing_field_name_101 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
//#line  39 "include/linux/mm_types.h"
union __anonunion____missing_field_name_102 {
   unsigned long index ;
   void *freelist ;
};
//#line  39 "include/linux/mm_types.h"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_98 __annonCompField16 ;
   union __anonunion____missing_field_name_100 __annonCompField18 ;
   union __anonunion____missing_field_name_102 __annonCompField19 ;
   struct list_head lru ;
};
//#line  122 "include/linux/mm_types.h"
struct __anonstruct_vm_set_104 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
//#line  122 "include/linux/mm_types.h"
union __anonunion_shared_103 {
   struct __anonstruct_vm_set_104 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
//#line  122
struct anon_vma;
//#line  122
struct vm_operations_struct;
//#line  122
struct mempolicy;
//#line  122 "include/linux/mm_types.h"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_103 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
//#line  179 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
//#line  184 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
//#line  190 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
//#line  7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
//#line  50 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
//#line  117 "include/linux/sem.h"
struct sem_undo_list;
//#line  130 "include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
//#line  136 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
//#line  10 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/signal.h"
struct siginfo;
//#line  30 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_105 {
   unsigned long sig[1] ;
};
//#line  30 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_105 sigset_t;
//#line  17 "include/asm-generic/signal.h"
typedef void __signalfn_t(int  );
//#line  18 "include/asm-generic/signal.h"
typedef __signalfn_t *__sighandler_t;
//#line  20 "include/asm-generic/signal.h"
typedef void __restorefn_t(void);
//#line  21 "include/asm-generic/signal.h"
typedef __restorefn_t *__sigrestore_t;
//#line  167 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
//#line  174 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
//#line  7 "include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
//#line  7 "include/asm-generic/siginfo.h"
typedef union sigval sigval_t;
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_107 {
   pid_t _pid ;
   uid_t _uid ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__timer_108 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__rt_109 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigchld_110 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigfault_111 {
   void *_addr ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__sigpoll_112 {
   long _band ;
   int _fd ;
};
//#line  40 "include/asm-generic/siginfo.h"
union __anonunion__sifields_106 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_107 _kill ;
   struct __anonstruct__timer_108 _timer ;
   struct __anonstruct__rt_109 _rt ;
   struct __anonstruct__sigchld_110 _sigchld ;
   struct __anonstruct__sigfault_111 _sigfault ;
   struct __anonstruct__sigpoll_112 _sigpoll ;
};
//#line  40 "include/asm-generic/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_106 _sifields ;
};
//#line  40 "include/asm-generic/siginfo.h"
typedef struct siginfo siginfo_t;
//#line  14 "include/linux/signal.h"
struct user_struct;
//#line  24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
//#line  5 "include/linux/path.h"
struct vfsmount;
//#line  7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
//#line  6 "include/linux/fs_struct.h"
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct path root ;
   struct path pwd ;
};
//#line  6 "include/linux/pid.h"
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
//#line  50
struct pid_namespace;
//#line  50 "include/linux/pid.h"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
//#line  57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
//#line  69 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
//#line  97 "include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
//#line  24 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_115 {

};
//#line  24 "include/linux/seccomp.h"
typedef struct __anonstruct_seccomp_t_115 seccomp_t;
//#line  80 "include/linux/plist.h"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
   spinlock_t *lock ;
};
//#line  38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
//#line  43 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
//#line  26 "include/linux/hrtimer.h"
struct hrtimer_clock_base;
//#line  27
struct hrtimer_cpu_base;
//#line  40
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
//#line  100 "include/linux/hrtimer.h"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
};
//#line  139 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
};
//#line  168 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
};
//#line  11 "include/linux/task_io_accounting.h"
struct task_io_accounting {

};
//#line  17 "include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
//#line  947 "include/linux/sysctl.h"
struct nsproxy;
//#line  28 "include/linux/key.h"
typedef int32_t key_serial_t;
//#line  31 "include/linux/key.h"
typedef uint32_t key_perm_t;
//#line  33
struct key;
//#line  73
struct seq_file;
//#line  75
struct signal_struct;
//#line  76
struct cred;
//#line  78
struct key_type;
//#line  80
struct keyring_list;
//#line  123
struct key_user;
//#line  123 "include/linux/key.h"
union __anonunion_type_data_170 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
//#line  123 "include/linux/key.h"
union __anonunion_payload_171 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
//#line  123 "include/linux/key.h"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_170 type_data ;
   union __anonunion_payload_171 payload ;
};
//#line  21 "include/linux/cred.h"
struct inode;
//#line  29 "include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
//#line  81 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
//#line  114 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
//#line  96 "include/linux/sched.h"
struct futex_pi_state;
//#line  97
struct robust_list_head;
//#line  98
struct bio;
//#line  337
struct user_namespace;
//#line  58 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
//#line  16 "include/linux/uio.h"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
//#line  15 "include/linux/aio.h"
struct kioctx;
//#line  87 "include/linux/aio.h"
union __anonunion_ki_obj_173 {
   void *user ;
   struct task_struct *tsk ;
};
//#line  87 "include/linux/aio.h"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_173 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
//#line  167 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
//#line  180 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
//#line  426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
//#line  433 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
//#line  452 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
//#line  479 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
//#line  492 "include/linux/sched.h"
union __anonunion____missing_field_name_174 {
   pid_t pgrp  __attribute__((__deprecated__)) ;
   pid_t __pgrp ;
};
//#line  492 "include/linux/sched.h"
union __anonunion____missing_field_name_175 {
   pid_t session  __attribute__((__deprecated__)) ;
   pid_t __session ;
};
//#line  492
struct tty_struct;
//#line  492
struct taskstats;
//#line  492
struct tty_audit_buf;
//#line  492 "include/linux/sched.h"
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   union __anonunion____missing_field_name_174 __annonCompField20 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_175 __annonCompField21 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
//#line  641 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
//#line  686
struct backing_dev_info;
//#line  687
struct reclaim_state;
//#line  690 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
//#line  706 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
//#line  751
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
//#line  827 "include/linux/sched.h"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
//#line  850
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
//#line  868 "include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   char *name ;
   unsigned long span[] ;
};
//#line  960
struct io_context;
//#line  969
struct audit_context;
//#line  971
struct pipe_inode_info;
//#line  974
struct rq;
//#line  977 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
};
//#line  1027 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
//#line  1041 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
//#line  1098 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
//#line  1114
struct linux_binfmt;
//#line  1114
struct files_struct;
//#line  1114
struct compat_robust_list_head;
//#line  1114 "include/linux/sched.h"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct bts_tracer *bts ;
   void *bts_buffer ;
   size_t bts_size ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_timestamp ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48UL] ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mempolicy *mempolicy ;
   short il_next ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
//#line  77 "include/linux/irq.h"
struct proc_dir_entry;
//#line  19 "include/linux/klist.h"
struct klist_node;
//#line  20 "include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
//#line  39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
//#line  62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
//#line  27 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
//#line  28 "include/linux/elf.h"
typedef __u16 Elf64_Half;
//#line  32 "include/linux/elf.h"
typedef __u32 Elf64_Word;
//#line  33 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
//#line  181 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
//#line  181 "include/linux/elf.h"
typedef struct elf64_sym Elf64_Sym;
//#line  32 "include/linux/moduleparam.h"
struct kernel_param;
//#line  39
struct kparam_string;
//#line  39
struct kparam_array;
//#line  39 "include/linux/moduleparam.h"
union __anonunion____missing_field_name_182 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
//#line  39 "include/linux/moduleparam.h"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_182 __annonCompField22 ;
};
//#line  52 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
//#line  58 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
//#line  19 "include/linux/marker.h"
struct marker;
//#line  33 "include/linux/marker.h"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
//#line  36 "include/linux/marker.h"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
//#line  41 "include/linux/marker.h"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
//#line  21 "include/linux/tracepoint.h"
struct tracepoint;
//#line  23 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
//#line  5 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/module.h"
struct mod_arch_specific {

};
//#line  34 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
//#line  48 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
//#line  58
struct module_param_attrs;
//#line  58 "include/linux/module.h"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
//#line  71
struct exception_table_entry;
//#line  222
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
//#line  229
struct module_sect_attrs;
//#line  229
struct module_notes_attrs;
//#line  229 "include/linux/module.h"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
//#line  594
struct device_driver;
//#line  16 "include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
//#line  4 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/device.h"
struct dma_mapping_ops;
//#line  4 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/device.h"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_mapping_ops *dma_ops ;
   void *iommu ;
};
//#line  32 "include/linux/device.h"
struct driver_private;
//#line  33
struct class;
//#line  34
struct class_private;
//#line  35
struct bus_type;
//#line  36
struct bus_type_private;
//#line  38 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
//#line  51
struct device_attribute;
//#line  51
struct driver_attribute;
//#line  51 "include/linux/device.h"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
//#line  122 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
//#line  155 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
//#line  187
struct class_attribute;
//#line  187 "include/linux/device.h"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
//#line  207
struct device_type;
//#line  240 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
//#line  287 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
//#line  300 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
//#line  360 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
//#line  369
struct dma_coherent_mem;
//#line  369 "include/linux/device.h"
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device * __attribute__((__recursive__)) parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   unsigned int uevent_suppress : 1 ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
//#line  11 "include/linux/dcache.h"
struct nameidata;
//#line  33 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
//#line  89 "include/linux/dcache.h"
union __anonunion_d_u_184 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
//#line  89
struct dentry_operations;
//#line  89
struct super_block;
//#line  89 "include/linux/dcache.h"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_184 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[32] ;
};
//#line  134 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
//#line  61 "include/linux/radix-tree.h"
struct radix_tree_node;
//#line  61 "include/linux/radix-tree.h"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
//#line  14 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
//#line  316 "include/linux/fs.h"
struct export_operations;
//#line  322
struct poll_table_struct;
//#line  323
struct kstatfs;
//#line  378 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
//#line  106 "include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
//#line  127 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
//#line  50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
//#line  137 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
//#line  137 "include/linux/dqblk_xfs.h"
typedef struct fs_qfilestat fs_qfilestat_t;
//#line  143 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
//#line  17 "include/linux/dqblk_qtree.h"
struct dquot;
//#line  182 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
//#line  183 "include/linux/quota.h"
typedef long long qsize_t;
//#line  197 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
//#line  211
struct quota_format_type;
//#line  213 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
//#line  263 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
//#line  285 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
//#line  296 "include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
//#line  314 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
//#line  328 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
//#line  372 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
//#line  443 "include/linux/fs.h"
struct writeback_control;
//#line  486 "include/linux/fs.h"
union __anonunion_arg_190 {
   char *buf ;
   void *data ;
};
//#line  486 "include/linux/fs.h"
struct __anonstruct_read_descriptor_t_189 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_190 arg ;
   int error ;
};
//#line  486 "include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_189 read_descriptor_t;
//#line  499 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
//#line  549 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  573
struct hd_struct;
//#line  573
struct gendisk;
//#line  573 "include/linux/fs.h"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
//#line  649
struct inode_operations;
//#line  649
struct file_operations;
//#line  649
struct file_lock;
//#line  649
struct cdev;
//#line  649 "include/linux/fs.h"
union __anonunion____missing_field_name_191 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
//#line  649
struct dnotify_struct;
//#line  649 "include/linux/fs.h"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_191 __annonCompField23 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
//#line  804 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
//#line  815 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
//#line  838 "include/linux/fs.h"
union __anonunion_f_u_192 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
//#line  838 "include/linux/fs.h"
struct file {
   union __anonunion_f_u_192 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
//#line  957 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
//#line  959 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
//#line  964 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
//#line  8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
//#line  13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
//#line  19
struct nfs4_lock_state;
//#line  20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
//#line  986 "include/linux/fs.h"
struct fasync_struct;
//#line  986 "include/linux/fs.h"
struct __anonstruct_afs_194 {
   struct list_head link ;
   int state ;
};
//#line  986 "include/linux/fs.h"
union __anonunion_fl_u_193 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_194 afs ;
};
//#line  986 "include/linux/fs.h"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_193 fl_u ;
};
//#line  1097 "include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
//#line  1132
struct file_system_type;
//#line  1132
struct super_operations;
//#line  1132
struct xattr_handler;
//#line  1132
struct mtd_info;
//#line  1132 "include/linux/fs.h"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
//#line  1258 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
//#line  1310 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
//#line  1339 "include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
//#line  1382 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
//#line  1565 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
//#line  24 "include/linux/usb.h"
struct usb_device;
//#line  25
struct usb_driver;
//#line  26
struct wusb_dev;
//#line  45
struct ep_device;
//#line  61 "include/linux/usb.h"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char * __attribute__((__blob__("extralen"))) extra ;
   int extralen ;
   int enabled ;
};
//#line  77 "include/linux/usb.h"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint * __attribute__((__blob__(Obfuscate_Nonstub_usb_host_interface("desc")))) endpoint ;
   char *string ;
   unsigned char * __attribute__((__blob__("extralen"))) extra ;
   int extralen ;
};
//#line  90
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
//#line  159 "include/linux/usb.h"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int is_active : 1 ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   int pm_usage_cnt ;
   struct work_struct reset_ws ;
};
//#line  224 "include/linux/usb.h"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
//#line  276 "include/linux/usb.h"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
//#line  307 "include/linux/usb.h"
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
//#line  314
struct mon_bus;
//#line  314 "include/linux/usb.h"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct device *dev ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
//#line  364
struct usb_tt;
//#line  432 "include/linux/usb.h"
struct usb_device {
   int devnum ;
   char devpath[16] ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus * __attribute__((__recursive__)) bus ;
   struct usb_host_endpoint ep0 ;
   struct device  __attribute__((__recursive__)) dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int discon_suspended : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct device *usb_classdev ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   int pm_usage_cnt ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   struct delayed_work autosuspend ;
   struct work_struct autoresume ;
   struct mutex pm_mutex ;
   unsigned long last_busy ;
   int autosuspend_delay ;
   unsigned long connect_time ;
   unsigned int auto_pm : 1 ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   unsigned int autosuspend_disabled : 1 ;
   unsigned int autoresume_disabled : 1 ;
   unsigned int skip_sys_resume : 1 ;
   struct wusb_dev *wusb_dev ;
};
//#line  946 "include/linux/usb.h"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
//#line  965 "include/linux/usb.h"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
//#line  1024 "include/linux/usb.h"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
   void (*disconnect)(struct usb_interface *intf ) ;
   int (*ioctl)(struct usb_interface *intf , unsigned int code , void *buf ) ;
   int (*suspend)(struct usb_interface *intf , pm_message_t message ) ;
   int (*resume)(struct usb_interface *intf ) ;
   int (*reset_resume)(struct usb_interface *intf ) ;
   int (*pre_reset)(struct usb_interface *intf ) ;
   int (*post_reset)(struct usb_interface *intf ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned int no_dynamic_id : 1 ;
   unsigned int supports_autosuspend : 1 ;
   unsigned int soft_unbind : 1 ;
};
//#line  1152 "include/linux/usb.h"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
//#line  1159
struct urb;
//#line  1161 "include/linux/usb.h"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
//#line  1344 "include/linux/usb.h"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device * __attribute__((__recursive__)) dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   int status ;
   unsigned int transfer_flags ;
   u8 *transfer_buffer ;
   dma_addr_t transfer_dma ;
   int transfer_buffer_length ;
   int actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   u8 * __attribute__((__recursive__, __noderef__)) context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
//#line  51 "include/sound/core.h"
typedef int snd_device_type_t;
//#line  67 "include/sound/core.h"
typedef int snd_device_state_t;
//#line  77
struct snd_device;
//#line  79 "include/sound/core.h"
struct snd_device_ops {
   int (*dev_free)(struct snd_device *dev ) ;
   int (*dev_register)(struct snd_device *dev ) ;
   int (*dev_disconnect)(struct snd_device *dev ) ;
};
//#line  85
struct snd_card;
//#line  85 "include/sound/core.h"
struct snd_device {
   struct list_head list ;
   struct snd_card *card ;
   snd_device_state_t state ;
   snd_device_type_t type ;
   void * __attribute__((__noderef__)) device_data ;
   struct snd_device_ops *ops ;
};
//#line  98 "include/sound/core.h"
struct snd_monitor_file {
   struct file *file ;
   struct snd_monitor_file *next ;
   struct file_operations  const  *disconnected_f_op ;
   struct list_head shutdown_list ;
};
//#line  107
struct snd_info_entry;
//#line  107
struct snd_shutdown_f_ops;
//#line  107
struct snd_mixer_oss;
//#line  107 "include/sound/core.h"
struct snd_card {
   int number ;
   char id[16] ;
   char driver[16] ;
   char shortname[32] ;
   char longname[80] ;
   char mixername[80] ;
   char components[128] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card *card ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct snd_monitor_file *files ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   struct device *dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
//#line  31 "include/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
//#line  95 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
//#line  33 "include/linux/poll.h"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
//#line  33 "include/linux/poll.h"
typedef struct poll_table_struct poll_table;
//#line  28 "include/sound/info.h"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
//#line  42 "include/sound/info.h"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
   void (*write)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
};
//#line  49 "include/sound/info.h"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry *entry , unsigned short mode , void **file_private_data ) ;
   int (*release)(struct snd_info_entry *entry , unsigned short mode , void *file_private_data ) ;
   long (*read)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                char *buf , unsigned long count , unsigned long pos ) ;
   long (*write)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                 char const   *buf , unsigned long count , unsigned long pos ) ;
   long long (*llseek)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                       long long offset , int orig ) ;
   unsigned int (*poll)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                        poll_table *wait ) ;
   int (*ioctl)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                unsigned int cmd , unsigned long arg ) ;
   int (*mmap)(struct snd_info_entry *entry , void *file_private_data , struct inode *inode ,
               struct file *file , struct vm_area_struct *vma ) ;
};
//#line  73 "include/sound/info.h"
union __anonunion_c_198 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
//#line  73 "include/sound/info.h"
struct snd_info_entry {
   char const   * __attribute__((__nullterm__)) name ;
   mode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_198 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   void * __attribute__((__noderef__)) private_data ;
   void (*private_free)(struct snd_info_entry *entry ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
//#line  144 "include/sound/asound.h"
typedef unsigned long snd_pcm_uframes_t;
//#line  145 "include/sound/asound.h"
typedef long snd_pcm_sframes_t;
//#line  169 "include/sound/asound.h"
typedef int snd_pcm_access_t;
//#line  177 "include/sound/asound.h"
typedef int snd_pcm_format_t;
//#line  241 "include/sound/asound.h"
typedef int snd_pcm_subformat_t;
//#line  260 "include/sound/asound.h"
typedef int snd_pcm_state_t;
//#line  278 "include/sound/asound.h"
union snd_pcm_sync_id {
   unsigned char id[16] ;
   unsigned short id16[8] ;
   unsigned int id32[4] ;
};
//#line  300 "include/sound/asound.h"
typedef int snd_pcm_hw_param_t;
//#line  334 "include/sound/asound.h"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned int openmin : 1 ;
   unsigned int openmax : 1 ;
   unsigned int integer : 1 ;
   unsigned int empty : 1 ;
};
//#line  344 "include/sound/asound.h"
struct snd_mask {
   u_int32_t bits[8] ;
};
//#line  348 "include/sound/asound.h"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3] ;
   struct snd_mask mres[5] ;
   struct snd_interval intervals[12] ;
   struct snd_interval ires[9] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64] ;
};
//#line  407 "include/sound/asound.h"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
//#line  415 "include/sound/asound.h"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
//#line  32 "include/sound/memalloc.h"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
//#line  55 "include/sound/memalloc.h"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
//#line  165 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
//#line  182 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
//#line  25 "include/sound/pcm_oss.h"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned int disable : 1 ;
   unsigned int direct : 1 ;
   unsigned int block : 1 ;
   unsigned int nonblock : 1 ;
   unsigned int partialfrag : 1 ;
   unsigned int nosilence : 1 ;
   unsigned int buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
//#line  39
struct snd_pcm_plugin;
//#line  39 "include/sound/pcm_oss.h"
struct snd_pcm_oss_runtime {
   unsigned int params : 1 ;
   unsigned int prepare : 1 ;
   unsigned int trigger : 1 ;
   unsigned int sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_interrupt ;
};
//#line  67
struct snd_pcm_substream;
//#line  71 "include/sound/pcm_oss.h"
struct snd_pcm_oss_substream {
   unsigned int oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
//#line  76 "include/sound/pcm_oss.h"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
//#line  84 "include/sound/pcm_oss.h"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
//#line  44 "include/sound/pcm.h"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
//#line  62 "include/sound/pcm.h"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream *substream ) ;
   int (*close)(struct snd_pcm_substream *substream ) ;
   int (*ioctl)(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
   int (*hw_params)(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *params ) ;
   int (*hw_free)(struct snd_pcm_substream *substream ) ;
   int (*prepare)(struct snd_pcm_substream *substream ) ;
   int (*trigger)(struct snd_pcm_substream *substream , int cmd ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream ) ;
   int (*copy)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
               void *buf , snd_pcm_uframes_t count ) ;
   int (*silence)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
                  snd_pcm_uframes_t count ) ;
   struct page *(*page)(struct snd_pcm_substream *substream , unsigned long offset ) ;
   int (*mmap)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ) ;
   int (*ack)(struct snd_pcm_substream *substream ) ;
};
//#line  204
struct snd_pcm_hw_rule;
//#line  208 "include/sound/pcm.h"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) ;
   int var ;
   int deps[4] ;
   void *private ;
};
//#line  216 "include/sound/pcm.h"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3] ;
   struct snd_interval intervals[12] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
//#line  258 "include/sound/pcm.h"
struct snd_pcm_hw_constraint_list {
   unsigned int count ;
   unsigned int *list ;
   unsigned int mask ;
};
//#line  264 "include/sound/pcm.h"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   wait_queue_head_t sleep ;
   struct fasync_struct *fasync ;
   void * __attribute__((__recursive__)) private_data ;
   void (*private_free)(struct snd_pcm_runtime *runtime ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream *substream ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream *substream ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char *dma_area ;
   dma_addr_t dma_addr ;
   size_t dma_bytes ;
   struct snd_dma_buffer *dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
};
//#line  342 "include/sound/pcm.h"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
//#line  348
struct snd_pcm;
//#line  348
struct snd_pcm_str;
//#line  348
struct snd_timer;
//#line  348 "include/sound/pcm.h"
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   void *private_data ;
   int number ;
   char name[32] ;
   int stream ;
   char latency_id[20] ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime * __attribute__((__recursive__)) runtime ;
   struct snd_timer *timer ;
   unsigned int timer_running : 1 ;
   spinlock_t timer_lock ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned int hw_opened : 1 ;
};
//#line  400 "include/sound/pcm.h"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
};
//#line  421 "include/sound/pcm.h"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64] ;
   char name[80] ;
   struct snd_pcm_str streams[2] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void * __attribute__((__recursive__)) private_data ;
   void (*private_free)(struct snd_pcm *pcm ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
//#line  49 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
//#line  51 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
//#line  54 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
//#line  122 "/scratch/sym/ipc_drivers/usb-audio/usbaudio.h"
struct snd_usb_audio {
   int index ;
   struct usb_device *dev ;
   struct snd_card *card ;
   u32 usb_id ;
   int shutdown ;
   int num_interfaces ;
   int num_suspended_intf ;
   struct list_head pcm_list ;
   int pcm_devs ;
   struct list_head midi_list ;
   int next_midi_device ;
   struct list_head mixer_list ;
};
//#line  169 "/scratch/sym/ipc_drivers/usb-audio/usbaudio.h"
struct snd_usb_audio_quirk {
   char const   * __attribute__((__nullterm__)) vendor_name ;
   char const   * __attribute__((__recursive__)) product_name ;
   int16_t ifnum ;
   uint16_t type ;
   void const   * __attribute__((__recursive__)) data ;
};
//#line  178 "/scratch/sym/ipc_drivers/usb-audio/usbaudio.h"
struct snd_usb_midi_endpoint_info {
   int8_t out_ep ;
   uint8_t out_interval ;
   int8_t in_ep ;
   uint8_t in_interval ;
   uint16_t out_cables ;
   uint16_t in_cables ;
};
//#line  127 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct audioformat {
   struct list_head list ;
   snd_pcm_format_t format ;
   unsigned int channels ;
   unsigned int fmt_type ;
   unsigned int frame_size ;
   int iface ;
   unsigned char altsetting ;
   unsigned char altset_idx ;
   unsigned char attributes ;
   unsigned char endpoint ;
   unsigned char ep_attr ;
   unsigned int maxpacksize ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int nr_rates ;
   unsigned int *rate_table ;
};
//#line  146
struct snd_usb_substream;
//#line  148 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct snd_urb_ctx {
   struct urb * __attribute__((__recursive__)) urb ;
   unsigned int buffer_size ;
   struct snd_usb_substream *subs ;
   int index ;
   int packets ;
};
//#line  156 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct snd_urb_ops {
   int (*prepare)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                  struct urb *u ) ;
   int (*retire)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                 struct urb *u ) ;
   int (*prepare_sync)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                       struct urb *u ) ;
   int (*retire_sync)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                      struct urb *u ) ;
};
//#line  163
struct snd_usb_stream;
//#line  163 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct snd_usb_substream {
   struct snd_usb_stream * __attribute__((__recursive__)) stream ;
   struct usb_device *dev ;
   struct snd_pcm_substream * __attribute__((__recursive__)) pcm_substream ;
   int direction ;
   int interface ;
   int endpoint ;
   struct audioformat *cur_audiofmt ;
   unsigned int cur_rate ;
   unsigned int period_bytes ;
   unsigned int format ;
   unsigned int datapipe ;
   unsigned int syncpipe ;
   unsigned int datainterval ;
   unsigned int syncinterval ;
   unsigned int freqn ;
   unsigned int freqm ;
   unsigned int freqmax ;
   unsigned int phase ;
   unsigned int maxpacksize ;
   unsigned int maxframesize ;
   unsigned int curpacksize ;
   unsigned int curframesize ;
   unsigned int fill_max : 1 ;
   unsigned int fmt_type ;
   unsigned int packs_per_ms ;
   unsigned int running : 1 ;
   unsigned int hwptr_done ;
   unsigned int transfer_done ;
   unsigned long active_mask ;
   unsigned long unlink_mask ;
   unsigned int nurbs ;
   struct snd_urb_ctx dataurb[8] ;
   struct snd_urb_ctx syncurb[4] ;
   char * __attribute__((__nullterm__)) syncbuf ;
   dma_addr_t sync_dma ;
   u64 formats ;
   unsigned int num_formats ;
   struct list_head fmt_list ;
   struct snd_pcm_hw_constraint_list rate_list ;
   spinlock_t lock ;
   struct snd_urb_ops ops ;
};
//#line  213 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct snd_usb_stream {
   struct snd_usb_audio *chip ;
   struct snd_pcm * __attribute__((__recursive__)) pcm ;
   int pcm_index ;
   unsigned int fmt_type ;
   struct snd_usb_substream substream[2] ;
   struct list_head list ;
};
//#line  225
struct snd_usb_midi_in_endpoint;
//#line  225
struct snd_usb_midi_out_endpoint;
//#line  225 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops {
   void (*input)(struct snd_usb_midi_in_endpoint * , uint8_t * , int  ) ;
   void (*output)(struct snd_usb_midi_out_endpoint * ) ;
   void (*output_packet)(struct urb * , uint8_t  , uint8_t  , uint8_t  , uint8_t  ) ;
   void (*init_out_endpoint)(struct snd_usb_midi_out_endpoint * ) ;
   void (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint * ) ;
};
//#line  335 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
typedef int (*quirk_func_t)(struct snd_usb_audio * , struct usb_interface * , struct snd_usb_audio_quirk  const  * );
//#line  183 "include/linux/timer.h"
enum hrtimer_restart;
//#line  318 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
//#line  34 "include/sound/seq_device.h"
struct snd_seq_device {
   struct snd_card *card ;
   int device ;
   char id[32] ;
   char name[80] ;
   int argsize ;
   void *driver_data ;
   int status ;
   void *private_data ;
   void (*private_free)(struct snd_seq_device *device ) ;
   struct list_head list ;
};
//#line  47 "include/sound/rawmidi.h"
struct snd_rawmidi;
//#line  48
struct snd_rawmidi_substream;
//#line  49
struct snd_seq_port_info;
//#line  51 "include/sound/rawmidi.h"
struct snd_rawmidi_ops {
   int (*open)(struct snd_rawmidi_substream *substream ) ;
   int (*close)(struct snd_rawmidi_substream *substream ) ;
   void (*trigger)(struct snd_rawmidi_substream *substream , int up ) ;
   void (*drain)(struct snd_rawmidi_substream *substream ) ;
};
//#line  58 "include/sound/rawmidi.h"
struct snd_rawmidi_global_ops {
   int (*dev_register)(struct snd_rawmidi *rmidi ) ;
   int (*dev_unregister)(struct snd_rawmidi *rmidi ) ;
   void (*get_port_info)(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *info ) ;
};
//#line  65 "include/sound/rawmidi.h"
struct snd_rawmidi_runtime {
   unsigned int drain : 1 ;
   unsigned int oss : 1 ;
   unsigned char *buffer ;
   size_t buffer_size ;
   size_t appl_ptr ;
   size_t hw_ptr ;
   size_t avail_min ;
   size_t avail ;
   size_t xruns ;
   spinlock_t lock ;
   wait_queue_head_t sleep ;
   void (*event)(struct snd_rawmidi_substream *substream ) ;
   struct tasklet_struct tasklet ;
   void * __attribute__((__recursive__)) private_data ;
   void (*private_free)(struct snd_rawmidi_substream *substream ) ;
};
//#line  88
struct snd_rawmidi_str;
//#line  88 "include/sound/rawmidi.h"
struct snd_rawmidi_substream {
   struct list_head  __attribute__((__noderef__)) list ;
   int stream ;
   int number ;
   unsigned int opened : 1 ;
   unsigned int append : 1 ;
   unsigned int active_sensing : 1 ;
   int use_count ;
   size_t bytes ;
   struct snd_rawmidi * __attribute__((__recursive__)) rmidi ;
   struct snd_rawmidi_str *pstr ;
   char name[32] ;
   struct snd_rawmidi_runtime * __attribute__((__recursive__)) runtime ;
   struct snd_rawmidi_ops *ops ;
};
//#line  111 "include/sound/rawmidi.h"
struct snd_rawmidi_str {
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct list_head  __attribute__((__noderef__)) substreams ;
};
//#line  117 "include/sound/rawmidi.h"
struct snd_rawmidi {
   struct snd_card *card ;
   struct list_head list ;
   unsigned int device ;
   unsigned int info_flags ;
   char id[64] ;
   char name[80] ;
   int ossreg ;
   struct snd_rawmidi_global_ops *ops ;
   struct snd_rawmidi_str streams[2] ;
   void * __attribute__((__recursive__, __noderef__)) private_data ;
   void (*private_free)(struct snd_rawmidi *rmidi ) ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   struct snd_info_entry *dev ;
   struct snd_info_entry *proc_entry ;
   struct snd_seq_device *seq_dev ;
};
//#line  160 "include/sound/asequencer.h"
struct snd_seq_addr {
   unsigned char client ;
   unsigned char port ;
};
//#line  511 "include/sound/asequencer.h"
struct snd_seq_port_info {
   struct snd_seq_addr addr ;
   char name[64] ;
   unsigned int capability ;
   unsigned int type ;
   int midi_channels ;
   int midi_voices ;
   int synth_voices ;
   int read_use ;
   int write_use ;
   void *kernel ;
   unsigned int flags ;
   unsigned char time_queue ;
   char reserved[59] ;
};
//#line  71 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct usb_ms_header_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDescriptorSubtype ;
   __u8 bcdMSC[2] ;
   __le16 wTotalLength ;
} __attribute__((__packed__)) ;
//#line  79 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct usb_ms_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDescriptorSubtype ;
   __u8 bNumEmbMIDIJack ;
   __u8 baAssocJackID[0] ;
} __attribute__((__packed__)) ;
//#line  89
struct snd_usb_midi_endpoint;
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct snd_usb_midi_endpoint {
   struct snd_usb_midi_out_endpoint *out ;
   struct snd_usb_midi_in_endpoint *in ;
};
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct snd_usb_midi {
   struct snd_usb_audio *chip ;
   struct usb_interface *iface ;
   struct snd_usb_audio_quirk  const  *quirk ;
   struct snd_rawmidi * __attribute__((__recursive__)) rmidi ;
   struct usb_protocol_ops *usb_protocol_ops ;
   struct list_head  __attribute__((__recursive__)) list ;
   struct timer_list error_timer ;
   spinlock_t disc_lock ;
   struct snd_usb_midi_endpoint endpoints[2] ;
   unsigned long input_triggered ;
   unsigned char disconnected ;
};
//#line  117 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct usbmidi_out_port {
   struct snd_usb_midi_out_endpoint *ep ;
   struct snd_rawmidi_substream * __attribute__((__recursive__)) substream ;
   int active ;
   uint8_t cable ;
   uint8_t state ;
   uint8_t data[2] ;
};
//#line  117 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct snd_usb_midi_out_endpoint {
   struct snd_usb_midi * __attribute__((__recursive__)) umidi ;
   struct urb * __attribute__((__recursive__)) urb ;
   int urb_active ;
   int max_transfer ;
   struct tasklet_struct tasklet ;
   spinlock_t buffer_lock ;
   struct usbmidi_out_port ports[16] ;
   int current_port ;
};
//#line  144 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct usbmidi_in_port {
   struct snd_rawmidi_substream *substream ;
   u8 running_status_length ;
};
//#line  144 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct snd_usb_midi_in_endpoint {
   struct snd_usb_midi *umidi ;
   struct urb * __attribute__((__recursive__)) urb ;
   struct usbmidi_in_port ports[16] ;
   u8 seen_f5 ;
   u8 error_resubmit ;
   int current_port ;
};
//#line  1122 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
struct port_info {
   u32 id ;
   short port ;
   short voices ;
   char const   * __attribute__((__nullterm__)) name ;
   unsigned int seq_flags ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/pda.h"
struct x8664_pda {
   struct task_struct *pcurrent ;
   unsigned long data_offset ;
   unsigned long kernelstack ;
   unsigned long oldrsp ;
   int irqcount ;
   unsigned int cpunumber ;
   char *irqstackptr ;
   short nodenumber ;
   short in_bootmem ;
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   short mmu_state ;
   short isidle ;
   struct mm_struct *active_mm ;
   unsigned int apic_timer_irqs ;
   unsigned int irq0_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
   unsigned int irq_threshold_count ;
   unsigned int irq_spurious_count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
//#line  183 "include/linux/timer.h"
enum hrtimer_restart;
//#line  146 "include/linux/usb/ch9.h"
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
} __attribute__((__packed__)) ;
//#line  63 "include/sound/asound.h"
struct snd_aes_iec958 {
   unsigned char status[24] ;
   unsigned char subcode[147] ;
   unsigned char pad ;
   unsigned char dig_subframe[4] ;
};
//#line  112 "include/sound/asound.h"
struct snd_hwdep_dsp_status {
   unsigned int version ;
   unsigned char id[32] ;
   unsigned int num_dsps ;
   unsigned int dsp_loaded ;
   unsigned int chip_ready ;
   unsigned char reserved[16] ;
};
//#line  121 "include/sound/asound.h"
struct snd_hwdep_dsp_image {
   unsigned int index ;
   unsigned char name[64] ;
   unsigned char *image ;
   size_t length ;
   unsigned long driver_data ;
};
//#line  725 "include/sound/asound.h"
typedef int snd_ctl_elem_type_t;
//#line  735 "include/sound/asound.h"
typedef int snd_ctl_elem_iface_t;
//#line  769 "include/sound/asound.h"
struct snd_ctl_elem_id {
   unsigned int numid ;
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char name[44] ;
   unsigned int index ;
};
//#line  787 "include/sound/asound.h"
struct __anonstruct_integer_215 {
   long min ;
   long max ;
   long step ;
};
//#line  787 "include/sound/asound.h"
struct __anonstruct_integer64_216 {
   long long min ;
   long long max ;
   long long step ;
};
//#line  787 "include/sound/asound.h"
struct __anonstruct_enumerated_217 {
   unsigned int items ;
   unsigned int item ;
   char name[64] ;
};
//#line  787 "include/sound/asound.h"
union __anonunion_value_214 {
   struct __anonstruct_integer_215 integer ;
   struct __anonstruct_integer64_216 integer64 ;
   struct __anonstruct_enumerated_217 enumerated ;
   unsigned char reserved[128] ;
};
//#line  787 "include/sound/asound.h"
union __anonunion_dimen_218 {
   unsigned short d[4] ;
   unsigned short *d_ptr ;
};
//#line  787 "include/sound/asound.h"
struct snd_ctl_elem_info {
   struct snd_ctl_elem_id id ;
   snd_ctl_elem_type_t type ;
   unsigned int access ;
   unsigned int count ;
   pid_t owner ;
   union __anonunion_value_214 value ;
   union __anonunion_dimen_218 dimen ;
   unsigned char reserved[64UL - 4UL * sizeof(unsigned short )] ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_integer_220 {
   long value[128] ;
   long *value_ptr ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_integer64_221 {
   long long value[64] ;
   long long *value_ptr ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_enumerated_222 {
   unsigned int item[128] ;
   unsigned int *item_ptr ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_bytes_223 {
   unsigned char data[512] ;
   unsigned char *data_ptr ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_value_219 {
   union __anonunion_integer_220 integer ;
   union __anonunion_integer64_221 integer64 ;
   union __anonunion_enumerated_222 enumerated ;
   union __anonunion_bytes_223 bytes ;
   struct snd_aes_iec958 iec958 ;
};
//#line  818 "include/sound/asound.h"
struct snd_ctl_elem_value {
   struct snd_ctl_elem_id id ;
   unsigned int indirect : 1 ;
   union __anonunion_value_219 value ;
   struct timespec tstamp ;
   unsigned char reserved[128UL - sizeof(struct timespec )] ;
};
//#line  29 "include/sound/control.h"
struct snd_kcontrol;
//#line  30 "include/sound/control.h"
typedef int snd_kcontrol_info_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo );
//#line  31 "include/sound/control.h"
typedef int snd_kcontrol_get_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  32 "include/sound/control.h"
typedef int snd_kcontrol_put_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  33 "include/sound/control.h"
typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                                  unsigned int *tlv );
//#line  39 "include/sound/control.h"
union __anonunion_tlv_228 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
//#line  39 "include/sound/control.h"
struct snd_kcontrol_new {
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char *name ;
   unsigned int index ;
   unsigned int access ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_228 tlv ;
   unsigned long private_value ;
};
//#line  57
struct snd_ctl_file;
//#line  57 "include/sound/control.h"
struct snd_kcontrol_volatile {
   struct snd_ctl_file *owner ;
   pid_t owner_pid ;
   unsigned int access ;
};
//#line  63 "include/sound/control.h"
union __anonunion_tlv_229 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
//#line  63 "include/sound/control.h"
struct snd_kcontrol {
   struct list_head list ;
   struct snd_ctl_elem_id id ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_229 tlv ;
   unsigned long private_value ;
   char *private_data ;
   void (*private_free)(struct snd_kcontrol *kcontrol ) ;
   struct snd_kcontrol_volatile vd[0] ;
};
//#line  87
struct usb_mixer_interface;
//#line  88
struct usb_mixer_elem_info;
//#line  136 "include/sound/control.h"
struct snd_ctl_file {
   struct list_head list ;
   struct snd_card *card ;
   pid_t pid ;
   int prefer_pcm_subdevice ;
   int prefer_rawmidi_subdevice ;
   wait_queue_head_t change_sleep ;
   spinlock_t read_lock ;
   struct fasync_struct *fasync ;
   int subscribed ;
   struct list_head events ;
};
//#line  28 "include/sound/hwdep.h"
struct snd_hwdep;
//#line  30 "include/sound/hwdep.h"
struct snd_hwdep_ops {
   long long (*llseek)(struct snd_hwdep *hw , struct file *file , long long offset ,
                       int orig ) ;
   long (*read)(struct snd_hwdep *hw , char *buf , long count , loff_t *offset ) ;
   long (*write)(struct snd_hwdep *hw , char const   *buf , long count , loff_t *offset ) ;
   int (*open)(struct snd_hwdep *hw , struct file *file ) ;
   int (*release)(struct snd_hwdep *hw , struct file *file ) ;
   unsigned int (*poll)(struct snd_hwdep *hw , struct file *file , poll_table *wait ) ;
   int (*ioctl)(struct snd_hwdep *hw , struct file *file , unsigned int cmd , unsigned long arg ) ;
   int (*ioctl_compat)(struct snd_hwdep *hw , struct file *file , unsigned int cmd ,
                       unsigned long arg ) ;
   int (*mmap)(struct snd_hwdep *hw , struct file *file , struct vm_area_struct *vma ) ;
   int (*dsp_status)(struct snd_hwdep *hw , struct snd_hwdep_dsp_status *status ) ;
   int (*dsp_load)(struct snd_hwdep *hw , struct snd_hwdep_dsp_image *image ) ;
};
//#line  44 "include/sound/hwdep.h"
struct snd_hwdep {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   char id[32] ;
   char name[80] ;
   int iface ;
   char oss_dev[32] ;
   int oss_type ;
   int ossreg ;
   struct snd_hwdep_ops ops ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_hwdep *hwdep ) ;
   struct mutex open_mutex ;
   int used ;
   unsigned int dsp_loaded ;
   unsigned int exclusive : 1 ;
};
//#line  57 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct rc_config {
   u32 usb_id ;
   u8 offset ;
   u8 length ;
   u8 packet_length ;
   u8 min_packet_length ;
   u8 mute_mixer_id ;
   u32 mute_code ;
} __attribute__((__noderef__, __address_space__(2))) ;
//#line  71 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct usb_mixer_interface {
   struct snd_usb_audio *chip ;
   unsigned int ctrlif ;
   struct list_head list ;
   unsigned int ignore_ctl_error ;
   struct urb *urb ;
   struct usb_mixer_elem_info **id_elems ;
   struct rc_config  const  *rc_cfg ;
   unsigned long rc_hwdep_open ;
   u32 rc_code ;
   wait_queue_head_t rc_waitq ;
   struct urb *rc_urb ;
   struct usb_ctrlrequest *rc_setup_packet ;
   u8 rc_buffer[6] ;
   u8 audigy2nx_leds[3] ;
};
//#line  92 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct usb_audio_term {
   int id ;
   int type ;
   int channels ;
   unsigned int chconfig ;
   int name ;
};
//#line  100
struct usbmix_name_map;
//#line  102
struct usbmix_selector_map;
//#line  102 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct mixer_build {
   struct snd_usb_audio *chip ;
   struct usb_mixer_interface *mixer ;
   unsigned char * __attribute__((__expfld__(buflen))) buffer ;
   unsigned int buflen ;
   unsigned long unitbitmap[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   struct usb_audio_term oterm ;
   struct usbmix_name_map  const  *map ;
   struct usbmix_selector_map  const  *selector_map ;
};
//#line  113 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct usb_mixer_elem_info {
   struct usb_mixer_interface *mixer ;
   struct usb_mixer_elem_info * __attribute__((__recursive__)) next_id_elem ;
   struct snd_ctl_elem_id *elem_id ;
   unsigned int id ;
   unsigned int control ;
   unsigned int cmask ;
   int channels ;
   int val_type ;
   int min ;
   int max ;
   int res ;
   u8 initialized ;
};
//#line  23 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
struct usbmix_name_map {
   int id ;
   char const   *name ;
   int control ;
};
//#line  29 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
struct usbmix_selector_map {
   int id ;
   int count ;
   char const   **names ;
};
//#line  35 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
struct usbmix_ctl_map {
   u32 id ;
   struct usbmix_name_map  const  *map ;
   struct usbmix_selector_map  const  *selector_map ;
   int ignore_ctl_error ;
};
//#line  500 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct iterm_name_combo {
   int type ;
   char * __attribute__((__nullterm__)) name ;
} __attribute__((__noderef__, __address_space__(2))) ;
//#line  648 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct usb_feature_control_info {
   char const   * __attribute__((__nullterm__)) name ;
   unsigned int type ;
};
//#line  1225 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct procunit_value_info {
   int control ;
   char *suffix ;
   int val_type ;
   int min_value ;
};
//#line  1232 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct procunit_info {
   int type ;
   char *name ;
   struct procunit_value_info *values ;
};
//#line  1988 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
struct sb_jack {
   int unitid ;
   char const   *name ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
//#line  1 "usbaudio_annotated.o"
#pragma merger(0,"./usbaudio_annotated.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  59 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) set_bit)(unsigned int nr ,
                                                                   unsigned long volatile   *addr ) 
{ 


  {
//#line  68
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
//#line  71
  return;
}
}
//#line  97 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/bitops.h"
__inline static void ( __attribute__((__always_inline__)) clear_bit)(int nr , unsigned long volatile   *addr ) 
{ 


  {
//#line  105
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
//#line  109
  return;
}
}
//#line  195 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) test_and_set_bit)(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
//#line  199
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
//#line  202
  return (oldbit);
}
}
//#line  315 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) variable_test_bit)(int nr ,
                                                                            unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
//#line  319
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
//#line  324
  return (oldbit);
}
}
//#line  395 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/bitops.h"
__inline static int ( __attribute__((__always_inline__)) ffs)(int x ) 
{ 
  int r ;

  {
//#line  399
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
//#line  408
  return (r + 1);
}
}
//#line  61 "include/asm-generic/bug.h"
extern void ( /* format attribute */  warn_slowpath)(char const   *file , int line ,
                                                     char const   *fmt  , ...) ;
//#line  178 "include/linux/kernel.h"
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
//#line  182
extern int ( /* format attribute */  snprintf)(char *buf , size_t size , char const   *fmt 
                                               , ...) ;
//#line  238
extern int ( /* format attribute */  printk)(char const   *fmt  , ...) ;
//#line  71 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/page_64.h"
extern unsigned long __phys_addr(unsigned long  ) ;
//#line  9 "include/asm-generic/page.h"
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size )  __attribute__((__const__)) ;
//#line  9 "include/asm-generic/page.h"
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size ) 
{ 
  int order ;

  {
//#line  13
  size = (size - 1UL) >> 11;
//#line  14
  order = -1;
//#line  15
  while (1) {
//#line  16
    size >>= 1;
//#line  17
    order ++;
//#line  15
    if (! size) {
//#line  15
      break;
    }
  }
//#line  19
  return (order);
}
}
//#line  33 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/string_64.h"
extern void *__memcpy(void *to , void const   *from , size_t len ) ;
//#line  47
extern void *memset(void *s , int c , size_t n ) ;
//#line  54
extern char *strcpy(char *dest , char const   *src ) ;
//#line  28 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
//#line  37
extern size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
//#line  107
extern void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
//#line  28 "include/linux/list.h"
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ 


  {
//#line  30
  list->next = (struct list_head * __attribute__((__recursive__)) )list;
//#line  31
  list->prev = (struct list_head * __attribute__((__recursive__)) )list;
//#line  32
  return;
}
}
//#line  51
extern void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) ;
//#line  64 "include/linux/list.h"
__inline static void ( __attribute__((__always_inline__)) list_add)(struct list_head *new ,
                                                                    struct list_head *head ) 
{ 


  {
//#line  66
  __list_add(new, head, (struct list_head *)head->next);
//#line  67
  return;
}
}
//#line  78 "include/linux/list.h"
__inline static void ( __attribute__((__always_inline__)) list_add_tail)(struct list_head *new ,
                                                                         struct list_head *head ) 
{ 


  {
//#line  80
  __list_add(new, (struct list_head *)head->prev, head);
//#line  81
  return;
}
}
//#line  110
extern void list_del(struct list_head *entry ) ;
//#line  94 "include/linux/spinlock.h"
extern void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
//#line  22 "include/linux/spinlock_api_smp.h"
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  35
extern unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  47
extern void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  56
extern void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
//#line  137 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
//#line  125 "include/linux/mutex.h"
extern void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) ;
//#line  151
extern void mutex_unlock(struct mutex *lock ) ;
//#line  222 "include/linux/gfp.h"
extern unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
//#line  235
extern void free_pages(unsigned long addr , unsigned int order ) ;
//#line  129 "include/linux/slab.h"
extern void kfree(void const   * ) ;
//#line  82 "include/linux/jiffies.h"
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
//#line  298
extern unsigned long msecs_to_jiffies(unsigned int m ) ;
//#line  205 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
//#line  212 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
//#line  227
  tmp___2 = __kmalloc(size, flags);
//#line  227
  return (tmp___2);
}
}
//#line  211 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kcalloc)(size_t n , size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
//#line  213
  if (size != 0UL) {
//#line  213
    if (n > 0xffffffffffffffffUL / size) {
//#line  214
      return ((void *)0);
    }
  }
//#line  215
  tmp = __kmalloc(n * size, flags | 32768U);
//#line  215
  return (tmp);
}
}
//#line  304 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
//#line  306
  tmp = kmalloc(size, flags | 32768U);
//#line  306
  return (tmp);
}
}
//#line  333 "include/linux/sched.h"
extern long schedule_timeout_uninterruptible(long timeout ) ;
//#line  159 "include/linux/moduleparam.h"
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
//#line  160
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
//#line  175
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
//#line  176
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
//#line  179
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
//#line  180
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
//#line  199
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
//#line  200
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
//#line  67 "include/linux/module.h"
int init_module(void) ;
//#line  68
void cleanup_module(void) ;
//#line  86
extern struct module __this_module ;
//#line  456 "include/linux/device.h"
__inline static void *( __attribute__((__always_inline__)) dev_get_drvdata)(struct device  const  *dev ) 
{ 


  {
//#line  458
  return ((void *)dev->driver_data);
}
}
//#line  461 "include/linux/device.h"
__inline static void ( __attribute__((__always_inline__)) dev_set_drvdata)(struct device *dev ,
                                                                           void *data ) 
{ 


  {
//#line  463
  dev->driver_data = data;
//#line  464
  return;
}
}
//#line  73 "include/linux/usb.h"
unsigned long Nonstub_usb_host_interface(struct usb_interface_descriptor desc ) ;
//#line  74
unsigned long Nonstub_get_size(unsigned long size ) ;
//#line  193 "include/linux/usb.h"
__inline static void *( __attribute__((__always_inline__)) usb_get_intfdata)(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
//#line  195
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
//#line  195
  return (tmp);
}
}
//#line  198 "include/linux/usb.h"
__inline static void ( __attribute__((__always_inline__)) usb_set_intfdata)(struct usb_interface *intf ,
                                                                            void *data ) 
{ 


  {
//#line  200
  dev_set_drvdata(& intf->dev, data);
//#line  201
  return;
}
}
//#line  583
extern int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                                      void *priv ) ;
//#line  596 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_interface_claimed)(struct usb_interface *iface ) 
{ 


  {
//#line  598
  return ((unsigned long )iface->dev.driver != (unsigned long )((void *)0));
}
}
//#line  610
extern struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) ;
//#line  640 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_make_path)(struct usb_device *dev ,
                                                                        char *buf ,
                                                                        size_t size ) 
{ 
  int actual ;
  int tmp ;

  {
//#line  643
  actual = snprintf(buf, size, "usb-%s-%s", (dev->bus)->bus_name, dev->devpath);
//#line  645
  if (actual >= (int )size) {
//#line  645
    tmp = -1;
  } else {
//#line  645
    tmp = actual;
  }
//#line  645
  return (tmp);
}
}
//#line  1107
extern int usb_register_driver(struct usb_driver * , struct module * , char const   * __attribute__((__nullterm__))  ) ;
//#line  1109 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_register)(struct usb_driver *driver ) 
{ 
  int tmp ;

  {
//#line  1111
  tmp = usb_register_driver(driver, & __this_module, (char const   * __attribute__((__nullterm__)) )"usb_audio");
//#line  1111
  return (tmp);
}
}
//#line  1113
extern void usb_deregister(struct usb_driver * ) ;
//#line  1483
extern struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
//#line  1484
extern void usb_free_urb(struct urb *urb ) ;
//#line  1487
extern int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
//#line  1488
extern int usb_unlink_urb(struct urb *urb ) ;
//#line  1528
extern void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                              dma_addr_t *dma ) ;
//#line  1530
extern void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) ;
//#line  1553
extern int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index , void *data ,
                           __u16 size , int timeout ) ;
//#line  1563
extern int usb_get_descriptor(struct usb_device *dev , unsigned char desctype , unsigned char descindex ,
                              void *buf , int size ) ;
//#line  1569
extern int usb_string(struct usb_device *dev , int index , char * __attribute__((__exp__(Nonstub_get_size("size")))) buf ,
                      size_t size ) ;
//#line  1575
extern int usb_reset_configuration(struct usb_device *dev ) ;
//#line  1576
extern int usb_set_interface(struct usb_device *dev , int ifnum , int alternate ) ;
//#line  1689 "include/linux/usb.h"
__inline static unsigned int ( __attribute__((__always_inline__)) __create_pipe)(struct usb_device *dev ,
                                                                                 unsigned int endpoint ) 
{ 


  {
//#line  1692
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
//#line  177 "include/sound/core.h"
__inline static void ( __attribute__((__always_inline__)) snd_power_change_state)(struct snd_card *card ,
                                                                                  unsigned int state ) 
{ 


  {
//#line  179
  card->power_state = state;
//#line  180
  __wake_up(& card->power_sleep, 3U, 1, (void *)0);
//#line  181
  return;
}
}
//#line  299
extern struct snd_card *snd_card_new(int idx , char const   * __attribute__((__nullterm__)) id ,
                                     struct module *module , int extra_size ) ;
//#line  301
extern int snd_card_disconnect(struct snd_card *card ) ;
//#line  302
extern int snd_card_free(struct snd_card *card ) ;
//#line  303
extern int snd_card_free_when_closed(struct snd_card *card ) ;
//#line  304
extern int snd_card_register(struct snd_card *card ) ;
//#line  307
extern int snd_component_add(struct snd_card *card , char const   * __attribute__((__nullterm__)) component ) ;
//#line  317
extern int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                          struct snd_device_ops *ops ) ;
//#line  412 "include/sound/core.h"
__inline static int ( __attribute__((__always_inline__)) __snd_bug_on)(int cond ) 
{ 


  {
//#line  414
  return (0);
}
}
//#line  113 "include/sound/info.h"
extern int ( /* format attribute */  snd_iprintf)(struct snd_info_buffer *buffer ,
                                                  char *fmt  , ...) ;
//#line  138
extern int snd_card_proc_new(struct snd_card *card , char const   * __attribute__((__nullterm__)) name ,
                             struct snd_info_entry **entryp ) ;
//#line  141 "include/sound/info.h"
__inline static void ( __attribute__((__always_inline__)) snd_info_set_text_ops)(struct snd_info_entry *entry ,
                                                                                 void *private_data ,
                                                                                 void (*read)(struct snd_info_entry * ,
                                                                                              struct snd_info_buffer * ) ) 
{ 


  {
//#line  145
  entry->private_data = (void * __attribute__((__noderef__)) )private_data;
//#line  146
  entry->c.text.read = read;
//#line  147
  return;
}
}
//#line  454 "include/sound/pcm.h"
extern int snd_pcm_new(struct snd_card *card , char * __attribute__((__nullterm__)) id ,
                       int device , int playback_count , int capture_count , struct snd_pcm **rpcm ) ;
//#line  457
extern int snd_pcm_new_stream(struct snd_pcm *pcm , int stream , int substream_count ) ;
//#line  473
extern int snd_pcm_stop(struct snd_pcm_substream *substream , int status ) ;
//#line  477
extern int snd_pcm_suspend_all(struct snd_pcm *pcm ) ;
//#line  623 "include/sound/pcm.h"
__inline static snd_pcm_sframes_t ( __attribute__((__always_inline__)) bytes_to_frames)(struct snd_pcm_runtime *runtime ,
                                                                                        ssize_t size ) 
{ 


  {
//#line  625
  return ((size * 8L) / (ssize_t )runtime->frame_bits);
}
}
//#line  781 "include/sound/pcm.h"
__inline static struct snd_mask *( __attribute__((__always_inline__)) hw_param_mask)(struct snd_pcm_hw_params *params ,
                                                                                     snd_pcm_hw_param_t var ) 
{ 


  {
//#line  784
  return (& params->masks[var]);
}
}
//#line  787 "include/sound/pcm.h"
__inline static struct snd_interval *( __attribute__((__always_inline__)) hw_param_interval)(struct snd_pcm_hw_params *params ,
                                                                                             snd_pcm_hw_param_t var ) 
{ 


  {
//#line  790
  return (& params->intervals[var - 8]);
}
}
//#line  842
extern int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime , snd_pcm_hw_param_t var ,
                                        unsigned int min , unsigned int max ) ;
//#line  845
extern int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                      snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_list *l ) ;
//#line  895
extern int snd_pcm_format_physical_width(snd_pcm_format_t format ) ;
//#line  901
extern void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) ;
//#line  904
extern int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd ,
                             void *arg ) ;
//#line  912
extern void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) ;
//#line  926
extern unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate ) ;
//#line  88 "include/sound/pcm_params.h"
__inline static unsigned int ( __attribute__((__always_inline__)) snd_mask_min)(struct snd_mask  const  *mask ) 
{ 
  int i ;
  int tmp ;

  {
//#line  91
  i = 0;
//#line  91
  while (i < 2) {
//#line  92
    if (mask->bits[i]) {
//#line  93
      tmp = ffs((int )mask->bits[i]);
//#line  93
      return ((unsigned int )((tmp - 1) + (i << 5)));
    }
//#line  91
    i ++;
  }
//#line  95
  return (0U);
}
}
//#line  162 "include/sound/pcm_params.h"
__inline static int ( __attribute__((__always_inline__)) snd_mask_test)(struct snd_mask  const  *mask ,
                                                                        unsigned int val ) 
{ 


  {
//#line  164
  return ((int )(mask->bits[val >> 5] & (1U << (val & 31U))));
}
}
//#line  259 "include/sound/pcm_params.h"
__inline static int ( __attribute__((__always_inline__)) snd_interval_checkempty)(struct snd_interval  const  *i ) 
{ 
  int tmp ;

  {
//#line  261
  if (i->min > i->max) {
//#line  261
    tmp = 1;
  } else
//#line  261
  if (i->min == i->max) {
//#line  261
    if (i->openmin) {
//#line  261
      tmp = 1;
    } else
//#line  261
    if (i->openmax) {
//#line  261
      tmp = 1;
    } else {
//#line  261
      tmp = 0;
    }
  } else {
//#line  261
    tmp = 0;
  }
//#line  261
  return (tmp);
}
}
//#line  217 "/scratch/sym/ipc_drivers/usb-audio/usbaudio.h"
unsigned int snd_usb_combine_bytes(unsigned char *bytes , int size ) ;
//#line  219
void *snd_usb_find_desc(void *descstart , int desclen , void *after , u8 dtype ) ;
//#line  220
void *snd_usb_find_csint_desc(void *buffer , int buflen , void *after , u8 dsubtype ) ;
//#line  222
int snd_usb_ctl_msg(struct usb_device *dev , unsigned int pipe , __u8 request , __u8 requesttype ,
                    __u16 value , __u16 index___0 , void *data , __u16 size , int timeout ) ;
//#line  226
int snd_usb_create_mixer(struct snd_usb_audio *chip , int ctrlif , int ignore_error ) ;
//#line  228
void snd_usb_mixer_disconnect(struct list_head *p ) ;
//#line  230
int snd_usb_create_midi_interface(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  234
void snd_usbmidi_disconnect(struct list_head *p ) ;
//#line  64 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
unsigned long Nonstub_get_size(unsigned long size ) 
{ 


  {
//#line  65
  return (size);
}
}
//#line  68 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
unsigned long Nonstub_usb_host_interface(struct usb_interface_descriptor desc ) 
{ 


  {
//#line  70
  return ((unsigned long )desc.bNumEndpoints);
}
}
//#line  74 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_author74[36]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  74
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'T', 
        (char const   )'a',      (char const   )'k',      (char const   )'a',      (char const   )'s', 
        (char const   )'h',      (char const   )'i',      (char const   )' ',      (char const   )'I', 
        (char const   )'w',      (char const   )'a',      (char const   )'i',      (char const   )' ', 
        (char const   )'<',      (char const   )'t',      (char const   )'i',      (char const   )'w', 
        (char const   )'a',      (char const   )'i',      (char const   )'@',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'.', 
        (char const   )'d',      (char const   )'e',      (char const   )'>',      (char const   )'\000'};
//#line  75 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_description75[22]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  75
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'A',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )'\000'};
//#line  76 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_license76[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  76
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
//#line  80 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int index[32]  = 
//#line  80
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
//#line  81 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char *id[32]  = 
//#line  81
  {      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0)};
//#line  82 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int enable[32]  = 
//#line  82
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
//#line  84 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int vid[32]  = 
//#line  84
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
//#line  85 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int pid[32]  = 
//#line  85
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
//#line  86 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int nrpacks  =    8;
//#line  87 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int async_unlink  =    1;
//#line  88 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int device_setup[32]  ;
//#line  89 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int ignore_ctl_error  ;
//#line  91 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_index  =    {(unsigned int )(sizeof(index) / sizeof(index[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(index[0]),
    (void *)(index)};
//#line  91 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_index[6]  = {      (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000'};
//#line  91 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_index  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_index, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_index}};
//#line  91 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_indextype91[28]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  91
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
//#line  92 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_index92[50]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  92
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'I', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )'\000'};
//#line  93 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_id  =    {(unsigned int )(sizeof(id) / sizeof(id[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_charp, & param_get_charp, (unsigned int )sizeof(id[0]), (void *)(id)};
//#line  93 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_id[3]  = {      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  93 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_id  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_id, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_id}};
//#line  93 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_idtype93[27]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  93
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'p',      (char const   )'\000'};
//#line  94 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_id94[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  94
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'U',      (char const   )'S', 
        (char const   )'B',      (char const   )' ',      (char const   )'a',      (char const   )'u', 
        (char const   )'d',      (char const   )'i',      (char const   )'o',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'.', 
        (char const   )'\000'};
//#line  95 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_enable  =    {(unsigned int )(sizeof(enable) / sizeof(enable[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_bool, & param_get_bool, (unsigned int )sizeof(enable[0]),
    (void *)(enable)};
//#line  95 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_enable[7]  = {      (char const   )'e',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
//#line  95 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_enable  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_enable}};
//#line  95 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_enabletype95[30]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  95
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
//#line  96 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_enable96[38]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  96
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'E',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )'\000'};
//#line  97 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_vid  =    {(unsigned int )(sizeof(vid) / sizeof(vid[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_int, & param_get_int, (unsigned int )sizeof(vid[0]), (void *)(vid)};
//#line  97 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_vid[4]  = {      (char const   )'v',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  97 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_vid  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_vid, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_vid}};
//#line  97 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_vidtype97[26]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  97
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'v',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
//#line  98 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_vid98[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  98
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'v',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'V',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'.', 
        (char const   )'\000'};
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_pid  =    {(unsigned int )(sizeof(pid) / sizeof(pid[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_int, & param_get_int, (unsigned int )sizeof(pid[0]), (void *)(pid)};
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_pid[4]  = {      (char const   )'p',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_pid  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_pid, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_pid}};
//#line  99 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_pidtype99[26]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  99
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'p',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
//#line  100 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_pid100[46]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  100
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'p',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'P',      (char const   )'r',      (char const   )'o', 
        (char const   )'d',      (char const   )'u',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'I',      (char const   )'D',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'a',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'.',      (char const   )'\000'};
//#line  101 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_nrpacks[8]  = 
//#line  101
  {      (char const   )'n',      (char const   )'r',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'\000'};
//#line  101 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_nrpacks  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_nrpacks, 420U, & param_set_int, & param_get_int, {(void *)(& nrpacks)}};
//#line  101 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_nrpackstype101[21]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  101
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'n',      (char const   )'r',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'s', 
        (char const   )':',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
//#line  102 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_nrpacks102[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  102
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'n',      (char const   )'r',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'s', 
        (char const   )':',      (char const   )'M',      (char const   )'a',      (char const   )'x', 
        (char const   )'.',      (char const   )' ',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'b',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'e',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'U',      (char const   )'R',      (char const   )'B',      (char const   )'.', 
        (char const   )'\000'};
//#line  103 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_async_unlink[13]  = 
//#line  103
  {      (char const   )'a',      (char const   )'s',      (char const   )'y',      (char const   )'n', 
        (char const   )'c',      (char const   )'_',      (char const   )'u',      (char const   )'n', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'\000'};
//#line  103 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_async_unlink  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_async_unlink, 292U, & param_set_bool, & param_get_bool, {(void *)(& async_unlink)}};
//#line  103 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_async_unlinktype103[27]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  103
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'k',      (char const   )':',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'\000'};
//#line  104 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_async_unlink104[41]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  104
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'k',      (char const   )':',      (char const   )'U',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )' ', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'.', 
        (char const   )'\000'};
//#line  105 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kparam_array  const  __param_arr_device_setup  =    {(unsigned int )(sizeof(device_setup) / sizeof(device_setup[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(device_setup[0]),
    (void *)(device_setup)};
//#line  105 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_device_setup[13]  = 
//#line  105
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'u',      (char const   )'p', 
        (char const   )'\000'};
//#line  105 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_device_setup  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_device_setup, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_device_setup}};
//#line  105 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_device_setuptype105[35]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  105
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'u', 
        (char const   )'p',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
//#line  106 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_device_setup106[53]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  106
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'u', 
        (char const   )'p',      (char const   )':',      (char const   )'S',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'u',      (char const   )'p',      (char const   )' ', 
        (char const   )'(',      (char const   )'i',      (char const   )'f',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'e',      (char const   )'d', 
        (char const   )'e',      (char const   )'d',      (char const   )')',      (char const   )'.', 
        (char const   )'\000'};
//#line  107 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __param_str_ignore_ctl_error[17]  = 
//#line  107
  {      (char const   )'i',      (char const   )'g',      (char const   )'n',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'_',      (char const   )'c', 
        (char const   )'t',      (char const   )'l',      (char const   )'_',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )'\000'};
//#line  107 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct kernel_param  const  __param_ignore_ctl_error  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_ignore_ctl_error, 292U, & param_set_bool, & param_get_bool, {(void *)(& ignore_ctl_error)}};
//#line  107 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_ignore_ctl_errortype107[31]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  107
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'c',      (char const   )'t',      (char const   )'l',      (char const   )'_', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'\000'};
//#line  108 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   __mod_ignore_ctl_error109[78]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  108
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'c',      (char const   )'t',      (char const   )'l',      (char const   )'_', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'I',      (char const   )'g', 
        (char const   )'n',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'e',      (char const   )'r',      (char const   )'r', 
        (char const   )'o',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )' ',      (char const   )'U',      (char const   )'S',      (char const   )'B', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'r',      (char const   )'o',      (char const   )'l', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'i',      (char const   )'x',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'f', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'.',      (char const   )'\000'};
//#line  233
void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) ;
//#line  235
void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  237 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_122l_ops  =    {& snd_usbmidi_us122l_input, & snd_usbmidi_us122l_output, (void (*)(struct urb * ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  242
void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) ;
//#line  244
void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  245
void snd_usbmidi_output_standard_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                        uint8_t p2 , uint8_t p3 ) ;
//#line  248 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_standard_ops  =    {& snd_usbmidi_standard_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_standard_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  254
void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                               int buffer_length ) ;
//#line  256
void snd_usbmidi_output_midiman_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                       uint8_t p2 , uint8_t p3 ) ;
//#line  259 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_midiman_ops  =    {& snd_usbmidi_midiman_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_midiman_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  265
void snd_usbmidi_maudio_broken_running_status_input(struct snd_usb_midi_in_endpoint *ep ,
                                                    uint8_t *buffer , int buffer_length ) ;
//#line  269 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops  =    {& snd_usbmidi_maudio_broken_running_status_input, & snd_usbmidi_standard_output,
    & snd_usbmidi_output_standard_packet, (void (*)(struct snd_usb_midi_out_endpoint * ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  275
void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) ;
//#line  278 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_cme_ops  =    {& snd_usbmidi_cme_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_standard_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  284
void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) ;
//#line  286
void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  287
void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  288
void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  289 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_emagic_ops  =    {& snd_usbmidi_emagic_input, & snd_usbmidi_emagic_output, (void (*)(struct urb * ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ))0,
    & snd_usbmidi_emagic_init_out, & snd_usbmidi_emagic_finish_out};
//#line  296
void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) ;
//#line  298
void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  300 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_novation_ops  =    {& snd_usbmidi_novation_input, & snd_usbmidi_novation_output, (void (*)(struct urb * ,
                                                                           uint8_t  ,
                                                                           uint8_t  ,
                                                                           uint8_t  ,
                                                                           uint8_t  ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  305
void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) ;
//#line  307
void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  308 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_protocol_ops snd_usbmidi_raw_ops  =    {& snd_usbmidi_raw_input, & snd_usbmidi_raw_output, (void (*)(struct urb * , uint8_t  ,
                                                                 uint8_t  , uint8_t  ,
                                                                 uint8_t  ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  314
static int ignore_interface_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  317
static int create_composite_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  320
static int create_standard_audio_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                       struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  323
static int create_fixed_stream_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                     struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  326
static int create_ua1000_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                               struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  329
static int create_ua101_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                              struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  332
static int create_uaxx_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                             struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  337 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static quirk_func_t const   quirk_funcs[16]  = 
//#line  337
  {      (quirk_func_t const   )(& ignore_interface_quirk),      (quirk_func_t const   )(& create_composite_quirk),      (quirk_func_t const   )(& snd_usb_create_midi_interface),      (quirk_func_t const   )(& snd_usb_create_midi_interface), 
        (quirk_func_t const   )(& snd_usb_create_midi_interface),      (quirk_func_t const   )(& snd_usb_create_midi_interface),      (quirk_func_t const   )(& snd_usb_create_midi_interface),      (quirk_func_t const   )(& snd_usb_create_midi_interface), 
        (quirk_func_t const   )(& snd_usb_create_midi_interface),      (quirk_func_t const   )(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * , struct usb_interface * , struct snd_usb_audio_quirk  const  * ))0,      (quirk_func_t const   )(& create_standard_audio_quirk), 
        (quirk_func_t const   )(& create_fixed_stream_quirk),      (quirk_func_t const   )(& create_ua1000_quirk),      (quirk_func_t const   )(& create_ua101_quirk),      (quirk_func_t const   )(& create_uaxx_quirk)};
//#line  363 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct mutex register_mutex  =    {{(int volatile   )1}, {{0U}, 3735899821U, 4294967295U, (void *)-1L, {(struct lock_class_key *)0,
                                                                         (struct lock_class *)0,
                                                                         "register_mutex.wait_lock"}},
    {(struct list_head * __attribute__((__recursive__)) )(& register_mutex.wait_list),
     (struct list_head * __attribute__((__recursive__)) )(& register_mutex.wait_list)},
    (struct thread_info *)0, (char const   *)0, (void *)(& register_mutex), {(struct lock_class_key *)0,
                                                                             (struct lock_class *)0,
                                                                             "register_mutex"}};
//#line  364 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) usb_chip[32]  ;
//#line  371 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
__inline static unsigned int ( __attribute__((__always_inline__)) get_usb_full_speed_rate)(unsigned int rate ) 
{ 


  {
//#line  373
  return (((rate << 13) + 62U) / 125U);
}
}
//#line  380 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
__inline static unsigned int ( __attribute__((__always_inline__)) get_usb_high_speed_rate)(unsigned int rate ) 
{ 


  {
//#line  382
  return (((rate << 10) + 62U) / 125U);
}
}
//#line  404 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_capture_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                    struct urb *urb ) 
{ 
  unsigned char *cp ;
  struct snd_urb_ctx *ctx ;

  {
//#line  408
  cp = urb->transfer_buffer;
//#line  409
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  411
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  412
  urb->iso_frame_desc[0].length = 3U;
//#line  413
  urb->iso_frame_desc[0].offset = 0U;
//#line  414
  *(cp + 0) = (unsigned char )(subs->freqn >> 2);
//#line  415
  *(cp + 1) = (unsigned char )(subs->freqn >> 10);
//#line  416
  *(cp + 2) = (unsigned char )(subs->freqn >> 18);
//#line  417
  return (0);
}
}
//#line  426 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_capture_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned char *cp ;
  struct snd_urb_ctx *ctx ;

  {
//#line  430
  cp = urb->transfer_buffer;
//#line  431
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  433
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  434
  urb->iso_frame_desc[0].length = 4U;
//#line  435
  urb->iso_frame_desc[0].offset = 0U;
//#line  436
  *(cp + 0) = (unsigned char )subs->freqn;
//#line  437
  *(cp + 1) = (unsigned char )(subs->freqn >> 8);
//#line  438
  *(cp + 2) = (unsigned char )(subs->freqn >> 16);
//#line  439
  *(cp + 3) = (unsigned char )(subs->freqn >> 24);
//#line  440
  return (0);
}
}
//#line  447 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_capture_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                   struct urb *urb ) 
{ 


  {
//#line  451
  return (0);
}
}
//#line  464 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                               struct urb *urb ) 
{ 
  int i ;
  int offs ;
  struct snd_urb_ctx *ctx ;

  {
//#line  469
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  471
  offs = 0;
//#line  472
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  473
  i = 0;
//#line  473
  while (i < ctx->packets) {
//#line  474
    urb->iso_frame_desc[i].offset = (unsigned int )offs;
//#line  475
    urb->iso_frame_desc[i].length = subs->curpacksize;
//#line  476
    offs = (int )((unsigned int )offs + subs->curpacksize);
//#line  473
    i ++;
  }
//#line  478
  urb->transfer_buffer_length = offs;
//#line  479
  urb->number_of_packets = ctx->packets;
//#line  480
  return (0);
}
}
//#line  489 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                              struct urb *urb ) 
{ 
  unsigned long flags ;
  unsigned char *cp ;
  int i ;
  unsigned int stride ;
  unsigned int len ;
  unsigned int oldptr ;
  int period_elapsed ;
  unsigned int cnt ;
  unsigned int blen ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
//#line  497
  period_elapsed = 0;
//#line  499
  stride = runtime->frame_bits >> 3;
//#line  501
  i = 0;
//#line  501
  while (i < urb->number_of_packets) {
//#line  502
    cp = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
//#line  503
    if (urb->iso_frame_desc[i].status) {
//#line  504
      printk("<3>frame %d active: %d\n", i, urb->iso_frame_desc[i].status);
    }
//#line  507
    len = urb->iso_frame_desc[i].actual_length / stride;
//#line  508
    if (! len) {
//#line  509
      goto __Cont;
    }
//#line  511
    while (1) {
//#line  511
      flags = _spin_lock_irqsave(& subs->lock);
//#line  511
      break;
    }
//#line  512
    oldptr = subs->hwptr_done;
//#line  513
    subs->hwptr_done += len;
//#line  514
    if ((snd_pcm_uframes_t )subs->hwptr_done >= runtime->buffer_size) {
//#line  515
      subs->hwptr_done = (unsigned int )((snd_pcm_uframes_t )subs->hwptr_done - runtime->buffer_size);
    }
//#line  516
    subs->transfer_done += len;
//#line  517
    if ((snd_pcm_uframes_t )subs->transfer_done >= runtime->period_size) {
//#line  518
      subs->transfer_done = (unsigned int )((snd_pcm_uframes_t )subs->transfer_done - runtime->period_size);
//#line  519
      period_elapsed = 1;
    }
//#line  521
    while (1) {
//#line  521
      _spin_unlock_irqrestore(& subs->lock, flags);
//#line  521
      break;
    }
//#line  523
    if ((snd_pcm_uframes_t )(oldptr + len) > runtime->buffer_size) {
//#line  524
      cnt = (unsigned int )(runtime->buffer_size - (snd_pcm_uframes_t )oldptr);
//#line  525
      blen = cnt * stride;
//#line  526
      __len = (size_t )blen;
//#line  526
      __ret = __builtin_memcpy((void *)(runtime->dma_area + oldptr * stride), (void const   *)cp,
                               __len);
//#line  527
      __len___0 = (size_t )(len * stride - blen);
//#line  527
      __ret___0 = __builtin_memcpy((void *)runtime->dma_area, (void const   *)(cp + blen),
                                   __len___0);
    } else {
//#line  529
      __len___1 = (size_t )(len * stride);
//#line  529
      __ret___1 = __builtin_memcpy((void *)(runtime->dma_area + oldptr * stride),
                                   (void const   *)cp, __len___1);
    }
    __Cont: /* CIL Label */ 
//#line  501
    i ++;
  }
//#line  532
  if (period_elapsed) {
//#line  533
    snd_pcm_period_elapsed((struct snd_pcm_substream *)subs->pcm_substream);
  }
//#line  534
  return (0);
}
}
//#line  540 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_paused_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                     struct urb *urb ) 
{ 


  {
//#line  544
  return (0);
}
}
//#line  554 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_playback_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                     struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;

  {
//#line  558
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  560
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  561
  urb->iso_frame_desc[0].length = 3U;
//#line  562
  urb->iso_frame_desc[0].offset = 0U;
//#line  563
  return (0);
}
}
//#line  572 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_playback_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                        struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;

  {
//#line  576
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  578
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  579
  urb->iso_frame_desc[0].length = 4U;
//#line  580
  urb->iso_frame_desc[0].offset = 0U;
//#line  581
  return (0);
}
}
//#line  590 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_playback_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                    struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
//#line  597
  if (urb->iso_frame_desc[0].status == 0) {
//#line  597
    if (urb->iso_frame_desc[0].actual_length == 3U) {
//#line  599
      f = (((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) << 2;
//#line  600
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  600
        if (f <= subs->freqmax) {
//#line  601
          while (1) {
//#line  601
            flags = _spin_lock_irqsave(& subs->lock);
//#line  601
            break;
          }
//#line  602
          subs->freqm = f;
//#line  603
          while (1) {
//#line  603
            _spin_unlock_irqrestore(& subs->lock, flags);
//#line  603
            break;
          }
        }
      }
    }
  }
//#line  607
  return (0);
}
}
//#line  616 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_playback_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
//#line  623
  if (urb->iso_frame_desc[0].status == 0) {
//#line  623
    if (urb->iso_frame_desc[0].actual_length == 4U) {
//#line  625
      f = ((((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) | ((unsigned int )*(urb->transfer_buffer + 3) << 24)) & 268435455U;
//#line  626
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  626
        if (f <= subs->freqmax) {
//#line  627
          while (1) {
//#line  627
            flags = _spin_lock_irqsave(& subs->lock);
//#line  627
            break;
          }
//#line  628
          subs->freqm = f;
//#line  629
          while (1) {
//#line  629
            _spin_unlock_irqrestore(& subs->lock, flags);
//#line  629
            break;
          }
        }
      }
    }
  }
//#line  633
  return (0);
}
}
//#line  642 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_playback_sync_urb_hs_emu(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                           struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
//#line  649
  if (urb->iso_frame_desc[0].status == 0) {
//#line  649
    if (urb->iso_frame_desc[0].actual_length == 4U) {
//#line  651
      f = ((((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) | ((unsigned int )*(urb->transfer_buffer + 3) << 24)) & 268435455U;
//#line  652
      f >>= subs->datainterval;
//#line  653
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  653
        if (f <= subs->freqmax) {
//#line  654
          while (1) {
//#line  654
            flags = _spin_lock_irqsave(& subs->lock);
//#line  654
            break;
          }
//#line  655
          subs->freqm = f;
//#line  656
          while (1) {
//#line  656
            _spin_unlock_irqrestore(& subs->lock, flags);
//#line  656
            break;
          }
        }
      }
    }
  }
//#line  660
  return (0);
}
}
//#line  664 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audio_next_packet_size(struct snd_usb_substream *subs ) 
{ 
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp ;

  {
//#line  666
  if (subs->fill_max) {
//#line  667
    return ((int )subs->maxframesize);
  } else {
//#line  669
    subs->phase = (subs->phase & 65535U) + (subs->freqm << subs->datainterval);
//#line  671
    _min1 = subs->phase >> 16;
//#line  671
    _min2 = subs->maxframesize;
//#line  671
    if (_min1 < _min2) {
//#line  671
      tmp = _min1;
    } else {
//#line  671
      tmp = _min2;
    }
//#line  671
    return ((int )tmp);
  }
}
}
//#line  680 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_nodata_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned int i ;
  unsigned int offs ;
  unsigned int counts ;
  struct snd_urb_ctx *ctx ;
  int stride ;
  int tmp ;
  int tmp___0 ;

  {
//#line  685
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  686
  stride = (int )(runtime->frame_bits >> 3);
//#line  688
  offs = 0U;
//#line  689
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  690
  urb->number_of_packets = (int )subs->packs_per_ms;
//#line  691
  i = 0U;
//#line  691
  while (i < subs->packs_per_ms) {
//#line  692
    tmp = snd_usb_audio_next_packet_size(subs);
//#line  692
    counts = (unsigned int )tmp;
//#line  693
    urb->iso_frame_desc[i].offset = offs * (unsigned int )stride;
//#line  694
    urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  695
    offs += counts;
//#line  691
    i ++;
  }
//#line  697
  urb->transfer_buffer_length = (int )(offs * (unsigned int )stride);
//#line  698
  if ((subs->cur_audiofmt)->format == 1) {
//#line  698
    tmp___0 = 128;
  } else {
//#line  698
    tmp___0 = 0;
  }
//#line  698
  memset((void *)urb->transfer_buffer, tmp___0, (size_t )(offs * (unsigned int )stride));
//#line  701
  return (0);
}
}
//#line  712 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int prepare_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                struct urb *urb ) 
{ 
  int i ;
  int stride ;
  int offs ;
  unsigned int counts ;
  unsigned long flags ;
  int period_elapsed ;
  struct snd_urb_ctx *ctx ;
  int tmp ;
  unsigned int len ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
//#line  719
  period_elapsed = 0;
//#line  720
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  722
  stride = (int )(runtime->frame_bits >> 3);
//#line  724
  offs = 0;
//#line  725
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )(ctx->subs)->dev;
//#line  726
  urb->number_of_packets = 0;
//#line  727
  while (1) {
//#line  727
    flags = _spin_lock_irqsave(& subs->lock);
//#line  727
    break;
  }
//#line  728
  i = 0;
//#line  728
  while (i < ctx->packets) {
//#line  729
    tmp = snd_usb_audio_next_packet_size(subs);
//#line  729
    counts = (unsigned int )tmp;
//#line  731
    urb->iso_frame_desc[i].offset = (unsigned int )(offs * stride);
//#line  732
    urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  733
    offs = (int )((unsigned int )offs + counts);
//#line  734
    (urb->number_of_packets) ++;
//#line  735
    subs->transfer_done += counts;
//#line  736
    if ((snd_pcm_uframes_t )subs->transfer_done >= runtime->period_size) {
//#line  737
      subs->transfer_done = (unsigned int )((snd_pcm_uframes_t )subs->transfer_done - runtime->period_size);
//#line  738
      period_elapsed = 1;
//#line  739
      if (subs->fmt_type == 2U) {
//#line  740
        if (subs->transfer_done > 0U) {
//#line  743
          offs = (int )((unsigned int )offs - subs->transfer_done);
//#line  744
          counts -= subs->transfer_done;
//#line  745
          urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  747
          subs->transfer_done = 0U;
        }
//#line  749
        i ++;
//#line  750
        if (i < ctx->packets) {
//#line  752
          urb->iso_frame_desc[i].offset = (unsigned int )(offs * stride);
//#line  754
          urb->iso_frame_desc[i].length = 0U;
//#line  755
          (urb->number_of_packets) ++;
        }
//#line  757
        break;
      }
    }
//#line  761
    if (period_elapsed) {
//#line  761
      if (((unsigned int )i & (subs->packs_per_ms - 1U)) == subs->packs_per_ms - 1U) {
//#line  763
        break;
      }
    }
//#line  728
    i ++;
  }
//#line  765
  if ((snd_pcm_uframes_t )(subs->hwptr_done + (unsigned int )offs) > runtime->buffer_size) {
//#line  767
    len = (unsigned int )(runtime->buffer_size - (snd_pcm_uframes_t )subs->hwptr_done);
//#line  768
    __len = (size_t )(len * (unsigned int )stride);
//#line  768
    __ret = __builtin_memcpy((void *)urb->transfer_buffer, (void const   *)(runtime->dma_area + subs->hwptr_done * (unsigned int )stride),
                             __len);
//#line  771
    __len___0 = (size_t )(((unsigned int )offs - len) * (unsigned int )stride);
//#line  771
    __ret___0 = __builtin_memcpy((void *)(urb->transfer_buffer + len * (unsigned int )stride),
                                 (void const   *)runtime->dma_area, __len___0);
  } else {
//#line  775
    __len___1 = (size_t )(offs * stride);
//#line  775
    __ret___1 = __builtin_memcpy((void *)urb->transfer_buffer, (void const   *)(runtime->dma_area + subs->hwptr_done * (unsigned int )stride),
                                 __len___1);
  }
//#line  779
  subs->hwptr_done += (unsigned int )offs;
//#line  780
  if ((snd_pcm_uframes_t )subs->hwptr_done >= runtime->buffer_size) {
//#line  781
    subs->hwptr_done = (unsigned int )((snd_pcm_uframes_t )subs->hwptr_done - runtime->buffer_size);
  }
//#line  782
  while (1) {
//#line  782
    _spin_unlock_irqrestore(& subs->lock, flags);
//#line  782
    break;
  }
//#line  783
  urb->transfer_buffer_length = offs * stride;
//#line  784
  if (period_elapsed) {
//#line  785
    snd_pcm_period_elapsed((struct snd_pcm_substream *)subs->pcm_substream);
  }
//#line  786
  return (0);
}
}
//#line  793 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int retire_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                               struct urb *urb ) 
{ 


  {
//#line  797
  return (0);
}
}
//#line  803 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_urb_ops ( __attribute__((__noderef__, __address_space__(2))) audio_urb_ops)[2]  = {      {& prepare_nodata_playback_urb,
      & retire_playback_urb, & prepare_playback_sync_urb, & retire_playback_sync_urb}, 
        {& prepare_capture_urb,
      & retire_capture_urb, & prepare_capture_sync_urb, & retire_capture_sync_urb}};
//#line  818 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_urb_ops ( __attribute__((__noderef__, __address_space__(2))) audio_urb_ops_high_speed)[2]  = {      {& prepare_nodata_playback_urb,
      & retire_playback_urb, & prepare_playback_sync_urb_hs, & retire_playback_sync_urb_hs}, 
        {& prepare_capture_urb,
      & retire_capture_urb, & prepare_capture_sync_urb_hs, & retire_capture_sync_urb}};
//#line  836 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_complete_urb(struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;
  struct snd_usb_substream *subs ;
  struct snd_pcm_substream *substream ;
  int err ;
  int tmp ;

  {
//#line  838
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  839
  subs = ctx->subs;
//#line  840
  substream = (struct snd_pcm_substream *)(ctx->subs)->pcm_substream;
//#line  841
  err = 0;
//#line  843
  if (subs->running) {
//#line  843
    tmp = (*(subs->ops.retire))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                urb);
//#line  843
    if (tmp) {
//#line  843
      goto _L;
    } else {
//#line  843
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
//#line  843
  if (! subs->running) {
//#line  843
    goto _L;
  } else {
//#line  843
    err = (*(subs->ops.prepare))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                 urb);
//#line  843
    if (err < 0) {
//#line  843
      goto _L;
    } else {
//#line  843
      err = usb_submit_urb(urb, 32U);
//#line  843
      if (err < 0) {
        _L: /* CIL Label */ 
//#line  847
        clear_bit(ctx->index, (unsigned long volatile   *)(& subs->active_mask));
//#line  848
        if (err < 0) {
//#line  849
          printk("<3>cannot submit urb (err = %d)\n", err);
//#line  850
          snd_pcm_stop(substream, 4);
        }
      }
    }
  }
//#line  853
  return;
}
}
//#line  859 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_complete_sync_urb(struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;
  struct snd_usb_substream *subs ;
  struct snd_pcm_substream *substream ;
  int err ;
  int tmp ;

  {
//#line  861
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  862
  subs = ctx->subs;
//#line  863
  substream = (struct snd_pcm_substream *)(ctx->subs)->pcm_substream;
//#line  864
  err = 0;
//#line  866
  if (subs->running) {
//#line  866
    tmp = (*(subs->ops.retire_sync))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                     urb);
//#line  866
    if (tmp) {
//#line  866
      goto _L;
    } else {
//#line  866
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
//#line  866
  if (! subs->running) {
//#line  866
    goto _L;
  } else {
//#line  866
    err = (*(subs->ops.prepare_sync))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                      urb);
//#line  866
    if (err < 0) {
//#line  866
      goto _L;
    } else {
//#line  866
      err = usb_submit_urb(urb, 32U);
//#line  866
      if (err < 0) {
        _L: /* CIL Label */ 
//#line  870
        clear_bit(ctx->index + 16, (unsigned long volatile   *)(& subs->active_mask));
//#line  871
        if (err < 0) {
//#line  872
          printk("<3>cannot submit sync urb (err = %d)\n", err);
//#line  873
          snd_pcm_stop(substream, 4);
        }
      }
    }
  }
//#line  876
  return;
}
}
//#line  880 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs , unsigned long offset ) 
{ 
  void *pageptr ;
  unsigned long tmp ;

  {
//#line  883
  pageptr = (void *)((subs->runtime)->dma_area + offset);
//#line  885
  tmp = __phys_addr((unsigned long )pageptr);
//#line  885
  return ((struct page *)0xffffe20000000000UL + (tmp >> 12));
}
}
//#line  889 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs , size_t size ) 
{ 
  struct snd_pcm_runtime *runtime ;
  int new_size ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
//#line  891
  runtime = (struct snd_pcm_runtime *)subs->runtime;
//#line  892
  tmp = get_order(size);
//#line  892
  new_size = (1 << tmp) * 4096;
//#line  894
  printk("MJR Added this: Size: %d, new-size: %d\n", size, new_size);
//#line  896
  if (runtime->dma_area) {
//#line  897
    if (runtime->dma_bytes >= (size_t )new_size) {
//#line  898
      return (0);
    }
//#line  900
    free_pages((unsigned long )runtime->dma_area, 4294967295U);
  }
//#line  903
  tmp___0 = get_order(size);
//#line  903
  tmp___1 = __get_free_pages(208U, (unsigned int )tmp___0);
//#line  903
  runtime->dma_area = (unsigned char *)tmp___1;
//#line  904
  if (! runtime->dma_area) {
//#line  905
    return (-12);
  }
//#line  906
  runtime->dma_bytes = (size_t )new_size;
//#line  907
  return (0);
}
}
//#line  911 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs ) 
{ 
  struct snd_pcm_runtime *runtime ;

  {
//#line  913
  runtime = (struct snd_pcm_runtime *)subs->runtime;
//#line  916
  free_pages((unsigned long )runtime->dma_area, 4294967295U);
//#line  917
  runtime->dma_area = (unsigned char *)((void *)0);
//#line  918
  return (0);
}
}
//#line  925 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int deactivate_urbs(struct snd_usb_substream *subs , int force , int can_sleep ) 
{ 
  unsigned int i ;
  struct urb *u ;
  int tmp ;
  int tmp___1 ;
  struct urb *u___0 ;
  int tmp___2 ;
  int tmp___4 ;

  {
//#line  930
  subs->running = 0U;
//#line  932
  if (! force) {
//#line  932
    if (((subs->stream)->chip)->shutdown) {
//#line  933
      return (-77);
    }
  }
//#line  943
  i = 0U;
//#line  943
  while (i < subs->nurbs) {
//#line  944
    tmp___1 = variable_test_bit((int )i, (unsigned long const volatile   *)(& subs->active_mask));
//#line  944
    if (tmp___1) {
//#line  945
      tmp = test_and_set_bit((int )i, (unsigned long volatile   *)(& subs->unlink_mask));
//#line  945
      if (! tmp) {
//#line  946
        u = (struct urb *)subs->dataurb[i].urb;
//#line  948
        usb_unlink_urb(u);
      }
    }
//#line  943
    i ++;
  }
//#line  954
  if (subs->syncpipe) {
//#line  955
    i = 0U;
//#line  955
    while (i < 4U) {
//#line  956
      tmp___4 = variable_test_bit((int )(i + 16U), (unsigned long const volatile   *)(& subs->active_mask));
//#line  956
      if (tmp___4) {
//#line  957
        tmp___2 = test_and_set_bit((int )(i + 16U), (unsigned long volatile   *)(& subs->unlink_mask));
//#line  957
        if (! tmp___2) {
//#line  958
          u___0 = (struct urb *)subs->syncurb[i].urb;
//#line  960
          usb_unlink_urb(u___0);
        }
      }
//#line  955
      i ++;
    }
  }
//#line  967
  return (0);
}
}
//#line  971 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static char const   *usb_error_string(int err ) 
{ 


  {
//#line  973
  switch (err) {
  case -19: 
//#line  975
  return ("no device");
  case -2: 
//#line  977
  return ("endpoint not enabled");
  case -32: 
//#line  979
  return ("endpoint stalled");
  case -28: 
//#line  981
  return ("not enough bandwidth");
  case -108: 
//#line  983
  return ("device disabled");
  case -113: 
//#line  985
  return ("device suspended");
  case -22: 
  case -11: 
  case -27: 
  case -90: 
//#line  990
  return ("internal error");
  default: 
//#line  992
  return ("unknown error");
  }
}
}
//#line  999 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int start_urbs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ) 
{ 
  unsigned int i ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
//#line  1004
  if (((subs->stream)->chip)->shutdown) {
//#line  1005
    return (-77);
  }
//#line  1007
  i = 0U;
//#line  1007
  while (i < subs->nurbs) {
//#line  1008
    tmp = __snd_bug_on(0);
//#line  1008
    if (tmp) {
//#line  1009
      return (-22);
    }
//#line  1010
    tmp___0 = (*(subs->ops.prepare))(subs, runtime, (struct urb *)subs->dataurb[i].urb);
//#line  1010
    if (tmp___0 < 0) {
//#line  1011
      printk("<3>cannot prepare datapipe for urb %d\n", i);
//#line  1012
      goto __error;
    }
//#line  1007
    i ++;
  }
//#line  1015
  if (subs->syncpipe) {
//#line  1016
    i = 0U;
//#line  1016
    while (i < 4U) {
//#line  1017
      tmp___1 = __snd_bug_on(0);
//#line  1017
      if (tmp___1) {
//#line  1018
        return (-22);
      }
//#line  1019
      tmp___2 = (*(subs->ops.prepare_sync))(subs, runtime, (struct urb *)subs->syncurb[i].urb);
//#line  1019
      if (tmp___2 < 0) {
//#line  1020
        printk("<3>cannot prepare syncpipe for urb %d\n", i);
//#line  1021
        goto __error;
      }
//#line  1016
      i ++;
    }
  }
//#line  1026
  subs->active_mask = 0UL;
//#line  1027
  subs->unlink_mask = 0UL;
//#line  1028
  subs->running = 1U;
//#line  1029
  i = 0U;
//#line  1029
  while (i < subs->nurbs) {
//#line  1030
    err = usb_submit_urb((struct urb *)subs->dataurb[i].urb, 32U);
//#line  1031
    if (err < 0) {
//#line  1032
      tmp___3 = usb_error_string(err);
//#line  1032
      printk("<3>cannot submit datapipe for urb %d, error %d: %s\n", i, err, tmp___3);
//#line  1035
      goto __error;
    }
//#line  1037
    set_bit(i, (unsigned long volatile   *)(& subs->active_mask));
//#line  1029
    i ++;
  }
//#line  1039
  if (subs->syncpipe) {
//#line  1040
    i = 0U;
//#line  1040
    while (i < 4U) {
//#line  1041
      err = usb_submit_urb((struct urb *)subs->syncurb[i].urb, 32U);
//#line  1042
      if (err < 0) {
//#line  1043
        tmp___4 = usb_error_string(err);
//#line  1043
        printk("<3>cannot submit syncpipe for urb %d, error %d: %s\n", i, err, tmp___4);
//#line  1046
        goto __error;
      }
//#line  1048
      set_bit(i + 16U, (unsigned long volatile   *)(& subs->active_mask));
//#line  1040
      i ++;
    }
  }
//#line  1051
  return (0);
  __error: 
//#line  1055
  deactivate_urbs(subs, 0, 0);
//#line  1056
  return (-32);
}
}
//#line  1063 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int wait_clear_urbs(struct snd_usb_substream *subs ) 
{ 
  unsigned long end_time ;
  unsigned long tmp ;
  unsigned int i ;
  int alive ;
  int tmp___1 ;
  int tmp___3 ;

  {
//#line  1065
  tmp = msecs_to_jiffies(1000U);
//#line  1065
  end_time = (unsigned long )(jiffies + (unsigned long volatile   )tmp);
//#line  1084
  while (1) {
//#line  1070
    alive = 0;
//#line  1071
    i = 0U;
//#line  1071
    while (i < subs->nurbs) {
//#line  1072
      tmp___1 = variable_test_bit((int )i, (unsigned long const volatile   *)(& subs->active_mask));
//#line  1072
      if (tmp___1) {
//#line  1073
        alive ++;
      }
//#line  1071
      i ++;
    }
//#line  1075
    if (subs->syncpipe) {
//#line  1076
      i = 0U;
//#line  1076
      while (i < 4U) {
//#line  1077
        tmp___3 = variable_test_bit((int )(i + 16U), (unsigned long const volatile   *)(& subs->active_mask));
//#line  1077
        if (tmp___3) {
//#line  1078
          alive ++;
        }
//#line  1076
        i ++;
      }
    }
//#line  1081
    if (! alive) {
//#line  1082
      break;
    }
//#line  1083
    schedule_timeout_uninterruptible(1L);
//#line  1084
    if (! ((long )jiffies - (long )end_time < 0L)) {
//#line  1069
      break;
    }
  }
//#line  1085
  if (alive) {
//#line  1086
    printk("<3>timeout: still %d active urbs..\n", alive);
  }
//#line  1087
  return (0);
}
}
//#line  1094 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static snd_pcm_uframes_t snd_usb_pcm_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_usb_substream *subs ;
  snd_pcm_uframes_t hwptr_done ;

  {
//#line  1099
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  1100
  _spin_lock(& subs->lock);
//#line  1101
  hwptr_done = (snd_pcm_uframes_t )subs->hwptr_done;
//#line  1102
  _spin_unlock(& subs->lock);
//#line  1103
  return (hwptr_done);
}
}
//#line  1110 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_playback_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;

  {
//#line  1113
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  1115
  switch (cmd) {
  case 1: 
  case 4: 
//#line  1118
  subs->ops.prepare = & prepare_playback_urb;
//#line  1119
  return (0);
  case 0: 
//#line  1121
  tmp = deactivate_urbs(subs, 0, 0);
//#line  1121
  return (tmp);
  case 3: 
//#line  1123
  subs->ops.prepare = & prepare_nodata_playback_urb;
//#line  1124
  return (0);
  default: 
//#line  1126
  return (-22);
  }
}
}
//#line  1133 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_capture_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;
  int tmp___0 ;

  {
//#line  1136
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  1138
  switch (cmd) {
  case 1: 
//#line  1140
  subs->ops.retire = & retire_capture_urb;
//#line  1141
  tmp = start_urbs(subs, (struct snd_pcm_runtime *)substream->runtime);
//#line  1141
  return (tmp);
  case 0: 
//#line  1143
  tmp___0 = deactivate_urbs(subs, 0, 0);
//#line  1143
  return (tmp___0);
  case 3: 
//#line  1145
  subs->ops.retire = & retire_paused_capture_urb;
//#line  1146
  return (0);
  case 4: 
//#line  1148
  subs->ops.retire = & retire_capture_urb;
//#line  1149
  return (0);
  default: 
//#line  1151
  return (-22);
  }
}
}
//#line  1159 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void release_urb_ctx(struct snd_urb_ctx *u ) 
{ 


  {
//#line  1161
  if (u->urb) {
//#line  1162
    if (u->buffer_size) {
//#line  1163
      usb_buffer_free((u->subs)->dev, (size_t )u->buffer_size, (void *)(u->urb)->transfer_buffer,
                      (u->urb)->transfer_dma);
    }
//#line  1166
    usb_free_urb((struct urb *)u->urb);
//#line  1167
    u->urb = (struct urb * __attribute__((__recursive__)) )((void *)0);
  }
//#line  1169
  return;
}
}
//#line  1174 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void release_substream_urbs(struct snd_usb_substream *subs , int force ) 
{ 
  int i ;

  {
//#line  1179
  deactivate_urbs(subs, force, 1);
//#line  1180
  wait_clear_urbs(subs);
//#line  1182
  i = 0;
//#line  1182
  while (i < 8) {
//#line  1183
    release_urb_ctx(& subs->dataurb[i]);
//#line  1182
    i ++;
  }
//#line  1184
  i = 0;
//#line  1184
  while (i < 4) {
//#line  1185
    release_urb_ctx(& subs->syncurb[i]);
//#line  1184
    i ++;
  }
//#line  1186
  usb_buffer_free(subs->dev, (size_t )16, (void *)subs->syncbuf, subs->sync_dma);
//#line  1188
  subs->syncbuf = (char * __attribute__((__nullterm__)) )((void *)0);
//#line  1189
  subs->nurbs = 0U;
//#line  1190
  return;
}
}
//#line  1195 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int init_substream_urbs(struct snd_usb_substream *subs , unsigned int period_bytes ,
                               unsigned int rate , unsigned int frame_bits ) 
{ 
  unsigned int maxsize ;
  unsigned int n ;
  unsigned int i ;
  int is_playback ;
  unsigned int npacks[8] ;
  unsigned int urb_packs ;
  unsigned int total_packs ;
  unsigned int packs_per_ms ;
  unsigned int _max1 ;
  unsigned int _max2 ;
  unsigned int tmp ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp___0 ;
  unsigned int minsize ;
  unsigned int _max1___0 ;
  unsigned int _max2___0 ;
  unsigned int tmp___1 ;
  struct snd_urb_ctx *u ;
  struct urb *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct snd_urb_ctx *u___0 ;
  struct urb *tmp___5 ;

  {
//#line  1199
  is_playback = subs->direction == 0;
//#line  1203
  if ((unsigned int )(subs->dev)->speed == 2U) {
//#line  1204
    subs->freqn = get_usb_full_speed_rate(rate);
  } else {
//#line  1206
    subs->freqn = get_usb_high_speed_rate(rate);
  }
//#line  1207
  subs->freqm = subs->freqn;
//#line  1209
  if (subs->maxpacksize) {
//#line  1211
    maxsize = subs->maxpacksize;
//#line  1212
    subs->freqmax = maxsize / (frame_bits >> 3) << (16U - subs->datainterval);
  } else {
//#line  1216
    subs->freqmax = subs->freqn + (subs->freqn >> 2);
//#line  1217
    maxsize = (subs->freqmax + 65535U) * (frame_bits >> 3) >> (16U - subs->datainterval);
  }
//#line  1220
  subs->phase = 0U;
//#line  1222
  if (subs->fill_max) {
//#line  1223
    subs->curpacksize = subs->maxpacksize;
  } else {
//#line  1225
    subs->curpacksize = maxsize;
  }
//#line  1227
  if ((unsigned int )(subs->dev)->speed == 3U) {
//#line  1228
    packs_per_ms = (unsigned int )(8 >> subs->datainterval);
  } else {
//#line  1230
    packs_per_ms = 1U;
  }
//#line  1231
  subs->packs_per_ms = packs_per_ms;
//#line  1233
  if (is_playback) {
//#line  1234
    urb_packs = (unsigned int )nrpacks;
//#line  1235
    _max1 = urb_packs;
//#line  1235
    _max2 = 1U;
//#line  1235
    if (_max1 > _max2) {
//#line  1235
      tmp = _max1;
    } else {
//#line  1235
      tmp = _max2;
    }
//#line  1235
    urb_packs = tmp;
//#line  1236
    _min1 = urb_packs;
//#line  1236
    _min2 = 20U;
//#line  1236
    if (_min1 < _min2) {
//#line  1236
      tmp___0 = _min1;
    } else {
//#line  1236
      tmp___0 = _min2;
    }
//#line  1236
    urb_packs = tmp___0;
  } else {
//#line  1238
    urb_packs = 1U;
  }
//#line  1239
  urb_packs *= packs_per_ms;
//#line  1242
  if (is_playback) {
//#line  1245
    minsize = (subs->freqn >> (16U - subs->datainterval)) * (frame_bits >> 3);
//#line  1248
    if (subs->syncpipe) {
//#line  1249
      minsize -= minsize >> 3;
    }
//#line  1250
    _max1___0 = minsize;
//#line  1250
    _max2___0 = 1U;
//#line  1250
    if (_max1___0 > _max2___0) {
//#line  1250
      tmp___1 = _max1___0;
    } else {
//#line  1250
      tmp___1 = _max2___0;
    }
//#line  1250
    minsize = tmp___1;
//#line  1251
    total_packs = ((period_bytes + minsize) - 1U) / minsize;
//#line  1253
    total_packs = ((total_packs + packs_per_ms) - 1U) & ~ (packs_per_ms - 1U);
//#line  1256
    if (total_packs < 2U * packs_per_ms) {
//#line  1257
      total_packs = 2U * packs_per_ms;
    }
  } else {
//#line  1259
    total_packs = 8U * urb_packs;
  }
//#line  1261
  subs->nurbs = ((total_packs + urb_packs) - 1U) / urb_packs;
//#line  1262
  if (subs->nurbs > 8U) {
//#line  1264
    subs->nurbs = 8U;
//#line  1265
    total_packs = 8U * urb_packs;
  }
//#line  1267
  n = total_packs;
//#line  1268
  i = 0U;
//#line  1268
  while (i < subs->nurbs) {
//#line  1269
    if (n > urb_packs) {
//#line  1269
      npacks[i] = urb_packs;
    } else {
//#line  1269
      npacks[i] = n;
    }
//#line  1270
    n -= urb_packs;
//#line  1268
    i ++;
  }
//#line  1272
  if (subs->nurbs <= 1U) {
//#line  1276
    subs->nurbs = 2U;
//#line  1277
    npacks[0] = (total_packs + 1U) / 2U;
//#line  1278
    npacks[1] = total_packs - npacks[0];
  } else
//#line  1279
  if (npacks[subs->nurbs - 1U] < packs_per_ms) {
//#line  1281
    if (subs->nurbs > 2U) {
//#line  1283
      npacks[0] += npacks[subs->nurbs - 1U];
//#line  1284
      (subs->nurbs) --;
    } else {
//#line  1287
      subs->nurbs = 2U;
//#line  1288
      npacks[0] = (total_packs + 1U) / 2U;
//#line  1289
      npacks[1] = total_packs - npacks[0];
    }
  }
//#line  1294
  i = 0U;
//#line  1294
  while (i < subs->nurbs) {
//#line  1295
    u = & subs->dataurb[i];
//#line  1296
    u->index = (int )i;
//#line  1297
    u->subs = subs;
//#line  1298
    u->packets = (int )npacks[i];
//#line  1299
    u->buffer_size = maxsize * (unsigned int )u->packets;
//#line  1300
    if (subs->fmt_type == 2U) {
//#line  1301
      (u->packets) ++;
    }
//#line  1302
    tmp___2 = usb_alloc_urb(u->packets, 208U);
//#line  1302
    u->urb = (struct urb * __attribute__((__recursive__)) )tmp___2;
//#line  1303
    if (! u->urb) {
//#line  1304
      goto out_of_memory;
    }
//#line  1305
    tmp___3 = usb_buffer_alloc(subs->dev, (size_t )u->buffer_size, 208U, & (u->urb)->transfer_dma);
//#line  1305
    (u->urb)->transfer_buffer = (u8 *)tmp___3;
//#line  1308
    if (! (u->urb)->transfer_buffer) {
//#line  1309
      goto out_of_memory;
    }
//#line  1310
    (u->urb)->pipe = subs->datapipe;
//#line  1311
    (u->urb)->transfer_flags = 6U;
//#line  1312
    (u->urb)->interval = 1 << subs->datainterval;
//#line  1313
    (u->urb)->context = (u8 * __attribute__((__recursive__, __noderef__)) )u;
//#line  1314
    (u->urb)->complete = & snd_complete_urb;
//#line  1294
    i ++;
  }
//#line  1317
  if (subs->syncpipe) {
//#line  1319
    tmp___4 = usb_buffer_alloc(subs->dev, (size_t )16, 208U, & subs->sync_dma);
//#line  1319
    subs->syncbuf = (char * __attribute__((__nullterm__)) )tmp___4;
//#line  1321
    if (! subs->syncbuf) {
//#line  1322
      goto out_of_memory;
    }
//#line  1323
    i = 0U;
//#line  1323
    while (i < 4U) {
//#line  1324
      u___0 = & subs->syncurb[i];
//#line  1325
      u___0->index = (int )i;
//#line  1326
      u___0->subs = subs;
//#line  1327
      u___0->packets = 1;
//#line  1328
      tmp___5 = usb_alloc_urb(1, 208U);
//#line  1328
      u___0->urb = (struct urb * __attribute__((__recursive__)) )tmp___5;
//#line  1329
      if (! u___0->urb) {
//#line  1330
        goto out_of_memory;
      }
//#line  1331
      (u___0->urb)->transfer_buffer = (u8 *)(subs->syncbuf + i * 4U);
//#line  1332
      (u___0->urb)->transfer_dma = subs->sync_dma + (dma_addr_t )(i * 4U);
//#line  1333
      (u___0->urb)->transfer_buffer_length = 4;
//#line  1334
      (u___0->urb)->pipe = subs->syncpipe;
//#line  1335
      (u___0->urb)->transfer_flags = 6U;
//#line  1337
      (u___0->urb)->number_of_packets = 1;
//#line  1338
      (u___0->urb)->interval = 1 << subs->syncinterval;
//#line  1339
      (u___0->urb)->context = (u8 * __attribute__((__recursive__, __noderef__)) )u___0;
//#line  1340
      (u___0->urb)->complete = & snd_complete_sync_urb;
//#line  1323
      i ++;
    }
  }
//#line  1343
  return (0);
  out_of_memory: 
//#line  1346
  release_substream_urbs(subs, 0);
//#line  1347
  return (-12);
}
}
//#line  1354 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat *find_format(struct snd_usb_substream *subs , unsigned int format ,
                                       unsigned int rate , unsigned int channels ) 
{ 
  struct list_head *p ;
  struct audioformat *found ;
  int cur_attr ;
  int attr ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  unsigned int i ;

  {
//#line  1358
  found = (struct audioformat *)((void *)0);
//#line  1359
  cur_attr = 0;
//#line  1361
  p = (struct list_head *)subs->fmt_list.next;
//#line  1361
  while (1) {
//#line  1361
    __builtin_prefetch((void const   *)p->next);
//#line  1361
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1361
      break;
    }
//#line  1363
    __mptr = (struct list_head  const  *)p;
//#line  1363
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1364
    if ((unsigned int )fp->format != format) {
//#line  1365
      goto __Cont;
    } else
//#line  1364
    if (fp->channels != channels) {
//#line  1365
      goto __Cont;
    }
//#line  1366
    if (rate < fp->rate_min) {
//#line  1367
      goto __Cont;
    } else
//#line  1366
    if (rate > fp->rate_max) {
//#line  1367
      goto __Cont;
    }
//#line  1368
    if (! (fp->rates & (unsigned int )(1 << 30))) {
//#line  1370
      i = 0U;
//#line  1370
      while (i < fp->nr_rates) {
//#line  1371
        if (*(fp->rate_table + i) == rate) {
//#line  1372
          break;
        }
//#line  1370
        i ++;
      }
//#line  1373
      if (i >= fp->nr_rates) {
//#line  1374
        goto __Cont;
      }
    }
//#line  1376
    attr = (int )fp->ep_attr & 12;
//#line  1377
    if (! found) {
//#line  1378
      found = fp;
//#line  1379
      cur_attr = attr;
//#line  1380
      goto __Cont;
    }
//#line  1387
    if (attr != cur_attr) {
//#line  1388
      if (attr == 4) {
//#line  1388
        if (subs->direction == 0) {
//#line  1392
          goto __Cont;
        } else {
//#line  1388
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
//#line  1388
      if (attr == 8) {
//#line  1388
        if (subs->direction == 1) {
//#line  1392
          goto __Cont;
        }
      }
//#line  1393
      if (cur_attr == 4) {
//#line  1393
        if (subs->direction == 0) {
//#line  1397
          found = fp;
//#line  1398
          cur_attr = attr;
//#line  1399
          goto __Cont;
        } else {
//#line  1393
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
//#line  1393
      if (cur_attr == 8) {
//#line  1393
        if (subs->direction == 1) {
//#line  1397
          found = fp;
//#line  1398
          cur_attr = attr;
//#line  1399
          goto __Cont;
        }
      }
    }
//#line  1403
    if (fp->maxpacksize > found->maxpacksize) {
//#line  1404
      found = fp;
//#line  1405
      cur_attr = attr;
    }
    __Cont: /* CIL Label */ 
//#line  1361
    p = (struct list_head *)p->next;
  }
//#line  1408
  return (found);
}
}
//#line  1415 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int init_usb_pitch(struct usb_device *dev , int iface , struct usb_host_interface *alts ,
                          struct audioformat *fmt ) 
{ 
  unsigned int ep ;
  unsigned char data[1] ;
  int err ;
  unsigned int tmp ;

  {
//#line  1423
  ep = (unsigned int )(alts->endpoint + 0)->desc.bEndpointAddress;
//#line  1425
  if ((int )fmt->attributes & 2) {
//#line  1426
    data[0] = (unsigned char)1;
//#line  1427
    tmp = __create_pipe(dev, 0U);
//#line  1427
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )1, (__u8 )((1 << 5) | 2),
                          (__u16 )(2 << 8), (__u16 )ep, (void *)(data), (__u16 )1,
                          1000);
//#line  1427
    if (err < 0) {
//#line  1430
      printk("<3>%d:%d:%d: cannot set enable PITCH\n", dev->devnum, iface, ep);
//#line  1432
      return (err);
    }
  }
//#line  1435
  return (0);
}
}
//#line  1438 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int init_usb_sample_rate(struct usb_device *dev , int iface , struct usb_host_interface *alts ,
                                struct audioformat *fmt , int rate ) 
{ 
  unsigned int ep ;
  unsigned char data[3] ;
  int err ;
  int crate ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
//#line  1446
  ep = (unsigned int )(alts->endpoint + 0)->desc.bEndpointAddress;
//#line  1448
  if ((int )fmt->attributes & 1) {
//#line  1450
    data[0] = (unsigned char )rate;
//#line  1451
    data[1] = (unsigned char )(rate >> 8);
//#line  1452
    data[2] = (unsigned char )(rate >> 16);
//#line  1453
    tmp = __create_pipe(dev, 0U);
//#line  1453
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )1, (__u8 )((1 << 5) | 2),
                          (__u16 )(1 << 8), (__u16 )ep, (void *)(data), (__u16 )3,
                          1000);
//#line  1453
    if (err < 0) {
//#line  1456
      printk("<3>%d:%d:%d: cannot set freq %d to ep 0x%x\n", dev->devnum, iface, (int )fmt->altsetting,
             rate, ep);
//#line  1458
      return (err);
    }
//#line  1460
    tmp___0 = __create_pipe(dev, 0U);
//#line  1460
    err = snd_usb_ctl_msg(dev, ((unsigned int )(2 << 30) | tmp___0) | 128U, (__u8 )129,
                          (__u8 )(((1 << 5) | 2) | 128), (__u16 )(1 << 8), (__u16 )ep,
                          (void *)(data), (__u16 )3, 1000);
//#line  1460
    if (err < 0) {
//#line  1463
      printk("<4>%d:%d:%d: cannot get freq at ep 0x%x\n", dev->devnum, iface, (int )fmt->altsetting,
             ep);
//#line  1465
      return (0);
    }
//#line  1467
    crate = ((int )data[0] | ((int )data[1] << 8)) | ((int )data[2] << 16);
//#line  1468
    if (crate != rate) {
//#line  1469
      printk("<4>current rate %d is different from the runtime rate %d\n", crate,
             rate);
    }
  }
//#line  1473
  return (0);
}
}
//#line  1479 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int set_format(struct snd_usb_substream *subs , struct audioformat *fmt ) 
{ 
  struct usb_device *dev ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct usb_interface *iface ;
  unsigned int ep ;
  unsigned int attr ;
  int is_playback ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
//#line  1481
  dev = subs->dev;
//#line  1486
  is_playback = subs->direction == 0;
//#line  1489
  iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )fmt->iface);
//#line  1490
  __ret_warn_on = ! (! (! iface));
//#line  1490
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
//#line  1490
  if (tmp) {
//#line  1490
    warn_slowpath("/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c", 1490,
                  (char const   *)((void *)0));
  }
//#line  1490
  tmp___0 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
//#line  1490
  if (tmp___0) {
//#line  1491
    return (-22);
  }
//#line  1492
  alts = iface->altsetting + fmt->altset_idx;
//#line  1493
  altsd = & alts->desc;
//#line  1494
  __ret_warn_on___0 = ! (! ((int )altsd->bAlternateSetting != (int )fmt->altsetting));
//#line  1494
  tmp___1 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
//#line  1494
  if (tmp___1) {
//#line  1494
    warn_slowpath("/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c", 1494,
                  (char const   *)((void *)0));
  }
//#line  1494
  tmp___2 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
//#line  1494
  if (tmp___2) {
//#line  1495
    return (-22);
  }
//#line  1497
  if ((unsigned long )fmt == (unsigned long )subs->cur_audiofmt) {
//#line  1498
    return (0);
  }
//#line  1501
  if (subs->interface >= 0) {
//#line  1501
    if (subs->interface != fmt->iface) {
//#line  1502
      tmp___3 = usb_set_interface(subs->dev, subs->interface, 0);
//#line  1502
      if (tmp___3 < 0) {
//#line  1503
        printk("<3>%d:%d:%d: return to setting 0 failed\n", dev->devnum, fmt->iface,
               (int )fmt->altsetting);
//#line  1505
        return (-5);
      }
//#line  1507
      subs->interface = -1;
//#line  1508
      subs->format = 0U;
    }
  }
//#line  1512
  if (subs->interface != fmt->iface) {
//#line  1512
    goto _L;
  } else
//#line  1512
  if (subs->format != (unsigned int )fmt->altset_idx) {
    _L: /* CIL Label */ 
//#line  1513
    tmp___4 = usb_set_interface(dev, fmt->iface, (int )fmt->altsetting);
//#line  1513
    if (tmp___4 < 0) {
//#line  1514
      printk("<3>%d:%d:%d: usb_set_interface failed\n", dev->devnum, fmt->iface, (int )fmt->altsetting);
//#line  1516
      return (-5);
    }
//#line  1518
    printk("<6>setting usb interface %d:%d\n", fmt->iface, (int )fmt->altsetting);
//#line  1519
    subs->interface = fmt->iface;
//#line  1520
    subs->format = (unsigned int )fmt->altset_idx;
  }
//#line  1524
  ep = (unsigned int )((int )fmt->endpoint & 15);
//#line  1525
  if (is_playback) {
//#line  1526
    tmp___5 = __create_pipe(dev, ep);
//#line  1526
    subs->datapipe = tmp___5;
  } else {
//#line  1528
    tmp___6 = __create_pipe(dev, ep);
//#line  1528
    subs->datapipe = tmp___6 | 128U;
  }
//#line  1529
  if ((unsigned int )(subs->dev)->speed == 3U) {
//#line  1529
    if ((int )(alts->endpoint + 0)->desc.bInterval >= 1) {
//#line  1529
      if ((int )(alts->endpoint + 0)->desc.bInterval <= 4) {
//#line  1532
        subs->datainterval = (unsigned int )((int )(alts->endpoint + 0)->desc.bInterval - 1);
      } else {
//#line  1534
        subs->datainterval = 0U;
      }
    } else {
//#line  1534
      subs->datainterval = 0U;
    }
  } else {
//#line  1534
    subs->datainterval = 0U;
  }
//#line  1535
  tmp___7 = 0U;
//#line  1535
  subs->syncinterval = tmp___7;
//#line  1535
  subs->syncpipe = tmp___7;
//#line  1536
  subs->maxpacksize = fmt->maxpacksize;
//#line  1537
  subs->fill_max = 0U;
//#line  1544
  attr = (unsigned int )((int )fmt->ep_attr & 12);
//#line  1545
  if (is_playback) {
//#line  1545
    if (attr == 4U) {
//#line  1545
      goto _L___3;
    } else {
//#line  1545
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
//#line  1545
  if (! is_playback) {
//#line  1545
    if (attr == 8U) {
      _L___3: /* CIL Label */ 
//#line  1545
      if ((int )altsd->bNumEndpoints >= 2) {
//#line  1552
        if (((int )(alts->endpoint + 1)->desc.bmAttributes & 3) != 1) {
//#line  1555
          printk("<3>%d:%d:%d : invalid synch pipe\n", dev->devnum, fmt->iface, (int )fmt->altsetting);
//#line  1557
          return (-22);
        } else
//#line  1552
        if ((int )(alts->endpoint + 1)->desc.bLength >= 9) {
//#line  1552
          if ((int )(alts->endpoint + 1)->desc.bSynchAddress != 0) {
//#line  1555
            printk("<3>%d:%d:%d : invalid synch pipe\n", dev->devnum, fmt->iface,
                   (int )fmt->altsetting);
//#line  1557
            return (-22);
          }
        }
//#line  1559
        ep = (unsigned int )(alts->endpoint + 1)->desc.bEndpointAddress;
//#line  1560
        if ((int )(alts->endpoint + 0)->desc.bLength >= 9) {
//#line  1560
          if (is_playback) {
//#line  1560
            if (ep != (unsigned int )((int )(alts->endpoint + 0)->desc.bSynchAddress | 128)) {
//#line  1563
              printk("<3>%d:%d:%d : invalid synch pipe\n", dev->devnum, fmt->iface,
                     (int )fmt->altsetting);
//#line  1565
              return (-22);
            } else {
//#line  1560
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
//#line  1560
          if (! is_playback) {
//#line  1560
            if (ep != (unsigned int )((int )(alts->endpoint + 0)->desc.bSynchAddress & -129)) {
//#line  1563
              printk("<3>%d:%d:%d : invalid synch pipe\n", dev->devnum, fmt->iface,
                     (int )fmt->altsetting);
//#line  1565
              return (-22);
            }
          }
        }
//#line  1567
        ep &= 15U;
//#line  1568
        if (is_playback) {
//#line  1569
          tmp___8 = __create_pipe(dev, ep);
//#line  1569
          subs->syncpipe = tmp___8 | 128U;
        } else {
//#line  1571
          tmp___9 = __create_pipe(dev, ep);
//#line  1571
          subs->syncpipe = tmp___9;
        }
//#line  1572
        if ((int )(alts->endpoint + 1)->desc.bLength >= 9) {
//#line  1572
          if ((int )(alts->endpoint + 1)->desc.bRefresh >= 1) {
//#line  1572
            if ((int )(alts->endpoint + 1)->desc.bRefresh <= 9) {
//#line  1575
              subs->syncinterval = (unsigned int )(alts->endpoint + 1)->desc.bRefresh;
            } else {
//#line  1572
              goto _L___2;
            }
          } else {
//#line  1572
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
//#line  1576
        if ((unsigned int )(subs->dev)->speed == 2U) {
//#line  1577
          subs->syncinterval = 1U;
        } else
//#line  1578
        if ((int )(alts->endpoint + 1)->desc.bInterval >= 1) {
//#line  1578
          if ((int )(alts->endpoint + 1)->desc.bInterval <= 16) {
//#line  1580
            subs->syncinterval = (unsigned int )((int )(alts->endpoint + 1)->desc.bInterval - 1);
          } else {
//#line  1582
            subs->syncinterval = 3U;
          }
        } else {
//#line  1582
          subs->syncinterval = 3U;
        }
      }
    }
  }
//#line  1586
  if ((int )fmt->attributes & 128) {
//#line  1587
    subs->fill_max = 1U;
  }
//#line  1589
  err = init_usb_pitch(dev, subs->interface, alts, fmt);
//#line  1589
  if (err < 0) {
//#line  1590
    return (err);
  }
//#line  1592
  subs->cur_audiofmt = fmt;
//#line  1601
  return (0);
}
}
//#line  1614 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_usb_substream *subs ;
  struct audioformat *fmt ;
  unsigned int channels ;
  unsigned int rate ;
  unsigned int format ;
  int ret ;
  int changed ;
  struct snd_interval *tmp ;
  struct snd_mask *tmp___0 ;
  struct snd_interval *tmp___1 ;
  struct snd_interval *tmp___2 ;
  struct snd_interval *tmp___3 ;
  struct snd_mask *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  struct snd_interval *tmp___7 ;
  int tmp___8 ;
  struct usb_host_interface *alts ;
  struct usb_interface *iface ;
  struct snd_mask *tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  struct snd_interval *tmp___12 ;
  struct snd_interval *tmp___13 ;
  struct snd_interval *tmp___14 ;
  struct snd_mask *tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  struct snd_interval *tmp___18 ;

  {
//#line  1617
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  1622
  tmp = hw_param_interval(hw_params, 18);
//#line  1622
  ret = snd_pcm_alloc_vmalloc_buffer(substream, (size_t )tmp->min);
//#line  1624
  if (ret < 0) {
//#line  1625
    return (ret);
  }
//#line  1627
  tmp___0 = hw_param_mask(hw_params, 1);
//#line  1627
  format = snd_mask_min((struct snd_mask  const  *)tmp___0);
//#line  1628
  tmp___1 = hw_param_interval(hw_params, 11);
//#line  1628
  rate = tmp___1->min;
//#line  1629
  tmp___2 = hw_param_interval(hw_params, 10);
//#line  1629
  channels = tmp___2->min;
//#line  1630
  fmt = find_format(subs, format, rate, channels);
//#line  1631
  if (! fmt) {
//#line  1632
    printk("<7>cannot set format: format = 0x%x, rate = %d, channels = %d\n", format,
           rate, channels);
//#line  1634
    return (-22);
  }
//#line  1637
  if ((unsigned long )subs->cur_audiofmt != (unsigned long )fmt) {
//#line  1637
    tmp___8 = 1;
  } else {
//#line  1637
    tmp___3 = hw_param_interval(hw_params, 13);
//#line  1637
    tmp___4 = hw_param_mask(hw_params, 1);
//#line  1637
    tmp___5 = snd_mask_min((struct snd_mask  const  *)tmp___4);
//#line  1637
    tmp___6 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___5);
//#line  1637
    tmp___7 = hw_param_interval(hw_params, 10);
//#line  1637
    if (subs->period_bytes != ((tmp___3->min * (unsigned int )tmp___6) * tmp___7->min) / 8U) {
//#line  1637
      tmp___8 = 1;
    } else
//#line  1637
    if (subs->cur_rate != rate) {
//#line  1637
      tmp___8 = 1;
    } else {
//#line  1637
      tmp___8 = 0;
    }
  }
//#line  1637
  changed = tmp___8;
//#line  1640
  ret = set_format(subs, fmt);
//#line  1640
  if (ret < 0) {
//#line  1641
    return (ret);
  }
//#line  1643
  if (subs->cur_rate != rate) {
//#line  1646
    iface = usb_ifnum_to_if((struct usb_device  const  *)subs->dev, (unsigned int )fmt->iface);
//#line  1647
    alts = iface->altsetting + fmt->altset_idx;
//#line  1648
    ret = init_usb_sample_rate(subs->dev, subs->interface, alts, fmt, (int )rate);
//#line  1649
    if (ret < 0) {
//#line  1650
      return (ret);
    }
//#line  1651
    subs->cur_rate = rate;
  }
//#line  1654
  if (changed) {
//#line  1656
    release_substream_urbs(subs, 0);
//#line  1658
    tmp___9 = hw_param_mask(hw_params, 1);
//#line  1658
    tmp___10 = snd_mask_min((struct snd_mask  const  *)tmp___9);
//#line  1658
    tmp___11 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___10);
//#line  1658
    tmp___12 = hw_param_interval(hw_params, 10);
//#line  1658
    tmp___13 = hw_param_interval(hw_params, 11);
//#line  1658
    tmp___14 = hw_param_interval(hw_params, 13);
//#line  1658
    tmp___15 = hw_param_mask(hw_params, 1);
//#line  1658
    tmp___16 = snd_mask_min((struct snd_mask  const  *)tmp___15);
//#line  1658
    tmp___17 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___16);
//#line  1658
    tmp___18 = hw_param_interval(hw_params, 10);
//#line  1658
    ret = init_substream_urbs(subs, ((tmp___14->min * (unsigned int )tmp___17) * tmp___18->min) / 8U,
                              tmp___13->min, (unsigned int )tmp___11 * tmp___12->min);
  }
//#line  1663
  return (ret);
}
}
//#line  1671 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;

  {
//#line  1673
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  1675
  subs->cur_audiofmt = (struct audioformat *)((void *)0);
//#line  1676
  subs->cur_rate = 0U;
//#line  1677
  subs->period_bytes = 0U;
//#line  1678
  if (! ((subs->stream)->chip)->shutdown) {
//#line  1679
    release_substream_urbs(subs, 0);
  }
//#line  1680
  tmp = snd_pcm_free_vmalloc_buffer(substream);
//#line  1680
  return (tmp);
}
}
//#line  1688 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  struct snd_usb_substream *subs ;
  snd_pcm_sframes_t tmp ;
  snd_pcm_sframes_t tmp___0 ;
  int tmp___1 ;

  {
//#line  1690
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1691
  subs = (struct snd_usb_substream *)runtime->private_data;
//#line  1693
  if (! subs->cur_audiofmt) {
//#line  1694
    printk("<3>usbaudio: no format is specified!\n");
//#line  1695
    return (-6);
  }
//#line  1699
  tmp = bytes_to_frames(runtime, (ssize_t )subs->maxpacksize);
//#line  1699
  subs->maxframesize = (unsigned int )tmp;
//#line  1700
  tmp___0 = bytes_to_frames(runtime, (ssize_t )subs->curpacksize);
//#line  1700
  subs->curframesize = (unsigned int )tmp___0;
//#line  1703
  subs->hwptr_done = 0U;
//#line  1704
  subs->transfer_done = 0U;
//#line  1705
  subs->phase = 0U;
//#line  1708
  deactivate_urbs(subs, 0, 1);
//#line  1709
  wait_clear_urbs(subs);
//#line  1713
  if (subs->direction == 0) {
//#line  1714
    subs->ops.prepare = & prepare_nodata_playback_urb;
//#line  1715
    tmp___1 = start_urbs(subs, runtime);
//#line  1715
    return (tmp___1);
  } else {
//#line  1717
    return (0);
  }
}
}
//#line  1720 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_usb_hardware  = 
//#line  1720
     {590099U, 0ULL, 0U, 0U, 0U, 0U, 0U, (size_t )1048576, (size_t )64, (size_t )524288,
    2U, 1024U, 0UL};
//#line  1745 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int hw_check_valid_format(struct snd_pcm_hw_params *params , struct audioformat *fp ) 
{ 
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  struct snd_interval *ct ;
  struct snd_interval *tmp___0 ;
  struct snd_mask *fmts ;
  struct snd_mask *tmp___1 ;
  int tmp___2 ;

  {
//#line  1747
  tmp = hw_param_interval(params, 11);
//#line  1747
  it = tmp;
//#line  1748
  tmp___0 = hw_param_interval(params, 10);
//#line  1748
  ct = tmp___0;
//#line  1749
  tmp___1 = hw_param_mask(params, 1);
//#line  1749
  fmts = tmp___1;
//#line  1752
  tmp___2 = snd_mask_test((struct snd_mask  const  *)fmts, (unsigned int )fp->format);
//#line  1752
  if (! tmp___2) {
//#line  1754
    return (0);
  }
//#line  1757
  if (fp->channels < ct->min) {
//#line  1759
    return (0);
  } else
//#line  1757
  if (fp->channels > ct->max) {
//#line  1759
    return (0);
  }
//#line  1762
  if (fp->rate_min > it->max) {
//#line  1764
    return (0);
  } else
//#line  1762
  if (fp->rate_min == it->max) {
//#line  1762
    if (it->openmax) {
//#line  1764
      return (0);
    }
  }
//#line  1766
  if (fp->rate_max < it->min) {
//#line  1768
    return (0);
  } else
//#line  1766
  if (fp->rate_max == it->min) {
//#line  1766
    if (it->openmin) {
//#line  1768
      return (0);
    }
  }
//#line  1770
  return (1);
}
}
//#line  1773 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int hw_rule_rate(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  unsigned int rmin ;
  unsigned int rmax ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
//#line  1776
  subs = (struct snd_usb_substream *)rule->private;
//#line  1778
  tmp = hw_param_interval(params, 11);
//#line  1778
  it = tmp;
//#line  1783
  changed = 0;
//#line  1784
  rmax = 0U;
//#line  1784
  rmin = rmax;
//#line  1785
  p = (struct list_head *)subs->fmt_list.next;
//#line  1785
  while (1) {
//#line  1785
    __builtin_prefetch((void const   *)p->next);
//#line  1785
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1785
      break;
    }
//#line  1787
    __mptr = (struct list_head  const  *)p;
//#line  1787
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1788
    tmp___0 = hw_check_valid_format(params, fp);
//#line  1788
    if (! tmp___0) {
//#line  1789
      goto __Cont;
    }
//#line  1790
    tmp___1 = changed;
//#line  1790
    changed ++;
//#line  1790
    if (tmp___1) {
//#line  1791
      if (rmin > fp->rate_min) {
//#line  1792
        rmin = fp->rate_min;
      }
//#line  1793
      if (rmax < fp->rate_max) {
//#line  1794
        rmax = fp->rate_max;
      }
    } else {
//#line  1796
      rmin = fp->rate_min;
//#line  1797
      rmax = fp->rate_max;
    }
    __Cont: /* CIL Label */ 
//#line  1785
    p = (struct list_head *)p->next;
  }
//#line  1801
  if (! changed) {
//#line  1803
    it->empty = 1U;
//#line  1804
    return (-22);
  }
//#line  1807
  changed = 0;
//#line  1808
  if (it->min < rmin) {
//#line  1809
    it->min = rmin;
//#line  1810
    it->openmin = 0U;
//#line  1811
    changed = 1;
  }
//#line  1813
  if (it->max > rmax) {
//#line  1814
    it->max = rmax;
//#line  1815
    it->openmax = 0U;
//#line  1816
    changed = 1;
  }
//#line  1818
  tmp___2 = snd_interval_checkempty((struct snd_interval  const  *)it);
//#line  1818
  if (tmp___2) {
//#line  1819
    it->empty = 1U;
//#line  1820
    return (-22);
  }
//#line  1823
  return (changed);
}
}
//#line  1827 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int hw_rule_channels(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  unsigned int rmin ;
  unsigned int rmax ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
//#line  1830
  subs = (struct snd_usb_substream *)rule->private;
//#line  1832
  tmp = hw_param_interval(params, 10);
//#line  1832
  it = tmp;
//#line  1837
  changed = 0;
//#line  1838
  rmax = 0U;
//#line  1838
  rmin = rmax;
//#line  1839
  p = (struct list_head *)subs->fmt_list.next;
//#line  1839
  while (1) {
//#line  1839
    __builtin_prefetch((void const   *)p->next);
//#line  1839
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1839
      break;
    }
//#line  1841
    __mptr = (struct list_head  const  *)p;
//#line  1841
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1842
    tmp___0 = hw_check_valid_format(params, fp);
//#line  1842
    if (! tmp___0) {
//#line  1843
      goto __Cont;
    }
//#line  1844
    tmp___1 = changed;
//#line  1844
    changed ++;
//#line  1844
    if (tmp___1) {
//#line  1845
      if (rmin > fp->channels) {
//#line  1846
        rmin = fp->channels;
      }
//#line  1847
      if (rmax < fp->channels) {
//#line  1848
        rmax = fp->channels;
      }
    } else {
//#line  1850
      rmin = fp->channels;
//#line  1851
      rmax = fp->channels;
    }
    __Cont: /* CIL Label */ 
//#line  1839
    p = (struct list_head *)p->next;
  }
//#line  1855
  if (! changed) {
//#line  1857
    it->empty = 1U;
//#line  1858
    return (-22);
  }
//#line  1861
  changed = 0;
//#line  1862
  if (it->min < rmin) {
//#line  1863
    it->min = rmin;
//#line  1864
    it->openmin = 0U;
//#line  1865
    changed = 1;
  }
//#line  1867
  if (it->max > rmax) {
//#line  1868
    it->max = rmax;
//#line  1869
    it->openmax = 0U;
//#line  1870
    changed = 1;
  }
//#line  1872
  tmp___2 = snd_interval_checkempty((struct snd_interval  const  *)it);
//#line  1872
  if (tmp___2) {
//#line  1873
    it->empty = 1U;
//#line  1874
    return (-22);
  }
//#line  1877
  return (changed);
}
}
//#line  1880 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int hw_rule_format(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_mask *fmt ;
  struct snd_mask *tmp ;
  u64 fbits ;
  u32 oldbits[2] ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;

  {
//#line  1883
  subs = (struct snd_usb_substream *)rule->private;
//#line  1885
  tmp = hw_param_mask(params, 1);
//#line  1885
  fmt = tmp;
//#line  1891
  fbits = (u64 )0;
//#line  1892
  p = (struct list_head *)subs->fmt_list.next;
//#line  1892
  while (1) {
//#line  1892
    __builtin_prefetch((void const   *)p->next);
//#line  1892
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1892
      break;
    }
//#line  1894
    __mptr = (struct list_head  const  *)p;
//#line  1894
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1895
    tmp___0 = hw_check_valid_format(params, fp);
//#line  1895
    if (! tmp___0) {
//#line  1896
      goto __Cont;
    }
//#line  1897
    fbits |= 1ULL << fp->format;
    __Cont: /* CIL Label */ 
//#line  1892
    p = (struct list_head *)p->next;
  }
//#line  1900
  oldbits[0] = fmt->bits[0];
//#line  1901
  oldbits[1] = fmt->bits[1];
//#line  1902
  fmt->bits[0] &= (u32 )fbits;
//#line  1903
  fmt->bits[1] &= (u32 )(fbits >> 32);
//#line  1904
  if (! fmt->bits[0]) {
//#line  1904
    if (! fmt->bits[1]) {
//#line  1906
      return (-22);
    }
  }
//#line  1908
  if (oldbits[0] != fmt->bits[0]) {
//#line  1908
    tmp___1 = 1;
  } else
//#line  1908
  if (oldbits[1] != fmt->bits[1]) {
//#line  1908
    tmp___1 = 1;
  } else {
//#line  1908
    tmp___1 = 0;
  }
//#line  1908
  changed = tmp___1;
//#line  1910
  return (changed);
}
}
//#line  1918 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int check_hw_params_convention(struct snd_usb_substream *subs ) 
{ 
  int i ;
  u32 *channels ;
  u32 *rates ;
  u32 cmaster ;
  u32 rmaster ;
  u32 rate_min ;
  u32 rate_max ;
  struct list_head *p ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct audioformat *f ;
  struct list_head  const  *__mptr ;
  struct audioformat *f___0 ;
  struct list_head  const  *__mptr___0 ;

  {
//#line  1924
  rate_min = (u32 )0;
//#line  1924
  rate_max = (u32 )0;
//#line  1926
  err = 1;
//#line  1928
  tmp = kcalloc((size_t )64, sizeof(u32 ), 208U);
//#line  1928
  channels = (u32 *)tmp;
//#line  1929
  tmp___0 = kcalloc((size_t )64, sizeof(u32 ), 208U);
//#line  1929
  rates = (u32 *)tmp___0;
//#line  1930
  if (! channels) {
//#line  1931
    err = -12;
//#line  1932
    goto __out;
  } else
//#line  1930
  if (! rates) {
//#line  1931
    err = -12;
//#line  1932
    goto __out;
  }
//#line  1935
  p = (struct list_head *)subs->fmt_list.next;
//#line  1935
  while (1) {
//#line  1935
    __builtin_prefetch((void const   *)p->next);
//#line  1935
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1935
      break;
    }
//#line  1937
    __mptr = (struct list_head  const  *)p;
//#line  1937
    f = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1939
    if (f->channels > 32U) {
//#line  1940
      goto __out;
    }
//#line  1942
    if (f->rates & (unsigned int )(1 << 30)) {
//#line  1943
      if (rate_min) {
//#line  1943
        if (f->rate_min != rate_min) {
//#line  1944
          goto __out;
        }
      }
//#line  1945
      if (rate_max) {
//#line  1945
        if (f->rate_max != rate_max) {
//#line  1946
          goto __out;
        }
      }
//#line  1947
      rate_min = f->rate_min;
//#line  1948
      rate_max = f->rate_max;
    }
//#line  1951
    if (*(rates + f->format) & (unsigned int )(1 << 30)) {
//#line  1952
      if (f->rates != *(rates + f->format)) {
//#line  1953
        goto __out;
      }
    }
//#line  1955
    if (f->rates & (unsigned int )(1 << 30)) {
//#line  1956
      if (*(rates + f->format)) {
//#line  1956
        if (*(rates + f->format) != f->rates) {
//#line  1957
          goto __out;
        }
      }
    }
//#line  1959
    *(channels + f->format) |= (unsigned int )(1 << f->channels);
//#line  1960
    *(rates + f->format) |= f->rates;
//#line  1962
    if (f->rates & (unsigned int )(1 << 31)) {
//#line  1963
      goto __out;
    }
//#line  1935
    p = (struct list_head *)p->next;
  }
//#line  1966
  rmaster = (u32 )0;
//#line  1966
  cmaster = rmaster;
//#line  1967
  i = 0;
//#line  1967
  while (i < 64) {
//#line  1968
    if (cmaster != *(channels + i)) {
//#line  1968
      if (cmaster) {
//#line  1968
        if (*(channels + i)) {
//#line  1969
          goto __out;
        }
      }
    }
//#line  1970
    if (rmaster != *(rates + i)) {
//#line  1970
      if (rmaster) {
//#line  1970
        if (*(rates + i)) {
//#line  1971
          goto __out;
        }
      }
    }
//#line  1972
    if (*(channels + i)) {
//#line  1973
      cmaster = *(channels + i);
    }
//#line  1974
    if (*(rates + i)) {
//#line  1975
      rmaster = *(rates + i);
    }
//#line  1967
    i ++;
  }
//#line  1978
  memset((void *)channels, 0, 64UL * sizeof(u32 ));
//#line  1979
  p = (struct list_head *)subs->fmt_list.next;
//#line  1979
  while (1) {
//#line  1979
    __builtin_prefetch((void const   *)p->next);
//#line  1979
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  1979
      break;
    }
//#line  1981
    __mptr___0 = (struct list_head  const  *)p;
//#line  1981
    f___0 = (struct audioformat *)((char *)__mptr___0 - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  1982
    if (f___0->rates & (unsigned int )(1 << 30)) {
//#line  1983
      goto __Cont;
    }
//#line  1984
    i = 0;
//#line  1984
    while (i < 32) {
//#line  1985
      if (f___0->rates & (unsigned int )(1 << i)) {
//#line  1986
        *(channels + i) |= (unsigned int )(1 << f___0->channels);
      }
//#line  1984
      i ++;
    }
    __Cont: /* CIL Label */ 
//#line  1979
    p = (struct list_head *)p->next;
  }
//#line  1989
  cmaster = (u32 )0;
//#line  1990
  i = 0;
//#line  1990
  while (i < 32) {
//#line  1991
    if (cmaster != *(channels + i)) {
//#line  1991
      if (cmaster) {
//#line  1991
        if (*(channels + i)) {
//#line  1992
          goto __out;
        }
      }
    }
//#line  1993
    if (*(channels + i)) {
//#line  1994
      cmaster = *(channels + i);
    }
//#line  1990
    i ++;
  }
//#line  1996
  err = 0;
  __out: 
//#line  1999
  kfree((void const   *)channels);
//#line  2000
  kfree((void const   *)rates);
//#line  2001
  return (err);
}
}
//#line  2007 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime , struct snd_usb_substream *subs ) 
{ 
  struct audioformat *fp ;
  int count ;
  int needs_knot ;
  int err ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  int i ;
  int tmp___0 ;

  {
//#line  2011
  count = 0;
//#line  2011
  needs_knot = 0;
//#line  2014
  __mptr = (struct list_head  const  *)subs->fmt_list.next;
//#line  2014
  fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  2014
  while (1) {
//#line  2014
    __builtin_prefetch((void const   *)fp->list.next);
//#line  2014
    if (! ((unsigned long )(& fp->list) != (unsigned long )(& subs->fmt_list))) {
//#line  2014
      break;
    }
//#line  2015
    if (fp->rates & (unsigned int )(1 << 30)) {
//#line  2016
      return (0);
    }
//#line  2017
    count = (int )((unsigned int )count + fp->nr_rates);
//#line  2018
    if (fp->rates & (unsigned int )(1 << 31)) {
//#line  2019
      needs_knot = 1;
    }
//#line  2014
    __mptr___0 = (struct list_head  const  *)fp->list.next;
//#line  2014
    fp = (struct audioformat *)((char *)__mptr___0 - (unsigned int )(& ((struct audioformat *)0)->list));
  }
//#line  2021
  if (! needs_knot) {
//#line  2022
    return (0);
  }
//#line  2024
  subs->rate_list.count = (unsigned int )count;
//#line  2025
  tmp = kmalloc(sizeof(int ) * (unsigned long )count, 208U);
//#line  2025
  subs->rate_list.list = (unsigned int *)tmp;
//#line  2026
  subs->rate_list.mask = 0U;
//#line  2027
  count = 0;
//#line  2028
  __mptr___1 = (struct list_head  const  *)subs->fmt_list.next;
//#line  2028
  fp = (struct audioformat *)((char *)__mptr___1 - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  2028
  while (1) {
//#line  2028
    __builtin_prefetch((void const   *)fp->list.next);
//#line  2028
    if (! ((unsigned long )(& fp->list) != (unsigned long )(& subs->fmt_list))) {
//#line  2028
      break;
    }
//#line  2030
    i = 0;
//#line  2030
    while ((unsigned int )i < fp->nr_rates) {
//#line  2031
      tmp___0 = count;
//#line  2031
      count ++;
//#line  2031
      *(subs->rate_list.list + tmp___0) = *(fp->rate_table + i);
//#line  2030
      i ++;
    }
//#line  2028
    __mptr___2 = (struct list_head  const  *)fp->list.next;
//#line  2028
    fp = (struct audioformat *)((char *)__mptr___2 - (unsigned int )(& ((struct audioformat *)0)->list));
  }
//#line  2033
  err = snd_pcm_hw_constraint_list(runtime, 0U, 11, & subs->rate_list);
//#line  2035
  if (err < 0) {
//#line  2036
    return (err);
  }
//#line  2038
  return (0);
}
}
//#line  2091
extern int ( /* missing proto */  snd_pcm_hw_rule_add_MJR2)() ;
//#line  2046 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int setup_hw_info(struct snd_pcm_runtime *runtime , struct snd_usb_substream *subs ) 
{ 
  struct list_head *p ;
  int err ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  size_t tmp ;

  {
//#line  2051
  runtime->hw.formats = subs->formats;
//#line  2053
  runtime->hw.rate_min = 2147483647U;
//#line  2054
  runtime->hw.rate_max = 0U;
//#line  2055
  runtime->hw.channels_min = 256U;
//#line  2056
  runtime->hw.channels_max = 0U;
//#line  2057
  runtime->hw.rates = 0U;
//#line  2059
  p = (struct list_head *)subs->fmt_list.next;
//#line  2059
  while (1) {
//#line  2059
    __builtin_prefetch((void const   *)p->next);
//#line  2059
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  2059
      break;
    }
//#line  2061
    __mptr = (struct list_head  const  *)p;
//#line  2061
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  2062
    runtime->hw.rates |= fp->rates;
//#line  2063
    if (runtime->hw.rate_min > fp->rate_min) {
//#line  2064
      runtime->hw.rate_min = fp->rate_min;
    }
//#line  2065
    if (runtime->hw.rate_max < fp->rate_max) {
//#line  2066
      runtime->hw.rate_max = fp->rate_max;
    }
//#line  2067
    if (runtime->hw.channels_min > fp->channels) {
//#line  2068
      runtime->hw.channels_min = fp->channels;
    }
//#line  2069
    if (runtime->hw.channels_max < fp->channels) {
//#line  2070
      runtime->hw.channels_max = fp->channels;
    }
//#line  2071
    if (fp->fmt_type == 2U) {
//#line  2071
      if (fp->frame_size > 0U) {
//#line  2073
        tmp = (size_t )fp->frame_size;
//#line  2073
        runtime->hw.period_bytes_max = tmp;
//#line  2073
        runtime->hw.period_bytes_min = tmp;
      }
    }
//#line  2059
    p = (struct list_head *)p->next;
  }
//#line  2082
  snd_pcm_hw_constraint_minmax(runtime, 12, 1000U, ~ 0U);
//#line  2086
  err = check_hw_params_convention(subs);
//#line  2087
  if (err < 0) {
//#line  2088
    return (err);
  } else
//#line  2089
  if (err) {
//#line  2091
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 11, & hw_rule_rate, subs, 1, 10, -1);
//#line  2091
    if (err < 0) {
//#line  2096
      return (err);
    }
//#line  2097
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 10, & hw_rule_channels, subs, 1, 11,
                                   -1);
//#line  2097
    if (err < 0) {
//#line  2102
      return (err);
    }
//#line  2103
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 1, & hw_rule_format, subs, 11, 10,
                                   -1);
//#line  2103
    if (err < 0) {
//#line  2108
      return (err);
    }
//#line  2109
    err = snd_usb_pcm_check_knot(runtime, subs);
//#line  2109
    if (err < 0) {
//#line  2110
      return (err);
    }
  }
//#line  2112
  return (0);
}
}
//#line  2115 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_open(struct snd_pcm_substream *substream , int direction ) 
{ 
  struct snd_usb_stream *as ;
  struct snd_pcm_runtime *runtime ;
  struct snd_usb_substream *subs ;
  int tmp ;

  {
//#line  2117
  as = (struct snd_usb_stream *)substream->private_data;
//#line  2118
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  2119
  subs = & as->substream[direction];
//#line  2121
  subs->interface = -1;
//#line  2122
  subs->format = 0U;
//#line  2123
  runtime->hw = (struct snd_pcm_hardware )snd_usb_hardware;
//#line  2124
  runtime->private_data = (void * __attribute__((__recursive__)) )subs;
//#line  2125
  subs->pcm_substream = (struct snd_pcm_substream * __attribute__((__recursive__)) )substream;
//#line  2126
  tmp = setup_hw_info(runtime, subs);
//#line  2126
  return (tmp);
}
}
//#line  2129 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_pcm_close(struct snd_pcm_substream *substream , int direction ) 
{ 
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;

  {
//#line  2131
  as = (struct snd_usb_stream *)substream->private_data;
//#line  2132
  subs = & as->substream[direction];
//#line  2134
  if (subs->interface >= 0) {
//#line  2135
    usb_set_interface(subs->dev, subs->interface, 0);
//#line  2136
    subs->interface = -1;
  }
//#line  2138
  subs->pcm_substream = (struct snd_pcm_substream * __attribute__((__recursive__)) )((void *)0);
//#line  2139
  return (0);
}
}
//#line  2142 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_playback_open(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
//#line  2144
  tmp = snd_usb_pcm_open(substream, 0);
//#line  2144
  return (tmp);
}
}
//#line  2147 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_playback_close(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
//#line  2149
  tmp = snd_usb_pcm_close(substream, 0);
//#line  2149
  return (tmp);
}
}
//#line  2152 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_capture_open(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
//#line  2154
  tmp = snd_usb_pcm_open(substream, 1);
//#line  2154
  return (tmp);
}
}
//#line  2157 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_capture_close(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
//#line  2159
  tmp = snd_usb_pcm_close(substream, 1);
//#line  2159
  return (tmp);
}
}
//#line  2162 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_usb_playback_ops  = 
//#line  2162
     {& snd_usb_playback_open, & snd_usb_playback_close, & snd_pcm_lib_ioctl, & snd_usb_hw_params,
    & snd_usb_hw_free, & snd_usb_pcm_prepare, & snd_usb_pcm_playback_trigger, & snd_usb_pcm_pointer,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             void *buf , snd_pcm_uframes_t count ))0, (int (*)(struct snd_pcm_substream *substream ,
                                                               int channel , snd_pcm_uframes_t pos ,
                                                               snd_pcm_uframes_t count ))0,
    & snd_pcm_get_vmalloc_page, (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
//#line  2174 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_usb_capture_ops  = 
//#line  2174
     {& snd_usb_capture_open, & snd_usb_capture_close, & snd_pcm_lib_ioctl, & snd_usb_hw_params,
    & snd_usb_hw_free, & snd_usb_pcm_prepare, & snd_usb_pcm_capture_trigger, & snd_usb_pcm_pointer,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             void *buf , snd_pcm_uframes_t count ))0, (int (*)(struct snd_pcm_substream *substream ,
                                                               int channel , snd_pcm_uframes_t pos ,
                                                               snd_pcm_uframes_t count ))0,
    & snd_pcm_get_vmalloc_page, (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
//#line  2195 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
unsigned int snd_usb_combine_bytes(unsigned char *bytes , int size ) 
{ 


  {
//#line  2197
  switch (size) {
  case 1: 
//#line  2198
  return ((unsigned int )*bytes);
  case 2: 
//#line  2199
  return ((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8));
  case 3: 
//#line  2200
  return (((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8)) | ((unsigned int )*(bytes + 2) << 16));
  case 4: 
//#line  2201
  return ((((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8)) | ((unsigned int )*(bytes + 2) << 16)) | ((unsigned int )*(bytes + 3) << 24));
  default: 
//#line  2202
  return (0U);
  }
}
}
//#line  2210 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
void *snd_usb_find_desc(void *descstart , int desclen , void *after , u8 dtype ) 
{ 
  u8 *p ;
  u8 *end ;
  u8 *next ;

  {
//#line  2214
  p = (u8 *)descstart;
//#line  2215
  end = p + desclen;
//#line  2216
  while ((unsigned long )p < (unsigned long )end) {
//#line  2217
    if ((int )*(p + 0) < 2) {
//#line  2218
      return ((void *)0);
    }
//#line  2219
    next = p + (int )*(p + 0);
//#line  2220
    if ((unsigned long )next > (unsigned long )end) {
//#line  2221
      return ((void *)0);
    }
//#line  2222
    if ((int )*(p + 1) == (int )dtype) {
//#line  2222
      if (! after) {
//#line  2223
        return ((void *)p);
      } else
//#line  2222
      if ((unsigned long )((void *)p) > (unsigned long )after) {
//#line  2223
        return ((void *)p);
      }
    }
//#line  2225
    p = next;
  }
//#line  2227
  return ((void *)0);
}
}
//#line  2233 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
void *snd_usb_find_csint_desc(void *buffer , int buflen , void *after , u8 dsubtype ) 
{ 
  unsigned char *p ;
  void *tmp ;

  {
//#line  2235
  p = (unsigned char *)after;
//#line  2237
  while (1) {
//#line  2237
    tmp = snd_usb_find_desc(buffer, buflen, (void *)p, (u8 )((1 << 5) | 4));
//#line  2237
    p = (unsigned char *)tmp;
//#line  2237
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
//#line  2237
      break;
    }
//#line  2239
    if ((int )*(p + 0) >= 3) {
//#line  2239
      if ((int )*(p + 2) == (int )dsubtype) {
//#line  2240
        return ((void *)p);
      }
    }
  }
//#line  2242
  return ((void *)0);
}
}
//#line  2249 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
int snd_usb_ctl_msg(struct usb_device *dev , unsigned int pipe , __u8 request , __u8 requesttype ,
                    __u16 value , __u16 index___0 , void *data , __u16 size , int timeout ) 
{ 
  int err ;
  void *buf ;
  size_t __len ;
  void *__ret ;

  {
//#line  2254
  buf = (void *)0;
//#line  2256
  if ((int )size > 0) {
//#line  2257
    buf = kmemdup((void const   *)data, (size_t )size, 208U);
//#line  2258
    if (! buf) {
//#line  2259
      return (-12);
    }
  }
//#line  2261
  err = usb_control_msg(dev, pipe, request, requesttype, value, index___0, buf, size,
                        timeout);
//#line  2263
  if ((int )size > 0) {
//#line  2264
    __len = (size_t )size;
//#line  2264
    __ret = __builtin_memcpy(data, (void const   *)buf, __len);
//#line  2265
    kfree((void const   *)buf);
  }
//#line  2267
  return (err);
}
}
//#line  2275
static int usb_audio_probe(struct usb_interface * __attribute__((__extraptr__(sizeof(struct usb_device *),"Nonstub_get_usb_device"))) intf ,
                           struct usb_device_id  const  *id___0 ) ;
//#line  2277
static void usb_audio_disconnect(struct usb_interface * __attribute__((__noderef__,
                                 __address_space__(2))) intf ) ;
//#line  2280
static int usb_audio_suspend(struct usb_interface *intf , pm_message_t message ) ;
//#line  2281
static int usb_audio_resume(struct usb_interface *intf ) ;
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_0  =    {(char const   * __attribute__((__nullterm__)) )"Creative Labs", (char const   * __attribute__((__recursive__)) )"Sound Blaster MP3+",
    (int16_t )-2, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_1  =    {(char const   * __attribute__((__nullterm__)) )"Logitech, Inc.", (char const   * __attribute__((__recursive__)) )"QuickCam Pro 9000",
    (int16_t )-2, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_2  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UX256",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_3  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MU1000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_4  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MU2000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_5  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MU500",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_6  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UW500",
    (int16_t )3, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_7  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF6",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_8  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF7",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_9  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF8",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_10  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UX96",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_11  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UX16",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_12  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"EOS BX",
    (int16_t )3, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_13  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UC-MX",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_14  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UC-KX",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_15  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"S08",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_16  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CLP-150",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_17  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CLP-170",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_18  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"P-250",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_19  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"TYROS",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_20  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PF-500",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_21  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"S90",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_22  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF-R",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_23  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MDP-5",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_24  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-204",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_25  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-206",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_26  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-208",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_27  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-210",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_28  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-1100",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_29  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-2100",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_30  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CLP-175",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_31  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-K1",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_32  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"EZ-J24",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_33  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"EZ-250i",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_34  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF ES 6",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_35  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF ES 7",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_36  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"MOTIF ES 8",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_37  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-301",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_38  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-303",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_39  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-305",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_40  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-307",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_41  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-309",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_42  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CVP-309GP",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_43  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-1500",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_44  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-3000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_45  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"ELS-01/01C",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_46  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PSR-295/293",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_47  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DGX-205/203",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_48  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DGX-305",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_49  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DGX-505",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_50  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_51  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_52  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_53  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_54  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_55  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_56  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_57  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_58  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_59  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_60  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_61  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_62  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_63  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_64  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_65  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_66  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_67  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_68  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )0, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_69  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_70  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_71  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_72  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_73  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DGP-7",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_74  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DGP-5",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_75  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_76  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"CS1D",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_77  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DSP1D",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_78  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DME32",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_79  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DM2000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_80  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"02R96",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_81  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"ACU16-C",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_82  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"NHB32-C",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_83  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DM1000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_84  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"01V96",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_85  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"SPX2000",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_86  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"PM5D",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_87  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DME64N",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_88  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DME24N",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_89  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_90  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_91  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )((void *)0),
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_92  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"DTX",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_93  =    {(char const   * __attribute__((__nullterm__)) )"Yamaha", (char const   * __attribute__((__recursive__)) )"UB99",
    (int16_t )-1, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_96  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    2, 4U, 0U, 0U, 0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)9, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_97  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    2, 2U, 0U, 0U, 1, (unsigned char)1, (unsigned char)1, (unsigned char)128, (unsigned char)129,
    (unsigned char)5, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_98  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_95[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )12, (void const   * __attribute__((__recursive__)) )(& __constr_expr_96)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )12,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_97)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_98)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_94  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"UA-100",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_95)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_101  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_100[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_101)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_99  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-4",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_100)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_104  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )63,
    (uint16_t )63};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_103[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_104)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_102  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SC-8850",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_103)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_107  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )5,
    (uint16_t )5};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_106[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_107)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_105  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"U-8",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_106)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_110  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_109[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_110)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_108  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-2",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_109)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_113  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )19,
    (uint16_t )19};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_112[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_113)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_111  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SC-8820",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_112)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_116  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_115[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_116)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_114  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"PC-300",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_115)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_119  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_118[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_119)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_117  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-1",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_118)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_122  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )19,
    (uint16_t )19};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_121[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_122)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_120  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SK-500",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_121)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_125  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    32, 2U, 0U, 0U, 0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)1, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_126  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    32, 2U, 0U, 0U, 1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)129,
    (unsigned char)1, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_127  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_124[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )12, (void const   * __attribute__((__recursive__)) )(& __constr_expr_125)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )12,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_126)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_127)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_123  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SC-D70",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_124)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_129[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_128  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-5",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_129)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_131  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_130  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"XV-5050",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_131)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_133  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_132  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-880",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_133)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_136  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_135[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_136)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_134  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"SD-90",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_135)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_139  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_138[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_139)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_137  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"MMP-2",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_138)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_141  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_140  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"V-SYNTH",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_141)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_143  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )63,
    (uint16_t )63};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_142  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-550",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_143)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_146  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    32, 2U, 0U, 0U, 1, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1,
    (unsigned char)1, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  __constr_expr_147  = 
//#line  2287
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    32, 2U, 0U, 0U, 2, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)130,
    (unsigned char)1, 0U, (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_148  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_145[5]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )12,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_146)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )12, (void const   * __attribute__((__recursive__)) )(& __constr_expr_147)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )3, (uint16_t )3,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_148)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_144  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-20",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_145)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_150  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_149  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"SD-20",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_150)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_152  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_151  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"SD-80",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_152)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_154[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )15,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )3, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_153  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-700",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_154)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_156  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_155  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"XV-2020",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_156)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_158  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_157  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"VariOS",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_158)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_160  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_159  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"PCR",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_160)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_162  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_161  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"Digital Piano",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_162)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_164[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )3, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_163  =    {(char const   * __attribute__((__nullterm__)) )"BOSS", (char const   * __attribute__((__recursive__)) )"GS-10",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(& __constr_expr_164)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_166  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_165  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"GI-20",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_166)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_168  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_167  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"RS-70",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_168)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_171  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_170[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )13, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )13,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )3, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_171)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_169  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"UA-1000",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_170)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_173[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_172  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_173)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_175  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_174  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_175)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_177[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_176  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"PCR-A",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_177)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_179  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_178  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"PCR-A",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_179)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_181[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )1, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )2, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_180  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-3FX",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_181)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_182  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-1SX",
    (int16_t )0, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_183  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"EXR Series",
    (int16_t )0, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_185  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_184  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"PCR-1",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_185)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_187  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_186  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SP-606",
    (int16_t )3, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_187)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_189  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_188  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"FANTOM-X",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_189)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_191[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )15,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_190  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-25",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_191)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_193  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_192  =    {(char const   * __attribute__((__nullterm__)) )"BOSS", (char const   * __attribute__((__recursive__)) )"DR-880",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_193)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_195  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_194  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )0,
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_195)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_198  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_197[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )14, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )14,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_198)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_196  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"UA-101",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_197)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_200  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_199  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"G-70",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_200)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_202  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_201  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"PC-50",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_202)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_204[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_203  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-1EX",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_204)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_206  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_205  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UM-3EX",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_206)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_208[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )15,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_207  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-4FX",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_208)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_210  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_209  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"Juno-G",
    (int16_t )0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_210)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_213  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_212[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_213)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_211  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SH-201",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_212)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_216  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_215[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_216)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_214  =    {(char const   * __attribute__((__nullterm__)) )"Roland", (char const   * __attribute__((__recursive__)) )"SonicCell",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_215)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_219  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_218[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_219)}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_217  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_218)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_221[4]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )15,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )15, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )-1, (unsigned short)0,
      (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_220  =    {(char const   * __attribute__((__nullterm__)) )"EDIROL", (char const   * __attribute__((__recursive__)) )"UA-25EX",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(__constr_expr_221)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_223  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_222  =    {(char const   * __attribute__((__nullterm__)) )"Hercules", (char const   * __attribute__((__recursive__)) )"DJ Console (WE)",
    (int16_t )4, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& __constr_expr_223)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_225  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_224  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 2x2",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_225)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_227  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_226  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 1x1",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_227)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_229  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_228  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"Keystation",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_229)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_231  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_230  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 4x4",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_231)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_233  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_232  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 8x8",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_233)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_235  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_234  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 8x8",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_235)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_237  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )3};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_236  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"MidiSport 2x4",
    (int16_t )-1, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_237)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_240  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_239[11]  = 
//#line  2287
  {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )3, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )4, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )5, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )6, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )7, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )8, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )9, (uint16_t )5,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_240)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_238  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"Quattro",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(& __constr_expr_239)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_242  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_241  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"AudioPhile",
    (int16_t )6, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_242)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_244  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_243  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"Ozone",
    (int16_t )3, (uint16_t )5, (void const   * __attribute__((__recursive__)) )(& __constr_expr_244)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_247  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_246[11]  = 
//#line  2287
  {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )3, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )4, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )5, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )6, (uint16_t )0, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )7, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )8, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )9, (uint16_t )5,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_247)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_245  =    {(char const   * __attribute__((__nullterm__)) )"M-Audio", (char const   * __attribute__((__recursive__)) )"OmniStudio",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(& __constr_expr_246)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_250  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_249[5]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )11,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )2, (uint16_t )11, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )3, (uint16_t )5,
      (void const   * __attribute__((__recursive__)) )(& __constr_expr_250)}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_248  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(& __constr_expr_249)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_251  =    {(char const   * __attribute__((__nullterm__)) )"Casio", (char const   * __attribute__((__recursive__)) )"PL-40R",
    (int16_t )0, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_252  =    {(char const   * __attribute__((__nullterm__)) )"Casio", (char const   * __attribute__((__recursive__)) )"Keyboard",
    (int16_t )0, (uint16_t )4, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_254[3]  = {      {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )0, (uint16_t )7, (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0,
      (char const   * __attribute__((__recursive__)) )0, (int16_t )1, (uint16_t )0,
      (void const   * __attribute__((__recursive__)) )0}, 
        {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
      (int16_t )-1, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0}};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_253  =    {(char const   * __attribute__((__nullterm__)) )"MOTU", (char const   * __attribute__((__recursive__)) )"Fastlane",
    (int16_t )-1, (uint16_t )1, (void const   * __attribute__((__recursive__)) )(& __constr_expr_254)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_256  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )33023,
    (uint16_t )33023};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_255  =    {(char const   * __attribute__((__nullterm__)) )"Emagic", (char const   * __attribute__((__recursive__)) )0,
    (int16_t )2, (uint16_t )8, (void const   * __attribute__((__recursive__)) )(& __constr_expr_256)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_258  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )33023,
    (uint16_t )33023};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_257  =    {(char const   * __attribute__((__nullterm__)) )"Emagic", (char const   * __attribute__((__recursive__)) )0,
    (int16_t )2, (uint16_t )8, (void const   * __attribute__((__recursive__)) )(& __constr_expr_258)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_260  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )32783,
    (uint16_t )32771};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_259  =    {(char const   * __attribute__((__nullterm__)) )"Emagic", (char const   * __attribute__((__recursive__)) )0,
    (int16_t )2, (uint16_t )8, (void const   * __attribute__((__recursive__)) )(& __constr_expr_260)};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_261  =    {(char const   * __attribute__((__nullterm__)) )"TerraTec", (char const   * __attribute__((__recursive__)) )"PHASE 26",
    (int16_t )3, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_262  =    {(char const   * __attribute__((__nullterm__)) )"TerraTec", (char const   * __attribute__((__recursive__)) )"PHASE 26",
    (int16_t )3, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_263  =    {(char const   * __attribute__((__nullterm__)) )"TerraTec", (char const   * __attribute__((__recursive__)) )"PHASE 26",
    (int16_t )3, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_264  =    {(char const   * __attribute__((__nullterm__)) )"Miditech", (char const   * __attribute__((__recursive__)) )"Play\'n Roll",
    (int16_t )0, (uint16_t )9, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_265  =    {(char const   * __attribute__((__nullterm__)) )"Stanton", (char const   * __attribute__((__recursive__)) )"ScratchAmp",
    (int16_t )-2, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_266  =    {(char const   * __attribute__((__nullterm__)) )"Stanton", (char const   * __attribute__((__recursive__)) )"ScratchAmp",
    (int16_t )-2, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_267  =    {(char const   * __attribute__((__nullterm__)) )"Novation", (char const   * __attribute__((__recursive__)) )"ReMOTE Audio/XStation",
    (int16_t )4, (uint16_t )6, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_268  =    {(char const   * __attribute__((__nullterm__)) )"Novation", (char const   * __attribute__((__recursive__)) )"Speedio",
    (int16_t )3, (uint16_t )6, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_269  =    {(char const   * __attribute__((__nullterm__)) )"Novation", (char const   * __attribute__((__recursive__)) )"ReMOTE25",
    (int16_t )0, (uint16_t )6, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_270  =    {(char const   * __attribute__((__nullterm__)) )"Rane", (char const   * __attribute__((__recursive__)) )"SL-1",
    (int16_t )-2, (unsigned short)0, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_271  =    {(char const   * __attribute__((__nullterm__)) )"Miditech", (char const   * __attribute__((__recursive__)) )"Midistart-2",
    (int16_t )0, (uint16_t )9, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_272  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )0, (uint16_t )9, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  __constr_expr_273  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (int16_t )-1, (uint16_t )2, (void const   * __attribute__((__recursive__)) )0};
//#line  2287 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct usb_device_id usb_audio_ids[190]  = 
//#line  2287
  {      {(__u16 )3, (__u16 )1054, (__u16 )12304, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_0))}, 
        {(__u16 )3,
      (__u16 )1054, (__u16 )16130, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1054, (__u16 )16132, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1054, (__u16 )16138, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2128, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2222, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2246, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2288, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2293, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2294, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1133, (__u16 )2448, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_1))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4096, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_2))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4097, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_3))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4098, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_4))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4099, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_5))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4100, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_6))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4101, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_7))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4102, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_8))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4103, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_9))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4104, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_10))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4105, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_11))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4106, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_12))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4108, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_13))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4109, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_14))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4110, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_15))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4111, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_16))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4112, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_17))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4113, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_18))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4114, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_19))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4115, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_20))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4116, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_21))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4117, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_22))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4118, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_23))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4119, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_24))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4120, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_25))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4121, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_26))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4122, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_27))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4123, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_28))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4124, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_29))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4125, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_30))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4126, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_31))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4127, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_32))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4128, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_33))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4129, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_34))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4130, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_35))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4131, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_36))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4132, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_37))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4133, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_38))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4134, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_39))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4135, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_40))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4136, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_41))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4137, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_42))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4138, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_43))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4139, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_44))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4142, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_45))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4144, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_46))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4145, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_47))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4146, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_48))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4147, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_49))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4148, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_50))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4149, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_51))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4150, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_52))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4151, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_53))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4152, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_54))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4153, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_55))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4154, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_56))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4155, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_57))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4156, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_58))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4157, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_59))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4158, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_60))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4159, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_61))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4160, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_62))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4161, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_63))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4162, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_64))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4163, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_65))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4164, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_66))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4165, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_67))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4174, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_68))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4175, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_69))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4176, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_70))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4177, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_71))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4178, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_72))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )8192, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_73))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )8193, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_74))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )8194, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_75))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20480, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_76))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20481, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_77))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20482, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_78))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20483, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_79))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20484, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_80))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20485, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_81))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20486, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_82))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20487, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_83))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20488, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_84))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20489, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_85))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20490, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_86))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20491, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_87))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20492, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_88))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20493, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_89))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20494, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_90))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20495, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_91))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )28672, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_92))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )28688, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_93))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )0, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_94))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_99))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )3, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_102))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )4, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_105))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )5, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_108))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )7, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_111))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )8, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_114))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )9, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_117))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )11, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_120))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )12, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_123))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )16, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_128))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )18, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_130))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )20, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_132))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )22, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_134))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )27, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_137))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )29, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_140))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )35, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_142))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )37, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_144))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )39, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_149))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )41, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_151))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )43, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_153))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )45, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_155))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )47, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_157))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )51, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_159))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )55, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_161))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )59, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_163))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )64, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_165))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )66, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_167))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )68, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_169))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )71, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_172))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )72, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_174))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )76, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_176))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )77, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_178))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )80, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_180))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )82, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_182))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )96, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_183))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )101, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_184))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )106, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_186))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )109, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_188))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )116, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_190))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )117, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_192))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )122, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_194))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )125, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_196))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )128, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_199))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )139, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_201))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )150, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_203))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )154, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_205))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )163, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_207))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )166, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_209))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )173, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_211))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )194, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_214))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )218, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_217))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )230, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_220))}, 
        {(__u16 )131,
      (__u16 )1784, (__u16 )45056, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_222))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4098, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_224))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4113, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_226))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4117, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_228))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4129, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_230))}, 
        {(__u16 )15, (__u16 )1891, (__u16 )4145, (__u16 )256, (__u16 )265, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_232))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4147, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_234))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4161, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_236))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )8193, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_238))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )8195, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_241))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )8200, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_243))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )8205, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_245))}, 
        {(__u16 )3, (__u16 )1891, (__u16 )8217, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_248))}, 
        {(__u16 )3,
      (__u16 )1999, (__u16 )26625, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_251))}, 
        {(__u16 )3, (__u16 )1999, (__u16 )26626, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_252))}, 
        {(__u16 )35,
      (__u16 )2045, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (__u8 )2, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_253))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_255))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_257))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )3, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_259))}, 
        {(__u16 )131, (__u16 )3277, (__u16 )18, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_261))}, 
        {(__u16 )131,
      (__u16 )3277, (__u16 )19, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_262))}, 
        {(__u16 )131, (__u16 )3277, (__u16 )20, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_263))}, 
        {(__u16 )3,
      (__u16 )3277, (__u16 )53, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_264))}, 
        {(__u16 )3, (__u16 )4157, (__u16 )256, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_265))}, 
        {(__u16 )3,
      (__u16 )4157, (__u16 )257, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_266))}, 
        {(__u16 )131, (__u16 )4661, (__u16 )1, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_267))}, 
        {(__u16 )131,
      (__u16 )4661, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_268))}, 
        {(__u16 )131, (__u16 )4661, (__u16 )18017, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_269))}, 
        {(__u16 )3,
      (__u16 )5093, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_270))}, 
        {(__u16 )3, (__u16 )18258, (__u16 )17, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_271))}, 
        {(__u16 )3,
      (__u16 )28932, (__u16 )8706, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_272))}, 
        {(__u16 )384, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )3, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_273))}, 
        {(__u16 )384, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )0, (__u16 )0, (__u16 )0, (__u16 )0, (__u16 )0, (__u8 )0, (__u8 )0, (__u8 )0,
      (__u8 )0, (__u8 )0, (__u8 )0, (struct snd_usb_audio_quirk *)0}};
//#line  2298
extern struct usb_device_id  const  __mod_usb_device_table  __attribute__((__unused__,
__alias__("usb_audio_ids"))) ;
//#line  2300 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct usb_driver usb_audio_driver  = 
//#line  2300
     {"snd-usb-audio", & usb_audio_probe, & usb_audio_disconnect, (int (*)(struct usb_interface *intf ,
                                                                         unsigned int code ,
                                                                         void *buf ))0,
    & usb_audio_suspend, & usb_audio_resume, (int (*)(struct usb_interface *intf ))0,
    (int (*)(struct usb_interface *intf ))0, (int (*)(struct usb_interface *intf ))0,
    (struct usb_device_id  const  *)(usb_audio_ids), {{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0,
                                                                                 (struct lock_class *)0,
                                                                                 (char const   *)0}},
                                                      {(struct list_head * __attribute__((__recursive__)) )0,
                                                       (struct list_head * __attribute__((__recursive__)) )0}},
    {{(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
      (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
      (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
      (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
     0}, 0U, 0U, 0U};
//#line  2405 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
__inline static void ( __attribute__((__always_inline__)) proc_pcm_format_add)(struct snd_usb_stream *stream ) 
{ 


  {
//#line  2407
  return;
}
}
//#line  2420 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct lock_class_key __key___5  ;
//#line  2415 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void init_substream(struct snd_usb_stream *as , int stream , struct audioformat *fp ) 
{ 
  struct snd_usb_substream *subs ;
  struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) *tmp ;

  {
//#line  2417
  subs = & as->substream[stream];
//#line  2419
  INIT_LIST_HEAD(& subs->fmt_list);
//#line  2420
  while (1) {
//#line  2420
    __spin_lock_init(& subs->lock, "&subs->lock", & __key___5);
//#line  2420
    break;
  }
//#line  2422
  subs->stream = (struct snd_usb_stream * __attribute__((__recursive__)) )as;
//#line  2423
  subs->direction = stream;
//#line  2424
  subs->dev = (as->chip)->dev;
//#line  2425
  if ((unsigned int )(subs->dev)->speed == 2U) {
//#line  2426
    subs->ops = audio_urb_ops[stream];
  } else {
//#line  2428
    subs->ops = audio_urb_ops_high_speed[stream];
//#line  2429
    switch ((int )(as->chip)->usb_id) {
    case (1054 << 16) | 16130: 
    case (1054 << 16) | 16132: 
    case (1054 << 16) | 16138: 
//#line  2433
    subs->ops.retire_sync = & retire_playback_sync_urb_hs_emu;
//#line  2434
    break;
    }
  }
//#line  2437
  if (stream == 0) {
//#line  2437
    tmp = & snd_usb_playback_ops;
  } else {
//#line  2437
    tmp = & snd_usb_capture_ops;
  }
//#line  2437
  snd_pcm_set_ops((struct snd_pcm *)as->pcm, stream, (struct snd_pcm_ops *)tmp);
//#line  2441
  list_add_tail(& fp->list, & subs->fmt_list);
//#line  2442
  subs->formats |= 1ULL << fp->format;
//#line  2443
  subs->endpoint = (int )fp->endpoint;
//#line  2444
  (subs->num_formats) ++;
//#line  2445
  subs->fmt_type = fp->fmt_type;
//#line  2446
  return;
}
}
//#line  2452 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void free_substream(struct snd_usb_substream *subs ) 
{ 
  struct list_head *p ;
  struct list_head *n ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;

  {
//#line  2456
  if (! subs->num_formats) {
//#line  2457
    return;
  }
//#line  2458
  p = (struct list_head *)subs->fmt_list.next;
//#line  2458
  n = (struct list_head *)p->next;
//#line  2458
  while ((unsigned long )p != (unsigned long )(& subs->fmt_list)) {
//#line  2459
    __mptr = (struct list_head  const  *)p;
//#line  2459
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  2460
    kfree((void const   *)fp->rate_table);
//#line  2461
    kfree((void const   *)fp);
//#line  2458
    p = n;
//#line  2458
    n = (struct list_head *)p->next;
  }
//#line  2463
  kfree((void const   *)subs->rate_list.list);
//#line  2464
  return;
}
}
//#line  2470 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_audio_stream_free(struct snd_usb_stream *stream ) 
{ 


  {
//#line  2472
  free_substream(& stream->substream[0]);
//#line  2473
  free_substream(& stream->substream[1]);
//#line  2474
  list_del(& stream->list);
//#line  2475
  kfree((void const   *)stream);
//#line  2476
  return;
}
}
//#line  2478 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_audio_pcm_free(struct snd_pcm *pcm ) 
{ 
  struct snd_usb_stream *stream ;

  {
//#line  2480
  stream = (struct snd_usb_stream *)pcm->private_data;
//#line  2481
  if (stream) {
//#line  2482
    stream->pcm = (struct snd_pcm * __attribute__((__recursive__)) )((void *)0);
//#line  2483
    snd_usb_audio_stream_free(stream);
  }
//#line  2485
  return;
}
}
//#line  2493 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int add_audio_endpoint(struct snd_usb_audio *chip , int stream , struct audioformat *fp ) 
{ 
  struct list_head *p ;
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;
  struct snd_pcm *pcm ;
  int err ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
//#line  2501
  p = (struct list_head *)chip->pcm_list.next;
//#line  2501
  while (1) {
//#line  2501
    __builtin_prefetch((void const   *)p->next);
//#line  2501
    if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  2501
      break;
    }
//#line  2502
    __mptr = (struct list_head  const  *)p;
//#line  2502
    as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  2503
    if (as->fmt_type != fp->fmt_type) {
//#line  2504
      goto __Cont;
    }
//#line  2505
    subs = & as->substream[stream];
//#line  2506
    if (! subs->endpoint) {
//#line  2507
      goto __Cont;
    }
//#line  2508
    if (subs->endpoint == (int )fp->endpoint) {
//#line  2509
      list_add_tail(& fp->list, & subs->fmt_list);
//#line  2510
      (subs->num_formats) ++;
//#line  2511
      subs->formats |= 1ULL << fp->format;
//#line  2512
      return (0);
    }
    __Cont: /* CIL Label */ 
//#line  2501
    p = (struct list_head *)p->next;
  }
//#line  2516
  p = (struct list_head *)chip->pcm_list.next;
//#line  2516
  while (1) {
//#line  2516
    __builtin_prefetch((void const   *)p->next);
//#line  2516
    if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  2516
      break;
    }
//#line  2517
    __mptr___0 = (struct list_head  const  *)p;
//#line  2517
    as = (struct snd_usb_stream *)((char *)__mptr___0 - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  2518
    if (as->fmt_type != fp->fmt_type) {
//#line  2519
      goto __Cont___0;
    }
//#line  2520
    subs = & as->substream[stream];
//#line  2521
    if (subs->endpoint) {
//#line  2522
      goto __Cont___0;
    }
//#line  2523
    err = snd_pcm_new_stream((struct snd_pcm *)as->pcm, stream, 1);
//#line  2524
    if (err < 0) {
//#line  2525
      return (err);
    }
//#line  2526
    init_substream(as, stream, fp);
//#line  2527
    return (0);
    __Cont___0: /* CIL Label */ 
//#line  2516
    p = (struct list_head *)p->next;
  }
//#line  2531
  tmp = kzalloc(sizeof(*as), 208U);
//#line  2531
  as = (struct snd_usb_stream *)tmp;
//#line  2532
  if (! as) {
//#line  2533
    return (-12);
  }
//#line  2534
  as->pcm_index = chip->pcm_devs;
//#line  2535
  as->chip = chip;
//#line  2536
  as->fmt_type = fp->fmt_type;
//#line  2537
  if (stream == 0) {
//#line  2537
    tmp___0 = 0;
  } else {
//#line  2537
    tmp___0 = 1;
  }
//#line  2537
  if (stream == 0) {
//#line  2537
    tmp___1 = 1;
  } else {
//#line  2537
    tmp___1 = 0;
  }
//#line  2537
  err = snd_pcm_new(chip->card, (char * __attribute__((__nullterm__)) )"USB Audio",
                    chip->pcm_devs, tmp___1, tmp___0, & pcm);
//#line  2541
  if (err < 0) {
//#line  2542
    kfree((void const   *)as);
//#line  2543
    return (err);
  }
//#line  2545
  as->pcm = (struct snd_pcm * __attribute__((__recursive__)) )pcm;
//#line  2546
  pcm->private_data = (void * __attribute__((__recursive__)) )as;
//#line  2547
  pcm->private_free = & snd_usb_audio_pcm_free;
//#line  2548
  pcm->info_flags = 0U;
//#line  2549
  if (chip->pcm_devs > 0) {
//#line  2550
    sprintf(pcm->name, "USB Audio #%d", chip->pcm_devs);
  } else {
//#line  2552
    strcpy(pcm->name, "USB Audio");
  }
//#line  2554
  init_substream(as, stream, fp);
//#line  2556
  list_add(& as->list, & chip->pcm_list);
//#line  2557
  (chip->pcm_devs) ++;
//#line  2559
  proc_pcm_format_add(as);
//#line  2561
  return (0);
}
}
//#line  2568 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int is_big_endian_format(struct snd_usb_audio *chip , struct audioformat *fp ) 
{ 


  {
//#line  2570
  switch ((int )chip->usb_id) {
  case (1891 << 16) | 8193: 
//#line  2572
  if ((int )fp->endpoint & 128) {
//#line  2573
    return (1);
  }
//#line  2574
  break;
  case (1891 << 16) | 8195: 
//#line  2576
  if (device_setup[chip->index] == 0) {
//#line  2578
    return (1);
  } else
//#line  2576
  if ((int )fp->altsetting == 1) {
//#line  2578
    return (1);
  } else
//#line  2576
  if ((int )fp->altsetting == 2) {
//#line  2578
    return (1);
  } else
//#line  2576
  if ((int )fp->altsetting == 3) {
//#line  2578
    return (1);
  }
  }
//#line  2580
  return (0);
}
}
//#line  2592 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_format_i_type(struct snd_usb_audio *chip , struct audioformat *fp ,
                                     int format , unsigned char *fmt ) 
{ 
  int pcm_format ;
  int sample_width ;
  int sample_bytes ;
  int tmp ;
  int tmp___0 ;

  {
//#line  2599
  pcm_format = -1;
//#line  2600
  sample_width = (int )*(fmt + 6);
//#line  2601
  sample_bytes = (int )*(fmt + 5);
//#line  2602
  switch (format) {
  case 0: 
//#line  2604
  printk("<6>%d:%u:%d : format type 0 is detected, processed as PCM\n", (chip->dev)->devnum,
         fp->iface, (int )fp->altsetting);
  case 1: 
//#line  2608
  if (sample_width > sample_bytes * 8) {
//#line  2609
    printk("<6>%d:%u:%d : sample bitwidth %d in over sample bytes %d\n", (chip->dev)->devnum,
           fp->iface, (int )fp->altsetting, sample_width, sample_bytes);
  }
//#line  2614
  switch ((int )*(fmt + 5)) {
  case 1: 
//#line  2616
  pcm_format = 0;
//#line  2617
  break;
  case 2: 
//#line  2619
  tmp = is_big_endian_format(chip, fp);
//#line  2619
  if (tmp) {
//#line  2620
    pcm_format = 3;
  } else {
//#line  2622
    pcm_format = 2;
  }
//#line  2623
  break;
  case 3: 
//#line  2625
  tmp___0 = is_big_endian_format(chip, fp);
//#line  2625
  if (tmp___0) {
//#line  2626
    pcm_format = 33;
  } else {
//#line  2628
    pcm_format = 32;
  }
//#line  2629
  break;
  case 4: 
//#line  2631
  pcm_format = 10;
//#line  2632
  break;
  default: 
//#line  2634
  printk("<6>%d:%u:%d : unsupported sample bitwidth %d in %d bytes\n", (chip->dev)->devnum,
         fp->iface, (int )fp->altsetting, sample_width, sample_bytes);
//#line  2637
  break;
  }
//#line  2639
  break;
  case 2: 
//#line  2641
  pcm_format = 1;
//#line  2645
  if (chip->usb_id == (u32 )((1274 << 16) | 16897)) {
//#line  2646
    pcm_format = 0;
  }
//#line  2647
  break;
  case 3: 
//#line  2649
  pcm_format = 14;
//#line  2650
  break;
  case 4: 
//#line  2652
  pcm_format = 21;
//#line  2653
  break;
  case 5: 
//#line  2655
  pcm_format = 20;
//#line  2656
  break;
  default: 
//#line  2658
  printk("<6>%d:%u:%d : unsupported format type %d\n", (chip->dev)->devnum, fp->iface,
         (int )fp->altsetting, format);
//#line  2660
  break;
  }
//#line  2662
  return (pcm_format);
}
}
//#line  2676 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_format_rates(struct snd_usb_audio *chip , struct audioformat *fp ,
                                    unsigned char *fmt , int offset ) 
{ 
  int nr_rates ;
  int tmp ;
  int r ;
  int idx ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int rate ;
  unsigned int tmp___2 ;

  {
//#line  2679
  nr_rates = (int )*(fmt + offset);
//#line  2681
  if (nr_rates) {
//#line  2681
    tmp = nr_rates;
  } else {
//#line  2681
    tmp = 2;
  }
//#line  2681
  if ((int )*(fmt + 0) < (offset + 1) + 3 * tmp) {
//#line  2682
    printk("<3>%d:%u:%d : invalid FORMAT_TYPE desc\n", (chip->dev)->devnum, fp->iface,
           (int )fp->altsetting);
//#line  2684
    return (-1);
  }
//#line  2687
  if (nr_rates) {
//#line  2693
    tmp___0 = kmalloc(sizeof(int ) * (unsigned long )nr_rates, 208U);
//#line  2693
    fp->rate_table = (unsigned int *)tmp___0;
//#line  2694
    if ((unsigned long )fp->rate_table == (unsigned long )((void *)0)) {
//#line  2695
      printk("<3>cannot malloc\n");
//#line  2696
      return (-1);
    }
//#line  2699
    fp->nr_rates = 0U;
//#line  2700
    tmp___1 = 0U;
//#line  2700
    fp->rate_max = tmp___1;
//#line  2700
    fp->rate_min = tmp___1;
//#line  2701
    r = 0;
//#line  2701
    idx = offset + 1;
//#line  2701
    while (r < nr_rates) {
//#line  2702
      rate = ((unsigned int )*(fmt + idx) | ((unsigned int )*((fmt + idx) + 1) << 8)) | ((unsigned int )*((fmt + idx) + 2) << 16);
//#line  2703
      if (! rate) {
//#line  2704
        goto __Cont;
      }
//#line  2706
      if (rate == 48000U) {
//#line  2706
        if (nr_rates == 1) {
//#line  2706
          if (chip->usb_id == (u32 )((3468 << 16) | 513)) {
//#line  2706
            goto _L;
          } else
//#line  2706
          if (chip->usb_id == (u32 )((3468 << 16) | 258)) {
            _L: /* CIL Label */ 
//#line  2706
            if ((int )fp->altsetting == 5) {
//#line  2706
              if (fp->maxpacksize == 392U) {
//#line  2710
                rate = 96000U;
              }
            }
          }
        }
      }
//#line  2711
      *(fp->rate_table + fp->nr_rates) = rate;
//#line  2712
      if (! fp->rate_min) {
//#line  2713
        fp->rate_min = rate;
      } else
//#line  2712
      if (rate < fp->rate_min) {
//#line  2713
        fp->rate_min = rate;
      }
//#line  2714
      if (! fp->rate_max) {
//#line  2715
        fp->rate_max = rate;
      } else
//#line  2714
      if (rate > fp->rate_max) {
//#line  2715
        fp->rate_max = rate;
      }
//#line  2716
      tmp___2 = snd_pcm_rate_to_rate_bit(rate);
//#line  2716
      fp->rates |= tmp___2;
//#line  2717
      (fp->nr_rates) ++;
      __Cont: /* CIL Label */ 
//#line  2701
      r ++;
//#line  2701
      idx += 3;
    }
//#line  2719
    if (! fp->nr_rates) {
//#line  2721
      return (-1);
    }
  } else {
//#line  2725
    fp->rates = (unsigned int )(1 << 30);
//#line  2726
    fp->rate_min = ((unsigned int )*(fmt + (offset + 1)) | ((unsigned int )*((fmt + (offset + 1)) + 1) << 8)) | ((unsigned int )*((fmt + (offset + 1)) + 2) << 16);
//#line  2727
    fp->rate_max = ((unsigned int )*(fmt + (offset + 4)) | ((unsigned int )*((fmt + (offset + 4)) + 1) << 8)) | ((unsigned int )*((fmt + (offset + 4)) + 2) << 16);
  }
//#line  2729
  return (0);
}
}
//#line  2735 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_format_i(struct snd_usb_audio *chip , struct audioformat *fp ,
                                int format , unsigned char *fmt ) 
{ 
  int pcm_format ;
  int tmp ;

  {
//#line  2740
  if ((int )*(fmt + 3) == 3) {
//#line  2745
    switch ((int )chip->usb_id) {
    case (1891 << 16) | 8195: 
//#line  2748
    if (device_setup[chip->index] == 0) {
//#line  2748
      if ((int )fp->altsetting == 6) {
//#line  2750
        pcm_format = 3;
      } else {
//#line  2752
        pcm_format = 2;
      }
    } else {
//#line  2752
      pcm_format = 2;
    }
//#line  2753
    break;
    default: 
//#line  2755
    pcm_format = 2;
    }
  } else {
//#line  2758
    pcm_format = parse_audio_format_i_type(chip, fp, format, fmt);
//#line  2759
    if (pcm_format < 0) {
//#line  2760
      return (-1);
    }
  }
//#line  2762
  fp->format = pcm_format;
//#line  2763
  fp->channels = (unsigned int )*(fmt + 4);
//#line  2764
  if (fp->channels < 1U) {
//#line  2765
    printk("<3>%d:%u:%d : invalid channels %d\n", (chip->dev)->devnum, fp->iface,
           (int )fp->altsetting, fp->channels);
//#line  2767
    return (-1);
  }
//#line  2769
  tmp = parse_audio_format_rates(chip, fp, fmt, 7);
//#line  2769
  return (tmp);
}
}
//#line  2775 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_format_ii(struct snd_usb_audio *chip , struct audioformat *fp ,
                                 int format , unsigned char *fmt ) 
{ 
  int brate ;
  int framesize ;
  int tmp ;

  {
//#line  2779
  switch (format) {
  case 4098: 
//#line  2783
  fp->format = 1;
//#line  2784
  break;
  case 4097: 
//#line  2786
  fp->format = 23;
//#line  2787
  break;
  default: 
//#line  2789
  printk("<6>%d:%u:%d : unknown format tag 0x%x is detected.  processed as MPEG.\n",
         (chip->dev)->devnum, fp->iface, (int )fp->altsetting, format);
//#line  2791
  fp->format = 23;
//#line  2792
  break;
  }
//#line  2794
  fp->channels = 1U;
//#line  2795
  brate = (int )((unsigned int )*(fmt + 4) | ((unsigned int )*((fmt + 4) + 1) << 8));
//#line  2796
  framesize = (int )((unsigned int )*(fmt + 6) | ((unsigned int )*((fmt + 6) + 1) << 8));
//#line  2797
  printk("<6>found format II with max.bitrate = %d, frame size=%d\n", brate, framesize);
//#line  2798
  fp->frame_size = (unsigned int )framesize;
//#line  2799
  tmp = parse_audio_format_rates(chip, fp, fmt, 8);
//#line  2799
  return (tmp);
}
}
//#line  2802 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_format(struct snd_usb_audio *chip , struct audioformat *fp ,
                              int format , unsigned char *fmt , int stream ) 
{ 
  int err ;

  {
//#line  2807
  switch ((int )*(fmt + 3)) {
  case 1: 
  case 3: 
//#line  2810
  err = parse_audio_format_i(chip, fp, format, fmt);
//#line  2811
  break;
  case 2: 
//#line  2813
  err = parse_audio_format_ii(chip, fp, format, fmt);
//#line  2814
  break;
  default: 
//#line  2816
  printk("<6>%d:%u:%d : format type %d is not supported yet\n", (chip->dev)->devnum,
         fp->iface, (int )fp->altsetting, (int )*(fmt + 3));
//#line  2818
  return (-1);
  }
//#line  2820
  fp->fmt_type = (unsigned int )*(fmt + 3);
//#line  2821
  if (err < 0) {
//#line  2822
    return (err);
  }
//#line  2828
  if (chip->usb_id == (u32 )((1054 << 16) | 12288)) {
//#line  2828
    goto _L;
  } else
//#line  2828
  if (chip->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  2828
    goto _L;
  } else
//#line  2828
  if (chip->usb_id == (u32 )((1054 << 16) | 12385)) {
    _L: /* CIL Label */ 
//#line  2831
    if ((int )*(fmt + 3) == 1) {
//#line  2831
      if (fp->rates != (unsigned int )(1 << 7)) {
//#line  2831
        if (fp->rates != (unsigned int )(1 << 10)) {
//#line  2834
          return (-1);
        }
      }
    }
  }
//#line  2837
  return (0);
}
}
//#line  2840
static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip , int iface ,
                                         int altno ) ;
//#line  2842 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int parse_audio_endpoints(struct snd_usb_audio *chip , int iface_no ) 
{ 
  struct usb_device *dev ;
  struct usb_interface *iface ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int i ;
  int altno ;
  int err ;
  int stream ;
  int format ;
  struct audioformat *fp ;
  unsigned char *fmt ;
  unsigned char *csep ;
  int num ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
//#line  2854
  dev = chip->dev;
//#line  2857
  iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )iface_no);
//#line  2859
  num = (int )iface->num_altsetting;
//#line  2865
  if (chip->usb_id == (u32 )((1274 << 16) | 16897)) {
//#line  2866
    num = 4;
  }
//#line  2868
  i = 0;
//#line  2868
  while (i < num) {
//#line  2869
    alts = iface->altsetting + i;
//#line  2870
    altsd = & alts->desc;
//#line  2872
    if ((int )altsd->bInterfaceClass != 1) {
//#line  2872
      if ((int )altsd->bInterfaceClass != 255) {
//#line  2878
        goto __Cont;
      } else {
//#line  2872
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
//#line  2872
    if ((int )altsd->bInterfaceSubClass != 2) {
//#line  2872
      if ((int )altsd->bInterfaceSubClass != 255) {
//#line  2878
        goto __Cont;
      } else {
//#line  2872
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
//#line  2872
    if ((int )altsd->bNumEndpoints < 1) {
//#line  2878
      goto __Cont;
    } else
//#line  2872
    if ((int )(alts->endpoint + 0)->desc.wMaxPacketSize == 0) {
//#line  2878
      goto __Cont;
    }
//#line  2880
    if (((int )(alts->endpoint + 0)->desc.bmAttributes & 3) != 1) {
//#line  2882
      goto __Cont;
    }
//#line  2884
    if ((int )(alts->endpoint + 0)->desc.bEndpointAddress & 128) {
//#line  2884
      stream = 1;
    } else {
//#line  2884
      stream = 0;
    }
//#line  2886
    altno = (int )altsd->bAlternateSetting;
//#line  2890
    if (chip->usb_id == (u32 )((1891 << 16) | 8195)) {
//#line  2890
      tmp = audiophile_skip_setting_quirk(chip, iface_no, altno);
//#line  2890
      if (tmp) {
//#line  2892
        goto __Cont;
      }
    }
//#line  2895
    tmp___0 = snd_usb_find_csint_desc((void *)alts->extra, alts->extralen, (void *)0,
                                      (u8 )1);
//#line  2895
    fmt = (unsigned char *)tmp___0;
//#line  2896
    if (! fmt) {
//#line  2897
      printk("<3>%d:%u:%d : AS_GENERAL descriptor not found\n", dev->devnum, iface_no,
             altno);
//#line  2899
      goto __Cont;
    }
//#line  2902
    if ((int )*(fmt + 0) < 7) {
//#line  2903
      printk("<3>%d:%u:%d : invalid AS_GENERAL desc\n", dev->devnum, iface_no, altno);
//#line  2905
      goto __Cont;
    }
//#line  2908
    format = ((int )*(fmt + 6) << 8) | (int )*(fmt + 5);
//#line  2911
    tmp___1 = snd_usb_find_csint_desc((void *)alts->extra, alts->extralen, (void *)0,
                                      (u8 )2);
//#line  2911
    fmt = (unsigned char *)tmp___1;
//#line  2912
    if (! fmt) {
//#line  2913
      printk("<3>%d:%u:%d : no FORMAT_TYPE desc\n", dev->devnum, iface_no, altno);
//#line  2915
      goto __Cont;
    }
//#line  2917
    if ((int )*(fmt + 0) < 8) {
//#line  2918
      printk("<3>%d:%u:%d : invalid FORMAT_TYPE desc\n", dev->devnum, iface_no, altno);
//#line  2920
      goto __Cont;
    }
//#line  2923
    tmp___2 = snd_usb_find_desc((void *)(alts->endpoint + 0)->extra, (alts->endpoint + 0)->extralen,
                                (void *)0, (u8 )((1 << 5) | 5));
//#line  2923
    csep = (unsigned char *)tmp___2;
//#line  2925
    if (! csep) {
//#line  2925
      if ((int )altsd->bNumEndpoints >= 2) {
//#line  2926
        tmp___3 = snd_usb_find_desc((void *)(alts->endpoint + 1)->extra, (alts->endpoint + 1)->extralen,
                                    (void *)0, (u8 )((1 << 5) | 5));
//#line  2926
        csep = (unsigned char *)tmp___3;
      }
    }
//#line  2927
    if (! csep) {
//#line  2928
      printk("<4>%d:%u:%d : no or invalid class specific endpoint descriptor\n", dev->devnum,
             iface_no, altno);
//#line  2931
      csep = (unsigned char *)((void *)0);
    } else
//#line  2927
    if ((int )*(csep + 0) < 7) {
//#line  2928
      printk("<4>%d:%u:%d : no or invalid class specific endpoint descriptor\n", dev->devnum,
             iface_no, altno);
//#line  2931
      csep = (unsigned char *)((void *)0);
    } else
//#line  2927
    if ((int )*(csep + 2) != 1) {
//#line  2928
      printk("<4>%d:%u:%d : no or invalid class specific endpoint descriptor\n", dev->devnum,
             iface_no, altno);
//#line  2931
      csep = (unsigned char *)((void *)0);
    }
//#line  2934
    tmp___4 = kzalloc(sizeof(*fp), 208U);
//#line  2934
    fp = (struct audioformat *)tmp___4;
//#line  2935
    if (! fp) {
//#line  2936
      printk("<3>cannot malloc\n");
//#line  2937
      return (-12);
    }
//#line  2940
    fp->iface = iface_no;
//#line  2941
    fp->altsetting = (unsigned char )altno;
//#line  2942
    fp->altset_idx = (unsigned char )i;
//#line  2943
    fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  2944
    fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  2945
    fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  2946
    if ((unsigned int )dev->speed == 3U) {
//#line  2947
      fp->maxpacksize = (((fp->maxpacksize >> 11) & 3U) + 1U) * (fp->maxpacksize & 2047U);
    }
//#line  2949
    if (csep) {
//#line  2949
      fp->attributes = *(csep + 3);
    } else {
//#line  2949
      fp->attributes = (unsigned char)0;
    }
//#line  2953
    switch ((int )chip->usb_id) {
    case (2706 << 16) | 83: 
//#line  2958
    fp->attributes = (unsigned char )((int )fp->attributes & -2);
//#line  2959
    break;
    case (1054 << 16) | 12320: 
    case (1891 << 16) | 8195: 
//#line  2963
    fp->attributes = (unsigned char )((int )fp->attributes | 1);
//#line  2964
    break;
    case (1151 << 16) | 3233: 
    case (1917 << 16) | 1967: 
//#line  2972
    fp->ep_attr = (unsigned char )((int )fp->ep_attr & -13);
//#line  2973
    if (stream == 0) {
//#line  2974
      fp->ep_attr = (unsigned char )((int )fp->ep_attr | 8);
    } else {
//#line  2976
      fp->ep_attr = (unsigned char )((int )fp->ep_attr | 12);
    }
//#line  2977
    break;
    }
//#line  2981
    tmp___5 = parse_audio_format(chip, fp, format, fmt, stream);
//#line  2981
    if (tmp___5 < 0) {
//#line  2982
      kfree((void const   *)fp->rate_table);
//#line  2983
      kfree((void const   *)fp);
//#line  2984
      goto __Cont;
    }
//#line  2987
    printk("<6>%d:%u:%d: add audio endpoint 0x%x\n", dev->devnum, iface_no, altno,
           (int )fp->endpoint);
//#line  2988
    err = add_audio_endpoint(chip, stream, fp);
//#line  2989
    if (err < 0) {
//#line  2990
      kfree((void const   *)fp->rate_table);
//#line  2991
      kfree((void const   *)fp);
//#line  2992
      return (err);
    }
//#line  2995
    usb_set_interface(chip->dev, iface_no, altno);
//#line  2996
    init_usb_pitch(chip->dev, iface_no, alts, fp);
//#line  2997
    init_usb_sample_rate(chip->dev, iface_no, alts, fp, (int )fp->rate_max);
    __Cont: /* CIL Label */ 
//#line  2868
    i ++;
  }
//#line  2999
  return (0);
}
}
//#line  3007 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_stream_disconnect(struct list_head *head ) 
{ 
  int idx ;
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;
  struct list_head  const  *__mptr ;

  {
//#line  3013
  __mptr = (struct list_head  const  *)head;
//#line  3013
  as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  3014
  idx = 0;
//#line  3014
  while (idx < 2) {
//#line  3015
    subs = & as->substream[idx];
//#line  3016
    if (! subs->num_formats) {
//#line  3017
      return;
    }
//#line  3018
    release_substream_urbs(subs, 1);
//#line  3019
    subs->interface = -1;
//#line  3014
    idx ++;
  }
//#line  3021
  return;
}
}
//#line  3026 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_create_streams(struct snd_usb_audio *chip , int ctrlif ) 
{ 
  struct usb_device *dev ;
  struct usb_host_interface *host_iface ;
  struct usb_interface *iface ;
  unsigned char *p1 ;
  int i ;
  int j ;
  struct usb_interface *tmp ;
  void *tmp___0 ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
//#line  3028
  dev = chip->dev;
//#line  3035
  tmp = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )ctrlif);
//#line  3035
  host_iface = tmp->altsetting + 0;
//#line  3036
  tmp___0 = snd_usb_find_csint_desc((void *)host_iface->extra, host_iface->extralen,
                                    (void *)0, (u8 )1);
//#line  3036
  p1 = (unsigned char *)tmp___0;
//#line  3036
  if (! p1) {
//#line  3037
    printk("<3>cannot find HEADER\n");
//#line  3038
    return (-22);
  }
//#line  3040
  if (! *(p1 + 7)) {
//#line  3041
    printk("<3>invalid HEADER\n");
//#line  3042
    return (-22);
  } else
//#line  3040
  if ((int )*(p1 + 0) < 8 + (int )*(p1 + 7)) {
//#line  3041
    printk("<3>invalid HEADER\n");
//#line  3042
    return (-22);
  }
//#line  3048
  i = 0;
//#line  3048
  while (i < (int )*(p1 + 7)) {
//#line  3051
    j = (int )*(p1 + (8 + i));
//#line  3052
    iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )j);
//#line  3053
    if (! iface) {
//#line  3054
      printk("<3>%d:%u:%d : does not exist\n", dev->devnum, ctrlif, j);
//#line  3056
      goto __Cont;
    }
//#line  3058
    tmp___1 = usb_interface_claimed(iface);
//#line  3058
    if (tmp___1) {
//#line  3059
      printk("<6>%d:%d:%d: skipping, already claimed\n", dev->devnum, ctrlif, j);
//#line  3060
      goto __Cont;
    }
//#line  3062
    alts = iface->altsetting + 0;
//#line  3063
    altsd = & alts->desc;
//#line  3064
    if ((int )altsd->bInterfaceClass == 1) {
//#line  3064
      goto _L;
    } else
//#line  3064
    if ((int )altsd->bInterfaceClass == 255) {
      _L: /* CIL Label */ 
//#line  3064
      if ((int )altsd->bInterfaceSubClass == 3) {
//#line  3067
        tmp___2 = snd_usb_create_midi_interface(chip, iface, (struct snd_usb_audio_quirk  const  *)((void *)0));
//#line  3067
        if (tmp___2 < 0) {
//#line  3068
          printk("<3>%d:%u:%d: cannot create sequencer device\n", dev->devnum, ctrlif,
                 j);
//#line  3069
          goto __Cont;
        }
//#line  3071
        usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
//#line  3072
        goto __Cont;
      }
    }
//#line  3074
    if ((int )altsd->bInterfaceClass != 1) {
//#line  3074
      if ((int )altsd->bInterfaceClass != 255) {
//#line  3077
        printk("<3>%d:%u:%d: skipping non-supported interface %d\n", dev->devnum,
               ctrlif, j, (int )altsd->bInterfaceClass);
//#line  3079
        goto __Cont;
      } else {
//#line  3074
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
//#line  3074
    if ((int )altsd->bInterfaceSubClass != 2) {
//#line  3077
      printk("<3>%d:%u:%d: skipping non-supported interface %d\n", dev->devnum, ctrlif,
             j, (int )altsd->bInterfaceClass);
//#line  3079
      goto __Cont;
    }
//#line  3081
    if ((unsigned int )dev->speed == 1U) {
//#line  3082
      printk("<3>low speed audio streaming not supported\n");
//#line  3083
      goto __Cont;
    }
//#line  3085
    tmp___3 = parse_audio_endpoints(chip, j);
//#line  3085
    if (! tmp___3) {
//#line  3086
      usb_set_interface(dev, j, 0);
//#line  3087
      usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
    }
    __Cont: /* CIL Label */ 
//#line  3048
    i ++;
  }
//#line  3091
  return (0);
}
}
//#line  3097 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_fixed_stream_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                     struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct audioformat *fp ;
  struct usb_host_interface *alts ;
  int stream ;
  int err ;
  unsigned int *rate_table ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
//#line  3104
  rate_table = (unsigned int *)((void *)0);
//#line  3106
  tmp = kmemdup((void const   *)quirk->data, sizeof(*fp), 208U);
//#line  3106
  fp = (struct audioformat *)tmp;
//#line  3107
  if (! fp) {
//#line  3108
    printk("<3>cannot memdup\n");
//#line  3109
    return (-12);
  }
//#line  3111
  if (fp->nr_rates > 0U) {
//#line  3112
    tmp___0 = kmalloc(sizeof(int ) * (unsigned long )fp->nr_rates, 208U);
//#line  3112
    rate_table = (unsigned int *)tmp___0;
//#line  3113
    if (! rate_table) {
//#line  3114
      kfree((void const   *)fp);
//#line  3115
      return (-12);
    }
//#line  3117
    __len = sizeof(int ) * (unsigned long )fp->nr_rates;
//#line  3117
    __ret = __builtin_memcpy((void *)rate_table, (void const   *)fp->rate_table, __len);
//#line  3118
    fp->rate_table = rate_table;
  }
//#line  3121
  if ((int )fp->endpoint & 128) {
//#line  3121
    stream = 1;
  } else {
//#line  3121
    stream = 0;
  }
//#line  3123
  err = add_audio_endpoint(chip, stream, fp);
//#line  3124
  if (err < 0) {
//#line  3125
    kfree((void const   *)fp);
//#line  3126
    kfree((void const   *)rate_table);
//#line  3127
    return (err);
  }
//#line  3129
  if (fp->iface != (int )(iface->altsetting + 0)->desc.bInterfaceNumber) {
//#line  3131
    kfree((void const   *)fp);
//#line  3132
    kfree((void const   *)rate_table);
//#line  3133
    return (-22);
  } else
//#line  3129
  if ((unsigned int )fp->altset_idx >= iface->num_altsetting) {
//#line  3131
    kfree((void const   *)fp);
//#line  3132
    kfree((void const   *)rate_table);
//#line  3133
    return (-22);
  }
//#line  3135
  alts = iface->altsetting + fp->altset_idx;
//#line  3136
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  3137
  usb_set_interface(chip->dev, fp->iface, 0);
//#line  3138
  init_usb_pitch(chip->dev, fp->iface, alts, fp);
//#line  3139
  init_usb_sample_rate(chip->dev, fp->iface, alts, fp, (int )fp->rate_max);
//#line  3140
  return (0);
}
}
//#line  3146 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_standard_audio_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                       struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int err ;

  {
//#line  3154
  alts = iface->altsetting + 0;
//#line  3155
  altsd = & alts->desc;
//#line  3156
  err = parse_audio_endpoints(chip, (int )altsd->bInterfaceNumber);
//#line  3157
  if (err < 0) {
//#line  3158
    printk("<3>cannot setup if %d: error %d\n", (int )altsd->bInterfaceNumber, err);
//#line  3160
    return (err);
  }
//#line  3163
  usb_set_interface(chip->dev, (int )altsd->bInterfaceNumber, 0);
//#line  3164
  return (0);
}
}
//#line  3175 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  ua_format  = 
//#line  3175
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    32, 2U, 1U, 0U, 0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 0U, (unsigned int )(1 << 30), 0U, 0U, 0U, (unsigned int *)0};
//#line  3195 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  ua700_ep  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  3199 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  ua700_quirk  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (short)0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& ua700_ep)};
//#line  3203 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_midi_endpoint_info  const  uaxx_ep  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  3207 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_usb_audio_quirk  const  uaxx_quirk  =    {(char const   * __attribute__((__nullterm__)) )0, (char const   * __attribute__((__recursive__)) )0,
    (short)0, (uint16_t )3, (void const   * __attribute__((__recursive__)) )(& uaxx_ep)};
//#line  3171 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_uaxx_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                             struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
//#line  3189
  if (iface->num_altsetting < 2U) {
//#line  3190
    return (-6);
  }
//#line  3191
  alts = iface->altsetting + 1;
//#line  3192
  altsd = & alts->desc;
//#line  3194
  if ((int )altsd->bNumEndpoints == 2) {
//#line  3211
    if (chip->usb_id == (u32 )((1410 << 16) | 43)) {
//#line  3212
      tmp = snd_usb_create_midi_interface(chip, iface, & ua700_quirk);
//#line  3212
      return (tmp);
    } else {
//#line  3215
      tmp___0 = snd_usb_create_midi_interface(chip, iface, & uaxx_quirk);
//#line  3215
      return (tmp___0);
    }
  }
//#line  3219
  if ((int )altsd->bNumEndpoints != 1) {
//#line  3220
    return (-6);
  }
//#line  3222
  tmp___1 = kmalloc(sizeof(*fp), 208U);
//#line  3222
  fp = (struct audioformat *)tmp___1;
//#line  3223
  if (! fp) {
//#line  3224
    return (-12);
  }
//#line  3225
  __len = sizeof(*fp);
//#line  3225
  if (__len >= 64UL) {
//#line  3225
    __ret = __memcpy((void *)fp, (void const   *)(& ua_format), __len);
  } else {
//#line  3225
    __ret = __builtin_memcpy((void *)fp, (void const   *)(& ua_format), __len);
  }
//#line  3227
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  3228
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  3229
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  3230
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  3232
  switch ((int )fp->maxpacksize) {
  case 288: 
//#line  3234
  tmp___2 = 44100U;
//#line  3234
  fp->rate_min = tmp___2;
//#line  3234
  fp->rate_max = tmp___2;
//#line  3235
  break;
  case 312: 
  case 320: 
//#line  3238
  tmp___3 = 48000U;
//#line  3238
  fp->rate_min = tmp___3;
//#line  3238
  fp->rate_max = tmp___3;
//#line  3239
  break;
  case 600: 
  case 608: 
//#line  3242
  tmp___4 = 96000U;
//#line  3242
  fp->rate_min = tmp___4;
//#line  3242
  fp->rate_max = tmp___4;
//#line  3243
  break;
  default: 
//#line  3245
  printk("<3>unknown sample rate\n");
//#line  3246
  kfree((void const   *)fp);
//#line  3247
  return (-6);
  }
//#line  3250
  if ((int )fp->endpoint & 128) {
//#line  3250
    stream = 1;
  } else {
//#line  3250
    stream = 0;
  }
//#line  3252
  err = add_audio_endpoint(chip, stream, fp);
//#line  3253
  if (err < 0) {
//#line  3254
    kfree((void const   *)fp);
//#line  3255
    return (err);
  }
//#line  3257
  usb_set_interface(chip->dev, fp->iface, 0);
//#line  3258
  return (0);
}
}
//#line  3268 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  ua1000_format  = 
//#line  3268
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    10, 0U, 1U, 0U, 0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 0U, (unsigned int )(1 << 30), 0U, 0U, 0U, (unsigned int *)0};
//#line  3264 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_ua1000_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                               struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
//#line  3281
  if (iface->num_altsetting != 2U) {
//#line  3282
    return (-6);
  }
//#line  3283
  alts = iface->altsetting + 1;
//#line  3284
  altsd = & alts->desc;
//#line  3285
  if (alts->extralen != 11) {
//#line  3287
    return (-6);
  } else
//#line  3285
  if ((int )*(alts->extra + 1) != ((1 << 5) | 4)) {
//#line  3287
    return (-6);
  } else
//#line  3285
  if ((int )altsd->bNumEndpoints != 1) {
//#line  3287
    return (-6);
  }
//#line  3289
  tmp = kmemdup((void const   *)(& ua1000_format), sizeof(*fp), 208U);
//#line  3289
  fp = (struct audioformat *)tmp;
//#line  3290
  if (! fp) {
//#line  3291
    return (-12);
  }
//#line  3293
  fp->channels = (unsigned int )*(alts->extra + 4);
//#line  3294
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  3295
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  3296
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  3297
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  3298
  tmp___0 = ((unsigned int )*(alts->extra + 8) | ((unsigned int )*((alts->extra + 8) + 1) << 8)) | ((unsigned int )*((alts->extra + 8) + 2) << 16);
//#line  3298
  fp->rate_min = tmp___0;
//#line  3298
  fp->rate_max = tmp___0;
//#line  3300
  if ((int )fp->endpoint & 128) {
//#line  3300
    stream = 1;
  } else {
//#line  3300
    stream = 0;
  }
//#line  3302
  err = add_audio_endpoint(chip, stream, fp);
//#line  3303
  if (err < 0) {
//#line  3304
    kfree((void const   *)fp);
//#line  3305
    return (err);
  }
//#line  3308
  usb_set_interface(chip->dev, fp->iface, 0);
//#line  3309
  return (0);
}
}
//#line  3320 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct audioformat  const  ua101_format  = 
//#line  3320
     {{(struct list_head * __attribute__((__recursive__)) )0, (struct list_head * __attribute__((__recursive__)) )0},
    10, 0U, 1U, 0U, 0, (unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)0,
    (unsigned char)0, 0U, (unsigned int )(1 << 30), 0U, 0U, 0U, (unsigned int *)0};
//#line  3316 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_ua101_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                              struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
//#line  3333
  if (iface->num_altsetting != 2U) {
//#line  3334
    return (-6);
  }
//#line  3335
  alts = iface->altsetting + 1;
//#line  3336
  altsd = & alts->desc;
//#line  3337
  if (alts->extralen != 18) {
//#line  3339
    return (-6);
  } else
//#line  3337
  if ((int )*(alts->extra + 1) != ((1 << 5) | 4)) {
//#line  3339
    return (-6);
  } else
//#line  3337
  if ((int )altsd->bNumEndpoints != 1) {
//#line  3339
    return (-6);
  }
//#line  3341
  tmp = kmemdup((void const   *)(& ua101_format), sizeof(*fp), 208U);
//#line  3341
  fp = (struct audioformat *)tmp;
//#line  3342
  if (! fp) {
//#line  3343
    return (-12);
  }
//#line  3345
  fp->channels = (unsigned int )*(alts->extra + 11);
//#line  3346
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  3347
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  3348
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  3349
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  3350
  tmp___0 = ((unsigned int )*(alts->extra + 15) | ((unsigned int )*((alts->extra + 15) + 1) << 8)) | ((unsigned int )*((alts->extra + 15) + 2) << 16);
//#line  3350
  fp->rate_min = tmp___0;
//#line  3350
  fp->rate_max = tmp___0;
//#line  3352
  if ((int )fp->endpoint & 128) {
//#line  3352
    stream = 1;
  } else {
//#line  3352
    stream = 0;
  }
//#line  3354
  err = add_audio_endpoint(chip, stream, fp);
//#line  3355
  if (err < 0) {
//#line  3356
    kfree((void const   *)fp);
//#line  3357
    return (err);
  }
//#line  3360
  usb_set_interface(chip->dev, fp->iface, 0);
//#line  3361
  return (0);
}
}
//#line  3364
static int snd_usb_create_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  3371 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int create_composite_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  int probed_ifnum ;
  int err ;
  int tmp ;

  {
//#line  3375
  probed_ifnum = (int )(iface->altsetting)->desc.bInterfaceNumber;
//#line  3378
  quirk = (struct snd_usb_audio_quirk  const  *)quirk->data;
//#line  3378
  while ((int const   )quirk->ifnum >= 0) {
//#line  3379
    iface = usb_ifnum_to_if((struct usb_device  const  *)chip->dev, (unsigned int )quirk->ifnum);
//#line  3380
    if (! iface) {
//#line  3381
      goto __Cont;
    }
//#line  3382
    if ((int const   )quirk->ifnum != (int const   )probed_ifnum) {
//#line  3382
      tmp = usb_interface_claimed(iface);
//#line  3382
      if (tmp) {
//#line  3384
        goto __Cont;
      }
    }
//#line  3385
    err = snd_usb_create_quirk(chip, iface, quirk);
//#line  3386
    if (err < 0) {
//#line  3387
      return (err);
    }
//#line  3388
    if ((int const   )quirk->ifnum != (int const   )probed_ifnum) {
//#line  3389
      usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
    }
    __Cont: /* CIL Label */ 
//#line  3378
    quirk ++;
  }
//#line  3391
  return (0);
}
}
//#line  3394 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int ignore_interface_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) 
{ 


  {
//#line  3398
  return (0);
}
}
//#line  3408 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_extigy_boot_quirk(struct usb_device *dev , struct usb_interface *intf ) 
{ 
  struct usb_host_config *config ;
  int err ;
  unsigned int tmp ;

  {
//#line  3410
  config = dev->actconfig;
//#line  3413
  if ((int )config->desc.wTotalLength == 794) {
//#line  3413
    goto _L;
  } else
//#line  3413
  if ((int )config->desc.wTotalLength == 483) {
    _L: /* CIL Label */ 
//#line  3415
    printk("sending Extigy boot sequence...\n");
//#line  3417
    tmp = __create_pipe(dev, 0U);
//#line  3417
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )16, (__u8 )67,
                          (__u16 )1, (__u16 )10, (void *)0, (__u16 )0, 1000);
//#line  3419
    if (err < 0) {
//#line  3419
      printk("error sending boot message: %d\n", err);
    }
//#line  3420
    err = usb_get_descriptor(dev, (unsigned char)1, (unsigned char)0, (void *)(& dev->descriptor),
                             (int )sizeof(dev->descriptor));
//#line  3422
    config = dev->actconfig;
//#line  3423
    if (err < 0) {
//#line  3423
      printk("error usb_get_descriptor: %d\n", err);
    }
//#line  3424
    err = usb_reset_configuration(dev);
//#line  3425
    if (err < 0) {
//#line  3425
      printk("error usb_reset_configuration: %d\n", err);
    }
//#line  3426
    printk("extigy_boot: new boot length = %d\n", (int )config->desc.wTotalLength);
//#line  3428
    return (-19);
  }
//#line  3430
  return (0);
}
}
//#line  3433 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev ) 
{ 
  u8 buf ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
//#line  3435
  buf = (u8 )1;
//#line  3437
  tmp = __create_pipe(dev, 0U);
//#line  3437
  snd_usb_ctl_msg(dev, ((unsigned int )(2 << 30) | tmp) | 128U, (__u8 )42, (__u8 )((128 | (2 << 5)) | 3),
                  (__u16 )0, (__u16 )0, (void *)(& buf), (__u16 )1, 1000);
//#line  3440
  if ((int )buf == 0) {
//#line  3441
    tmp___0 = __create_pipe(dev, 0U);
//#line  3441
    snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp___0, (__u8 )41, (__u8 )((2 << 5) | 3),
                    (__u16 )1, (__u16 )2000, (void *)0, (__u16 )0, 1000);
//#line  3444
    return (-19);
  }
//#line  3446
  return (0);
}
}
//#line  3453 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_cm106_write_int_reg(struct usb_device *dev , int reg , u16 value ) 
{ 
  u8 buf[4] ;
  unsigned int tmp ;
  int tmp___0 ;

  {
//#line  3456
  buf[0] = (u8 )32;
//#line  3457
  buf[1] = (u8 )((int )value & 255);
//#line  3458
  buf[2] = (u8 )(((int )value >> 8) & 255);
//#line  3459
  buf[3] = (u8 )reg;
//#line  3460
  tmp = __create_pipe(dev, 0U);
//#line  3460
  tmp___0 = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )9, (__u8 )((1 << 5) | 2),
                            (__u16 )0, (__u16 )0, (void *)(& buf), (__u16 )4, 1000);
//#line  3460
  return (tmp___0);
}
}
//#line  3465 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_cm106_boot_quirk(struct usb_device *dev ) 
{ 
  int tmp ;

  {
//#line  3471
  tmp = snd_usb_cm106_write_int_reg(dev, 2, (u16 )32772);
//#line  3471
  return (tmp);
}
}
//#line  3489 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip , int iface ,
                                         int altno ) 
{ 


  {
//#line  3495
  usb_set_interface(chip->dev, iface, 0);
//#line  3497
  if (device_setup[chip->index] & 1) {
//#line  3498
    if (device_setup[chip->index] & 2) {
//#line  3498
      if (altno != 6) {
//#line  3500
        return (1);
      }
    }
//#line  3501
    if (device_setup[chip->index] & 4) {
//#line  3501
      if (altno != 1) {
//#line  3503
        return (1);
      }
    }
//#line  3504
    if ((device_setup[chip->index] & 31) == 25) {
//#line  3504
      if (altno != 2) {
//#line  3506
        return (1);
      }
    }
//#line  3507
    if ((device_setup[chip->index] & 31) == 9) {
//#line  3507
      if (altno != 3) {
//#line  3509
        return (1);
      }
    }
//#line  3510
    if ((device_setup[chip->index] & 31) == 17) {
//#line  3510
      if (altno != 4) {
//#line  3512
        return (1);
      }
    }
//#line  3513
    if ((device_setup[chip->index] & 31) == 1) {
//#line  3513
      if (altno != 5) {
//#line  3515
        return (1);
      }
    }
  }
//#line  3517
  return (0);
}
}
//#line  3529 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_create_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  int tmp ;

  {
//#line  3533
  if ((int const   )quirk->type < 16) {
//#line  3534
    tmp = (*(quirk_funcs[quirk->type]))(chip, iface, quirk);
//#line  3534
    return (tmp);
  } else {
//#line  3536
    printk("<3>invalid quirk type %d\n", (int const   )quirk->type);
//#line  3537
    return (-6);
  }
}
}
//#line  3545 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void proc_audio_usbbus_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_usb_audio *chip ;

  {
//#line  3548
  chip = (struct snd_usb_audio *)entry->private_data;
//#line  3549
  if (! chip->shutdown) {
//#line  3550
    snd_iprintf(buffer, (char *)"%03d/%03d\n", ((chip->dev)->bus)->busnum, (chip->dev)->devnum);
  }
//#line  3551
  return;
}
}
//#line  3553 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void proc_audio_usbid_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_usb_audio *chip ;

  {
//#line  3556
  chip = (struct snd_usb_audio *)entry->private_data;
//#line  3557
  if (! chip->shutdown) {
//#line  3558
    snd_iprintf(buffer, (char *)"%04x:%04x\n", chip->usb_id >> 16, (int )((u16 )chip->usb_id));
  }
//#line  3561
  return;
}
}
//#line  3563 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_audio_create_proc(struct snd_usb_audio *chip ) 
{ 
  struct snd_info_entry *entry ;
  int tmp ;
  int tmp___0 ;

  {
//#line  3565
  entry = (struct snd_info_entry *)((void *)0);
//#line  3566
  tmp = snd_card_proc_new(chip->card, (char const   * __attribute__((__nullterm__)) )"usbbus",
                          & entry);
//#line  3566
  if (! tmp) {
//#line  3567
    snd_info_set_text_ops(entry, (void *)chip, & proc_audio_usbbus_read);
  }
//#line  3568
  tmp___0 = snd_card_proc_new(chip->card, (char const   * __attribute__((__nullterm__)) )"usbid",
                              & entry);
//#line  3568
  if (! tmp___0) {
//#line  3569
    snd_info_set_text_ops(entry, (void *)chip, & proc_audio_usbid_read);
  }
//#line  3570
  return;
}
}
//#line  3579 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audio_free(struct snd_usb_audio *chip ) 
{ 


  {
//#line  3581
  kfree((void const   *)chip);
//#line  3582
  return (0);
}
}
//#line  3585 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audio_dev_free(struct snd_device *device ) 
{ 
  struct snd_usb_audio *chip ;
  int tmp ;

  {
//#line  3589
  chip = (struct snd_usb_audio *)device->device_data;
//#line  3590
  tmp = snd_usb_audio_free(chip);
//#line  3590
  return (tmp);
}
}
//#line  3604
static int snd_usb_audio_create(struct usb_device *dev , int idx , struct snd_usb_audio_quirk  const  *quirk ,
                                struct snd_usb_audio **rchip ) ;
//#line  3604 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static struct snd_device_ops ops  =    {& snd_usb_audio_dev_free, (int (*)(struct snd_device *dev ))0, (int (*)(struct snd_device *dev ))0};
//#line  3596 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audio_create(struct usb_device *dev , int idx , struct snd_usb_audio_quirk  const  *quirk ,
                                struct snd_usb_audio **rchip ) 
{ 
  struct snd_card *card ;
  struct snd_usb_audio *chip ;
  int err ;
  int len ;
  char component[14] ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
//#line  3608
  *rchip = (struct snd_usb_audio *)((void *)0);
//#line  3610
  if ((unsigned int )dev->speed != 1U) {
//#line  3610
    if ((unsigned int )dev->speed != 2U) {
//#line  3610
      if ((unsigned int )dev->speed != 3U) {
//#line  3613
        printk("<3>unknown device speed %d\n", (unsigned int )dev->speed);
//#line  3614
        return (-6);
      }
    }
  }
//#line  3617
  card = snd_card_new(index[idx], (char const   * __attribute__((__nullterm__)) )id[idx],
                      & __this_module, 0);
//#line  3618
  if ((unsigned long )card == (unsigned long )((void *)0)) {
//#line  3619
    printk("<3>cannot create card instance %d\n", idx);
//#line  3620
    return (-12);
  }
//#line  3623
  tmp = kzalloc(sizeof(*chip), 208U);
//#line  3623
  chip = (struct snd_usb_audio *)tmp;
//#line  3624
  if (! chip) {
//#line  3625
    snd_card_free(card);
//#line  3626
    return (-12);
  }
//#line  3629
  chip->index = idx;
//#line  3630
  chip->dev = dev;
//#line  3631
  chip->card = card;
//#line  3632
  chip->usb_id = (u32 )(((int )dev->descriptor.idVendor << 16) | (int )dev->descriptor.idProduct);
//#line  3634
  INIT_LIST_HEAD(& chip->pcm_list);
//#line  3635
  INIT_LIST_HEAD(& chip->midi_list);
//#line  3636
  INIT_LIST_HEAD(& chip->mixer_list);
//#line  3638
  err = snd_device_new(card, 8192, (void *)chip, & ops);
//#line  3638
  if (err < 0) {
//#line  3639
    snd_usb_audio_free(chip);
//#line  3640
    snd_card_free(card);
//#line  3641
    return (err);
  }
//#line  3644
  strcpy(card->driver, "USB-Audio");
//#line  3645
  sprintf(component, "USB%04x:%04x", chip->usb_id >> 16, (int )((u16 )chip->usb_id));
//#line  3647
  snd_component_add(card, (char const   * __attribute__((__nullterm__)) )(component));
//#line  3650
  if (quirk) {
//#line  3650
    if (quirk->product_name) {
//#line  3651
      strlcpy(card->shortname, (char const   *)quirk->product_name, sizeof(card->shortname));
    } else {
//#line  3650
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
//#line  3653
  if (! dev->descriptor.iProduct) {
//#line  3657
    sprintf(card->shortname, "USB Device %#04x:%#04x", chip->usb_id >> 16, (int )((u16 )chip->usb_id));
  } else {
//#line  3653
    tmp___0 = usb_string(dev, (int )dev->descriptor.iProduct, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )(card->shortname),
                         sizeof(card->shortname));
//#line  3653
    if (tmp___0 <= 0) {
//#line  3657
      sprintf(card->shortname, "USB Device %#04x:%#04x", chip->usb_id >> 16, (int )((u16 )chip->usb_id));
    }
  }
//#line  3664
  if (quirk) {
//#line  3664
    if (quirk->vendor_name) {
//#line  3665
      tmp___1 = strlcpy(card->longname, (char const   *)quirk->vendor_name, sizeof(card->longname));
//#line  3665
      len = (int )tmp___1;
    } else {
//#line  3664
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
//#line  3667
  if (dev->descriptor.iManufacturer) {
//#line  3668
    len = usb_string(dev, (int )dev->descriptor.iManufacturer, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )(card->longname),
                     sizeof(card->longname));
  } else {
//#line  3671
    len = 0;
  }
//#line  3674
  if (len > 0) {
//#line  3675
    strlcat(card->longname, " ", sizeof(card->longname));
  }
//#line  3677
  strlcat(card->longname, (char const   *)(card->shortname), sizeof(card->longname));
//#line  3679
  tmp___2 = strlcat(card->longname, " at ", sizeof(card->longname));
//#line  3679
  len = (int )tmp___2;
//#line  3681
  if ((unsigned long )len < sizeof(card->longname)) {
//#line  3682
    usb_make_path(dev, card->longname + len, sizeof(card->longname) - (unsigned long )len);
  }
//#line  3684
  if ((unsigned int )dev->speed == 1U) {
//#line  3684
    tmp___4 = ", low speed";
  } else {
//#line  3684
    if ((unsigned int )dev->speed == 2U) {
//#line  3684
      tmp___3 = ", full speed";
    } else {
//#line  3684
      tmp___3 = ", high speed";
    }
//#line  3684
    tmp___4 = tmp___3;
  }
//#line  3684
  strlcat(card->longname, tmp___4, sizeof(card->longname));
//#line  3690
  snd_usb_audio_create_proc(chip);
//#line  3692
  *rchip = chip;
//#line  3693
  return (0);
}
}
//#line  3707 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void *snd_usb_audio_probe(struct usb_device *dev , struct usb_interface *intf ,
                                 struct usb_device_id  const  *usb_id ) 
{ 
  struct snd_usb_audio_quirk  const  *quirk ;
  int i ;
  int err ;
  struct snd_usb_audio *chip ;
  struct usb_host_interface *alts ;
  int ifnum ;
  u32 id___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int error ;
  int tmp___5 ;

  {
//#line  3711
  quirk = (struct snd_usb_audio_quirk  const  *)usb_id->driver_info;
//#line  3718
  alts = intf->altsetting + 0;
//#line  3719
  ifnum = (int )alts->desc.bInterfaceNumber;
//#line  3720
  id___0 = (u32 )(((int )dev->descriptor.idVendor << 16) | (int )dev->descriptor.idProduct);
//#line  3723
  if (quirk) {
//#line  3723
    if ((int const   )quirk->ifnum >= 0) {
//#line  3723
      if (ifnum != (int )quirk->ifnum) {
//#line  3724
        goto __err_val;
      }
    }
  }
//#line  3726
  printk("%s Location 1\n", "snd_usb_audio_probe");
//#line  3730
  if (id___0 == (u32 )((1054 << 16) | 12288)) {
//#line  3731
    tmp = snd_usb_extigy_boot_quirk(dev, intf);
//#line  3731
    if (tmp < 0) {
//#line  3732
      goto __err_val;
    }
  }
//#line  3735
  printk("%s Location 2\n", "snd_usb_audio_probe");
//#line  3738
  if (id___0 == (u32 )((1054 << 16) | 12320)) {
//#line  3739
    tmp___0 = snd_usb_audigy2nx_boot_quirk(dev);
//#line  3739
    if (tmp___0 < 0) {
//#line  3740
      goto __err_val;
    }
  }
//#line  3743
  printk("%s Location 3\n", "snd_usb_audio_probe");
//#line  3746
  if (id___0 == (u32 )((4341 << 16) | 512)) {
//#line  3747
    tmp___1 = snd_usb_cm106_boot_quirk(dev);
//#line  3747
    if (tmp___1 < 0) {
//#line  3748
      goto __err_val;
    }
  }
//#line  3751
  printk("%s Location 4\n", "snd_usb_audio_probe");
//#line  3758
  chip = (struct snd_usb_audio *)((void *)0);
//#line  3759
  mutex_lock_nested(& register_mutex, 0U);
//#line  3760
  i = 0;
//#line  3760
  while (i < 32) {
//#line  3761
    if (usb_chip[i]) {
//#line  3761
      if ((unsigned long )(usb_chip[i])->dev == (unsigned long )dev) {
//#line  3766
        chip = (struct snd_usb_audio *)usb_chip[i];
//#line  3767
        break;
      }
    }
//#line  3760
    i ++;
  }
//#line  3771
  printk("%s Location 5\n", "snd_usb_audio_probe");
//#line  3773
  if (! chip) {
//#line  3777
    i = 0;
//#line  3777
    while (i < 32) {
//#line  3778
      if (enable[i]) {
//#line  3778
        if (! usb_chip[i]) {
//#line  3778
          if (vid[i] == -1) {
//#line  3778
            goto _L___0;
          } else
//#line  3778
          if ((u32 )vid[i] == id___0 >> 16) {
            _L___0: /* CIL Label */ 
//#line  3778
            if (pid[i] == -1) {
//#line  3778
              goto _L;
            } else
//#line  3778
            if (pid[i] == (int )((u16 )id___0)) {
              _L: /* CIL Label */ 
//#line  3781
              tmp___2 = snd_usb_audio_create(dev, i, quirk, & chip);
//#line  3781
              if (tmp___2 < 0) {
//#line  3782
                goto __error;
              }
//#line  3784
              (chip->card)->dev = & intf->dev;
//#line  3785
              break;
            }
          }
        }
      }
//#line  3777
      i ++;
    }
//#line  3787
    if (! chip) {
//#line  3788
      printk("<3>no available usb audio device\n");
//#line  3789
      goto __error;
    }
  }
//#line  3793
  printk("%s Location 6\n", "snd_usb_audio_probe");
//#line  3795
  err = 1;
//#line  3796
  if (quirk) {
//#line  3796
    if ((int const   )quirk->ifnum != -2) {
//#line  3798
      err = snd_usb_create_quirk(chip, intf, quirk);
//#line  3798
      if (err < 0) {
//#line  3799
        goto __error;
      }
    }
  }
//#line  3802
  printk("%s Location 7\n", "snd_usb_audio_probe");
//#line  3804
  if (err > 0) {
//#line  3806
    tmp___3 = snd_usb_create_streams(chip, ifnum);
//#line  3806
    if (tmp___3 < 0) {
//#line  3808
      goto __error;
    } else {
//#line  3806
      tmp___4 = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);
//#line  3806
      if (tmp___4 < 0) {
//#line  3808
        goto __error;
      }
    }
  }
//#line  3812
  printk("%s Location 8\n", "snd_usb_audio_probe");
//#line  3816
  tmp___5 = snd_card_register(chip->card);
//#line  3816
  error = tmp___5;
//#line  3818
  if (error < 0) {
//#line  3819
    printk("%s failure: %d\n", "snd_usb_audio_probe", error);
//#line  3820
    goto __error;
  }
//#line  3823
  printk("%s success: %d\n", "snd_usb_audio_probe", error);
//#line  3826
  usb_chip[chip->index] = (struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) )chip;
//#line  3827
  (chip->num_interfaces) ++;
//#line  3828
  mutex_unlock(& register_mutex);
//#line  3829
  return ((void *)chip);
  __error: 
//#line  3832
  printk("%s Location ERROR\n", "snd_usb_audio_probe");
//#line  3833
  if (chip) {
//#line  3833
    if (! chip->num_interfaces) {
//#line  3834
      snd_card_free(chip->card);
    }
  }
//#line  3835
  mutex_unlock(& register_mutex);
  __err_val: 
//#line  3837
  return ((void *)0);
}
}
//#line  3844 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_audio_disconnect(struct usb_device *dev , void *ptr ) 
{ 
  struct snd_usb_audio *chip ;
  struct snd_card *card ;
  struct list_head *p ;

  {
//#line  3850
  if ((unsigned long )ptr == (unsigned long )((void *)-1L)) {
//#line  3851
    return;
  }
//#line  3853
  chip = (struct snd_usb_audio *)ptr;
//#line  3854
  card = chip->card;
//#line  3855
  mutex_lock_nested(& register_mutex, 0U);
//#line  3856
  chip->shutdown = 1;
//#line  3857
  (chip->num_interfaces) --;
//#line  3858
  if (chip->num_interfaces <= 0) {
//#line  3859
    snd_card_disconnect(card);
//#line  3862
    p = (struct list_head *)chip->pcm_list.next;
//#line  3862
    while (1) {
//#line  3862
      __builtin_prefetch((void const   *)p->next);
//#line  3862
      if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  3862
        break;
      }
//#line  3863
      snd_usb_stream_disconnect(p);
//#line  3862
      p = (struct list_head *)p->next;
    }
//#line  3866
    p = (struct list_head *)chip->midi_list.next;
//#line  3866
    while (1) {
//#line  3866
      __builtin_prefetch((void const   *)p->next);
//#line  3866
      if (! ((unsigned long )p != (unsigned long )(& chip->midi_list))) {
//#line  3866
        break;
      }
//#line  3867
      snd_usbmidi_disconnect(p);
//#line  3866
      p = (struct list_head *)p->next;
    }
//#line  3870
    p = (struct list_head *)chip->mixer_list.next;
//#line  3870
    while (1) {
//#line  3870
      __builtin_prefetch((void const   *)p->next);
//#line  3870
      if (! ((unsigned long )p != (unsigned long )(& chip->mixer_list))) {
//#line  3870
        break;
      }
//#line  3871
      snd_usb_mixer_disconnect(p);
//#line  3870
      p = (struct list_head *)p->next;
    }
//#line  3873
    usb_chip[chip->index] = (struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) )((void *)0);
//#line  3874
    mutex_unlock(& register_mutex);
//#line  3875
    snd_card_free_when_closed(card);
  } else {
//#line  3877
    mutex_unlock(& register_mutex);
  }
//#line  3879
  return;
}
}
//#line  3881 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
struct usb_device *Nonstub_get_usb_device(struct usb_interface *intf , int marshaling ,
                                          int gen_kern , struct usb_device *after ) 
{ 
  struct usb_device *dev ;
  struct device  const __attribute__((__recursive__)) *__mptr ;

  {
//#line  3885
  __mptr = (struct device  const __attribute__((__recursive__)) *)intf->dev.parent;
//#line  3885
  dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
//#line  3886
  if (! gen_kern) {
//#line  3897
    if (marshaling) {
//#line  3898
      if (! after) {
//#line  3899
        intf->dev.parent = (struct device * __attribute__((__recursive__)) )dev;
      } else {
//#line  3901
        intf->dev.parent = (struct device * __attribute__((__recursive__)) )(& after->dev);
//#line  3902
        dev = after;
      }
    } else
//#line  3905
    if (! after) {
//#line  3906
      intf->dev.parent = (struct device * __attribute__((__recursive__)) )dev;
    } else {
//#line  3908
      intf->dev.parent = (struct device * __attribute__((__recursive__)) )(& after->dev);
//#line  3909
      dev = after;
    }
  }
//#line  3914
  return (dev);
}
}
//#line  3929 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int usb_audio_probe(struct usb_interface * __attribute__((__extraptr__(sizeof(struct usb_device *),"Nonstub_get_usb_device"))) intf ,
                           struct usb_device_id  const  *id___0 ) 
{ 
  void *chip ;
  struct device  const __attribute__((__recursive__)) *__mptr ;

  {
//#line  3934
  __mptr = (struct device  const __attribute__((__recursive__)) *)intf->dev.parent;
//#line  3934
  chip = snd_usb_audio_probe((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)),
                             (struct usb_interface *)intf, id___0);
//#line  3935
  if (chip) {
//#line  3936
    usb_set_intfdata((struct usb_interface *)intf, chip);
//#line  3937
    return (0);
  } else {
//#line  3939
    return (-5);
  }
}
}
//#line  3942 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void usb_audio_disconnect(struct usb_interface * __attribute__((__noderef__,
                                 __address_space__(2))) intf ) 
{ 
  void *tmp ;
  struct device  const __attribute__((__recursive__)) *__mptr ;

  {
//#line  3947
  tmp = usb_get_intfdata((struct usb_interface *)intf);
//#line  3947
  __mptr = (struct device  const __attribute__((__recursive__)) *)intf->dev.parent;
//#line  3947
  snd_usb_audio_disconnect((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)),
                           tmp);
//#line  3949
  return;
}
}
//#line  3952 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int usb_audio_suspend(struct usb_interface *intf , pm_message_t message ) 
{ 
  struct snd_usb_audio *chip ;
  void *tmp ;
  struct list_head *p ;
  struct snd_usb_stream *as ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
//#line  3954
  tmp = usb_get_intfdata(intf);
//#line  3954
  chip = (struct snd_usb_audio *)tmp;
//#line  3958
  if ((unsigned long )chip == (unsigned long )((void *)-1L)) {
//#line  3959
    return (0);
  }
//#line  3961
  snd_power_change_state(chip->card, 768U);
//#line  3962
  tmp___0 = chip->num_suspended_intf;
//#line  3962
  (chip->num_suspended_intf) ++;
//#line  3962
  if (! tmp___0) {
//#line  3963
    p = (struct list_head *)chip->pcm_list.next;
//#line  3963
    while (1) {
//#line  3963
      __builtin_prefetch((void const   *)p->next);
//#line  3963
      if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  3963
        break;
      }
//#line  3964
      __mptr = (struct list_head  const  *)p;
//#line  3964
      as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  3965
      snd_pcm_suspend_all((struct snd_pcm *)as->pcm);
//#line  3963
      p = (struct list_head *)p->next;
    }
  }
//#line  3969
  return (0);
}
}
//#line  3972 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int usb_audio_resume(struct usb_interface *intf ) 
{ 
  struct snd_usb_audio *chip ;
  void *tmp ;

  {
//#line  3974
  tmp = usb_get_intfdata(intf);
//#line  3974
  chip = (struct snd_usb_audio *)tmp;
//#line  3976
  if ((unsigned long )chip == (unsigned long )((void *)-1L)) {
//#line  3977
    return (0);
  }
//#line  3978
  (chip->num_suspended_intf) --;
//#line  3978
  if (chip->num_suspended_intf) {
//#line  3979
    return (0);
  }
//#line  3985
  snd_power_change_state(chip->card, 0U);
//#line  3987
  return (0);
}
}
//#line  3991
static int snd_usb_audio_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
//#line  3991 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static int snd_usb_audio_init(void) 
{ 
  int tmp ;

  {
//#line  3995
  if (nrpacks < 1) {
//#line  3996
    printk("<4>invalid nrpacks value.\n");
//#line  3997
    return (-22);
  } else
//#line  3995
  if (nrpacks > 20) {
//#line  3996
    printk("<4>invalid nrpacks value.\n");
//#line  3997
    return (-22);
  }
//#line  3999
  tmp = usb_register(& usb_audio_driver);
//#line  3999
  return (tmp);
}
}
//#line  4003
static void snd_usb_audio_cleanup(void)  __attribute__((__section__(".exit.text"))) ;
//#line  4003 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
static void snd_usb_audio_cleanup(void) 
{ 


  {
//#line  4005
  usb_deregister(& usb_audio_driver);
//#line  4007
  return;
}
}
//#line  4009 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
int init_module(void) 
{ 
  int tmp ;

  {
//#line  4009
  tmp = snd_usb_audio_init();
//#line  4009
  return (tmp);
}
}
//#line  4010 "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c"
void cleanup_module(void) 
{ 


  {
//#line  4010
  snd_usb_audio_cleanup();
//#line  4010
  return;
}
}
//#line  1 "usbmidi.o"
#pragma merger(0,"./usbmidi.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  32 "include/linux/spinlock_api_smp.h"
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  53
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  41 "include/linux/timer.h"
extern void init_timer(struct timer_list *timer ) ;
//#line  91
extern int mod_timer(struct timer_list *timer , unsigned long expires ) ;
//#line  172
extern int del_timer_sync(struct timer_list *timer ) ;
//#line  362 "include/linux/interrupt.h"
extern void __tasklet_schedule(struct tasklet_struct *t ) ;
//#line  364 "include/linux/interrupt.h"
__inline static void ( __attribute__((__always_inline__)) tasklet_schedule)(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
//#line  366
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
//#line  366
  if (! tmp) {
//#line  367
    __tasklet_schedule(t);
  }
//#line  368
  return;
}
}
//#line  404
extern void tasklet_kill(struct tasklet_struct *t ) ;
//#line  406
extern void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
//#line  656 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_num)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
//#line  658
  return ((int )((int const   )epd->bEndpointAddress & 15));
}
}
//#line  679 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_dir_in)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
//#line  681
  return (((int const   )epd->bEndpointAddress & 128) == 128);
}
}
//#line  690 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_dir_out)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
//#line  693
  return (((int const   )epd->bEndpointAddress & 128) == 0);
}
}
//#line  702 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_xfer_bulk)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
//#line  705
  return (((int const   )epd->bmAttributes & 3) == 2);
}
}
//#line  729 "include/linux/usb.h"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_xfer_int)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
//#line  732
  return (((int const   )epd->bmAttributes & 3) == 3);
}
}
//#line  1426 "include/linux/usb.h"
__inline static void ( __attribute__((__always_inline__)) usb_fill_bulk_urb)(struct urb *urb ,
                                                                             struct usb_device *dev ,
                                                                             unsigned int pipe ,
                                                                             void *transfer_buffer ,
                                                                             int buffer_length ,
                                                                             void (*complete_fn)(struct urb * ) ,
                                                                             void *context ) 
{ 


  {
//#line  1434
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )dev;
//#line  1435
  urb->pipe = pipe;
//#line  1436
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  1437
  urb->transfer_buffer_length = buffer_length;
//#line  1438
  urb->complete = complete_fn;
//#line  1439
  urb->context = (u8 * __attribute__((__recursive__, __noderef__)) )context;
//#line  1440
  return;
}
}
//#line  1460 "include/linux/usb.h"
__inline static void ( __attribute__((__always_inline__)) usb_fill_int_urb)(struct urb *urb ,
                                                                            struct usb_device *dev ,
                                                                            unsigned int pipe ,
                                                                            void *transfer_buffer ,
                                                                            int buffer_length ,
                                                                            void (*complete_fn)(struct urb * ) ,
                                                                            void *context ,
                                                                            int interval ) 
{ 


  {
//#line  1469
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )dev;
//#line  1470
  urb->pipe = pipe;
//#line  1471
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  1472
  urb->transfer_buffer_length = buffer_length;
//#line  1473
  urb->complete = complete_fn;
//#line  1474
  urb->context = (u8 * __attribute__((__recursive__, __noderef__)) )context;
//#line  1475
  if ((unsigned int )dev->speed == 3U) {
//#line  1476
    urb->interval = 1 << (interval - 1);
  } else {
//#line  1478
    urb->interval = interval;
  }
//#line  1479
  urb->start_frame = -1;
//#line  1480
  return;
}
}
//#line  1489
extern void usb_kill_urb(struct urb *urb ) ;
//#line  1558
extern int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                        int len , int *actual_length , int timeout ) ;
//#line  1715 "include/linux/usb.h"
__inline static __u16 ( __attribute__((__always_inline__)) usb_maxpacket)(struct usb_device *udev ,
                                                                          int pipe ,
                                                                          int is_out ) 
{ 
  struct usb_host_endpoint *ep ;
  unsigned int epnum ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
//#line  1719
  epnum = (unsigned int )((pipe >> 15) & 15);
//#line  1721
  if (is_out) {
//#line  1722
    __ret_warn_on = ! (! (pipe & 128));
//#line  1722
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
//#line  1722
    if (tmp) {
//#line  1722
      warn_slowpath("include/linux/usb.h", 1722, (char const   *)((void *)0));
    }
//#line  1722
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
//#line  1723
    ep = udev->ep_out[epnum];
  } else {
//#line  1725
    __ret_warn_on___0 = ! (! (! (pipe & 128)));
//#line  1725
    tmp___0 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
//#line  1725
    if (tmp___0) {
//#line  1725
      warn_slowpath("include/linux/usb.h", 1725, (char const   *)((void *)0));
    }
//#line  1725
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
//#line  1726
    ep = udev->ep_in[epnum];
  }
//#line  1728
  if (! ep) {
//#line  1729
    return ((__u16 )0);
  }
//#line  1732
  return (ep->desc.wMaxPacketSize);
}
}
//#line  150 "include/sound/rawmidi.h"
extern int snd_rawmidi_new(struct snd_card *card , char * __attribute__((__nullterm__)) id ,
                           int device , int output_count , int input_count , struct snd_rawmidi **rmidi ) ;
//#line  153
extern void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi , int stream , struct snd_rawmidi_ops *ops ) ;
//#line  159
extern int snd_rawmidi_receive(struct snd_rawmidi_substream *substream , unsigned char const   *buffer ,
                               int count ) ;
//#line  162
extern int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream ) ;
//#line  163
extern int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                                     int count ) ;
//#line  165
extern int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream , int count ) ;
//#line  166
extern int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                                int count ) ;
//#line  232 "/scratch/sym/ipc_drivers/usb-audio/usbaudio.h"
void snd_usbmidi_input_stop(struct list_head *p ) ;
//#line  233
void snd_usbmidi_input_start(struct list_head *p ) ;
//#line  66 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __mod_author66[44]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  66 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'C', 
        (char const   )'l',      (char const   )'e',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'L', 
        (char const   )'a',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'<', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'@', 
        (char const   )'l',      (char const   )'a',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'c',      (char const   )'h',      (char const   )'.', 
        (char const   )'d',      (char const   )'e',      (char const   )'>',      (char const   )'\000'};
//#line  67 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __mod_description67[41]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  67
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'A',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )'/',      (char const   )'M',      (char const   )'I', 
        (char const   )'D',      (char const   )'I',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'l',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'u',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
//#line  68 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __mod_license68[21]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  68
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'D',      (char const   )'u',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'B',      (char const   )'S',      (char const   )'D', 
        (char const   )'/',      (char const   )'G',      (char const   )'P',      (char const   )'L', 
        (char const   )'\000'};
//#line  156
static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  158 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static uint8_t const   snd_usbmidi_cin_length[16]  = 
//#line  158
  {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )2,      (uint8_t const   )3, 
        (uint8_t const   )3,      (uint8_t const   )1,      (uint8_t const   )2,      (uint8_t const   )3, 
        (uint8_t const   )3,      (uint8_t const   )3,      (uint8_t const   )3,      (uint8_t const   )3, 
        (uint8_t const   )2,      (uint8_t const   )2,      (uint8_t const   )3,      (uint8_t const   )1};
//#line  168 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_submit_urb(struct urb *urb , gfp_t flags ) 
{ 
  int err ;
  int tmp ;

  {
//#line  170
  tmp = usb_submit_urb(urb, flags);
//#line  170
  err = tmp;
//#line  171
  if (err < 0) {
//#line  171
    if (err != -19) {
//#line  172
      printk("<3>usb_submit_urb: %d\n", err);
    }
  }
//#line  173
  return (err);
}
}
//#line  179 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_urb_error(int status ) 
{ 


  {
//#line  181
  switch (status) {
  case -2: 
  case -104: 
  case -108: 
  case -19: 
//#line  187
  return (-19);
  case -71: 
  case -62: 
  case -84: 
//#line  192
  return (-5);
  default: 
//#line  194
  printk("<3>urb status %d\n", status);
//#line  195
  return (0);
  }
}
}
//#line  202 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep , int portidx ,
                                   uint8_t *data , int length ) 
{ 
  struct usbmidi_in_port *port ;
  int tmp___0 ;

  {
//#line  205
  port = & ep->ports[portidx];
//#line  207
  if (! port->substream) {
//#line  208
    while (1) {
//#line  208
      break;
    }
//#line  209
    return;
  }
//#line  211
  tmp___0 = variable_test_bit((port->substream)->number, (unsigned long const volatile   *)(& (ep->umidi)->input_triggered));
//#line  211
  if (! tmp___0) {
//#line  212
    return;
  }
//#line  213
  snd_rawmidi_receive(port->substream, (unsigned char const   *)data, length);
//#line  214
  return;
}
}
//#line  231 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_in_urb_complete(struct urb *urb ) 
{ 
  struct snd_usb_midi_in_endpoint *ep ;
  int err ;
  int tmp ;

  {
//#line  233
  ep = (struct snd_usb_midi_in_endpoint *)urb->context;
//#line  235
  if (urb->status == 0) {
//#line  237
    (*(((ep->umidi)->usb_protocol_ops)->input))(ep, urb->transfer_buffer, urb->actual_length);
  } else {
//#line  240
    tmp = snd_usbmidi_urb_error(urb->status);
//#line  240
    err = tmp;
//#line  241
    if (err < 0) {
//#line  242
      if (err != -19) {
//#line  243
        ep->error_resubmit = (u8 )1;
//#line  244
        mod_timer(& (ep->umidi)->error_timer, (unsigned long )(jiffies + (unsigned long volatile   )100));
      }
//#line  247
      return;
    }
  }
//#line  251
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )((ep->umidi)->chip)->dev;
//#line  252
  snd_usbmidi_submit_urb(urb, 32U);
//#line  253
  return;
}
}
//#line  255 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_out_urb_complete(struct urb *urb ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;
  int err ;
  int tmp ;

  {
//#line  257
  ep = (struct snd_usb_midi_out_endpoint *)urb->context;
//#line  259
  _spin_lock(& ep->buffer_lock);
//#line  260
  ep->urb_active = 0;
//#line  261
  _spin_unlock(& ep->buffer_lock);
//#line  262
  if (urb->status < 0) {
//#line  263
    tmp = snd_usbmidi_urb_error(urb->status);
//#line  263
    err = tmp;
//#line  264
    if (err < 0) {
//#line  265
      if (err != -19) {
//#line  266
        mod_timer(& (ep->umidi)->error_timer, (unsigned long )(jiffies + (unsigned long volatile   )100));
      }
//#line  268
      return;
    }
  }
//#line  271
  snd_usbmidi_do_output(ep);
//#line  272
  return;
}
}
//#line  278 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  struct urb *urb ;
  unsigned long flags ;
  int tmp ;

  {
//#line  280
  urb = (struct urb *)ep->urb;
//#line  283
  while (1) {
//#line  283
    flags = _spin_lock_irqsave(& ep->buffer_lock);
//#line  283
    break;
  }
//#line  284
  if (ep->urb_active) {
//#line  284
    goto _L;
  } else
//#line  284
  if (((ep->umidi)->chip)->shutdown) {
    _L: /* CIL Label */ 
//#line  285
    while (1) {
//#line  285
      _spin_unlock_irqrestore(& ep->buffer_lock, flags);
//#line  285
      break;
    }
//#line  286
    return;
  }
//#line  289
  urb->transfer_buffer_length = 0;
//#line  290
  (*(((ep->umidi)->usb_protocol_ops)->output))(ep);
//#line  292
  if (urb->transfer_buffer_length > 0) {
//#line  295
    urb->dev = (struct usb_device * __attribute__((__recursive__)) )((ep->umidi)->chip)->dev;
//#line  296
    tmp = snd_usbmidi_submit_urb(urb, 32U);
//#line  296
    ep->urb_active = tmp >= 0;
  }
//#line  298
  while (1) {
//#line  298
    _spin_unlock_irqrestore(& ep->buffer_lock, flags);
//#line  298
    break;
  }
//#line  299
  return;
}
}
//#line  301 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_out_tasklet(struct snd_usb_midi_out_endpoint *data ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;

  {
//#line  303
  ep = data;
//#line  305
  snd_usbmidi_do_output(ep);
//#line  306
  return;
}
}
//#line  309 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_error_timer(struct snd_usb_midi *data ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct snd_usb_midi_in_endpoint *in ;

  {
//#line  311
  umidi = data;
//#line  314
  _spin_lock(& umidi->disc_lock);
//#line  315
  if (umidi->disconnected) {
//#line  316
    _spin_unlock(& umidi->disc_lock);
//#line  317
    return;
  }
//#line  319
  i = 0;
//#line  319
  while (i < 2) {
//#line  320
    in = umidi->endpoints[i].in;
//#line  321
    if (in) {
//#line  321
      if (in->error_resubmit) {
//#line  322
        in->error_resubmit = (u8 )0;
//#line  323
        (in->urb)->dev = (struct usb_device * __attribute__((__recursive__)) )(umidi->chip)->dev;
//#line  324
        snd_usbmidi_submit_urb((struct urb *)in->urb, 32U);
      }
    }
//#line  326
    if (umidi->endpoints[i].out) {
//#line  327
      snd_usbmidi_do_output(umidi->endpoints[i].out);
    }
//#line  319
    i ++;
  }
//#line  329
  _spin_unlock(& umidi->disc_lock);
//#line  330
  return;
}
}
//#line  333 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep , void const   *data ,
                                 int len ) 
{ 
  int err ;
  void *buf ;
  void *tmp ;

  {
//#line  337
  tmp = kmemdup(data, (size_t )len, 208U);
//#line  337
  buf = tmp;
//#line  338
  if (! buf) {
//#line  339
    return (-12);
  }
//#line  341
  err = usb_bulk_msg(((ep->umidi)->chip)->dev, (ep->urb)->pipe, buf, len, (int *)((void *)0),
                     250);
//#line  343
  kfree((void const   *)buf);
//#line  344
  return (err);
}
}
//#line  353 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) 
{ 
  int i ;
  int cable ;
  int length ;

  {
//#line  358
  i = 0;
//#line  358
  while (i + 3 < buffer_length) {
//#line  359
    if ((int )*(buffer + i) != 0) {
//#line  360
      cable = (int )*(buffer + i) >> 4;
//#line  361
      length = (int )snd_usbmidi_cin_length[(int )*(buffer + i) & 15];
//#line  362
      snd_usbmidi_input_data(ep, cable, buffer + (i + 1), length);
    }
//#line  358
    i += 4;
  }
//#line  364
  return;
}
}
//#line  366 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                               int buffer_length ) 
{ 
  int i ;
  int port ;
  int length ;

  {
//#line  371
  i = 0;
//#line  371
  while (i + 3 < buffer_length) {
//#line  372
    if ((int )*(buffer + (i + 3)) != 0) {
//#line  373
      port = (int )*(buffer + (i + 3)) >> 4;
//#line  374
      length = (int )*(buffer + (i + 3)) & 3;
//#line  375
      snd_usbmidi_input_data(ep, port, buffer + i, length);
    }
//#line  371
    i += 4;
  }
//#line  377
  return;
}
}
//#line  383 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_maudio_broken_running_status_input(struct snd_usb_midi_in_endpoint *ep ,
                                                    uint8_t *buffer , int buffer_length ) 
{ 
  int i ;
  int cable ;
  u8 cin ;
  struct usbmidi_in_port *port ;
  int length ;

  {
//#line  389
  i = 0;
//#line  389
  while (i + 3 < buffer_length) {
//#line  390
    if ((int )*(buffer + i) != 0) {
//#line  391
      cable = (int )*(buffer + i) >> 4;
//#line  392
      cin = (u8 )((int )*(buffer + i) & 15);
//#line  393
      port = & ep->ports[cable];
//#line  396
      length = (int )snd_usbmidi_cin_length[cin];
//#line  397
      if ((int )cin == 15) {
//#line  397
        if (! ((int )*(buffer + (i + 1)) >= 248)) {
//#line  397
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
//#line  399
      if ((int )cin >= 8) {
//#line  399
        if ((int )cin <= 14) {
//#line  401
          port->running_status_length = (u8 )(length - 1);
        } else {
//#line  399
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
//#line  402
      if ((int )cin == 4) {
//#line  402
        if ((int )port->running_status_length != 0) {
//#line  402
          if ((int )*(buffer + (i + 1)) < 128) {
//#line  406
            length = (int )port->running_status_length;
          } else {
//#line  414
            port->running_status_length = (u8 )0;
          }
        } else {
//#line  414
          port->running_status_length = (u8 )0;
        }
      } else {
//#line  414
        port->running_status_length = (u8 )0;
      }
//#line  415
      snd_usbmidi_input_data(ep, cable, buffer + (i + 1), length);
    }
//#line  389
    i += 4;
  }
//#line  417
  return;
}
}
//#line  423 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) 
{ 


  {
//#line  426
  if (buffer_length < 2) {
//#line  427
    snd_usbmidi_standard_input(ep, buffer, buffer_length);
  } else
//#line  426
  if (((int )*(buffer + 0) & 15) != 15) {
//#line  427
    snd_usbmidi_standard_input(ep, buffer, buffer_length);
  } else {
//#line  429
    snd_usbmidi_input_data(ep, (int )*(buffer + 0) >> 4, buffer + 1, buffer_length - 1);
  }
//#line  431
  return;
}
}
//#line  436 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_output_standard_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                        uint8_t p2 , uint8_t p3 ) 
{ 
  uint8_t *buf ;

  {
//#line  440
  buf = urb->transfer_buffer + urb->transfer_buffer_length;
//#line  441
  *(buf + 0) = p0;
//#line  442
  *(buf + 1) = p1;
//#line  443
  *(buf + 2) = p2;
//#line  444
  *(buf + 3) = p3;
//#line  445
  urb->transfer_buffer_length += 4;
//#line  446
  return;
}
}
//#line  451 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_output_midiman_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                       uint8_t p2 , uint8_t p3 ) 
{ 
  uint8_t *buf ;

  {
//#line  455
  buf = urb->transfer_buffer + urb->transfer_buffer_length;
//#line  456
  *(buf + 0) = p1;
//#line  457
  *(buf + 1) = p2;
//#line  458
  *(buf + 2) = p3;
//#line  459
  *(buf + 3) = (uint8_t )(((int )p0 & 240) | (int )snd_usbmidi_cin_length[(int )p0 & 15]);
//#line  460
  urb->transfer_buffer_length += 4;
//#line  461
  return;
}
}
//#line  466 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port , uint8_t b ,
                                      struct urb *urb ) 
{ 
  uint8_t p0 ;
  void (*output_packet)(struct urb * , uint8_t  , uint8_t  , uint8_t  , uint8_t  ) ;

  {
//#line  469
  p0 = port->cable;
//#line  470
  output_packet = (((port->ep)->umidi)->usb_protocol_ops)->output_packet;
//#line  473
  if ((int )b >= 248) {
//#line  474
    (*output_packet)(urb, (uint8_t )((int )p0 | 15), b, (uint8_t )0, (uint8_t )0);
  } else
//#line  475
  if ((int )b >= 240) {
//#line  476
    switch ((int )b) {
    case 240: 
//#line  478
    port->data[0] = b;
//#line  479
    port->state = (uint8_t )5;
//#line  480
    break;
    case 241: 
    case 243: 
//#line  483
    port->data[0] = b;
//#line  484
    port->state = (uint8_t )1;
//#line  485
    break;
    case 242: 
//#line  487
    port->data[0] = b;
//#line  488
    port->state = (uint8_t )2;
//#line  489
    break;
    case 244: 
    case 245: 
//#line  492
    port->state = (uint8_t )0;
//#line  493
    break;
    case 246: 
//#line  495
    (*output_packet)(urb, (uint8_t )((int )p0 | 5), (uint8_t )246, (uint8_t )0, (uint8_t )0);
//#line  496
    port->state = (uint8_t )0;
//#line  497
    break;
    case 247: 
//#line  499
    switch ((int )port->state) {
    case 4: 
//#line  501
    (*output_packet)(urb, (uint8_t )((int )p0 | 5), (uint8_t )247, (uint8_t )0, (uint8_t )0);
//#line  502
    break;
    case 5: 
//#line  504
    (*output_packet)(urb, (uint8_t )((int )p0 | 6), port->data[0], (uint8_t )247,
                     (uint8_t )0);
//#line  505
    break;
    case 6: 
//#line  507
    (*output_packet)(urb, (uint8_t )((int )p0 | 7), port->data[0], port->data[1],
                     (uint8_t )247);
//#line  508
    break;
    }
//#line  510
    port->state = (uint8_t )0;
//#line  511
    break;
    }
  } else
//#line  513
  if ((int )b >= 128) {
//#line  514
    port->data[0] = b;
//#line  515
    if ((int )b >= 192) {
//#line  515
      if ((int )b <= 223) {
//#line  516
        port->state = (uint8_t )1;
      } else {
//#line  518
        port->state = (uint8_t )2;
      }
    } else {
//#line  518
      port->state = (uint8_t )2;
    }
  } else {
//#line  520
    switch ((int )port->state) {
    case 1: 
//#line  522
    if ((int )port->data[0] < 240) {
//#line  523
      p0 = (uint8_t )((int )p0 | ((int )port->data[0] >> 4));
    } else {
//#line  525
      p0 = (uint8_t )((int )p0 | 2);
//#line  526
      port->state = (uint8_t )0;
    }
//#line  528
    (*output_packet)(urb, p0, port->data[0], b, (uint8_t )0);
//#line  529
    break;
    case 2: 
//#line  531
    port->data[1] = b;
//#line  532
    port->state = (uint8_t )3;
//#line  533
    break;
    case 3: 
//#line  535
    if ((int )port->data[0] < 240) {
//#line  536
      p0 = (uint8_t )((int )p0 | ((int )port->data[0] >> 4));
//#line  537
      port->state = (uint8_t )2;
    } else {
//#line  539
      p0 = (uint8_t )((int )p0 | 3);
//#line  540
      port->state = (uint8_t )0;
    }
//#line  542
    (*output_packet)(urb, p0, port->data[0], port->data[1], b);
//#line  543
    break;
    case 4: 
//#line  545
    port->data[0] = b;
//#line  546
    port->state = (uint8_t )5;
//#line  547
    break;
    case 5: 
//#line  549
    port->data[1] = b;
//#line  550
    port->state = (uint8_t )6;
//#line  551
    break;
    case 6: 
//#line  553
    (*output_packet)(urb, (uint8_t )((int )p0 | 4), port->data[0], port->data[1],
                     b);
//#line  554
    port->state = (uint8_t )4;
//#line  555
    break;
    }
  }
//#line  558
  return;
}
}
//#line  560 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  struct urb *urb ;
  int p ;
  struct usbmidi_out_port *port ;
  uint8_t b ;
  int tmp ;

  {
//#line  562
  urb = (struct urb *)ep->urb;
//#line  566
  p = 0;
//#line  566
  while (p < 16) {
//#line  567
    port = & ep->ports[p];
//#line  568
    if (! port->active) {
//#line  569
      goto __Cont;
    }
//#line  570
    while (urb->transfer_buffer_length + 3 < ep->max_transfer) {
//#line  572
      tmp = snd_rawmidi_transmit((struct snd_rawmidi_substream *)port->substream,
                                 & b, 1);
//#line  572
      if (tmp != 1) {
//#line  573
        port->active = 0;
//#line  574
        break;
      }
//#line  576
      snd_usbmidi_transmit_byte(port, b, urb);
    }
    __Cont: /* CIL Label */ 
//#line  566
    p ++;
  }
//#line  579
  return;
}
}
//#line  594 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) 
{ 


  {
//#line  597
  if (buffer_length < 2) {
//#line  598
    return;
  } else
//#line  597
  if (! *(buffer + 0)) {
//#line  598
    return;
  } else
//#line  597
  if (buffer_length < (int )*(buffer + 0) + 1) {
//#line  598
    return;
  }
//#line  599
  snd_usbmidi_input_data(ep, 0, buffer + 2, (int )*(buffer + 0) - 1);
//#line  600
  return;
}
}
//#line  602 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  uint8_t *transfer_buffer ;
  int count ;

  {
//#line  607
  if (! ep->ports[0].active) {
//#line  608
    return;
  }
//#line  609
  transfer_buffer = (ep->urb)->transfer_buffer;
//#line  610
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               transfer_buffer + 2, ep->max_transfer - 2);
//#line  613
  if (count < 1) {
//#line  614
    ep->ports[0].active = 0;
//#line  615
    return;
  }
//#line  617
  *(transfer_buffer + 0) = (uint8_t )0;
//#line  618
  *(transfer_buffer + 1) = (uint8_t )count;
//#line  619
  (ep->urb)->transfer_buffer_length = 2 + count;
//#line  620
  return;
}
}
//#line  629 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) 
{ 


  {
//#line  632
  snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
//#line  633
  return;
}
}
//#line  635 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int count ;

  {
//#line  639
  if (! ep->ports[0].active) {
//#line  640
    return;
  }
//#line  641
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               (ep->urb)->transfer_buffer, ep->max_transfer);
//#line  644
  if (count < 1) {
//#line  645
    ep->ports[0].active = 0;
//#line  646
    return;
  }
//#line  648
  (ep->urb)->transfer_buffer_length = count;
//#line  649
  return;
}
}
//#line  654 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) 
{ 


  {
//#line  657
  if (buffer_length != 9) {
//#line  658
    return;
  }
//#line  659
  buffer_length = 8;
//#line  660
  while (1) {
//#line  660
    if (buffer_length) {
//#line  660
      if (! ((int )*(buffer + (buffer_length - 1)) == 253)) {
//#line  660
        break;
      }
    } else {
//#line  660
      break;
    }
//#line  661
    buffer_length --;
  }
//#line  662
  if (buffer_length) {
//#line  663
    snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
  }
//#line  664
  return;
}
}
//#line  666 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int count ;

  {
//#line  670
  if (! ep->ports[0].active) {
//#line  671
    return;
  }
//#line  672
  if ((unsigned int )((ep->urb)->dev)->speed == 3U) {
//#line  672
    count = 1;
  } else {
//#line  672
    count = 2;
  }
//#line  673
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               (ep->urb)->transfer_buffer, count);
//#line  676
  if (count < 1) {
//#line  677
    ep->ports[0].active = 0;
//#line  678
    return;
  }
//#line  681
  memset((void *)((ep->urb)->transfer_buffer + count), 253, (size_t )(9 - count));
//#line  682
  (ep->urb)->transfer_buffer_length = count;
//#line  683
  return;
}
}
//#line  691 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static u8 const   init_data[9]  = 
//#line  691
  {      (u8 const   )240,      (u8 const   )0,      (u8 const   )32,      (u8 const   )49, 
        (u8 const   )100,      (u8 const   )11,      (u8 const   )0,      (u8 const   )0, 
        (u8 const   )247};
//#line  689 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
//#line  701
  send_bulk_static_data(ep, (void const   *)(init_data), (int )sizeof(init_data));
//#line  703
  send_bulk_static_data(ep, (void const   *)(init_data), (int )sizeof(init_data));
//#line  704
  return;
}
}
//#line  708 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static u8 const   finish_data[10]  = 
//#line  708
  {      (u8 const   )240,      (u8 const   )0,      (u8 const   )32,      (u8 const   )49, 
        (u8 const   )100,      (u8 const   )16,      (u8 const   )0,      (u8 const   )127, 
        (u8 const   )64,      (u8 const   )247};
//#line  706 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
//#line  719
  send_bulk_static_data(ep, (void const   *)(finish_data), (int )sizeof(finish_data));
//#line  720
  return;
}
}
//#line  724 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) 
{ 
  int i ;

  {
//#line  730
  i = 0;
//#line  730
  while (i < buffer_length) {
//#line  731
    if ((int )*(buffer + i) == 255) {
//#line  732
      buffer_length = i;
//#line  733
      break;
    }
//#line  730
    i ++;
  }
//#line  737
  if (ep->seen_f5) {
//#line  738
    goto switch_port;
  }
//#line  740
  while (buffer_length > 0) {
//#line  742
    i = 0;
//#line  742
    while (i < buffer_length) {
//#line  743
      if ((int )*(buffer + i) == 245) {
//#line  744
        break;
      }
//#line  742
      i ++;
    }
//#line  745
    snd_usbmidi_input_data(ep, ep->current_port, buffer, i);
//#line  746
    buffer += i;
//#line  747
    buffer_length -= i;
//#line  749
    if (buffer_length <= 0) {
//#line  750
      break;
    }
//#line  752
    ep->seen_f5 = (u8 )1;
//#line  753
    buffer ++;
//#line  754
    buffer_length --;
    switch_port: 
//#line  757
    if (buffer_length <= 0) {
//#line  758
      break;
    }
//#line  759
    if ((int )*(buffer + 0) < 128) {
//#line  760
      ep->current_port = ((int )*(buffer + 0) - 1) & 15;
//#line  761
      buffer ++;
//#line  762
      buffer_length --;
    }
//#line  764
    ep->seen_f5 = (u8 )0;
  }
//#line  766
  return;
}
}
//#line  768 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int port0 ;
  uint8_t *buf ;
  int buf_free ;
  int length ;
  int i ;
  int portnum ;
  struct usbmidi_out_port *port ;
  int tmp ;

  {
//#line  770
  port0 = ep->current_port;
//#line  771
  buf = (ep->urb)->transfer_buffer;
//#line  772
  buf_free = ep->max_transfer;
//#line  775
  i = 0;
//#line  775
  while (i < 16) {
//#line  777
    portnum = (port0 + i) & 15;
//#line  778
    port = & ep->ports[portnum];
//#line  780
    if (! port->active) {
//#line  781
      goto __Cont;
    }
//#line  782
    tmp = snd_rawmidi_transmit_peek((struct snd_rawmidi_substream *)port->substream,
                                    buf, 1);
//#line  782
    if (tmp != 1) {
//#line  783
      port->active = 0;
//#line  784
      goto __Cont;
    }
//#line  787
    if (portnum != ep->current_port) {
//#line  788
      if (buf_free < 2) {
//#line  789
        break;
      }
//#line  790
      ep->current_port = portnum;
//#line  791
      *(buf + 0) = (uint8_t )245;
//#line  792
      *(buf + 1) = (uint8_t )((portnum + 1) & 15);
//#line  793
      buf += 2;
//#line  794
      buf_free -= 2;
    }
//#line  797
    if (buf_free < 1) {
//#line  798
      break;
    }
//#line  799
    length = snd_rawmidi_transmit((struct snd_rawmidi_substream *)port->substream,
                                  buf, buf_free);
//#line  800
    if (length > 0) {
//#line  801
      buf += length;
//#line  802
      buf_free -= length;
//#line  803
      if (buf_free < 1) {
//#line  804
        break;
      }
    }
    __Cont: /* CIL Label */ 
//#line  775
    i ++;
  }
//#line  807
  if (buf_free < ep->max_transfer) {
//#line  807
    if (buf_free > 0) {
//#line  808
      *buf = (uint8_t )255;
//#line  809
      buf_free --;
    }
  }
//#line  811
  (ep->urb)->transfer_buffer_length = ep->max_transfer - buf_free;
//#line  812
  return;
}
}
//#line  814 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_usb_midi *umidi ;
  struct usbmidi_out_port *port ;
  int i ;
  int j ;

  {
//#line  816
  umidi = (struct snd_usb_midi *)(substream->rmidi)->private_data;
//#line  817
  port = (struct usbmidi_out_port *)((void *)0);
//#line  820
  i = 0;
//#line  820
  while (i < 2) {
//#line  821
    if (umidi->endpoints[i].out) {
//#line  822
      j = 0;
//#line  822
      while (j < 16) {
//#line  823
        if ((unsigned long )(umidi->endpoints[i].out)->ports[j].substream == (unsigned long )substream) {
//#line  824
          port = & (umidi->endpoints[i].out)->ports[j];
//#line  825
          break;
        }
//#line  822
        j ++;
      }
    }
//#line  820
    i ++;
  }
//#line  827
  if (! port) {
//#line  828
    while (1) {
//#line  828
      break;
    }
//#line  829
    return (-6);
  }
//#line  831
  (substream->runtime)->private_data = (void * __attribute__((__recursive__)) )port;
//#line  832
  port->state = (uint8_t )0;
//#line  833
  return (0);
}
}
//#line  836 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream ) 
{ 


  {
//#line  838
  return (0);
}
}
//#line  841 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream , int up___0 ) 
{ 
  struct usbmidi_out_port *port ;
  int tmp ;

  {
//#line  843
  port = (struct usbmidi_out_port *)(substream->runtime)->private_data;
//#line  845
  port->active = up___0;
//#line  846
  if (up___0) {
//#line  847
    if ((((port->ep)->umidi)->chip)->shutdown) {
//#line  850
      while (1) {
//#line  850
        tmp = snd_rawmidi_transmit_empty(substream);
//#line  850
        if (tmp) {
//#line  850
          break;
        }
//#line  851
        snd_rawmidi_transmit_ack(substream, 1);
      }
//#line  852
      return;
    }
//#line  854
    tasklet_schedule(& (port->ep)->tasklet);
  }
//#line  856
  return;
}
}
//#line  858 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream ) 
{ 


  {
//#line  860
  return (0);
}
}
//#line  863 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream ) 
{ 


  {
//#line  865
  return (0);
}
}
//#line  868 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream , int up___0 ) 
{ 
  struct snd_usb_midi *umidi ;

  {
//#line  870
  umidi = (struct snd_usb_midi *)(substream->rmidi)->private_data;
//#line  872
  if (up___0) {
//#line  873
    set_bit((unsigned int )substream->number, (unsigned long volatile   *)(& umidi->input_triggered));
  } else {
//#line  875
    clear_bit(substream->number, (unsigned long volatile   *)(& umidi->input_triggered));
  }
//#line  876
  return;
}
}
//#line  878 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct snd_rawmidi_ops snd_usbmidi_output_ops  =    {& snd_usbmidi_output_open, & snd_usbmidi_output_close, & snd_usbmidi_output_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  884 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct snd_rawmidi_ops snd_usbmidi_input_ops  =    {& snd_usbmidi_input_open, & snd_usbmidi_input_close, & snd_usbmidi_input_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  894 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep ) 
{ 


  {
//#line  896
  if (ep->urb) {
//#line  897
    usb_buffer_free(((ep->umidi)->chip)->dev, (size_t )(ep->urb)->transfer_buffer_length,
                    (void *)(ep->urb)->transfer_buffer, (ep->urb)->transfer_dma);
//#line  901
    usb_free_urb((struct urb *)ep->urb);
  }
//#line  903
  kfree((void const   *)ep);
//#line  904
  return;
}
}
//#line  909 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *ep_info ,
                                          struct snd_usb_midi_endpoint *rep ) 
{ 
  struct snd_usb_midi_in_endpoint *ep ;
  void *buffer ;
  unsigned int pipe ;
  int length ;
  void *tmp ;
  struct urb *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  __u16 tmp___3 ;

  {
//#line  918
  rep->in = (struct snd_usb_midi_in_endpoint *)((void *)0);
//#line  919
  tmp = kzalloc(sizeof(*ep), 208U);
//#line  919
  ep = (struct snd_usb_midi_in_endpoint *)tmp;
//#line  920
  if (! ep) {
//#line  921
    return (-12);
  }
//#line  922
  ep->umidi = umidi;
//#line  924
  tmp___0 = usb_alloc_urb(0, 208U);
//#line  924
  ep->urb = (struct urb * __attribute__((__recursive__)) )tmp___0;
//#line  925
  if (! ep->urb) {
//#line  926
    snd_usbmidi_in_endpoint_delete(ep);
//#line  927
    return (-12);
  }
//#line  929
  if (ep_info->in_interval) {
//#line  930
    tmp___1 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->in_ep);
//#line  930
    pipe = ((unsigned int )(1 << 30) | tmp___1) | 128U;
  } else {
//#line  932
    tmp___2 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->in_ep);
//#line  932
    pipe = ((unsigned int )(3 << 30) | tmp___2) | 128U;
  }
//#line  933
  tmp___3 = usb_maxpacket((umidi->chip)->dev, (int )pipe, 0);
//#line  933
  length = (int )tmp___3;
//#line  934
  buffer = usb_buffer_alloc((umidi->chip)->dev, (size_t )length, 208U, & (ep->urb)->transfer_dma);
//#line  936
  if (! buffer) {
//#line  937
    snd_usbmidi_in_endpoint_delete(ep);
//#line  938
    return (-12);
  }
//#line  940
  if (ep_info->in_interval) {
//#line  941
    usb_fill_int_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, length,
                     & snd_usbmidi_in_urb_complete, (void *)ep, (int )ep_info->in_interval);
  } else {
//#line  945
    usb_fill_bulk_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, length,
                      & snd_usbmidi_in_urb_complete, (void *)ep);
  }
//#line  947
  (ep->urb)->transfer_flags = 4U;
//#line  949
  rep->in = ep;
//#line  950
  return (0);
}
}
//#line  953 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static unsigned int snd_usbmidi_count_bits(unsigned int x ) 
{ 
  unsigned int bits ;

  {
//#line  957
  bits = 0U;
//#line  957
  while (x) {
//#line  958
    x &= x - 1U;
//#line  957
    bits ++;
  }
//#line  959
  return (bits);
}
}
//#line  966 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
//#line  968
  if (ep->urb) {
//#line  969
    usb_buffer_free(((ep->umidi)->chip)->dev, (size_t )ep->max_transfer, (void *)(ep->urb)->transfer_buffer,
                    (ep->urb)->transfer_dma);
//#line  972
    usb_free_urb((struct urb *)ep->urb);
  }
//#line  974
  kfree((void const   *)ep);
//#line  975
  return;
}
}
//#line  1025 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct lock_class_key __key___4  ;
//#line  980 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *ep_info ,
                                           struct snd_usb_midi_endpoint *rep ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;
  int i ;
  unsigned int pipe ;
  void *buffer ;
  void *tmp ;
  struct urb *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  __u16 tmp___3 ;

  {
//#line  989
  rep->out = (struct snd_usb_midi_out_endpoint *)((void *)0);
//#line  990
  tmp = kzalloc(sizeof(*ep), 208U);
//#line  990
  ep = (struct snd_usb_midi_out_endpoint *)tmp;
//#line  991
  if (! ep) {
//#line  992
    return (-12);
  }
//#line  993
  ep->umidi = (struct snd_usb_midi * __attribute__((__recursive__)) )umidi;
//#line  995
  tmp___0 = usb_alloc_urb(0, 208U);
//#line  995
  ep->urb = (struct urb * __attribute__((__recursive__)) )tmp___0;
//#line  996
  if (! ep->urb) {
//#line  997
    snd_usbmidi_out_endpoint_delete(ep);
//#line  998
    return (-12);
  }
//#line  1000
  if (ep_info->out_interval) {
//#line  1001
    tmp___1 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->out_ep);
//#line  1001
    pipe = (unsigned int )(1 << 30) | tmp___1;
  } else {
//#line  1003
    tmp___2 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->out_ep);
//#line  1003
    pipe = (unsigned int )(3 << 30) | tmp___2;
  }
//#line  1004
  if ((umidi->chip)->usb_id == (u32 )((2706 << 16) | 4128)) {
//#line  1006
    ep->max_transfer = 4;
  } else {
//#line  1008
    tmp___3 = usb_maxpacket((umidi->chip)->dev, (int )pipe, 1);
//#line  1008
    ep->max_transfer = (int )tmp___3;
  }
//#line  1009
  buffer = usb_buffer_alloc((umidi->chip)->dev, (size_t )ep->max_transfer, 208U, & (ep->urb)->transfer_dma);
//#line  1011
  if (! buffer) {
//#line  1012
    snd_usbmidi_out_endpoint_delete(ep);
//#line  1013
    return (-12);
  }
//#line  1015
  if (ep_info->out_interval) {
//#line  1016
    usb_fill_int_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, ep->max_transfer,
                     & snd_usbmidi_out_urb_complete, (void *)ep, (int )ep_info->out_interval);
  } else {
//#line  1020
    usb_fill_bulk_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, ep->max_transfer,
                      & snd_usbmidi_out_urb_complete, (void *)ep);
  }
//#line  1023
  (ep->urb)->transfer_flags = 4U;
//#line  1025
  while (1) {
//#line  1025
    __spin_lock_init(& ep->buffer_lock, "&ep->buffer_lock", & __key___4);
//#line  1025
    break;
  }
//#line  1026
  tasklet_init(& ep->tasklet, (void (*)(unsigned long  ))(& snd_usbmidi_out_tasklet),
               (unsigned long )ep);
//#line  1028
  i = 0;
//#line  1028
  while (i < 16) {
//#line  1029
    if ((int )ep_info->out_cables & (1 << i)) {
//#line  1030
      ep->ports[i].ep = ep;
//#line  1031
      ep->ports[i].cable = (uint8_t )(i << 4);
    }
//#line  1028
    i ++;
  }
//#line  1034
  if ((umidi->usb_protocol_ops)->init_out_endpoint) {
//#line  1035
    (*((umidi->usb_protocol_ops)->init_out_endpoint))(ep);
  }
//#line  1037
  rep->out = ep;
//#line  1038
  return (0);
}
}
//#line  1044 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_free(struct snd_usb_midi *umidi ) 
{ 
  int i ;
  struct snd_usb_midi_endpoint *ep ;

  {
//#line  1048
  i = 0;
//#line  1048
  while (i < 2) {
//#line  1049
    ep = & umidi->endpoints[i];
//#line  1050
    if (ep->out) {
//#line  1051
      snd_usbmidi_out_endpoint_delete(ep->out);
    }
//#line  1052
    if (ep->in) {
//#line  1053
      snd_usbmidi_in_endpoint_delete(ep->in);
    }
//#line  1048
    i ++;
  }
//#line  1055
  kfree((void const   *)umidi);
//#line  1056
  return;
}
}
//#line  1061 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_disconnect(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const __attribute__((__recursive__)) *__mptr ;
  struct snd_usb_midi_endpoint *ep ;

  {
//#line  1066
  __mptr = (struct list_head  const __attribute__((__recursive__)) *)p;
//#line  1066
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  1072
  _spin_lock_irq(& umidi->disc_lock);
//#line  1073
  umidi->disconnected = (unsigned char)1;
//#line  1074
  _spin_unlock_irq(& umidi->disc_lock);
//#line  1075
  i = 0;
//#line  1075
  while (i < 2) {
//#line  1076
    ep = & umidi->endpoints[i];
//#line  1077
    if (ep->out) {
//#line  1078
      tasklet_kill(& (ep->out)->tasklet);
    }
//#line  1079
    if (ep->out) {
//#line  1079
      if ((ep->out)->urb) {
//#line  1080
        usb_kill_urb((struct urb *)(ep->out)->urb);
//#line  1081
        if ((umidi->usb_protocol_ops)->finish_out_endpoint) {
//#line  1082
          (*((umidi->usb_protocol_ops)->finish_out_endpoint))(ep->out);
        }
      }
    }
//#line  1084
    if (ep->in) {
//#line  1085
      usb_kill_urb((struct urb *)(ep->in)->urb);
    }
//#line  1087
    if (ep->out) {
//#line  1088
      snd_usbmidi_out_endpoint_delete(ep->out);
//#line  1089
      ep->out = (struct snd_usb_midi_out_endpoint *)((void *)0);
    }
//#line  1091
    if (ep->in) {
//#line  1092
      snd_usbmidi_in_endpoint_delete(ep->in);
//#line  1093
      ep->in = (struct snd_usb_midi_in_endpoint *)((void *)0);
    }
//#line  1075
    i ++;
  }
//#line  1096
  del_timer_sync(& umidi->error_timer);
//#line  1097
  return;
}
}
//#line  1099 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi ) 
{ 
  struct snd_usb_midi *umidi ;

  {
//#line  1101
  umidi = (struct snd_usb_midi *)rmidi->private_data;
//#line  1102
  snd_usbmidi_free(umidi);
//#line  1103
  return;
}
}
//#line  1105 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi ,
                                                                int stream , int number ) 
{ 
  struct list_head *list ;
  struct snd_rawmidi_substream *substream ;
  struct list_head  const __attribute__((__noderef__)) *__mptr ;

  {
//#line  1109
  list = (struct list_head *)(umidi->rmidi)->streams[stream].substreams.next;
//#line  1109
  while (1) {
//#line  1109
    __builtin_prefetch((void const   *)list->next);
//#line  1109
    if (! ((unsigned long )list != (unsigned long )(& (umidi->rmidi)->streams[stream].substreams))) {
//#line  1109
      break;
    }
//#line  1110
    __mptr = (struct list_head  const __attribute__((__noderef__)) *)list;
//#line  1110
    substream = (struct snd_rawmidi_substream *)((char *)__mptr - (unsigned int )(& ((struct snd_rawmidi_substream *)0)->list));
//#line  1111
    if (substream->number == number) {
//#line  1112
      return (substream);
    }
//#line  1109
    list = (struct list_head *)list->next;
  }
//#line  1114
  return ((struct snd_rawmidi_substream *)((void *)0));
}
}
//#line  1122 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct port_info snd_usbmidi_port_info[57]  = 
//#line  1122
  {      {(u32 )(1410 << 16), (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 3), (short)0, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)1, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)2, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part C",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)3, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part D",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)4, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 3), (short)5, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 4), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 4), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 7), (short)0, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 7),
      (short)1, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 7),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 11), (short)0, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 11),
      (short)1, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 11),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 12), (short)0, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 12),
      (short)1, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 12),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 20), (short)8, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 22), (short)0, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 22),
      (short)1, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 22),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 22), (short)3, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 35), (short)5, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 39), (short)0, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 39),
      (short)1, (short)64, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 39),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 41), (short)0, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part A",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 41),
      (short)1, (short)128, (char const   * __attribute__((__nullterm__)) )"%s Part B",
      (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 41),
      (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 41), (short)3, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 43), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 43), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 47), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 47), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s External MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 47), (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Sync",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51), (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 59), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 59), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 68), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 68), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 72), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 72), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 72), (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 1",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77), (short)2, (short)0, (char const   * __attribute__((__nullterm__)) )"%s 2",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 154), (short)3, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1891 << 16) | 4145), (short)8, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1891 << 16) | 4147), (short)8, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Control",
      (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((2045 << 16) | 1), (short)0, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI A",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2045 << 16) | 1), (short)1, (short)0, (char const   * __attribute__((__nullterm__)) )"%s MIDI B",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 1), (short)8, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Broadcast",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 2), (short)8, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Broadcast",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 3), (short)4, (short)0, (char const   * __attribute__((__nullterm__)) )"%s Broadcast",
      (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}};
//#line  1242 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct port_info *find_port_info(struct snd_usb_midi *umidi , int number ) 
{ 
  int i ;

  {
//#line  1246
  i = 0;
//#line  1246
  while ((unsigned long )i < sizeof(snd_usbmidi_port_info) / sizeof(snd_usbmidi_port_info[0]) + (sizeof(char [1]) - 1UL)) {
//#line  1247
    if (snd_usbmidi_port_info[i].id == (umidi->chip)->usb_id) {
//#line  1247
      if ((int )snd_usbmidi_port_info[i].port == number) {
//#line  1249
        return (& snd_usbmidi_port_info[i]);
      }
    }
//#line  1246
    i ++;
  }
//#line  1251
  return ((struct port_info *)((void *)0));
}
}
//#line  1254 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *seq_port_info ) 
{ 
  struct snd_usb_midi *umidi ;
  struct port_info *port_info ;

  {
//#line  1257
  umidi = (struct snd_usb_midi *)rmidi->private_data;
//#line  1261
  port_info = find_port_info(umidi, number);
//#line  1262
  if (port_info) {
//#line  1263
    seq_port_info->type = port_info->seq_flags;
//#line  1264
    seq_port_info->midi_voices = (int )port_info->voices;
  }
//#line  1266
  return;
}
}
//#line  1268 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_init_substream(struct snd_usb_midi *umidi , int stream , int number ,
                                       struct snd_rawmidi_substream **rsubstream ) 
{ 
  struct port_info *port_info ;
  char const   * __attribute__((__nullterm__)) name_format ;
  struct snd_rawmidi_substream *substream ;
  struct snd_rawmidi_substream *tmp ;

  {
//#line  1275
  tmp = snd_usbmidi_find_substream(umidi, stream, number);
//#line  1275
  substream = tmp;
//#line  1276
  if (! substream) {
//#line  1277
    while (1) {
//#line  1277
      break;
    }
//#line  1278
    return;
  }
//#line  1282
  port_info = find_port_info(umidi, number);
//#line  1283
  if (port_info) {
//#line  1283
    name_format = port_info->name;
  } else {
//#line  1283
    name_format = (char const   * __attribute__((__nullterm__)) )"%s MIDI %d";
  }
//#line  1286
  sprintf(substream->name, (char const   *)name_format, ((umidi->chip)->card)->shortname,
          number + 1);
//#line  1288
  *rsubstream = substream;
//#line  1289
  return;
}
}
//#line  1294 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  int i ;
  int j ;
  int err ;
  int out_ports ;
  int in_ports ;

  {
//#line  1298
  out_ports = 0;
//#line  1298
  in_ports = 0;
//#line  1300
  i = 0;
//#line  1300
  while (i < 2) {
//#line  1301
    if ((endpoints + i)->out_cables) {
//#line  1302
      err = snd_usbmidi_out_endpoint_create(umidi, endpoints + i, & umidi->endpoints[i]);
//#line  1304
      if (err < 0) {
//#line  1305
        return (err);
      }
    }
//#line  1307
    if ((endpoints + i)->in_cables) {
//#line  1308
      err = snd_usbmidi_in_endpoint_create(umidi, endpoints + i, & umidi->endpoints[i]);
//#line  1310
      if (err < 0) {
//#line  1311
        return (err);
      }
    }
//#line  1314
    j = 0;
//#line  1314
    while (j < 16) {
//#line  1315
      if ((int )(endpoints + i)->out_cables & (1 << j)) {
//#line  1316
        snd_usbmidi_init_substream(umidi, 0, out_ports, (struct snd_rawmidi_substream **)(& (umidi->endpoints[i].out)->ports[j].substream));
//#line  1318
        out_ports ++;
      }
//#line  1320
      if ((int )(endpoints + i)->in_cables & (1 << j)) {
//#line  1321
        snd_usbmidi_init_substream(umidi, 1, in_ports, & (umidi->endpoints[i].in)->ports[j].substream);
//#line  1323
        in_ports ++;
      }
//#line  1314
      j ++;
    }
//#line  1300
    i ++;
  }
//#line  1327
  printk("<6>created %d output and %d input ports\n", out_ports, in_ports);
//#line  1329
  return (0);
}
}
//#line  1335 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_ms_header_descriptor *ms_header ;
  struct usb_host_endpoint *hostep ;
  struct usb_endpoint_descriptor *ep ;
  struct usb_ms_endpoint_descriptor *ms_ep ;
  int i ;
  int epidx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  1347
  intf = umidi->iface;
//#line  1348
  if (! intf) {
//#line  1349
    return (-6);
  }
//#line  1350
  hostif = intf->altsetting + 0;
//#line  1351
  intfd = & hostif->desc;
//#line  1352
  ms_header = (struct usb_ms_header_descriptor *)hostif->extra;
//#line  1353
  if (hostif->extralen >= 7) {
//#line  1353
    if ((int )ms_header->bLength >= 7) {
//#line  1353
      if ((int )ms_header->bDescriptorType == ((1 << 5) | 4)) {
//#line  1353
        if ((int )ms_header->bDescriptorSubtype == 1) {
//#line  1357
          printk("<6>MIDIStreaming version %02x.%02x\n", (int )ms_header->bcdMSC[1],
                 (int )ms_header->bcdMSC[0]);
        } else {
//#line  1360
          printk("<4>MIDIStreaming interface descriptor not found\n");
        }
      } else {
//#line  1360
        printk("<4>MIDIStreaming interface descriptor not found\n");
      }
    } else {
//#line  1360
      printk("<4>MIDIStreaming interface descriptor not found\n");
    }
  } else {
//#line  1360
    printk("<4>MIDIStreaming interface descriptor not found\n");
  }
//#line  1362
  epidx = 0;
//#line  1363
  i = 0;
//#line  1363
  while (i < (int )intfd->bNumEndpoints) {
//#line  1364
    hostep = hostif->endpoint + i;
//#line  1365
    ep = & hostep->desc;
//#line  1366
    tmp = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)ep);
//#line  1366
    if (! tmp) {
//#line  1366
      tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
//#line  1366
      if (! tmp___0) {
//#line  1367
        goto __Cont;
      }
    }
//#line  1368
    ms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;
//#line  1369
    if (hostep->extralen < 4) {
//#line  1373
      goto __Cont;
    } else
//#line  1369
    if ((int )ms_ep->bLength < 4) {
//#line  1373
      goto __Cont;
    } else
//#line  1369
    if ((int )ms_ep->bDescriptorType != ((1 << 5) | 5)) {
//#line  1373
      goto __Cont;
    } else
//#line  1369
    if ((int )ms_ep->bDescriptorSubtype != 1) {
//#line  1373
      goto __Cont;
    }
//#line  1374
    tmp___5 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)ep);
//#line  1374
    if (tmp___5) {
//#line  1375
      if ((endpoints + epidx)->out_ep) {
//#line  1376
        epidx ++;
//#line  1376
        if (epidx >= 2) {
//#line  1377
          printk("<4>too many endpoints\n");
//#line  1378
          break;
        }
      }
//#line  1381
      tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  1381
      (endpoints + epidx)->out_ep = (int8_t )tmp___1;
//#line  1382
      tmp___2 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
//#line  1382
      if (tmp___2) {
//#line  1383
        (endpoints + epidx)->out_interval = ep->bInterval;
      } else
//#line  1384
      if ((unsigned int )((umidi->chip)->dev)->speed == 1U) {
//#line  1390
        (endpoints + epidx)->out_interval = (uint8_t )1;
      }
//#line  1391
      (endpoints + epidx)->out_cables = (uint16_t )((1 << (int )ms_ep->bNumEmbMIDIJack) - 1);
//#line  1392
      printk("<6>EP %02X: %d jack(s)\n", (int )ep->bEndpointAddress, (int )ms_ep->bNumEmbMIDIJack);
    } else {
//#line  1395
      if ((endpoints + epidx)->in_ep) {
//#line  1396
        epidx ++;
//#line  1396
        if (epidx >= 2) {
//#line  1397
          printk("<4>too many endpoints\n");
//#line  1398
          break;
        }
      }
//#line  1401
      tmp___3 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  1401
      (endpoints + epidx)->in_ep = (int8_t )tmp___3;
//#line  1402
      tmp___4 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
//#line  1402
      if (tmp___4) {
//#line  1403
        (endpoints + epidx)->in_interval = ep->bInterval;
      } else
//#line  1404
      if ((unsigned int )((umidi->chip)->dev)->speed == 1U) {
//#line  1405
        (endpoints + epidx)->in_interval = (uint8_t )1;
      }
//#line  1406
      (endpoints + epidx)->in_cables = (uint16_t )((1 << (int )ms_ep->bNumEmbMIDIJack) - 1);
//#line  1407
      printk("<6>EP %02X: %d jack(s)\n", (int )ep->bEndpointAddress, (int )ms_ep->bNumEmbMIDIJack);
    }
    __Cont: /* CIL Label */ 
//#line  1363
    i ++;
  }
//#line  1411
  return (0);
}
}
//#line  1418 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;

  {
//#line  1424
  intf = umidi->iface;
//#line  1425
  if (! intf) {
//#line  1426
    return;
  } else
//#line  1425
  if (intf->num_altsetting != 2U) {
//#line  1426
    return;
  }
//#line  1428
  hostif = intf->altsetting + 1;
//#line  1429
  intfd = & hostif->desc;
//#line  1430
  if ((int )intfd->bNumEndpoints != 2) {
//#line  1433
    return;
  } else
//#line  1430
  if (((int )(hostif->endpoint + 0)->desc.bmAttributes & 3) != 2) {
//#line  1433
    return;
  } else
//#line  1430
  if (((int )(hostif->endpoint + 1)->desc.bmAttributes & 3) != 3) {
//#line  1433
    return;
  }
//#line  1435
  printk("<6>switching to altsetting %d with int ep\n", (int )intfd->bAlternateSetting);
//#line  1437
  usb_set_interface((umidi->chip)->dev, (int )intfd->bInterfaceNumber, (int )intfd->bAlternateSetting);
//#line  1439
  return;
}
}
//#line  1444 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ,
                                        int max_endpoints ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_endpoint_descriptor *epd ;
  int i ;
  int out_eps ;
  int in_eps ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
//#line  1452
  out_eps = 0;
//#line  1452
  in_eps = 0;
//#line  1454
  if ((umidi->chip)->usb_id >> 16 == 1410U) {
//#line  1455
    snd_usbmidi_switch_roland_altsetting(umidi);
  }
//#line  1457
  if ((endpoint + 0)->out_ep) {
//#line  1458
    return (0);
  } else
//#line  1457
  if ((endpoint + 0)->in_ep) {
//#line  1458
    return (0);
  }
//#line  1460
  intf = umidi->iface;
//#line  1461
  if (! intf) {
//#line  1462
    return (-2);
  } else
//#line  1461
  if (intf->num_altsetting < 1U) {
//#line  1462
    return (-2);
  }
//#line  1463
  hostif = intf->cur_altsetting;
//#line  1464
  intfd = & hostif->desc;
//#line  1466
  i = 0;
//#line  1466
  while (i < (int )intfd->bNumEndpoints) {
//#line  1467
    epd = & (hostif->endpoint + i)->desc;
//#line  1468
    tmp = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
//#line  1468
    if (! tmp) {
//#line  1468
      tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
//#line  1468
      if (! tmp___0) {
//#line  1470
        goto __Cont;
      }
    }
//#line  1471
    if (out_eps < max_endpoints) {
//#line  1471
      tmp___3 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
//#line  1471
      if (tmp___3) {
//#line  1473
        tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)epd);
//#line  1473
        (endpoint + out_eps)->out_ep = (int8_t )tmp___1;
//#line  1474
        tmp___2 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
//#line  1474
        if (tmp___2) {
//#line  1475
          (endpoint + out_eps)->out_interval = epd->bInterval;
        }
//#line  1476
        out_eps ++;
      }
    }
//#line  1478
    if (in_eps < max_endpoints) {
//#line  1478
      tmp___6 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)epd);
//#line  1478
      if (tmp___6) {
//#line  1480
        tmp___4 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)epd);
//#line  1480
        (endpoint + in_eps)->in_ep = (int8_t )tmp___4;
//#line  1481
        tmp___5 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
//#line  1481
        if (tmp___5) {
//#line  1482
          (endpoint + in_eps)->in_interval = epd->bInterval;
        }
//#line  1483
        in_eps ++;
      }
    }
    __Cont: /* CIL Label */ 
//#line  1466
    i ++;
  }
//#line  1486
  if (out_eps) {
//#line  1486
    tmp___7 = 0;
  } else
//#line  1486
  if (in_eps) {
//#line  1486
    tmp___7 = 0;
  } else {
//#line  1486
    tmp___7 = -2;
  }
//#line  1486
  return (tmp___7);
}
}
//#line  1492 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  int err ;
  int i ;

  {
//#line  1497
  err = snd_usbmidi_detect_endpoints(umidi, endpoints, 2);
//#line  1498
  i = 0;
//#line  1498
  while (i < 2) {
//#line  1499
    if ((endpoints + i)->out_ep) {
//#line  1500
      (endpoints + i)->out_cables = (uint16_t )1;
    }
//#line  1501
    if ((endpoints + i)->in_ep) {
//#line  1502
      (endpoints + i)->in_cables = (uint16_t )1;
    }
//#line  1498
    i ++;
  }
//#line  1504
  return (err);
}
}
//#line  1510 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  uint8_t *cs_desc ;
  int tmp ;

  {
//#line  1518
  intf = umidi->iface;
//#line  1519
  if (! intf) {
//#line  1520
    return (-2);
  }
//#line  1521
  hostif = intf->altsetting;
//#line  1522
  intfd = & hostif->desc;
//#line  1523
  if ((int )intfd->bNumEndpoints < 1) {
//#line  1524
    return (-2);
  }
//#line  1530
  cs_desc = (uint8_t *)hostif->extra;
//#line  1530
  while (1) {
//#line  1530
    if ((unsigned long )cs_desc < (unsigned long )(hostif->extra + hostif->extralen)) {
//#line  1530
      if (! ((int )*(cs_desc + 0) >= 2)) {
//#line  1530
        break;
      }
    } else {
//#line  1530
      break;
    }
//#line  1533
    if ((int )*(cs_desc + 1) == ((1 << 5) | 4)) {
//#line  1534
      if ((int )*(cs_desc + 2) == 2) {
//#line  1535
        endpoint->in_cables = (uint16_t )(((int )endpoint->in_cables << 1) | 1);
      } else
//#line  1536
      if ((int )*(cs_desc + 2) == 3) {
//#line  1537
        endpoint->out_cables = (uint16_t )(((int )endpoint->out_cables << 1) | 1);
      }
    }
//#line  1530
    cs_desc += (int )*(cs_desc + 0);
  }
//#line  1540
  if (! endpoint->in_cables) {
//#line  1540
    if (! endpoint->out_cables) {
//#line  1541
      return (-2);
    }
  }
//#line  1543
  tmp = snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
//#line  1543
  return (tmp);
}
}
//#line  1549 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ) 
{ 
  struct snd_usb_midi_endpoint_info ep_info ;
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_endpoint_descriptor *epd ;
  int cable ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  1559
  intf = umidi->iface;
//#line  1560
  if (! intf) {
//#line  1561
    return (-2);
  }
//#line  1562
  hostif = intf->altsetting;
//#line  1563
  intfd = & hostif->desc;
//#line  1574
  if ((int )endpoint->out_cables > 1) {
//#line  1574
    tmp = 5;
  } else {
//#line  1574
    tmp = 3;
  }
//#line  1574
  if ((int )intfd->bNumEndpoints < tmp) {
//#line  1575
    printk("<3>not enough endpoints\n");
//#line  1576
    return (-2);
  }
//#line  1579
  epd = & (hostif->endpoint + 0)->desc;
//#line  1580
  tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)epd);
//#line  1580
  if (tmp___0) {
//#line  1580
    tmp___1 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
//#line  1580
    if (! tmp___1) {
//#line  1581
      printk("<3>endpoint[0] isn\'t interrupt\n");
//#line  1582
      return (-6);
    }
  } else {
//#line  1581
    printk("<3>endpoint[0] isn\'t interrupt\n");
//#line  1582
    return (-6);
  }
//#line  1584
  epd = & (hostif->endpoint + 2)->desc;
//#line  1585
  tmp___2 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
//#line  1585
  if (tmp___2) {
//#line  1585
    tmp___3 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
//#line  1585
    if (! tmp___3) {
//#line  1586
      printk("<3>endpoint[2] isn\'t bulk output\n");
//#line  1587
      return (-6);
    }
  } else {
//#line  1586
    printk("<3>endpoint[2] isn\'t bulk output\n");
//#line  1587
    return (-6);
  }
//#line  1589
  if ((int )endpoint->out_cables > 1) {
//#line  1590
    epd = & (hostif->endpoint + 4)->desc;
//#line  1591
    tmp___4 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
//#line  1591
    if (tmp___4) {
//#line  1591
      tmp___5 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
//#line  1591
      if (! tmp___5) {
//#line  1593
        printk("<3>endpoint[4] isn\'t bulk output\n");
//#line  1594
        return (-6);
      }
    } else {
//#line  1593
      printk("<3>endpoint[4] isn\'t bulk output\n");
//#line  1594
      return (-6);
    }
  }
//#line  1598
  ep_info.out_ep = (int8_t )((int )(hostif->endpoint + 2)->desc.bEndpointAddress & 15);
//#line  1599
  ep_info.out_interval = (uint8_t )0;
//#line  1600
  ep_info.out_cables = (uint16_t )((int )endpoint->out_cables & 21845);
//#line  1601
  err = snd_usbmidi_out_endpoint_create(umidi, & ep_info, & umidi->endpoints[0]);
//#line  1602
  if (err < 0) {
//#line  1603
    return (err);
  }
//#line  1605
  ep_info.in_ep = (int8_t )((int )(hostif->endpoint + 0)->desc.bEndpointAddress & 15);
//#line  1606
  ep_info.in_interval = (hostif->endpoint + 0)->desc.bInterval;
//#line  1607
  ep_info.in_cables = endpoint->in_cables;
//#line  1608
  err = snd_usbmidi_in_endpoint_create(umidi, & ep_info, & umidi->endpoints[0]);
//#line  1609
  if (err < 0) {
//#line  1610
    return (err);
  }
//#line  1612
  if ((int )endpoint->out_cables > 1) {
//#line  1613
    ep_info.out_ep = (int8_t )((int )(hostif->endpoint + 4)->desc.bEndpointAddress & 15);
//#line  1614
    ep_info.out_cables = (uint16_t )((int )endpoint->out_cables & 43690);
//#line  1615
    err = snd_usbmidi_out_endpoint_create(umidi, & ep_info, & umidi->endpoints[1]);
//#line  1616
    if (err < 0) {
//#line  1617
      return (err);
    }
  }
//#line  1620
  cable = 0;
//#line  1620
  while (cable < 16) {
//#line  1621
    if ((int )endpoint->out_cables & (1 << cable)) {
//#line  1622
      snd_usbmidi_init_substream(umidi, 0, cable, (struct snd_rawmidi_substream **)(& (umidi->endpoints[cable & 1].out)->ports[cable].substream));
    }
//#line  1624
    if ((int )endpoint->in_cables & (1 << cable)) {
//#line  1625
      snd_usbmidi_init_substream(umidi, 1, cable, & (umidi->endpoints[0].in)->ports[cable].substream);
    }
//#line  1620
    cable ++;
  }
//#line  1628
  return (0);
}
}
//#line  1631 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct snd_rawmidi_global_ops snd_usbmidi_ops  =    {(int (*)(struct snd_rawmidi *rmidi ))0, (int (*)(struct snd_rawmidi *rmidi ))0,
    & snd_usbmidi_get_port_info};
//#line  1635 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi , int out_ports ,
                                      int in_ports ) 
{ 
  struct snd_rawmidi *rmidi ;
  int err ;
  int tmp ;

  {
//#line  1638
  rmidi = (struct snd_rawmidi *)((void *)0);
//#line  1641
  tmp = (umidi->chip)->next_midi_device;
//#line  1641
  ((umidi->chip)->next_midi_device) ++;
//#line  1641
  err = snd_rawmidi_new((umidi->chip)->card, (char * __attribute__((__nullterm__)) )"USB MIDI",
                        tmp, out_ports, in_ports, & rmidi);
//#line  1644
  if (err < 0) {
//#line  1645
    return (err);
  }
//#line  1646
  strcpy(rmidi->name, (char const   *)(((umidi->chip)->card)->shortname));
//#line  1647
  rmidi->info_flags = 7U;
//#line  1650
  rmidi->ops = & snd_usbmidi_ops;
//#line  1651
  rmidi->private_data = (void * __attribute__((__recursive__, __noderef__)) )umidi;
//#line  1652
  rmidi->private_free = & snd_usbmidi_rawmidi_free;
//#line  1653
  snd_rawmidi_set_ops(rmidi, 0, & snd_usbmidi_output_ops);
//#line  1654
  snd_rawmidi_set_ops(rmidi, 1, & snd_usbmidi_input_ops);
//#line  1656
  umidi->rmidi = (struct snd_rawmidi * __attribute__((__recursive__)) )rmidi;
//#line  1657
  return (0);
}
}
//#line  1663 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_input_stop(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const __attribute__((__recursive__)) *__mptr ;
  struct snd_usb_midi_endpoint *ep ;

  {
//#line  1668
  __mptr = (struct list_head  const __attribute__((__recursive__)) *)p;
//#line  1668
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  1669
  i = 0;
//#line  1669
  while (i < 2) {
//#line  1670
    ep = & umidi->endpoints[i];
//#line  1671
    if (ep->in) {
//#line  1672
      usb_kill_urb((struct urb *)(ep->in)->urb);
    }
//#line  1669
    i ++;
  }
//#line  1674
  return;
}
}
//#line  1676 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep ) 
{ 
  struct urb *urb ;

  {
//#line  1679
  if (ep) {
//#line  1680
    urb = usb_alloc_urb(0, 208U);
//#line  1681
    ep->urb = (struct urb * __attribute__((__recursive__)) )urb;
//#line  1682
    urb->dev = (struct usb_device * __attribute__((__recursive__)) )((ep->umidi)->chip)->dev;
//#line  1683
    snd_usbmidi_submit_urb(urb, 208U);
  }
//#line  1685
  return;
}
}
//#line  1690 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
void snd_usbmidi_input_start(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const __attribute__((__recursive__)) *__mptr ;

  {
//#line  1695
  __mptr = (struct list_head  const __attribute__((__recursive__)) *)p;
//#line  1695
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  1696
  i = 0;
//#line  1696
  while (i < 2) {
//#line  1697
    snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
//#line  1696
    i ++;
  }
//#line  1698
  return;
}
}
//#line  1720 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct lock_class_key __key___6  ;
//#line  1703 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
int snd_usb_create_midi_interface(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct snd_usb_midi *umidi ;
  struct snd_usb_midi_endpoint_info endpoints[2] ;
  int out_ports ;
  int in_ports ;
  int i ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
//#line  1712
  tmp = kzalloc(sizeof(*umidi), 208U);
//#line  1712
  umidi = (struct snd_usb_midi *)tmp;
//#line  1713
  if (! umidi) {
//#line  1714
    return (-12);
  }
//#line  1715
  umidi->chip = chip;
//#line  1716
  umidi->iface = iface;
//#line  1717
  umidi->quirk = quirk;
//#line  1718
  umidi->usb_protocol_ops = & snd_usbmidi_standard_ops;
//#line  1719
  init_timer(& umidi->error_timer);
//#line  1720
  while (1) {
//#line  1720
    __spin_lock_init(& umidi->disc_lock, "&umidi->disc_lock", & __key___6);
//#line  1720
    break;
  }
//#line  1721
  umidi->error_timer.function = (void (*)(unsigned long  ))(& snd_usbmidi_error_timer);
//#line  1722
  umidi->error_timer.data = (void *)((unsigned long )umidi);
//#line  1725
  memset((void *)(endpoints), 0, sizeof(endpoints));
//#line  1726
  if (quirk) {
//#line  1726
    tmp___0 = (int const   )quirk->type;
  } else {
//#line  1726
    tmp___0 = (int const   )2;
  }
//#line  1726
  switch ((int )tmp___0) {
  case 2: 
//#line  1728
  err = snd_usbmidi_get_ms_info(umidi, endpoints);
//#line  1729
  if (chip->usb_id == (u32 )((1891 << 16) | 336)) {
//#line  1730
    umidi->usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops;
  }
//#line  1732
  break;
  case 10: 
//#line  1734
  umidi->usb_protocol_ops = & snd_usbmidi_122l_ops;
  case 3: 
//#line  1737
  __len = sizeof(struct snd_usb_midi_endpoint_info );
//#line  1737
  if (__len >= 64UL) {
//#line  1737
    __ret = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len);
  } else {
//#line  1737
    __ret = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                             __len);
  }
//#line  1739
  err = snd_usbmidi_detect_endpoints(umidi, & endpoints[0], 1);
//#line  1740
  break;
  case 4: 
//#line  1742
  err = snd_usbmidi_detect_yamaha(umidi, & endpoints[0]);
//#line  1743
  break;
  case 5: 
//#line  1745
  umidi->usb_protocol_ops = & snd_usbmidi_midiman_ops;
//#line  1746
  __len___0 = sizeof(struct snd_usb_midi_endpoint_info );
//#line  1746
  if (__len___0 >= 64UL) {
//#line  1746
    __ret___0 = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len___0);
  } else {
//#line  1746
    __ret___0 = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                                 __len___0);
  }
//#line  1748
  err = 0;
//#line  1749
  break;
  case 6: 
//#line  1751
  umidi->usb_protocol_ops = & snd_usbmidi_novation_ops;
//#line  1752
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
//#line  1753
  break;
  case 7: 
//#line  1755
  umidi->usb_protocol_ops = & snd_usbmidi_raw_ops;
//#line  1756
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
//#line  1757
  break;
  case 8: 
//#line  1759
  umidi->usb_protocol_ops = & snd_usbmidi_emagic_ops;
//#line  1760
  __len___1 = sizeof(struct snd_usb_midi_endpoint_info );
//#line  1760
  if (__len___1 >= 64UL) {
//#line  1760
    __ret___1 = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len___1);
  } else {
//#line  1760
    __ret___1 = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                                 __len___1);
  }
//#line  1762
  err = snd_usbmidi_detect_endpoints(umidi, & endpoints[0], 1);
//#line  1763
  break;
  case 9: 
//#line  1765
  umidi->usb_protocol_ops = & snd_usbmidi_cme_ops;
//#line  1766
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
//#line  1767
  break;
  default: 
//#line  1769
  while (1) {
//#line  1769
    break;
  }
//#line  1770
  err = -6;
//#line  1771
  break;
  }
//#line  1773
  if (err < 0) {
//#line  1774
    kfree((void const   *)umidi);
//#line  1775
    return (err);
  }
//#line  1779
  out_ports = 0;
//#line  1780
  in_ports = 0;
//#line  1781
  i = 0;
//#line  1781
  while (i < 2) {
//#line  1782
    tmp___1 = snd_usbmidi_count_bits((unsigned int )endpoints[i].out_cables);
//#line  1782
    out_ports = (int )((unsigned int )out_ports + tmp___1);
//#line  1783
    tmp___2 = snd_usbmidi_count_bits((unsigned int )endpoints[i].in_cables);
//#line  1783
    in_ports = (int )((unsigned int )in_ports + tmp___2);
//#line  1781
    i ++;
  }
//#line  1785
  err = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);
//#line  1786
  if (err < 0) {
//#line  1787
    kfree((void const   *)umidi);
//#line  1788
    return (err);
  }
//#line  1792
  if (quirk) {
//#line  1792
    if ((int const   )quirk->type == 5) {
//#line  1793
      err = snd_usbmidi_create_endpoints_midiman(umidi, & endpoints[0]);
    } else {
//#line  1795
      err = snd_usbmidi_create_endpoints(umidi, endpoints);
    }
  } else {
//#line  1795
    err = snd_usbmidi_create_endpoints(umidi, endpoints);
  }
//#line  1796
  if (err < 0) {
//#line  1797
    snd_usbmidi_free(umidi);
//#line  1798
    return (err);
  }
//#line  1801
  list_add((struct list_head *)(& umidi->list), & (umidi->chip)->midi_list);
//#line  1803
  i = 0;
//#line  1803
  while (i < 2) {
//#line  1804
    snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
//#line  1803
    i ++;
  }
//#line  1805
  return (0);
}
}
//#line  1808 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __kstrtab_snd_usb_create_midi_interface[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  1808
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'_',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'f',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'\000'};
//#line  1808 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct kernel_symbol  const  __ksymtab_snd_usb_create_midi_interface  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usb_create_midi_interface), __kstrtab_snd_usb_create_midi_interface};
//#line  1809 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __kstrtab_snd_usbmidi_input_stop[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  1809
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )'_',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'p',      (char const   )'\000'};
//#line  1809 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_input_stop  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_input_stop), __kstrtab_snd_usbmidi_input_stop};
//#line  1810 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __kstrtab_snd_usbmidi_input_start[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  1810
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )'_',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )'\000'};
//#line  1810 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_input_start  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_input_start), __kstrtab_snd_usbmidi_input_start};
//#line  1811 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static char const   __kstrtab_snd_usbmidi_disconnect[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  1811
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'n',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'\000'};
//#line  1811 "/scratch/sym/ipc_drivers/usb-audio/usbmidi.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_disconnect  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_disconnect), __kstrtab_snd_usbmidi_disconnect};
//#line  1 "usbmixer.o"
#pragma merger(0,"./usbmixer.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  119 "include/linux/kernel.h"
extern int _cond_resched(void) ;
//#line  126
extern void __might_sleep(char *file , int line ) ;
//#line  153 "include/linux/kernel.h"
__inline static void ( __attribute__((__always_inline__)) might_fault)(void) 
{ 


  {
//#line  155
  while (1) {
//#line  155
    __might_sleep((char *)"include/linux/kernel.h", 155);
//#line  155
    _cond_resched();
//#line  155
    break;
  }
//#line  156
  return;
}
}
//#line  51 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/pda.h"
extern  __attribute__((__noreturn__)) void __bad_pda_field(void) ;
//#line  57
extern struct x8664_pda _proxy_pda ;
//#line  23 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/current.h"
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ 
  struct task_struct *ret__ ;

  {
//#line  25
  switch ((int )sizeof(_proxy_pda.pcurrent)) {
  case 2: 
//#line  25
  __asm__  ("mov"
            "w %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  25
  break;
  case 4: 
//#line  25
  __asm__  ("mov"
            "l %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  25
  break;
  case 8: 
//#line  25
  __asm__  ("mov"
            "q %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  25
  break;
  default: 
//#line  25
  __bad_pda_field();
  }
//#line  25
  return (ret__);
}
}
//#line  23 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/cmpxchg_64.h"
__inline static unsigned long ( __attribute__((__always_inline__)) __xchg)(unsigned long x ,
                                                                           void volatile   *ptr ,
                                                                           int size ) 
{ 


  {
//#line  26
  switch (size) {
  case 1: 
//#line  28
  __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  32
  break;
  case 2: 
//#line  34
  __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  38
  break;
  case 4: 
//#line  40
  __asm__  volatile   ("xchgl %k0,%1": "=r" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  44
  break;
  case 8: 
//#line  46
  __asm__  volatile   ("xchgq %0,%1": "=r" (x): "m" (*((long volatile   *)ptr)), "0" (x): "memory");
//#line  50
  break;
  }
//#line  52
  return (x);
}
}
//#line  53 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/string_64.h"
extern unsigned long strlen(char const   *s ) ;
//#line  56
extern int strcmp(char const   *cs , char const   *ct ) ;
//#line  84 "include/linux/thread_info.h"
__inline static int ( __attribute__((__always_inline__)) test_ti_thread_flag)(struct thread_info *ti ,
                                                                              int flag ) 
{ 
  int tmp___0 ;

  {
//#line  86
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
//#line  86
  return (tmp___0);
}
}
//#line  80 "include/linux/wait.h"
extern void init_waitqueue_head(wait_queue_head_t *q ) ;
//#line  436
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
//#line  438
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
//#line  441
extern int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync ,
                                    void *key ) ;
//#line  334 "include/linux/sched.h"
extern void schedule(void) ;
//#line  2116 "include/linux/sched.h"
__inline static int ( __attribute__((__always_inline__)) test_tsk_thread_flag)(struct task_struct *tsk ,
                                                                               int flag ) 
{ 
  int tmp ;

  {
//#line  2118
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
//#line  2118
  return (tmp);
}
}
//#line  2136 "include/linux/sched.h"
__inline static int ( __attribute__((__always_inline__)) signal_pending)(struct task_struct *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
//#line  2138
  tmp = test_tsk_thread_flag(p, 2);
//#line  2138
  if (tmp) {
//#line  2138
    tmp___0 = 1;
  } else {
//#line  2138
    tmp___0 = 0;
  }
//#line  2138
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
//#line  2138
  return ((int )tmp___1);
}
}
//#line  1395 "include/linux/usb.h"
__inline static void ( __attribute__((__always_inline__)) usb_fill_control_urb)(struct urb *urb ,
                                                                                struct usb_device *dev ,
                                                                                unsigned int pipe ,
                                                                                unsigned char *setup_packet ,
                                                                                void *transfer_buffer ,
                                                                                int buffer_length ,
                                                                                void (*complete_fn)(struct urb * ) ,
                                                                                void *context ) 
{ 


  {
//#line  1404
  urb->dev = (struct usb_device * __attribute__((__recursive__)) )dev;
//#line  1405
  urb->pipe = pipe;
//#line  1406
  urb->setup_packet = setup_packet;
//#line  1407
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  1408
  urb->transfer_buffer_length = buffer_length;
//#line  1409
  urb->complete = complete_fn;
//#line  1410
  urb->context = (u8 * __attribute__((__recursive__, __noderef__)) )context;
//#line  1411
  return;
}
}
//#line  155 "include/sound/control.h"
extern void snd_ctl_notify(struct snd_card *card , unsigned int mask , struct snd_ctl_elem_id *id ) ;
//#line  157
extern struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew ,
                                         void *private_data ) ;
//#line  159
extern int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) ;
//#line  164
extern struct snd_kcontrol *snd_ctl_find_id(struct snd_card *card , struct snd_ctl_elem_id *id ) ;
//#line  210
extern int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-usb-audio/arch/x86/include/asm/uaccess_64.h"
extern unsigned long __attribute__((__warn_unused_result__))  copy_to_user(void *to ,
                                                                           void const   *from ,
                                                                           unsigned int len ) ;
//#line  37 "include/linux/poll.h"
__inline static void ( __attribute__((__always_inline__)) poll_wait)(struct file *filp ,
                                                                     wait_queue_head_t *wait_address ,
                                                                     poll_table *p ) 
{ 


  {
//#line  39
  if (p) {
//#line  39
    if (wait_address) {
//#line  40
      (*(p->qproc))(filp, wait_address, p);
    }
  }
//#line  41
  return;
}
}
//#line  69 "include/sound/hwdep.h"
extern int snd_hwdep_new(struct snd_card *card , char * __attribute__((__nullterm__)) id ,
                         int device , struct snd_hwdep **rhwdep ) ;
//#line  57 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct rc_config  const  rc_configs[3]  = {      {(u32 )((1054 << 16) | 12288), (u8 )0, (u8 )1, (u8 )2, (u8 )1, (u8 )18, (u32 )19}, 
        {(u32 )((1054 << 16) | 12320),
      (u8 )2, (u8 )1, (u8 )6, (u8 )6, (u8 )18, (u32 )19}, 
        {(u32 )((1054 << 16) | 12352), (u8 )2, (u8 )2, (u8 )6, (u8 )6, (u8 )2, (u32 )28305}};
//#line  64 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map extigy_map[20]  = 
//#line  64 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
  {      {2, "PCM Playback", 0}, 
        {5, (char const   *)((void *)0), 0}, 
        {6, "Digital In", 0}, 
        {8, "Line Playback", 0}, 
        {10, "Mic Playback", 0}, 
        {11, "Capture Input Source", 0}, 
        {12, "Capture", 0}, 
        {17, (char const   *)((void *)0), 1}, 
        {17, "Channel Routing", 2}, 
        {18, "Tone Control - Bass", 3}, 
        {18, "Tone Control - Treble", 5}, 
        {18, "Master Playback", 0}, 
        {21, (char const   *)((void *)0), 0}, 
        {22, "Digital Out Playback", 0}, 
        {23, "Digital Out1 Playback", 0}, 
        {25, "IEC958 Optical Playback", 0}, 
        {26, "IEC958 Optical Playback", 0}, 
        {27, (char const   *)((void *)0), 0}, 
        {29, (char const   *)((void *)0), 0}, 
        {0, (char const   *)0, 0}};
//#line  105 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map mp3plus_map[7]  = {      {8, "Capture Input Source", 0}, 
        {9, "Master Playback", 0}, 
        {10, "Mic Boost", 7}, 
        {11, "Line Capture", 0}, 
        {12, "Digital In Playback", 0}, 
        {14, "Line Playback", 0}, 
        {0, (char const   *)0, 0}};
//#line  143 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map audigy2nx_map[17]  = 
//#line  143
  {      {6, "Digital In Playback", 0}, 
        {8, "Line Playback", 0}, 
        {11, "What-U-Hear Capture", 0}, 
        {12, "Line Capture", 0}, 
        {13, "Digital In Capture", 0}, 
        {14, "Capture Source", 0}, 
        {17, (char const   *)((void *)0), 0}, 
        {18, "Master Playback", 0}, 
        {21, (char const   *)((void *)0), 0}, 
        {22, "Digital Out Playback", 0}, 
        {23, (char const   *)((void *)0), 0}, 
        {27, (char const   *)((void *)0), 0}, 
        {28, "Speaker Playback", 0}, 
        {29, "Digital Out Source", 0}, 
        {30, "Headphone Playback", 0}, 
        {31, "Headphone Source", 0}, 
        {0, (char const   *)0, 0}};
//#line  171 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static char const   *__constr_expr_0___0[3]  = {      "Line",      "Digital In",      "What-U-Hear"};
//#line  171 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static char const   *__constr_expr_1___0[3]  = {      "Front",      "PCM",      "Digital In"};
//#line  171 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static char const   *__constr_expr_2___0[2]  = {      "Front",      "Side"};
//#line  171 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_selector_map audigy2nx_selectors[4]  = {      {14, 3, __constr_expr_0___0}, 
        {29, 3, __constr_expr_1___0}, 
        {31, 2, __constr_expr_2___0}, 
        {0, 0, (char const   **)0}};
//#line  191 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map live24ext_map[2]  = {      {5, "Mic Capture", 0}, 
        {0, (char const   *)0, 0}};
//#line  198 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map linex_map[2]  = {      {3, "Master", 0}, 
        {0, (char const   *)0, 0}};
//#line  205 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map maya44_map[5]  = {      {2, "Line Playback", 0}, 
        {4, "Line Playback", 0}, 
        {7, "Master Playback", 0}, 
        {10, "Line Capture", 0}, 
        {0, (char const   *)0, 0}};
//#line  228 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map justlink_map[6]  = {      {3, (char const   *)((void *)0), 0}, 
        {7, "Master Playback", 0}, 
        {8, (char const   *)((void *)0), 0}, 
        {9, (char const   *)((void *)0), 0}, 
        {12, (char const   *)((void *)0), 0}, 
        {0, (char const   *)0, 0}};
//#line  245 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_name_map aureon_51_2_map[8]  = 
//#line  245
  {      {8, "Capture Source", 0}, 
        {9, "Master Playback", 0}, 
        {10, "Mic Capture", 0}, 
        {11, "Line Capture", 0}, 
        {12, "IEC958 In Capture", 0}, 
        {13, "Mic Playback", 0}, 
        {14, "Line Playback", 0}, 
        {0, (char const   *)0, 0}};
//#line  268 "/scratch/sym/ipc_drivers/usb-audio/usbmixer_maps.c"
static struct usbmix_ctl_map usbmix_ctl_maps[11]  = 
//#line  268
  {      {(u32 )((1054 << 16) | 12288), (struct usbmix_name_map  const  *)(extigy_map),
      (struct usbmix_selector_map  const  *)0, 1}, 
        {(u32 )((1054 << 16) | 12304), (struct usbmix_name_map  const  *)(mp3plus_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((1054 << 16) | 12320), (struct usbmix_name_map  const  *)(audigy2nx_map),
      (struct usbmix_selector_map  const  *)(audigy2nx_selectors), 0}, 
        {(u32 )((1054 << 16) | 12352), (struct usbmix_name_map  const  *)(live24ext_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((1784 << 16) | 45056), (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      1}, 
        {(u32 )((1784 << 16) | 53250), (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      1}, 
        {(u32 )((2235 << 16) | 9986), (struct usbmix_name_map  const  *)(linex_map),
      (struct usbmix_selector_map  const  *)0, 1}, 
        {(u32 )((2706 << 16) | 145), (struct usbmix_name_map  const  *)(maya44_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((3141 << 16) | 4440), (struct usbmix_name_map  const  *)(justlink_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((3277 << 16) | 40), (struct usbmix_name_map  const  *)(aureon_51_2_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )0, (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      0}};
//#line  195 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
int Nonstub_return_buflen(int buflen ) 
{ 


  {
//#line  196
  return (buflen);
}
}
//#line  201 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int check_mapped_name(struct mixer_build *state , int unitid , int control ,
                             char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                             int buflen ) 
{ 
  struct usbmix_name_map  const  *p ;
  size_t tmp ;

  {
//#line  207
  if (! state->map) {
//#line  208
    return (0);
  }
//#line  210
  p = state->map;
//#line  210
  while (p->id) {
//#line  211
    if (p->id == (int const   )unitid) {
//#line  211
      if (p->name) {
//#line  211
        if (! control) {
//#line  213
          buflen --;
//#line  214
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
//#line  214
          return ((int )tmp);
        } else
//#line  211
        if (! p->control) {
//#line  213
          buflen --;
//#line  214
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
//#line  214
          return ((int )tmp);
        } else
//#line  211
        if (control == (int )p->control) {
//#line  213
          buflen --;
//#line  214
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
//#line  214
          return ((int )tmp);
        }
      }
    }
//#line  210
    p ++;
  }
//#line  217
  return (0);
}
}
//#line  221 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int check_ignored_ctl(struct mixer_build *state , int unitid , int control ) 
{ 
  struct usbmix_name_map  const  *p ;

  {
//#line  225
  if (! state->map) {
//#line  226
    return (0);
  }
//#line  227
  p = state->map;
//#line  227
  while (p->id) {
//#line  228
    if (p->id == (int const   )unitid) {
//#line  228
      if (! p->name) {
//#line  228
        if (! control) {
//#line  231
          return (1);
        } else
//#line  228
        if (! p->control) {
//#line  231
          return (1);
        } else
//#line  228
        if (control == (int )p->control) {
//#line  231
          return (1);
        }
      }
    }
//#line  227
    p ++;
  }
//#line  234
  return (0);
}
}
//#line  238 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int check_mapped_selector_name(struct mixer_build *state , int unitid , int index___0 ,
                                      char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                                      int buflen ) 
{ 
  struct usbmix_selector_map  const  *p ;
  size_t tmp ;

  {
//#line  245
  if (! state->selector_map) {
//#line  246
    return (0);
  }
//#line  247
  p = state->selector_map;
//#line  247
  while (p->id) {
//#line  248
    if (p->id == (int const   )unitid) {
//#line  248
      if (index___0 < (int )p->count) {
//#line  249
        tmp = strlcpy((char *)buf, *(p->names + index___0), (size_t )buflen);
//#line  249
        return ((int )tmp);
      }
    }
//#line  247
    p ++;
  }
//#line  251
  return (0);
}
}
//#line  257 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void *find_audio_control_unit(struct mixer_build *state , unsigned char unit ) 
{ 
  unsigned char *p ;
  void *tmp ;

  {
//#line  261
  p = (unsigned char *)((void *)0);
//#line  262
  while (1) {
//#line  262
    tmp = snd_usb_find_desc((void *)state->buffer, (int )state->buflen, (void *)p,
                            (u8 )((1 << 5) | 4));
//#line  262
    p = (unsigned char *)tmp;
//#line  262
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
//#line  262
      break;
    }
//#line  264
    if ((int )*(p + 0) >= 4) {
//#line  264
      if ((int )*(p + 2) >= 2) {
//#line  264
        if ((int )*(p + 2) <= 8) {
//#line  264
          if ((int )*(p + 3) == (int )unit) {
//#line  265
            return ((void *)p);
          }
        }
      }
    }
  }
//#line  267
  return ((void *)0);
}
}
//#line  274 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_copy_string_desc(struct mixer_build *state , int index___0 , char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                                    int maxlen ) 
{ 
  int len ;
  int tmp ;

  {
//#line  278
  tmp = usb_string((state->chip)->dev, index___0, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )buf,
                   (size_t )(maxlen - 1));
//#line  278
  len = tmp;
//#line  279
  *(buf + len) = (char)0;
//#line  280
  return (len);
}
}
//#line  286 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int convert_signed_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
//#line  288
  switch (cval->val_type) {
  case 0: 
//#line  290
  return (! (! val));
  case 1: 
//#line  292
  return (! val);
  case 3: 
//#line  294
  val &= 255;
//#line  295
  break;
  case 2: 
//#line  297
  val &= 255;
//#line  298
  if (val >= 128) {
//#line  299
    val -= 256;
  }
//#line  300
  break;
  case 5: 
//#line  302
  val &= 65535;
//#line  303
  break;
  case 4: 
//#line  305
  val &= 65535;
//#line  306
  if (val >= 32768) {
//#line  307
    val -= 65536;
  }
//#line  308
  break;
  }
//#line  310
  return (val);
}
}
//#line  316 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int convert_bytes_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
//#line  318
  switch (cval->val_type) {
  case 0: 
//#line  320
  return (! (! val));
  case 1: 
//#line  322
  return (! val);
  case 2: 
  case 3: 
//#line  325
  return (val & 255);
  case 4: 
  case 5: 
//#line  328
  return (val & 65535);
  }
//#line  330
  return (0);
}
}
//#line  333 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_relative_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
//#line  335
  if (! cval->res) {
//#line  336
    cval->res = 1;
  }
//#line  337
  if (val < cval->min) {
//#line  338
    return (0);
  } else
//#line  339
  if (val >= cval->max) {
//#line  340
    return ((((cval->max - cval->min) + cval->res) - 1) / cval->res);
  } else {
//#line  342
    return ((val - cval->min) / cval->res);
  }
}
}
//#line  345 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_abs_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
//#line  347
  if (val < 0) {
//#line  348
    return (cval->min);
  }
//#line  349
  if (! cval->res) {
//#line  350
    cval->res = 1;
  }
//#line  351
  val *= cval->res;
//#line  352
  val += cval->min;
//#line  353
  if (val > cval->max) {
//#line  354
    return (cval->max);
  }
//#line  355
  return (val);
}
}
//#line  363 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_ctl_value(struct usb_mixer_elem_info *cval , int request , int validx ,
                         int *value_ret ) 
{ 
  unsigned char buf[2] ;
  int val_len ;
  int tmp ;
  int timeout ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
//#line  366
  if (cval->val_type >= 4) {
//#line  366
    tmp = 2;
  } else {
//#line  366
    tmp = 1;
  }
//#line  366
  val_len = tmp;
//#line  367
  timeout = 10;
//#line  369
  while (1) {
//#line  369
    tmp___3 = timeout;
//#line  369
    timeout --;
//#line  369
    if (! (tmp___3 > 0)) {
//#line  369
      break;
    }
//#line  370
    tmp___1 = __create_pipe(((cval->mixer)->chip)->dev, 0U);
//#line  370
    tmp___2 = snd_usb_ctl_msg(((cval->mixer)->chip)->dev, ((unsigned int )(2 << 30) | tmp___1) | 128U,
                              (__u8 )request, (__u8 )((1 | (1 << 5)) | 128), (__u16 )validx,
                              (__u16 )((cval->mixer)->ctrlif | (cval->id << 8)), (void *)(buf),
                              (__u16 )val_len, 100);
//#line  370
    if (tmp___2 >= val_len) {
//#line  376
      tmp___0 = snd_usb_combine_bytes(buf, val_len);
//#line  376
      *value_ret = convert_signed_value(cval, (int )tmp___0);
//#line  377
      return (0);
    }
  }
//#line  382
  return (-22);
}
}
//#line  385 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_cur_ctl_value(struct usb_mixer_elem_info *cval , int validx , int *value ) 
{ 
  int tmp ;

  {
//#line  387
  tmp = get_ctl_value(cval, 129, validx, value);
//#line  387
  return (tmp);
}
}
//#line  391 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
__inline static int ( __attribute__((__always_inline__)) get_cur_mix_value)(struct usb_mixer_elem_info *cval ,
                                                                            int channel ,
                                                                            int *value ) 
{ 
  int tmp ;

  {
//#line  393
  tmp = get_ctl_value(cval, 129, (int )((cval->control << 8) | (unsigned int )channel),
                      value);
//#line  393
  return (tmp);
}
}
//#line  400 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int set_ctl_value(struct usb_mixer_elem_info *cval , int request , int validx ,
                         int value_set ) 
{ 
  unsigned char buf[2] ;
  int val_len ;
  int tmp ;
  int timeout ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
//#line  403
  if (cval->val_type >= 4) {
//#line  403
    tmp = 2;
  } else {
//#line  403
    tmp = 1;
  }
//#line  403
  val_len = tmp;
//#line  404
  timeout = 10;
//#line  406
  value_set = convert_bytes_value(cval, value_set);
//#line  407
  buf[0] = (unsigned char )(value_set & 255);
//#line  408
  buf[1] = (unsigned char )((value_set >> 8) & 255);
//#line  409
  while (1) {
//#line  409
    tmp___2 = timeout;
//#line  409
    timeout --;
//#line  409
    if (! (tmp___2 > 0)) {
//#line  409
      break;
    }
//#line  410
    tmp___0 = __create_pipe(((cval->mixer)->chip)->dev, 0U);
//#line  410
    tmp___1 = snd_usb_ctl_msg(((cval->mixer)->chip)->dev, (unsigned int )(2 << 30) | tmp___0,
                              (__u8 )request, (__u8 )(1 | (1 << 5)), (__u16 )validx,
                              (__u16 )((cval->mixer)->ctrlif | (cval->id << 8)), (void *)(buf),
                              (__u16 )val_len, 100);
//#line  410
    if (tmp___1 >= 0) {
//#line  416
      return (0);
    }
  }
//#line  419
  return (-22);
}
}
//#line  422 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int set_cur_ctl_value(struct usb_mixer_elem_info *cval , int validx , int value ) 
{ 
  int tmp ;

  {
//#line  424
  tmp = set_ctl_value(cval, 1, validx, value);
//#line  424
  return (tmp);
}
}
//#line  427 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
__inline static int ( __attribute__((__always_inline__)) set_cur_mix_value)(struct usb_mixer_elem_info *cval ,
                                                                            int channel ,
                                                                            int value ) 
{ 
  int tmp ;

  {
//#line  429
  tmp = set_ctl_value(cval, 1, (int )((cval->control << 8) | (unsigned int )channel),
                      value);
//#line  429
  return (tmp);
}
}
//#line  435 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_vol_tlv(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                         unsigned int *_tlv ) 
{ 
  struct usb_mixer_elem_info *cval ;
  unsigned int scale[4] ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
//#line  438
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  439
  scale[0] = 1U;
//#line  439
  scale[1] = (unsigned int )(2UL * sizeof(unsigned int ));
//#line  439
  scale[2] = 0U;
//#line  439
  scale[3] = 0U;
//#line  441
  if ((unsigned long )size < sizeof(scale)) {
//#line  442
    return (-12);
  }
//#line  446
  tmp = convert_signed_value(cval, cval->min);
//#line  446
  scale[2] = (unsigned int )((tmp * 100) / 256);
//#line  447
  tmp___0 = convert_signed_value(cval, cval->res);
//#line  447
  scale[3] = (unsigned int )((tmp___0 * 100) / 256);
//#line  448
  tmp___1 = (unsigned long )copy_to_user((void *)_tlv, (void const   *)(scale), (unsigned int )sizeof(scale));
//#line  448
  if (tmp___1) {
//#line  449
    return (-14);
  }
//#line  450
  return (0);
}
}
//#line  457
static int parse_audio_unit(struct mixer_build *state , int unitid ) ;
//#line  464 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int check_matrix_bitmap(unsigned char *bmap___0 , int ich , int och , int num_outs ) 
{ 
  int idx ;

  {
//#line  466
  idx = ich * num_outs + och;
//#line  467
  return ((int )*(bmap___0 + (idx >> 3)) & (128 >> (idx & 7)));
}
}
//#line  478 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int add_control_to_empty(struct mixer_build *state , struct snd_kcontrol *kctl ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int err ;
  struct snd_kcontrol *tmp ;

  {
//#line  480
  cval = (struct usb_mixer_elem_info *)kctl->private_data;
//#line  483
  while (1) {
//#line  483
    tmp = snd_ctl_find_id((state->chip)->card, & kctl->id);
//#line  483
    if (! tmp) {
//#line  483
      break;
    }
//#line  484
    (kctl->id.index) ++;
  }
//#line  485
  err = snd_ctl_add((state->chip)->card, kctl);
//#line  485
  if (err < 0) {
//#line  486
    while (1) {
//#line  486
      break;
    }
//#line  487
    return (err);
  }
//#line  489
  cval->elem_id = & kctl->id;
//#line  490
  cval->next_id_elem = (struct usb_mixer_elem_info * __attribute__((__recursive__)) )*((state->mixer)->id_elems + cval->id);
//#line  491
  *((state->mixer)->id_elems + cval->id) = cval;
//#line  492
  return (0);
}
}
//#line  500 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct iterm_name_combo iterm_names[37]  = 
//#line  500
  {      {768, (char * __attribute__((__nullterm__)) )"Output"}, 
        {769, (char * __attribute__((__nullterm__)) )"Speaker"}, 
        {770, (char * __attribute__((__nullterm__)) )"Headphone"}, 
        {771, (char * __attribute__((__nullterm__)) )"HMD Audio"}, 
        {772, (char * __attribute__((__nullterm__)) )"Desktop Speaker"}, 
        {773, (char * __attribute__((__nullterm__)) )"Room Speaker"}, 
        {774, (char * __attribute__((__nullterm__)) )"Com Speaker"}, 
        {775, (char * __attribute__((__nullterm__)) )"LFE"}, 
        {1536, (char * __attribute__((__nullterm__)) )"External In"}, 
        {1537, (char * __attribute__((__nullterm__)) )"Analog In"}, 
        {1538, (char * __attribute__((__nullterm__)) )"Digital In"}, 
        {1539, (char * __attribute__((__nullterm__)) )"Line"}, 
        {1540, (char * __attribute__((__nullterm__)) )"Legacy In"}, 
        {1541, (char * __attribute__((__nullterm__)) )"IEC958 In"}, 
        {1542, (char * __attribute__((__nullterm__)) )"1394 DA Stream"}, 
        {1543, (char * __attribute__((__nullterm__)) )"1394 DV Stream"}, 
        {1792, (char * __attribute__((__nullterm__)) )"Embedded"}, 
        {1793, (char * __attribute__((__nullterm__)) )"Noise Source"}, 
        {1794, (char * __attribute__((__nullterm__)) )"Equalization Noise"}, 
        {1795, (char * __attribute__((__nullterm__)) )"CD"}, 
        {1796, (char * __attribute__((__nullterm__)) )"DAT"}, 
        {1797, (char * __attribute__((__nullterm__)) )"DCC"}, 
        {1798, (char * __attribute__((__nullterm__)) )"MiniDisk"}, 
        {1799, (char * __attribute__((__nullterm__)) )"Analog Tape"}, 
        {1800, (char * __attribute__((__nullterm__)) )"Phonograph"}, 
        {1801, (char * __attribute__((__nullterm__)) )"VCR Audio"}, 
        {1802, (char * __attribute__((__nullterm__)) )"Video Disk Audio"}, 
        {1803, (char * __attribute__((__nullterm__)) )"DVD Audio"}, 
        {1804, (char * __attribute__((__nullterm__)) )"TV Tuner Audio"}, 
        {1805, (char * __attribute__((__nullterm__)) )"Satellite Rec Audio"}, 
        {1806, (char * __attribute__((__nullterm__)) )"Cable Tuner Audio"}, 
        {1807, (char * __attribute__((__nullterm__)) )"DSS Audio"}, 
        {1808, (char * __attribute__((__nullterm__)) )"Radio Receiver"}, 
        {1809, (char * __attribute__((__nullterm__)) )"Radio Transmitter"}, 
        {1810, (char * __attribute__((__nullterm__)) )"Multi-Track Recorder"}, 
        {1811, (char * __attribute__((__nullterm__)) )"Synthesizer"}, 
        {0, (char * __attribute__((__nullterm__)) )0}};
//#line  543 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_term_name(struct mixer_build *state , struct usb_audio_term *iterm ,
                         unsigned char *name , int maxlen , int term_only ) 
{ 
  struct iterm_name_combo *names ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
//#line  548
  if (iterm->name) {
//#line  549
    tmp = snd_usb_copy_string_desc(state, iterm->name, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )name,
                                   maxlen);
//#line  549
    return (tmp);
  }
//#line  552
  if (iterm->type >> 16) {
//#line  553
    if (term_only) {
//#line  554
      return (0);
    }
//#line  555
    switch (iterm->type >> 16) {
    case 5: 
//#line  557
    strcpy((char *)name, "Selector");
//#line  557
    return (8);
    case 7: 
//#line  559
    strcpy((char *)name, "Process Unit");
//#line  559
    return (12);
    case 8: 
//#line  561
    strcpy((char *)name, "Ext Unit");
//#line  561
    return (8);
    case 4: 
//#line  563
    strcpy((char *)name, "Mixer");
//#line  563
    return (5);
    default: 
//#line  565
    tmp___0 = sprintf((char *)name, "Unit %d", iterm->id);
//#line  565
    return (tmp___0);
    }
  }
//#line  569
  switch (iterm->type & 65280) {
  case 256: 
//#line  571
  strcpy((char *)name, "PCM");
//#line  571
  return (3);
  case 512: 
//#line  573
  strcpy((char *)name, "Mic");
//#line  573
  return (3);
  case 1024: 
//#line  575
  strcpy((char *)name, "Headset");
//#line  575
  return (7);
  case 1280: 
//#line  577
  strcpy((char *)name, "Phone");
//#line  577
  return (5);
  }
//#line  580
  names = iterm_names;
//#line  580
  while (names->type) {
//#line  581
    if (names->type == iterm->type) {
//#line  582
      strcpy((char *)name, (char const   *)names->name);
//#line  583
      tmp___1 = strlen((char const   *)names->name);
//#line  583
      return ((int )tmp___1);
    }
//#line  580
    names ++;
  }
//#line  585
  return (0);
}
}
//#line  593 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int check_input_term(struct mixer_build *state , int id___0 , struct usb_audio_term *term ) 
{ 
  unsigned char *p1 ;
  int tmp ;
  void *tmp___0 ;

  {
//#line  597
  memset((void *)term, 0, sizeof(*term));
//#line  598
  while (1) {
//#line  598
    tmp___0 = find_audio_control_unit(state, (unsigned char )id___0);
//#line  598
    p1 = (unsigned char *)tmp___0;
//#line  598
    if (! ((unsigned long )p1 != (unsigned long )((void *)0))) {
//#line  598
      break;
    }
//#line  599
    term->id = id___0;
//#line  600
    switch ((int )*(p1 + 2)) {
    case 2: 
//#line  602
    term->type = (int )((unsigned int )((int )*p1 + 4) | ((unsigned int )*((p1 + 4) + 1) << 8));
//#line  603
    term->channels = (int )*(p1 + 7);
//#line  604
    term->chconfig = (unsigned int )((int )*p1 + 8) | ((unsigned int )*((p1 + 8) + 1) << 8);
//#line  605
    term->name = (int )*(p1 + 11);
//#line  606
    return (0);
    case 6: 
//#line  608
    id___0 = (int )*(p1 + 4);
//#line  609
    break;
    case 4: 
//#line  611
    term->type = (int )*(p1 + 2) << 16;
//#line  612
    term->channels = (int )*(p1 + (5 + (int )*(p1 + 4)));
//#line  613
    term->chconfig = (unsigned int )(((int )*p1 + 6) + (int )*(p1 + 4)) | ((unsigned int )*(((p1 + 6) + (int )*(p1 + 4)) + 1) << 8);
//#line  614
    term->name = (int )*(p1 + ((int )*(p1 + 0) - 1));
//#line  615
    return (0);
    case 5: 
//#line  618
    tmp = check_input_term(state, (int )*(p1 + 5), term);
//#line  618
    if (tmp < 0) {
//#line  619
      return (-19);
    }
//#line  620
    term->type = (int )*(p1 + 2) << 16;
//#line  621
    term->id = id___0;
//#line  622
    term->name = (int )*(p1 + ((9 + (int )*(p1 + 0)) - 1));
//#line  623
    return (0);
    case 7: 
    case 8: 
//#line  626
    if ((int )*(p1 + 6) == 1) {
//#line  627
      id___0 = (int )*(p1 + 7);
//#line  628
      break;
    }
//#line  630
    term->type = (int )*(p1 + 2) << 16;
//#line  631
    term->channels = (int )*(p1 + (7 + (int )*(p1 + 6)));
//#line  632
    term->chconfig = (unsigned int )(((int )*p1 + 8) + (int )*(p1 + 6)) | ((unsigned int )*(((p1 + 8) + (int )*(p1 + 6)) + 1) << 8);
//#line  633
    term->name = (int )*(p1 + ((12 + (int )*(p1 + 6)) + (int )*(p1 + (11 + (int )*(p1 + 6)))));
//#line  634
    return (0);
    default: 
//#line  636
    return (-19);
    }
  }
//#line  639
  return (-19);
}
}
//#line  653 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct usb_feature_control_info ( __attribute__((__noderef__, __address_space__(2))) audio_feature_info)[10]  = 
//#line  653
  {      {(char const   * __attribute__((__nullterm__)) )"Mute", 1U}, 
        {(char const   * __attribute__((__nullterm__)) )"Volume", 4U}, 
        {(char const   * __attribute__((__nullterm__)) )"Tone Control - Bass", 2U}, 
        {(char const   * __attribute__((__nullterm__)) )"Tone Control - Mid", 2U}, 
        {(char const   * __attribute__((__nullterm__)) )"Tone Control - Treble", 2U}, 
        {(char const   * __attribute__((__nullterm__)) )"Graphic Equalizer",
      2U}, 
        {(char const   * __attribute__((__nullterm__)) )"Auto Gain Control", 0U}, 
        {(char const   * __attribute__((__nullterm__)) )"Delay Control", 5U}, 
        {(char const   * __attribute__((__nullterm__)) )"Bass Boost", 0U}, 
        {(char const   * __attribute__((__nullterm__)) )"Loudness", 0U}};
//#line  668 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void usb_mixer_elem_free(struct snd_kcontrol *kctl ) 
{ 


  {
//#line  670
  kfree((void const   *)kctl->private_data);
//#line  671
  kctl->private_data = (char *)((void *)0);
//#line  672
  return;
}
}
//#line  682 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int get_min_max(struct usb_mixer_elem_info *cval , int default_min ) 
{ 
  int minchn ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int last_valid_res ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int last_valid_res___0 ;
  int saved ;
  int test ;
  int check ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  685
  cval->min = default_min;
//#line  686
  cval->max = cval->min + 1;
//#line  687
  cval->res = 1;
//#line  689
  if (cval->val_type == 0) {
//#line  691
    cval->initialized = (u8 )1;
  } else
//#line  689
  if (cval->val_type == 1) {
//#line  691
    cval->initialized = (u8 )1;
  } else {
//#line  693
    minchn = 0;
//#line  694
    if (cval->cmask) {
//#line  696
      i = 0;
//#line  696
      while (i < 10) {
//#line  697
        if (cval->cmask & (unsigned int )(1 << i)) {
//#line  698
          minchn = i + 1;
//#line  699
          break;
        }
//#line  696
        i ++;
      }
    }
//#line  702
    tmp = get_ctl_value(cval, 131, (int )((cval->control << 8) | (unsigned int )minchn),
                        & cval->max);
//#line  702
    if (tmp < 0) {
//#line  702
      goto _L;
    } else {
//#line  702
      tmp___0 = get_ctl_value(cval, 130, (int )((cval->control << 8) | (unsigned int )minchn),
                              & cval->min);
//#line  702
      if (tmp___0 < 0) {
        _L: /* CIL Label */ 
//#line  704
        while (1) {
//#line  704
          break;
        }
//#line  706
        return (-22);
      }
    }
//#line  708
    tmp___3 = get_ctl_value(cval, 132, (int )((cval->control << 8) | (unsigned int )minchn),
                            & cval->res);
//#line  708
    if (tmp___3 < 0) {
//#line  709
      cval->res = 1;
    } else {
//#line  711
      last_valid_res = cval->res;
//#line  713
      while (cval->res > 1) {
//#line  714
        tmp___1 = set_ctl_value(cval, 4, (int )((cval->control << 8) | (unsigned int )minchn),
                                cval->res / 2);
//#line  714
        if (tmp___1 < 0) {
//#line  715
          break;
        }
//#line  716
        cval->res /= 2;
      }
//#line  718
      tmp___2 = get_ctl_value(cval, 132, (int )((cval->control << 8) | (unsigned int )minchn),
                              & cval->res);
//#line  718
      if (tmp___2 < 0) {
//#line  719
        cval->res = last_valid_res;
      }
    }
//#line  721
    if (cval->res == 0) {
//#line  722
      cval->res = 1;
    }
//#line  730
    if (cval->min + cval->res < cval->max) {
//#line  731
      last_valid_res___0 = cval->res;
//#line  733
      get_cur_mix_value(cval, minchn, & saved);
//#line  734
      while (1) {
//#line  735
        test = saved;
//#line  736
        if (test < cval->max) {
//#line  737
          test += cval->res;
        } else {
//#line  739
          test -= cval->res;
        }
//#line  740
        if (test < cval->min) {
//#line  743
          cval->res = last_valid_res___0;
//#line  744
          break;
        } else
//#line  740
        if (test > cval->max) {
//#line  743
          cval->res = last_valid_res___0;
//#line  744
          break;
        } else {
//#line  740
          tmp___4 = set_cur_mix_value(cval, minchn, test);
//#line  740
          if (tmp___4) {
//#line  743
            cval->res = last_valid_res___0;
//#line  744
            break;
          } else {
//#line  740
            tmp___5 = get_cur_mix_value(cval, minchn, & check);
//#line  740
            if (tmp___5) {
//#line  743
              cval->res = last_valid_res___0;
//#line  744
              break;
            }
          }
        }
//#line  746
        if (test == check) {
//#line  747
          break;
        }
//#line  748
        cval->res *= 2;
      }
//#line  750
      set_cur_mix_value(cval, minchn, saved);
    }
//#line  753
    cval->initialized = (u8 )1;
  }
//#line  755
  return (0);
}
}
//#line  760 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct usb_mixer_elem_info *cval ;

  {
//#line  762
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  764
  if (cval->val_type == 0) {
//#line  766
    uinfo->type = 1;
  } else
//#line  764
  if (cval->val_type == 1) {
//#line  766
    uinfo->type = 1;
  } else {
//#line  768
    uinfo->type = 2;
  }
//#line  769
  uinfo->count = (unsigned int )cval->channels;
//#line  770
  if (cval->val_type == 0) {
//#line  772
    uinfo->value.integer.min = 0L;
//#line  773
    uinfo->value.integer.max = 1L;
  } else
//#line  770
  if (cval->val_type == 1) {
//#line  772
    uinfo->value.integer.min = 0L;
//#line  773
    uinfo->value.integer.max = 1L;
  } else {
//#line  775
    if (! cval->initialized) {
//#line  776
      get_min_max(cval, 0);
    }
//#line  777
    uinfo->value.integer.min = 0L;
//#line  778
    uinfo->value.integer.max = (long )((((cval->max - cval->min) + cval->res) - 1) / cval->res);
  }
//#line  781
  return (0);
}
}
//#line  785 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int c ;
  int cnt ;
  int val ;
  int err ;

  {
//#line  787
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  790
  if (cval->cmask) {
//#line  791
    cnt = 0;
//#line  792
    c = 0;
//#line  792
    while (c < 10) {
//#line  793
      if (cval->cmask & (unsigned int )(1 << c)) {
//#line  794
        err = get_cur_mix_value(cval, c + 1, & val);
//#line  795
        if (err < 0) {
//#line  796
          if ((cval->mixer)->ignore_ctl_error) {
//#line  797
            ucontrol->value.integer.value[0] = (long )cval->min;
//#line  798
            return (0);
          }
//#line  800
          while (1) {
//#line  800
            break;
          }
//#line  801
          return (err);
        }
//#line  803
        val = get_relative_value(cval, val);
//#line  804
        ucontrol->value.integer.value[cnt] = (long )val;
//#line  805
        cnt ++;
      }
//#line  792
      c ++;
    }
  } else {
//#line  810
    err = get_cur_mix_value(cval, 0, & val);
//#line  811
    if (err < 0) {
//#line  812
      if ((cval->mixer)->ignore_ctl_error) {
//#line  813
        ucontrol->value.integer.value[0] = (long )cval->min;
//#line  814
        return (0);
      }
//#line  816
      while (1) {
//#line  816
        break;
      }
//#line  817
      return (err);
    }
//#line  819
    val = get_relative_value(cval, val);
//#line  820
    ucontrol->value.integer.value[0] = (long )val;
  }
//#line  822
  return (0);
}
}
//#line  826 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int c ;
  int cnt ;
  int val ;
  int oval ;
  int err ;
  int changed ;

  {
//#line  828
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  830
  changed = 0;
//#line  832
  if (cval->cmask) {
//#line  833
    cnt = 0;
//#line  834
    c = 0;
//#line  834
    while (c < 10) {
//#line  835
      if (cval->cmask & (unsigned int )(1 << c)) {
//#line  836
        err = get_cur_mix_value(cval, c + 1, & oval);
//#line  837
        if (err < 0) {
//#line  838
          if ((cval->mixer)->ignore_ctl_error) {
//#line  839
            return (0);
          }
//#line  840
          return (err);
        }
//#line  842
        val = (int )ucontrol->value.integer.value[cnt];
//#line  843
        val = get_abs_value(cval, val);
//#line  844
        if (oval != val) {
//#line  845
          set_cur_mix_value(cval, c + 1, val);
//#line  846
          changed = 1;
        }
//#line  848
        get_cur_mix_value(cval, c + 1, & val);
//#line  849
        cnt ++;
      }
//#line  834
      c ++;
    }
  } else {
//#line  854
    err = get_cur_mix_value(cval, 0, & oval);
//#line  855
    if (err < 0) {
//#line  855
      if ((cval->mixer)->ignore_ctl_error) {
//#line  856
        return (0);
      }
    }
//#line  857
    if (err < 0) {
//#line  858
      return (err);
    }
//#line  859
    val = (int )ucontrol->value.integer.value[0];
//#line  860
    val = get_abs_value(cval, val);
//#line  861
    if (val != oval) {
//#line  862
      set_cur_mix_value(cval, 0, val);
//#line  863
      changed = 1;
    }
  }
//#line  866
  return (changed);
}
}
//#line  869 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) usb_feature_unit_ctl  = 
//#line  869
     {2, 0U, 0U, (unsigned char *)"", 0U, 0U, 0U, & mixer_ctl_feature_info, & mixer_ctl_feature_get,
    & mixer_ctl_feature_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  882 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void build_feature_ctl(struct mixer_build *state , unsigned char *desc , unsigned int ctl_mask ,
                              int control , struct usb_audio_term *iterm , int unitid ) 
{ 
  unsigned int len ;
  int mapped_name ;
  int nameid ;
  struct snd_kcontrol *kctl ;
  struct usb_mixer_elem_info *cval ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  int c ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
//#line  886
  len = 0U;
//#line  887
  mapped_name = 0;
//#line  888
  nameid = (int )*(desc + ((int )*(desc + 0) - 1));
//#line  892
  control ++;
//#line  894
  if (control == 6) {
//#line  896
    return;
  }
//#line  899
  tmp = check_ignored_ctl(state, unitid, control);
//#line  899
  if (tmp) {
//#line  900
    return;
  }
//#line  902
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  902
  cval = (struct usb_mixer_elem_info *)tmp___0;
//#line  903
  if (! cval) {
//#line  904
    printk("<3>cannot malloc kcontrol\n");
//#line  905
    return;
  }
//#line  907
  cval->mixer = state->mixer;
//#line  908
  cval->id = (unsigned int )unitid;
//#line  909
  cval->control = (unsigned int )control;
//#line  910
  cval->cmask = ctl_mask;
//#line  911
  cval->val_type = (int )audio_feature_info[control - 1].type;
//#line  912
  if (ctl_mask == 0U) {
//#line  913
    cval->channels = 1;
  } else {
//#line  915
    c = 0;
//#line  916
    i = 0;
//#line  916
    while (i < 16) {
//#line  917
      if (ctl_mask & (unsigned int )(1 << i)) {
//#line  918
        c ++;
      }
//#line  916
      i ++;
    }
//#line  919
    cval->channels = c;
  }
//#line  923
  get_min_max(cval, 0);
//#line  925
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& usb_feature_unit_ctl),
                      (void *)cval);
//#line  926
  if (! kctl) {
//#line  927
    printk("<3>cannot malloc kcontrol\n");
//#line  928
    kfree((void const   *)cval);
//#line  929
    return;
  }
//#line  931
  kctl->private_free = & usb_mixer_elem_free;
//#line  933
  tmp___1 = check_mapped_name(state, unitid, control, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  933
  len = (unsigned int )tmp___1;
//#line  934
  mapped_name = len != 0U;
//#line  935
  if (! len) {
//#line  935
    if (nameid) {
//#line  936
      tmp___2 = snd_usb_copy_string_desc(state, nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                         (int )sizeof(kctl->id.name));
//#line  936
      len = (unsigned int )tmp___2;
    }
  }
//#line  938
  switch (control) {
  case 1: 
  case 2: 
//#line  948
  if (! len) {
//#line  949
    tmp___3 = get_term_name(state, iterm, kctl->id.name, (int )sizeof(kctl->id.name),
                            1);
//#line  949
    len = (unsigned int )tmp___3;
//#line  950
    if (! len) {
//#line  951
      tmp___4 = get_term_name(state, & state->oterm, kctl->id.name, (int )sizeof(kctl->id.name),
                              1);
//#line  951
      len = (unsigned int )tmp___4;
    }
//#line  952
    if (! len) {
//#line  955
      tmp___5 = sprintf((char *)(kctl->id.name), "Feature %d", unitid);
//#line  955
      len = (unsigned int )tmp___5;
    }
  }
//#line  961
  if (! mapped_name) {
//#line  961
    if (! (state->oterm.type >> 16)) {
//#line  962
      if ((state->oterm.type & 65280) == 256) {
//#line  963
        tmp___6 = strlcat((char *)(kctl->id.name), " Capture", sizeof(kctl->id.name));
//#line  963
        len = (unsigned int )tmp___6;
      } else {
//#line  965
        tmp___7 = strlcat((char *)(kctl->id.name + len), " Playback", sizeof(kctl->id.name));
//#line  965
        len = (unsigned int )tmp___7;
      }
    }
  }
//#line  968
  if (control == 1) {
//#line  968
    tmp___8 = " Switch";
  } else {
//#line  968
    tmp___8 = " Volume";
  }
//#line  968
  strlcat((char *)(kctl->id.name + len), tmp___8, sizeof(kctl->id.name));
//#line  970
  if (control == 2) {
//#line  971
    kctl->tlv.c = & mixer_vol_tlv;
//#line  972
    kctl->vd[0].access |= (unsigned int )((1 << 4) | (1 << 28));
  }
//#line  976
  break;
  default: 
//#line  979
  if (! len) {
//#line  980
    strlcpy((char *)(kctl->id.name), (char const   *)audio_feature_info[control - 1].name,
            sizeof(kctl->id.name));
  }
//#line  982
  break;
  }
//#line  989
  switch ((int )(state->chip)->usb_id) {
  case (1137 << 16) | 257: 
  case (1137 << 16) | 260: 
  case (1137 << 16) | 261: 
  case (1650 << 16) | 4161: 
//#line  994
  tmp___9 = strcmp((char const   *)(kctl->id.name), "PCM Playback Volume");
//#line  994
  if (! tmp___9) {
//#line  994
    if (cval->min == -15616) {
//#line  996
      printk("<6>using volume control quirk for the UDA1321/N101 chip\n");
//#line  997
      cval->max = -256;
    }
  }
  }
//#line  1003
  add_control_to_empty(state, kctl);
//#line  1004
  return;
}
}
//#line  1013 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_feature_unit(struct mixer_build *state , int unitid , unsigned char *ftr ) 
{ 
  int channels ;
  int i ;
  int j ;
  struct usb_audio_term iterm ;
  unsigned int master_bits ;
  unsigned int first_ch_bits ;
  int err ;
  int csize ;
  int tmp ;
  unsigned int ch_bits ;
  unsigned int mask ;
  unsigned int tmp___0 ;

  {
//#line  1020
  if ((int )*(ftr + 0) < 7) {
//#line  1021
    printk("<3>usbaudio: unit %u: invalid FEATURE_UNIT descriptor\n", unitid);
//#line  1022
    return (-22);
  } else {
//#line  1020
    csize = (int )*(ftr + 5);
//#line  1020
    if (csize) {
//#line  1020
      if ((int )*(ftr + 0) < 7 + csize) {
//#line  1021
        printk("<3>usbaudio: unit %u: invalid FEATURE_UNIT descriptor\n", unitid);
//#line  1022
        return (-22);
      }
    } else {
//#line  1021
      printk("<3>usbaudio: unit %u: invalid FEATURE_UNIT descriptor\n", unitid);
//#line  1022
      return (-22);
    }
  }
//#line  1026
  err = parse_audio_unit(state, (int )*(ftr + 4));
//#line  1026
  if (err < 0) {
//#line  1027
    return (err);
  }
//#line  1030
  tmp = check_input_term(state, (int )*(ftr + 4), & iterm);
//#line  1030
  if (tmp < 0) {
//#line  1031
    return (-22);
  }
//#line  1033
  channels = ((int )*(ftr + 0) - 7) / csize - 1;
//#line  1035
  master_bits = snd_usb_combine_bytes(ftr + 6, csize);
//#line  1036
  if (channels > 0) {
//#line  1037
    first_ch_bits = snd_usb_combine_bytes((ftr + 6) + csize, csize);
  } else {
//#line  1039
    first_ch_bits = 0U;
  }
//#line  1041
  i = 0;
//#line  1041
  while (i < 10) {
//#line  1042
    ch_bits = 0U;
//#line  1043
    j = 0;
//#line  1043
    while (j < channels) {
//#line  1044
      tmp___0 = snd_usb_combine_bytes((ftr + 6) + csize * (j + 1), csize);
//#line  1044
      mask = tmp___0;
//#line  1045
      if (mask & (unsigned int )(1 << i)) {
//#line  1046
        ch_bits |= (unsigned int )(1 << j);
      }
//#line  1043
      j ++;
    }
//#line  1048
    if (ch_bits & 1U) {
//#line  1049
      build_feature_ctl(state, ftr, ch_bits, i, & iterm, unitid);
    }
//#line  1050
    if (master_bits & (unsigned int )(1 << i)) {
//#line  1051
      build_feature_ctl(state, ftr, 0U, i, & iterm, unitid);
    }
//#line  1041
    i ++;
  }
//#line  1054
  return (0);
}
}
//#line  1069 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void build_mixer_unit_ctl(struct mixer_build *state , unsigned char *desc ,
                                 int in_pin , int in_ch , int unitid , struct usb_audio_term *iterm ) 
{ 
  struct usb_mixer_elem_info *cval ;
  unsigned int input_pins ;
  unsigned int num_outs ;
  unsigned int i ;
  unsigned int len ;
  struct snd_kcontrol *kctl ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
//#line  1074
  input_pins = (unsigned int )*(desc + 4);
//#line  1075
  num_outs = (unsigned int )*(desc + (5U + input_pins));
//#line  1079
  tmp = check_ignored_ctl(state, unitid, 0);
//#line  1079
  if (tmp) {
//#line  1080
    return;
  }
//#line  1082
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  1082
  cval = (struct usb_mixer_elem_info *)tmp___0;
//#line  1083
  if (! cval) {
//#line  1084
    return;
  }
//#line  1086
  cval->mixer = state->mixer;
//#line  1087
  cval->id = (unsigned int )unitid;
//#line  1088
  cval->control = (unsigned int )(in_ch + 1);
//#line  1089
  cval->val_type = 4;
//#line  1090
  i = 0U;
//#line  1090
  while (i < num_outs) {
//#line  1091
    tmp___1 = check_matrix_bitmap((desc + 9) + input_pins, in_ch, (int )i, (int )num_outs);
//#line  1091
    if (tmp___1) {
//#line  1092
      cval->cmask |= (unsigned int )(1 << i);
//#line  1093
      (cval->channels) ++;
    }
//#line  1090
    i ++;
  }
//#line  1098
  get_min_max(cval, 0);
//#line  1100
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& usb_feature_unit_ctl),
                      (void *)cval);
//#line  1101
  if (! kctl) {
//#line  1102
    printk("<3>cannot malloc kcontrol\n");
//#line  1103
    kfree((void const   *)cval);
//#line  1104
    return;
  }
//#line  1106
  kctl->private_free = & usb_mixer_elem_free;
//#line  1108
  tmp___2 = check_mapped_name(state, unitid, 0, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  1108
  len = (unsigned int )tmp___2;
//#line  1109
  if (! len) {
//#line  1110
    tmp___3 = get_term_name(state, iterm, kctl->id.name, (int )sizeof(kctl->id.name),
                            0);
//#line  1110
    len = (unsigned int )tmp___3;
  }
//#line  1111
  if (! len) {
//#line  1112
    tmp___4 = sprintf((char *)(kctl->id.name), "Mixer Source %d", in_ch + 1);
//#line  1112
    len = (unsigned int )tmp___4;
  }
//#line  1113
  strlcat((char *)(kctl->id.name + len), " Volume", sizeof(kctl->id.name));
//#line  1117
  add_control_to_empty(state, kctl);
//#line  1118
  return;
}
}
//#line  1124 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_mixer_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  struct usb_audio_term iterm ;
  int input_pins ;
  int num_ins ;
  int num_outs ;
  int pin ;
  int ich ;
  int err ;
  int och ;
  int ich_has_controls ;
  int tmp ;

  {
//#line  1130
  if ((int )*(desc + 0) < 11) {
//#line  1131
    printk("<3>invalid MIXER UNIT descriptor %d\n", unitid);
//#line  1132
    return (-22);
  } else {
//#line  1130
    input_pins = (int )*(desc + 4);
//#line  1130
    if (input_pins) {
//#line  1130
      num_outs = (int )*(desc + (5 + input_pins));
//#line  1130
      if (! num_outs) {
//#line  1131
        printk("<3>invalid MIXER UNIT descriptor %d\n", unitid);
//#line  1132
        return (-22);
      }
    } else {
//#line  1131
      printk("<3>invalid MIXER UNIT descriptor %d\n", unitid);
//#line  1132
      return (-22);
    }
  }
//#line  1135
  if ((int )*(desc + 0) <= 10 + input_pins) {
//#line  1137
    return (0);
  }
//#line  1140
  num_ins = 0;
//#line  1141
  ich = 0;
//#line  1142
  pin = 0;
//#line  1142
  while (pin < input_pins) {
//#line  1143
    err = parse_audio_unit(state, (int )*(desc + (5 + pin)));
//#line  1144
    if (err < 0) {
//#line  1145
      return (err);
    }
//#line  1146
    err = check_input_term(state, (int )*(desc + (5 + pin)), & iterm);
//#line  1147
    if (err < 0) {
//#line  1148
      return (err);
    }
//#line  1149
    num_ins += iterm.channels;
//#line  1150
    while (ich < num_ins) {
//#line  1151
      ich_has_controls = 0;
//#line  1153
      och = 0;
//#line  1153
      while (och < num_outs) {
//#line  1154
        tmp = check_matrix_bitmap((desc + 9) + input_pins, ich, och, num_outs);
//#line  1154
        if (tmp) {
//#line  1156
          ich_has_controls = 1;
//#line  1157
          break;
        }
//#line  1153
        och ++;
      }
//#line  1160
      if (ich_has_controls) {
//#line  1161
        build_mixer_unit_ctl(state, desc, pin, ich, unitid, & iterm);
      }
//#line  1150
      ich ++;
    }
//#line  1142
    pin ++;
  }
//#line  1165
  return (0);
}
}
//#line  1174 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int err ;
  int val ;

  {
//#line  1176
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  1179
  err = get_cur_ctl_value(cval, (int )(cval->control << 8), & val);
//#line  1180
  if (err < 0) {
//#line  1180
    if ((cval->mixer)->ignore_ctl_error) {
//#line  1181
      ucontrol->value.integer.value[0] = (long )cval->min;
//#line  1182
      return (0);
    }
  }
//#line  1184
  if (err < 0) {
//#line  1185
    return (err);
  }
//#line  1186
  val = get_relative_value(cval, val);
//#line  1187
  ucontrol->value.integer.value[0] = (long )val;
//#line  1188
  return (0);
}
}
//#line  1192 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int oval ;
  int err ;

  {
//#line  1194
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  1197
  err = get_cur_ctl_value(cval, (int )(cval->control << 8), & oval);
//#line  1198
  if (err < 0) {
//#line  1199
    if ((cval->mixer)->ignore_ctl_error) {
//#line  1200
      return (0);
    }
//#line  1201
    return (err);
  }
//#line  1203
  val = (int )ucontrol->value.integer.value[0];
//#line  1204
  val = get_abs_value(cval, val);
//#line  1205
  if (val != oval) {
//#line  1206
    set_cur_ctl_value(cval, (int )(cval->control << 8), val);
//#line  1207
    return (1);
  }
//#line  1209
  return (0);
}
}
//#line  1213 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) mixer_procunit_ctl  = 
//#line  1213
     {2, 0U, 0U, (unsigned char *)"", 0U, 0U, 0U, & mixer_ctl_feature_info, & mixer_ctl_procunit_get,
    & mixer_ctl_procunit_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  1238 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) updown_proc_info)[3]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Mode Select", 3, 1}, 
        {0, (char *)0, 0, 0}};
//#line  1243 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) prologic_proc_info)[3]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Mode Select", 3, 1}, 
        {0, (char *)0, 0, 0}};
//#line  1248 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) threed_enh_proc_info)[3]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Spaciousness", 3, 0}, 
        {0, (char *)0, 0, 0}};
//#line  1253 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) reverb_proc_info)[5]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Level", 3, 0}, 
        {3, (char *)"Time", 5, 0}, 
        {4, (char *)"Delay", 3, 0}, 
        {0, (char *)0, 0, 0}};
//#line  1260 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) chorus_proc_info)[5]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Level", 3, 0}, 
        {3, (char *)"Rate", 5, 0}, 
        {4, (char *)"Depth", 5, 0}, 
        {0, (char *)0, 0, 0}};
//#line  1267 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) dcr_proc_info)[7]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {2, (char *)"Ratio", 5, 0}, 
        {3, (char *)"Max Amp", 4, 0}, 
        {4, (char *)"Threshold", 4, 0}, 
        {5, (char *)"Attack Time", 5, 0}, 
        {6, (char *)"Release Time", 5, 0}, 
        {0, (char *)0, 0, 0}};
//#line  1277 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_info ( __attribute__((__noderef__, __address_space__(2))) procunits)[7]  = {      {1,
      (char *)"Up Down", (struct procunit_value_info *)(updown_proc_info)}, 
        {2, (char *)"Dolby Prologic", (struct procunit_value_info *)(prologic_proc_info)}, 
        {3,
      (char *)"3D Stereo Extender", (struct procunit_value_info *)(threed_enh_proc_info)}, 
        {4,
      (char *)"Reverb", (struct procunit_value_info *)(reverb_proc_info)}, 
        {5, (char *)"Chorus", (struct procunit_value_info *)(chorus_proc_info)}, 
        {6, (char *)"DCR", (struct procunit_value_info *)(dcr_proc_info)}, 
        {0, (char *)0, (struct procunit_value_info *)0}};
//#line  1298
static int build_audio_procunit(struct mixer_build *state , int unitid , unsigned char *dsc ,
                                struct procunit_info *list , char *name ) ;
//#line  1298 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) default_value_info)[2]  = {      {1,
      (char *)"Switch", 0, 0}, 
        {0, (char *)0, 0, 0}};
//#line  1302 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct procunit_info  __attribute__((__noderef__, __address_space__(2))) default_info  =    {0,
    (char *)((void *)0), (struct procunit_value_info *)(default_value_info)};
//#line  1290 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int build_audio_procunit(struct mixer_build *state , int unitid , unsigned char *dsc ,
                                struct procunit_info *list , char *name ) 
{ 
  int num_ins ;
  struct usb_mixer_elem_info *cval ;
  struct snd_kcontrol *kctl ;
  int i ;
  int err ;
  int nameid ;
  int type ;
  int len ;
  struct procunit_info *info ;
  struct procunit_value_info *valinfo ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
//#line  1292
  num_ins = (int )*(dsc + 6);
//#line  1306
  if ((int )*(dsc + 0) < 13) {
//#line  1307
    printk("<3>invalid %s descriptor (id %d)\n", name, unitid);
//#line  1308
    return (-22);
  } else
//#line  1306
  if ((int )*(dsc + 0) < 13 + num_ins) {
//#line  1307
    printk("<3>invalid %s descriptor (id %d)\n", name, unitid);
//#line  1308
    return (-22);
  } else
//#line  1306
  if ((int )*(dsc + 0) < num_ins + (int )*(dsc + (11 + num_ins))) {
//#line  1307
    printk("<3>invalid %s descriptor (id %d)\n", name, unitid);
//#line  1308
    return (-22);
  }
//#line  1311
  i = 0;
//#line  1311
  while (i < num_ins) {
//#line  1312
    err = parse_audio_unit(state, (int )*(dsc + (7 + i)));
//#line  1312
    if (err < 0) {
//#line  1313
      return (err);
    }
//#line  1311
    i ++;
  }
//#line  1316
  type = (int )((unsigned int )*(dsc + 4) | ((unsigned int )*((dsc + 4) + 1) << 8));
//#line  1317
  info = list;
//#line  1317
  while (1) {
//#line  1317
    if (info) {
//#line  1317
      if (! info->type) {
//#line  1317
        break;
      }
    } else {
//#line  1317
      break;
    }
//#line  1318
    if (info->type == type) {
//#line  1319
      break;
    }
//#line  1317
    info ++;
  }
//#line  1320
  if (! info) {
//#line  1321
    info = (struct procunit_info *)(& default_info);
  } else
//#line  1320
  if (! info->type) {
//#line  1321
    info = (struct procunit_info *)(& default_info);
  }
//#line  1323
  valinfo = info->values;
//#line  1323
  while (valinfo->control) {
//#line  1325
    if (! ((int )*(dsc + (12 + num_ins)) & (1 << (valinfo->control - 1)))) {
//#line  1326
      goto __Cont;
    }
//#line  1327
    tmp = check_ignored_ctl(state, unitid, valinfo->control);
//#line  1327
    if (tmp) {
//#line  1328
      goto __Cont;
    }
//#line  1329
    tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  1329
    cval = (struct usb_mixer_elem_info *)tmp___0;
//#line  1330
    if (! cval) {
//#line  1331
      printk("<3>cannot malloc kcontrol\n");
//#line  1332
      return (-12);
    }
//#line  1334
    cval->mixer = state->mixer;
//#line  1335
    cval->id = (unsigned int )unitid;
//#line  1336
    cval->control = (unsigned int )valinfo->control;
//#line  1337
    cval->val_type = valinfo->val_type;
//#line  1338
    cval->channels = 1;
//#line  1341
    if (type == 1) {
//#line  1341
      if (cval->control == 2U) {
//#line  1343
        cval->min = 1;
//#line  1344
        cval->max = (int )*(dsc + 15);
//#line  1345
        cval->res = 1;
//#line  1346
        cval->initialized = (u8 )1;
      } else {
//#line  1348
        get_min_max(cval, valinfo->min_value);
      }
    } else {
//#line  1348
      get_min_max(cval, valinfo->min_value);
    }
//#line  1350
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& mixer_procunit_ctl),
                        (void *)cval);
//#line  1351
    if (! kctl) {
//#line  1352
      printk("<3>cannot malloc kcontrol\n");
//#line  1353
      kfree((void const   *)cval);
//#line  1354
      return (-12);
    }
//#line  1356
    kctl->private_free = & usb_mixer_elem_free;
//#line  1358
    tmp___1 = check_mapped_name(state, unitid, (int )cval->control, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                (int )sizeof(kctl->id.name));
//#line  1358
    if (! tmp___1) {
//#line  1360
      if (info->name) {
//#line  1361
        strlcpy((char *)(kctl->id.name), (char const   *)info->name, sizeof(kctl->id.name));
      } else {
//#line  1363
        nameid = (int )*(dsc + ((12 + num_ins) + (int )*(dsc + (11 + num_ins))));
//#line  1364
        len = 0;
//#line  1365
        if (nameid) {
//#line  1366
          len = snd_usb_copy_string_desc(state, nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                         (int )sizeof(kctl->id.name));
        }
//#line  1367
        if (! len) {
//#line  1368
          strlcpy((char *)(kctl->id.name), (char const   *)name, sizeof(kctl->id.name));
        }
      }
    }
//#line  1370
    strlcat((char *)(kctl->id.name), " ", sizeof(kctl->id.name));
//#line  1371
    strlcat((char *)(kctl->id.name), (char const   *)valinfo->suffix, sizeof(kctl->id.name));
//#line  1375
    err = add_control_to_empty(state, kctl);
//#line  1375
    if (err < 0) {
//#line  1376
      return (err);
    }
    __Cont: /* CIL Label */ 
//#line  1323
    valinfo ++;
  }
//#line  1378
  return (0);
}
}
//#line  1382 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_processing_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  int tmp ;

  {
//#line  1384
  tmp = build_audio_procunit(state, unitid, desc, (struct procunit_info *)(procunits),
                             (char *)"Processing Unit");
//#line  1384
  return (tmp);
}
}
//#line  1387 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_extension_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  int tmp ;

  {
//#line  1389
  tmp = build_audio_procunit(state, unitid, desc, (struct procunit_info *)((void *)0),
                             (char *)"Extension Unit");
//#line  1389
  return (tmp);
}
}
//#line  1400 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct usb_mixer_elem_info *cval ;
  char **itemlist ;
  int tmp ;

  {
//#line  1402
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  1403
  itemlist = (char **)kcontrol->private_value;
//#line  1405
  tmp = __snd_bug_on(0);
//#line  1405
  if (tmp) {
//#line  1406
    return (-22);
  }
//#line  1407
  uinfo->type = 3;
//#line  1408
  uinfo->count = 1U;
//#line  1409
  uinfo->value.enumerated.items = (unsigned int )cval->max;
//#line  1410
  if ((int )uinfo->value.enumerated.item >= cval->max) {
//#line  1411
    uinfo->value.enumerated.item = (unsigned int )(cval->max - 1);
  }
//#line  1412
  strcpy(uinfo->value.enumerated.name, (char const   *)*(itemlist + uinfo->value.enumerated.item));
//#line  1413
  return (0);
}
}
//#line  1417 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int err ;

  {
//#line  1419
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  1422
  err = get_cur_ctl_value(cval, 0, & val);
//#line  1423
  if (err < 0) {
//#line  1424
    if ((cval->mixer)->ignore_ctl_error) {
//#line  1425
      ucontrol->value.enumerated.item[0] = 0U;
//#line  1426
      return (0);
    }
//#line  1428
    return (err);
  }
//#line  1430
  val = get_relative_value(cval, val);
//#line  1431
  ucontrol->value.enumerated.item[0] = (unsigned int )val;
//#line  1432
  return (0);
}
}
//#line  1436 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int oval ;
  int err ;

  {
//#line  1438
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  1441
  err = get_cur_ctl_value(cval, 0, & oval);
//#line  1442
  if (err < 0) {
//#line  1443
    if ((cval->mixer)->ignore_ctl_error) {
//#line  1444
      return (0);
    }
//#line  1445
    return (err);
  }
//#line  1447
  val = (int )ucontrol->value.enumerated.item[0];
//#line  1448
  val = get_abs_value(cval, val);
//#line  1449
  if (val != oval) {
//#line  1450
    set_cur_ctl_value(cval, 0, val);
//#line  1451
    return (1);
  }
//#line  1453
  return (0);
}
}
//#line  1457 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) mixer_selectunit_ctl  = 
//#line  1457
     {2, 0U, 0U, (unsigned char *)"", 0U, 0U, 0U, & mixer_ctl_selector_info, & mixer_ctl_selector_get,
    & mixer_ctl_selector_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  1469 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl ) 
{ 
  int i ;
  int num_ins ;
  struct usb_mixer_elem_info *cval ;
  char **itemlist ;

  {
//#line  1471
  num_ins = 0;
//#line  1473
  if (kctl->private_data) {
//#line  1474
    cval = (struct usb_mixer_elem_info *)kctl->private_data;
//#line  1475
    num_ins = cval->max;
//#line  1476
    kfree((void const   *)cval);
//#line  1477
    kctl->private_data = (char *)((void *)0);
  }
//#line  1479
  if (kctl->private_value) {
//#line  1480
    itemlist = (char **)kctl->private_value;
//#line  1481
    i = 0;
//#line  1481
    while (i < num_ins) {
//#line  1482
      kfree((void const   *)*(itemlist + i));
//#line  1481
      i ++;
    }
//#line  1483
    kfree((void const   *)itemlist);
//#line  1484
    kctl->private_value = 0UL;
  }
//#line  1486
  return;
}
}
//#line  1491 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_selector_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  unsigned int num_ins ;
  unsigned int i ;
  unsigned int nameid ;
  unsigned int len ;
  int err ;
  struct usb_mixer_elem_info *cval ;
  struct snd_kcontrol *kctl ;
  char **namelist ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct usb_audio_term iterm ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
//#line  1493
  num_ins = (unsigned int )*(desc + 4);
//#line  1500
  if (! num_ins) {
//#line  1501
    printk("<3>invalid SELECTOR UNIT descriptor %d\n", unitid);
//#line  1502
    return (-22);
  } else
//#line  1500
  if ((unsigned int )*(desc + 0) < 5U + num_ins) {
//#line  1501
    printk("<3>invalid SELECTOR UNIT descriptor %d\n", unitid);
//#line  1502
    return (-22);
  }
//#line  1505
  i = 0U;
//#line  1505
  while (i < num_ins) {
//#line  1506
    err = parse_audio_unit(state, (int )*(desc + (5U + i)));
//#line  1506
    if (err < 0) {
//#line  1507
      return (err);
    }
//#line  1505
    i ++;
  }
//#line  1510
  if (num_ins == 1U) {
//#line  1511
    return (0);
  }
//#line  1513
  tmp = check_ignored_ctl(state, unitid, 0);
//#line  1513
  if (tmp) {
//#line  1514
    return (0);
  }
//#line  1516
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  1516
  cval = (struct usb_mixer_elem_info *)tmp___0;
//#line  1517
  if (! cval) {
//#line  1518
    printk("<3>cannot malloc kcontrol\n");
//#line  1519
    return (-12);
  }
//#line  1521
  cval->mixer = state->mixer;
//#line  1522
  cval->id = (unsigned int )unitid;
//#line  1523
  cval->val_type = 3;
//#line  1524
  cval->channels = 1;
//#line  1525
  cval->min = 1;
//#line  1526
  cval->max = (int )num_ins;
//#line  1527
  cval->res = 1;
//#line  1528
  cval->initialized = (u8 )1;
//#line  1530
  tmp___1 = kmalloc(sizeof(char *) * (unsigned long )num_ins, 208U);
//#line  1530
  namelist = (char **)tmp___1;
//#line  1531
  if (! namelist) {
//#line  1532
    printk("<3>cannot malloc\n");
//#line  1533
    kfree((void const   *)cval);
//#line  1534
    return (-12);
  }
//#line  1537
  i = 0U;
//#line  1537
  while (i < num_ins) {
//#line  1539
    len = 0U;
//#line  1540
    tmp___2 = kmalloc((size_t )64, 208U);
//#line  1540
    *(namelist + i) = (char *)tmp___2;
//#line  1541
    if (! *(namelist + i)) {
//#line  1542
      printk("<3>cannot malloc\n");
//#line  1543
      while (1) {
//#line  1543
        tmp___3 = i;
//#line  1543
        i --;
//#line  1543
        if (! tmp___3) {
//#line  1543
          break;
        }
//#line  1544
        kfree((void const   *)*(namelist + i));
      }
//#line  1545
      kfree((void const   *)namelist);
//#line  1546
      kfree((void const   *)cval);
//#line  1547
      return (-12);
    }
//#line  1549
    tmp___4 = check_mapped_selector_name(state, unitid, (int )i, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )*(namelist + i),
                                         64);
//#line  1549
    len = (unsigned int )tmp___4;
//#line  1551
    if (! len) {
//#line  1551
      tmp___6 = check_input_term(state, (int )*(desc + (5U + i)), & iterm);
//#line  1551
      if (tmp___6 >= 0) {
//#line  1552
        tmp___5 = get_term_name(state, & iterm, (unsigned char *)*(namelist + i),
                                64, 0);
//#line  1552
        len = (unsigned int )tmp___5;
      }
    }
//#line  1553
    if (! len) {
//#line  1554
      sprintf(*(namelist + i), "Input %d", i);
    }
//#line  1537
    i ++;
  }
//#line  1557
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& mixer_selectunit_ctl),
                      (void *)cval);
//#line  1558
  if (! kctl) {
//#line  1559
    printk("<3>cannot malloc kcontrol\n");
//#line  1560
    kfree((void const   *)namelist);
//#line  1561
    kfree((void const   *)cval);
//#line  1562
    return (-12);
  }
//#line  1564
  kctl->private_value = (unsigned long )namelist;
//#line  1565
  kctl->private_free = & usb_mixer_selector_elem_free;
//#line  1567
  nameid = (unsigned int )*(desc + ((int )*(desc + 0) - 1));
//#line  1568
  tmp___7 = check_mapped_name(state, unitid, 0, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  1568
  len = (unsigned int )tmp___7;
//#line  1569
  if (! len) {
//#line  1571
    if (nameid) {
//#line  1572
      snd_usb_copy_string_desc(state, (int )nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                               (int )sizeof(kctl->id.name));
    } else {
//#line  1574
      tmp___8 = get_term_name(state, & state->oterm, kctl->id.name, (int )sizeof(kctl->id.name),
                              0);
//#line  1574
      len = (unsigned int )tmp___8;
//#line  1576
      if (! len) {
//#line  1577
        strlcpy((char *)(kctl->id.name), "USB", sizeof(kctl->id.name));
      }
//#line  1579
      if ((state->oterm.type & 65280) == 256) {
//#line  1580
        strlcat((char *)(kctl->id.name), " Capture Source", sizeof(kctl->id.name));
      } else {
//#line  1582
        strlcat((char *)(kctl->id.name), " Playback Source", sizeof(kctl->id.name));
      }
    }
  }
//#line  1587
  err = add_control_to_empty(state, kctl);
//#line  1587
  if (err < 0) {
//#line  1588
    return (err);
  }
//#line  1590
  return (0);
}
}
//#line  1598 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int parse_audio_unit(struct mixer_build *state , int unitid ) 
{ 
  unsigned char *p1 ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  1602
  tmp = test_and_set_bit(unitid, (unsigned long volatile   *)(state->unitbitmap));
//#line  1602
  if (tmp) {
//#line  1603
    return (0);
  }
//#line  1605
  tmp___0 = find_audio_control_unit(state, (unsigned char )unitid);
//#line  1605
  p1 = (unsigned char *)tmp___0;
//#line  1606
  if (! p1) {
//#line  1607
    printk("<3>usbaudio: unit %d not found!\n", unitid);
//#line  1608
    return (-22);
  }
//#line  1611
  switch ((int )*(p1 + 2)) {
  case 2: 
//#line  1613
  return (0);
  case 4: 
//#line  1615
  tmp___1 = parse_audio_mixer_unit(state, unitid, p1);
//#line  1615
  return (tmp___1);
  case 5: 
//#line  1617
  tmp___2 = parse_audio_selector_unit(state, unitid, p1);
//#line  1617
  return (tmp___2);
  case 6: 
//#line  1619
  tmp___3 = parse_audio_feature_unit(state, unitid, p1);
//#line  1619
  return (tmp___3);
  case 7: 
//#line  1621
  tmp___4 = parse_audio_processing_unit(state, unitid, p1);
//#line  1621
  return (tmp___4);
  case 8: 
//#line  1623
  tmp___5 = parse_audio_extension_unit(state, unitid, p1);
//#line  1623
  return (tmp___5);
  default: 
//#line  1625
  printk("<3>usbaudio: unit %u: unexpected type 0x%02x\n", unitid, (int )*(p1 + 2));
//#line  1626
  return (-22);
  }
}
}
//#line  1630 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_usb_mixer_free(struct usb_mixer_interface *mixer ) 
{ 


  {
//#line  1632
  kfree((void const   *)mixer->id_elems);
//#line  1633
  if (mixer->urb) {
//#line  1634
    kfree((void const   *)(mixer->urb)->transfer_buffer);
//#line  1635
    usb_free_urb(mixer->urb);
  }
//#line  1637
  usb_free_urb(mixer->rc_urb);
//#line  1638
  kfree((void const   *)mixer->rc_setup_packet);
//#line  1639
  kfree((void const   *)mixer);
//#line  1640
  return;
}
}
//#line  1642 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_mixer_dev_free(struct snd_device *device ) 
{ 
  struct usb_mixer_interface *mixer ;

  {
//#line  1644
  mixer = (struct usb_mixer_interface *)device->device_data;
//#line  1645
  snd_usb_mixer_free(mixer);
//#line  1646
  return (0);
}
}
//#line  1654 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_mixer_controls(struct usb_mixer_interface *mixer ) 
{ 
  unsigned char *desc ;
  struct mixer_build state ;
  int err ;
  struct usbmix_ctl_map  const  *map ;
  struct usb_host_interface *hostif ;
  struct usb_interface *tmp ;
  void *tmp___0 ;

  {
//#line  1662
  tmp = usb_ifnum_to_if((struct usb_device  const  *)(mixer->chip)->dev, mixer->ctrlif);
//#line  1662
  hostif = tmp->altsetting + 0;
//#line  1663
  memset((void *)(& state), 0, sizeof(state));
//#line  1664
  state.chip = mixer->chip;
//#line  1665
  state.mixer = mixer;
//#line  1666
  state.buffer = (unsigned char * __attribute__((__expfld__(buflen))) )hostif->extra;
//#line  1667
  state.buflen = (unsigned int )hostif->extralen;
//#line  1670
  map = (struct usbmix_ctl_map  const  *)(usbmix_ctl_maps);
//#line  1670
  while (map->id) {
//#line  1671
    if (map->id == (u32 const   )(state.chip)->usb_id) {
//#line  1672
      state.map = (struct usbmix_name_map  const  *)map->map;
//#line  1673
      state.selector_map = (struct usbmix_selector_map  const  *)map->selector_map;
//#line  1674
      mixer->ignore_ctl_error = (unsigned int )map->ignore_ctl_error;
//#line  1675
      break;
    }
//#line  1670
    map ++;
  }
//#line  1679
  desc = (unsigned char *)((void *)0);
//#line  1680
  while (1) {
//#line  1680
    tmp___0 = snd_usb_find_csint_desc((void *)hostif->extra, hostif->extralen, (void *)desc,
                                      (u8 )3);
//#line  1680
    desc = (unsigned char *)tmp___0;
//#line  1680
    if (! ((unsigned long )desc != (unsigned long )((void *)0))) {
//#line  1680
      break;
    }
//#line  1681
    if ((int )*(desc + 0) < 9) {
//#line  1682
      continue;
    }
//#line  1683
    set_bit((unsigned int )*(desc + 3), (unsigned long volatile   *)(state.unitbitmap));
//#line  1684
    state.oterm.id = (int )*(desc + 3);
//#line  1685
    state.oterm.type = (int )((unsigned int )*(desc + 4) | ((unsigned int )*((desc + 4) + 1) << 8));
//#line  1686
    state.oterm.name = (int )*(desc + 8);
//#line  1687
    err = parse_audio_unit(& state, (int )*(desc + 7));
//#line  1688
    if (err < 0) {
//#line  1689
      return (err);
    }
  }
//#line  1691
  return (0);
}
}
//#line  1694 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer , int unitid ) 
{ 
  struct usb_mixer_elem_info *info ;

  {
//#line  1699
  info = *(mixer->id_elems + unitid);
//#line  1699
  while (info) {
//#line  1700
    snd_ctl_notify((mixer->chip)->card, 1U, info->elem_id);
//#line  1699
    info = (struct usb_mixer_elem_info *)info->next_id_elem;
  }
//#line  1702
  return;
}
}
//#line  1704 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_usb_mixer_memory_change(struct usb_mixer_interface *mixer , int unitid ) 
{ 


  {
//#line  1707
  if (! mixer->rc_cfg) {
//#line  1708
    return;
  }
//#line  1710
  switch (unitid) {
  case 0: 
//#line  1712
  (mixer->rc_urb)->dev = (struct usb_device * __attribute__((__recursive__)) )(mixer->chip)->dev;
//#line  1713
  usb_submit_urb(mixer->rc_urb, 32U);
//#line  1714
  break;
  case 4: 
  case 7: 
  case 19: 
  case 20: 
//#line  1719
  break;
  case 3: 
//#line  1722
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
//#line  1723
    snd_usb_mixer_notify_id(mixer, (int )(mixer->rc_cfg)->mute_mixer_id);
  }
//#line  1724
  break;
  default: 
//#line  1726
  while (1) {
//#line  1726
    break;
  }
//#line  1727
  break;
  }
//#line  1729
  return;
}
}
//#line  1731 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_usb_mixer_status_complete(struct urb *urb ) 
{ 
  struct usb_mixer_interface *mixer ;
  u8 *buf ;
  int i ;

  {
//#line  1733
  mixer = (struct usb_mixer_interface *)urb->context;
//#line  1735
  if (urb->status == 0) {
//#line  1736
    buf = urb->transfer_buffer;
//#line  1739
    i = urb->actual_length;
//#line  1739
    while (i >= 2) {
//#line  1740
      while (1) {
//#line  1740
        break;
      }
//#line  1743
      if (((int )*(buf + 0) & 15) != 0) {
//#line  1744
        goto __Cont;
      }
//#line  1745
      if (! ((int )*(buf + 0) & 64)) {
//#line  1746
        snd_usb_mixer_notify_id(mixer, (int )*(buf + 1));
      } else {
//#line  1748
        snd_usb_mixer_memory_change(mixer, (int )*(buf + 1));
      }
      __Cont: /* CIL Label */ 
//#line  1739
      buf += 2;
//#line  1739
      i -= 2;
    }
  }
//#line  1751
  if (urb->status != -2) {
//#line  1751
    if (urb->status != -104) {
//#line  1752
      urb->dev = (struct usb_device * __attribute__((__recursive__)) )(mixer->chip)->dev;
//#line  1753
      usb_submit_urb(urb, 32U);
    }
  }
//#line  1755
  return;
}
}
//#line  1758 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer ) 
{ 
  struct usb_host_interface *hostif ;
  struct usb_endpoint_descriptor *ep ;
  void *transfer_buffer ;
  int buffer_length ;
  unsigned int epnum ;
  struct usb_interface *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
//#line  1766
  tmp = usb_ifnum_to_if((struct usb_device  const  *)(mixer->chip)->dev, mixer->ctrlif);
//#line  1766
  hostif = tmp->altsetting + 0;
//#line  1768
  if ((int )hostif->desc.bNumEndpoints < 1) {
//#line  1769
    return (0);
  }
//#line  1770
  ep = & (hostif->endpoint + 0)->desc;
//#line  1771
  tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)ep);
//#line  1771
  if (tmp___0) {
//#line  1771
    tmp___1 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
//#line  1771
    if (! tmp___1) {
//#line  1772
      return (0);
    }
  } else {
//#line  1772
    return (0);
  }
//#line  1774
  tmp___2 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  1774
  epnum = (unsigned int )tmp___2;
//#line  1775
  buffer_length = (int )ep->wMaxPacketSize;
//#line  1776
  transfer_buffer = kmalloc((size_t )buffer_length, 208U);
//#line  1777
  if (! transfer_buffer) {
//#line  1778
    return (-12);
  }
//#line  1779
  mixer->urb = usb_alloc_urb(0, 208U);
//#line  1780
  if (! mixer->urb) {
//#line  1781
    kfree((void const   *)transfer_buffer);
//#line  1782
    return (-12);
  }
//#line  1784
  tmp___3 = __create_pipe((mixer->chip)->dev, epnum);
//#line  1784
  usb_fill_int_urb(mixer->urb, (mixer->chip)->dev, ((unsigned int )(1 << 30) | tmp___3) | 128U,
                   transfer_buffer, buffer_length, & snd_usb_mixer_status_complete,
                   (void *)mixer, (int )ep->bInterval);
//#line  1788
  usb_submit_urb(mixer->urb, 208U);
//#line  1789
  return (0);
}
}
//#line  1792 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_usb_soundblaster_remote_complete(struct urb *urb ) 
{ 
  struct usb_mixer_interface *mixer ;
  struct rc_config  const  *rc ;
  u32 code ;

  {
//#line  1794
  mixer = (struct usb_mixer_interface *)urb->context;
//#line  1795
  rc = mixer->rc_cfg;
//#line  1798
  if (urb->status < 0) {
//#line  1799
    return;
  } else
//#line  1798
  if (urb->actual_length < (int )rc->min_packet_length) {
//#line  1799
    return;
  }
//#line  1801
  code = (u32 )mixer->rc_buffer[rc->offset];
//#line  1802
  if ((int const   )rc->length == 2) {
//#line  1803
    code |= (unsigned int )((int )mixer->rc_buffer[(int const   )rc->offset + 1] << 8);
  }
//#line  1806
  if (code == (u32 )rc->mute_code) {
//#line  1807
    snd_usb_mixer_notify_id(mixer, (int )rc->mute_mixer_id);
  }
//#line  1808
  mixer->rc_code = code;
//#line  1809
  __asm__  volatile   ("sfence": : : "memory");
//#line  1810
  __wake_up(& mixer->rc_waitq, 3U, 1, (void *)0);
//#line  1811
  return;
}
}
//#line  1813 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_sbrc_hwdep_open(struct snd_hwdep *hw , struct file *file ) 
{ 
  struct usb_mixer_interface *mixer ;
  int tmp ;

  {
//#line  1815
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  1817
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& mixer->rc_hwdep_open));
//#line  1817
  if (tmp) {
//#line  1818
    return (-16);
  }
//#line  1819
  return (0);
}
}
//#line  1822 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_sbrc_hwdep_release(struct snd_hwdep *hw , struct file *file ) 
{ 
  struct usb_mixer_interface *mixer ;

  {
//#line  1824
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  1826
  clear_bit(0, (unsigned long volatile   *)(& mixer->rc_hwdep_open));
//#line  1827
  __asm__  volatile   ("": : : "memory");
//#line  1828
  return (0);
}
}
//#line  1831 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw , char *buf , long count ,
                                    loff_t *offset ) 
{ 
  struct usb_mixer_interface *mixer ;
  int err ;
  u32 rc_code ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int __ret_pu ;
  char __pu_val ;
  int __ret_pu___0 ;
  u32 __pu_val___0 ;
  long tmp___4 ;

  {
//#line  1834
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  1838
  if (count != 1L) {
//#line  1838
    if (count != 4L) {
//#line  1839
      return (-22L);
    }
  }
//#line  1840
  __ret = 0;
//#line  1840
  tmp___3 = __xchg(0UL, (void volatile   *)(& mixer->rc_code), (int )sizeof(mixer->rc_code));
//#line  1840
  rc_code = (u32 )tmp___3;
//#line  1840
  if (! (rc_code != 0U)) {
//#line  1840
    while (1) {
//#line  1840
      tmp = get_current();
//#line  1840
      __wait.flags = 0U;
//#line  1840
      __wait.private = (void *)tmp;
//#line  1840
      __wait.func = & autoremove_wake_function;
//#line  1840
      __wait.task_list.next = (struct list_head * __attribute__((__recursive__)) )(& __wait.task_list);
//#line  1840
      __wait.task_list.prev = (struct list_head * __attribute__((__recursive__)) )(& __wait.task_list);
//#line  1840
      while (1) {
//#line  1840
        prepare_to_wait(& mixer->rc_waitq, & __wait, 1);
//#line  1840
        tmp___0 = __xchg(0UL, (void volatile   *)(& mixer->rc_code), (int )sizeof(mixer->rc_code));
//#line  1840
        rc_code = (u32 )tmp___0;
//#line  1840
        if (rc_code != 0U) {
//#line  1840
          break;
        }
//#line  1840
        tmp___1 = get_current();
//#line  1840
        tmp___2 = signal_pending(tmp___1);
//#line  1840
        if (! tmp___2) {
//#line  1840
          schedule();
//#line  1840
          goto __Cont;
        }
//#line  1840
        __ret = -512;
//#line  1840
        break;
        __Cont: /* CIL Label */ ;
      }
//#line  1840
      finish_wait(& mixer->rc_waitq, & __wait);
//#line  1840
      break;
    }
  }
//#line  1840
  err = __ret;
//#line  1842
  if (err == 0) {
//#line  1843
    if (count == 1L) {
//#line  1844
      might_fault();
//#line  1844
      __pu_val = (char )rc_code;
//#line  1844
      switch ((int )sizeof(*buf)) {
      case 1: 
//#line  1844
      __asm__  volatile   ("call __put_user_"
                           "1": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  1844
      break;
      case 2: 
//#line  1844
      __asm__  volatile   ("call __put_user_"
                           "2": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  1844
      break;
      case 4: 
//#line  1844
      __asm__  volatile   ("call __put_user_"
                           "4": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  1844
      break;
      case 8: 
//#line  1844
      __asm__  volatile   ("call __put_user_"
                           "8": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  1844
      break;
      default: 
//#line  1844
      __asm__  volatile   ("call __put_user_"
                           "X": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  1844
      break;
      }
//#line  1844
      err = __ret_pu;
    } else {
//#line  1846
      might_fault();
//#line  1846
      __pu_val___0 = rc_code;
//#line  1846
      switch ((int )sizeof(*((u32 *)buf))) {
      case 1: 
//#line  1846
      __asm__  volatile   ("call __put_user_"
                           "1": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  1846
      break;
      case 2: 
//#line  1846
      __asm__  volatile   ("call __put_user_"
                           "2": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  1846
      break;
      case 4: 
//#line  1846
      __asm__  volatile   ("call __put_user_"
                           "4": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  1846
      break;
      case 8: 
//#line  1846
      __asm__  volatile   ("call __put_user_"
                           "8": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  1846
      break;
      default: 
//#line  1846
      __asm__  volatile   ("call __put_user_"
                           "X": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  1846
      break;
      }
//#line  1846
      err = __ret_pu___0;
    }
  }
//#line  1848
  if (err < 0) {
//#line  1848
    tmp___4 = (long )err;
  } else {
//#line  1848
    tmp___4 = count;
  }
//#line  1848
  return (tmp___4);
}
}
//#line  1851 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static unsigned int snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw , struct file *file ,
                                            poll_table *wait ) 
{ 
  struct usb_mixer_interface *mixer ;
  int tmp ;

  {
//#line  1854
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  1856
  poll_wait(file, & mixer->rc_waitq, wait);
//#line  1857
  if (mixer->rc_code) {
//#line  1857
    tmp = 65;
  } else {
//#line  1857
    tmp = 0;
  }
//#line  1857
  return ((unsigned int )tmp);
}
}
//#line  1860 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer ) 
{ 
  struct snd_hwdep *hwdep ;
  int err ;
  int len ;
  int i ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
//#line  1865
  i = 0;
//#line  1865
  while ((unsigned long )i < sizeof(rc_configs) / sizeof(rc_configs[0]) + (sizeof(char [1]) - 1UL)) {
//#line  1866
    if (rc_configs[i].usb_id == (u32 const   )(mixer->chip)->usb_id) {
//#line  1867
      break;
    }
//#line  1865
    i ++;
  }
//#line  1868
  if ((unsigned long )i >= sizeof(rc_configs) / sizeof(rc_configs[0]) + (sizeof(char [1]) - 1UL)) {
//#line  1869
    return (0);
  }
//#line  1870
  mixer->rc_cfg = & rc_configs[i];
//#line  1872
  len = (int )(mixer->rc_cfg)->packet_length;
//#line  1874
  init_waitqueue_head(& mixer->rc_waitq);
//#line  1875
  err = snd_hwdep_new((mixer->chip)->card, (char * __attribute__((__nullterm__)) )"SB remote control",
                      0, & hwdep);
//#line  1876
  if (err < 0) {
//#line  1877
    return (err);
  }
//#line  1880
  sprintf(hwdep->name, "%s remote control", ((mixer->chip)->card)->shortname);
//#line  1881
  hwdep->iface = 15;
//#line  1882
  hwdep->private_data = (void *)mixer;
//#line  1883
  hwdep->ops.read = & snd_usb_sbrc_hwdep_read;
//#line  1884
  hwdep->ops.open = & snd_usb_sbrc_hwdep_open;
//#line  1885
  hwdep->ops.release = & snd_usb_sbrc_hwdep_release;
//#line  1886
  hwdep->ops.poll = & snd_usb_sbrc_hwdep_poll;
//#line  1888
  mixer->rc_urb = usb_alloc_urb(0, 208U);
//#line  1889
  if (! mixer->rc_urb) {
//#line  1890
    return (-12);
  }
//#line  1891
  tmp = kmalloc(sizeof(*(mixer->rc_setup_packet)), 208U);
//#line  1891
  mixer->rc_setup_packet = (struct usb_ctrlrequest *)tmp;
//#line  1892
  if (! mixer->rc_setup_packet) {
//#line  1893
    usb_free_urb(mixer->rc_urb);
//#line  1894
    mixer->rc_urb = (struct urb *)((void *)0);
//#line  1895
    return (-12);
  }
//#line  1897
  (mixer->rc_setup_packet)->bRequestType = (__u8 )((128 | (1 << 5)) | 1);
//#line  1899
  (mixer->rc_setup_packet)->bRequest = (__u8 )133;
//#line  1900
  (mixer->rc_setup_packet)->wValue = (__u16 )0;
//#line  1901
  (mixer->rc_setup_packet)->wIndex = (__u16 )0;
//#line  1902
  (mixer->rc_setup_packet)->wLength = (__u16 )len;
//#line  1903
  tmp___0 = __create_pipe((mixer->chip)->dev, 0U);
//#line  1903
  usb_fill_control_urb(mixer->rc_urb, (mixer->chip)->dev, ((unsigned int )(2 << 30) | tmp___0) | 128U,
                       (u8 *)mixer->rc_setup_packet, (void *)(mixer->rc_buffer), len,
                       & snd_usb_soundblaster_remote_complete, (void *)mixer);
//#line  1907
  return (0);
}
}
//#line  1912 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_interface *mixer ;
  int index___0 ;

  {
//#line  1914
  mixer = (struct usb_mixer_interface *)kcontrol->private_data;
//#line  1915
  index___0 = (int )kcontrol->private_value;
//#line  1917
  ucontrol->value.integer.value[0] = (long )mixer->audigy2nx_leds[index___0];
//#line  1918
  return (0);
}
}
//#line  1921 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_interface *mixer ;
  int index___0 ;
  int value ;
  int err ;
  int changed ;
  unsigned int tmp ;

  {
//#line  1923
  mixer = (struct usb_mixer_interface *)kcontrol->private_data;
//#line  1924
  index___0 = (int )kcontrol->private_value;
//#line  1925
  value = (int )ucontrol->value.integer.value[0];
//#line  1928
  if (value > 1) {
//#line  1929
    return (-22);
  }
//#line  1930
  changed = value != (int )mixer->audigy2nx_leds[index___0];
//#line  1931
  tmp = __create_pipe((mixer->chip)->dev, 0U);
//#line  1931
  err = snd_usb_ctl_msg((mixer->chip)->dev, (unsigned int )(2 << 30) | tmp, (__u8 )36,
                        (__u8 )((2 << 5) | 3), (__u16 )value, (__u16 )(index___0 + 2),
                        (void *)0, (__u16 )0, 100);
//#line  1935
  if (err < 0) {
//#line  1936
    return (err);
  }
//#line  1937
  mixer->audigy2nx_leds[index___0] = (u8 )value;
//#line  1938
  return (changed);
}
}
//#line  1941 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_audigy2nx_controls)[3]  = {      {2,
      0U, 0U, (unsigned char *)"CMSS LED Switch", 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {2, 0U, 0U, (unsigned char *)"Power LED Switch", 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      1UL}, 
        {2, 0U, 0U, (unsigned char *)"Dolby Digital LED Switch", 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      2UL}};
//#line  1968 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer ) 
{ 
  int i ;
  int err ;
  struct snd_kcontrol *tmp ;

  {
//#line  1972
  i = 0;
//#line  1972
  while ((unsigned long )i < sizeof(snd_audigy2nx_controls) / sizeof(snd_audigy2nx_controls[0]) + (sizeof(char [1]) - 1UL)) {
//#line  1973
    if (i > 1) {
//#line  1973
      if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
//#line  1975
        break;
      }
    }
//#line  1976
    tmp = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_audigy2nx_controls[i]),
                       (void *)mixer);
//#line  1976
    err = snd_ctl_add((mixer->chip)->card, tmp);
//#line  1978
    if (err < 0) {
//#line  1979
      return (err);
    }
//#line  1972
    i ++;
  }
//#line  1981
  mixer->audigy2nx_leds[1] = (u8 )1;
//#line  1982
  return (0);
}
}
//#line  1988
static void snd_audigy2nx_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
//#line  1988 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct sb_jack  const  jacks_audigy2nx[5]  = {      {4, "dig in "}, 
        {7, "line in"}, 
        {19, "spk out"}, 
        {20, "hph out"}, 
        {-1, (char const   *)((void *)0)}};
//#line  1988 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct sb_jack  const  jacks_live24ext[4]  = {      {4, "line in"}, 
        {3, "hph out"}, 
        {0, "RC     "}, 
        {-1, (char const   *)((void *)0)}};
//#line  1985 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static void snd_audigy2nx_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct sb_jack  const  *jacks ;
  struct usb_mixer_interface *mixer ;
  int i ;
  int err ;
  u8 buf[3] ;
  unsigned int tmp ;

  {
//#line  2004
  mixer = (struct usb_mixer_interface *)entry->private_data;
//#line  2008
  snd_iprintf(buffer, (char *)"%s jacks\n\n", ((mixer->chip)->card)->shortname);
//#line  2009
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  2010
    jacks = jacks_audigy2nx;
  } else
//#line  2011
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
//#line  2012
    jacks = jacks_live24ext;
  } else {
//#line  2014
    return;
  }
//#line  2016
  i = 0;
//#line  2016
  while ((jacks + i)->name) {
//#line  2017
    snd_iprintf(buffer, (char *)"%s: ", (jacks + i)->name);
//#line  2018
    tmp = __create_pipe((mixer->chip)->dev, 0U);
//#line  2018
    err = snd_usb_ctl_msg((mixer->chip)->dev, ((unsigned int )(2 << 30) | tmp) | 128U,
                          (__u8 )133, (__u8 )((128 | (1 << 5)) | 1), (__u16 )0, (__u16 )((jacks + i)->unitid << 8),
                          (void *)(buf), (__u16 )3, 100);
//#line  2023
    if (err == 3) {
//#line  2023
      if ((int )buf[0] == 3) {
//#line  2024
        snd_iprintf(buffer, (char *)"%02x %02x\n", (int )buf[1], (int )buf[2]);
      } else
//#line  2023
      if ((int )buf[0] == 6) {
//#line  2024
        snd_iprintf(buffer, (char *)"%02x %02x\n", (int )buf[1], (int )buf[2]);
      } else {
//#line  2026
        snd_iprintf(buffer, (char *)"?\n");
      }
    } else {
//#line  2026
      snd_iprintf(buffer, (char *)"?\n");
    }
//#line  2016
    i ++;
  }
//#line  2028
  return;
}
}
//#line  2033 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
static struct snd_device_ops  __attribute__((__noderef__, __address_space__(2))) dev_ops  =    {& snd_usb_mixer_dev_free,
    (int (*)(struct snd_device *dev ))0, (int (*)(struct snd_device *dev ))0};
//#line  2030 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
int snd_usb_create_mixer(struct snd_usb_audio *chip , int ctrlif , int ignore_error ) 
{ 
  struct usb_mixer_interface *mixer ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct snd_info_entry *entry ;
  int tmp___1 ;

  {
//#line  2039
  strcpy((chip->card)->mixername, "USB Mixer");
//#line  2041
  tmp = kzalloc(sizeof(*mixer), 208U);
//#line  2041
  mixer = (struct usb_mixer_interface *)tmp;
//#line  2042
  if (! mixer) {
//#line  2043
    return (-12);
  }
//#line  2044
  mixer->chip = chip;
//#line  2045
  mixer->ctrlif = (unsigned int )ctrlif;
//#line  2046
  mixer->ignore_ctl_error = (unsigned int )ignore_error;
//#line  2047
  tmp___0 = kcalloc((size_t )256, sizeof(*(mixer->id_elems)), 208U);
//#line  2047
  mixer->id_elems = (struct usb_mixer_elem_info **)tmp___0;
//#line  2048
  if (! mixer->id_elems) {
//#line  2049
    kfree((void const   *)mixer);
//#line  2050
    return (-12);
  }
//#line  2053
  err = snd_usb_mixer_controls(mixer);
//#line  2053
  if (err < 0) {
//#line  2055
    goto _error;
  } else {
//#line  2053
    err = snd_usb_mixer_status_create(mixer);
//#line  2053
    if (err < 0) {
//#line  2055
      goto _error;
    }
  }
//#line  2057
  err = snd_usb_soundblaster_remote_init(mixer);
//#line  2057
  if (err < 0) {
//#line  2058
    goto _error;
  }
//#line  2060
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  2060
    goto _L;
  } else
//#line  2060
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
    _L: /* CIL Label */ 
//#line  2064
    err = snd_audigy2nx_controls_create(mixer);
//#line  2064
    if (err < 0) {
//#line  2065
      goto _error;
    }
//#line  2066
    tmp___1 = snd_card_proc_new(chip->card, (char const   * __attribute__((__nullterm__)) )"audigy2nx",
                                & entry);
//#line  2066
    if (! tmp___1) {
//#line  2067
      snd_info_set_text_ops(entry, (void *)mixer, & snd_audigy2nx_proc_read);
    }
  }
//#line  2071
  err = snd_device_new(chip->card, 8192, (void *)mixer, (struct snd_device_ops *)(& dev_ops));
//#line  2072
  if (err < 0) {
//#line  2073
    goto _error;
  }
//#line  2074
  list_add(& mixer->list, & chip->mixer_list);
//#line  2075
  return (0);
  _error: 
//#line  2078
  snd_usb_mixer_free(mixer);
//#line  2079
  return (err);
}
}
//#line  2082 "/scratch/sym/ipc_drivers/usb-audio/usbmixer.c"
void snd_usb_mixer_disconnect(struct list_head *p ) 
{ 
  struct usb_mixer_interface *mixer ;
  struct list_head  const  *__mptr ;

  {
//#line  2086
  __mptr = (struct list_head  const  *)p;
//#line  2086
  mixer = (struct usb_mixer_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_mixer_interface *)0)->list));
//#line  2087
  usb_kill_urb(mixer->urb);
//#line  2088
  usb_kill_urb(mixer->rc_urb);
//#line  2089
  return;
}
}
