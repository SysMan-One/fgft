/* Generated by CIL v. 1.4.0 */
/* print_CIL_Input is true */

#include "../../common/slave_top.h" // Matt E1
int disp_kern(char *function_name , struct req_args *rqargs ) ;
char function_id_map[2165][128]  = 
  {      "0", 
        "1", 
        "2", 
        "3", 
        "4", 
        "5", 
        "6", 
        "7", 
        "8", 
        "9", 
        "10", 
        "11", 
        "12", 
        "13", 
        "14", 
        "15", 
        "16", 
        "17", 
        "18", 
        "19", 
        "20", 
        "21", 
        "22", 
        "23", 
        "24", 
        "25", 
        "26", 
        "27", 
        "28", 
        "29", 
        "30", 
        "31", 
        "32", 
        "33", 
        "34", 
        "35", 
        "36", 
        "37", 
        "38", 
        "39", 
        "40", 
        "41", 
        "42", 
        "43", 
        "44", 
        "45", 
        "46", 
        "47", 
        "48", 
        "49", 
        "50", 
        "51", 
        "52", 
        "53", 
        "54", 
        "55", 
        "56", 
        "57", 
        "58", 
        "59", 
        "60", 
        "61", 
        "62", 
        "63", 
        "64", 
        "65", 
        "66", 
        "67", 
        "68", 
        "69", 
        "70", 
        "71", 
        "72", 
        "73", 
        "74", 
        "75", 
        "76", 
        "77", 
        "78", 
        "79", 
        "80", 
        "81", 
        "82", 
        "83", 
        "84", 
        "85", 
        "86", 
        "87", 
        "88", 
        "89", 
        "90", 
        "91", 
        "92", 
        "93", 
        "94", 
        "95", 
        "96", 
        "97", 
        "98", 
        "99", 
        "100", 
        "101", 
        "102", 
        "103", 
        "104", 
        "105", 
        "106", 
        "107", 
        "108", 
        "109", 
        "110", 
        "111", 
        "112", 
        "113", 
        "114", 
        "115", 
        "116", 
        "117", 
        "118", 
        "119", 
        "120", 
        "121", 
        "122", 
        "123", 
        "124", 
        "125", 
        "126", 
        "127", 
        "128", 
        "129", 
        "130", 
        "131", 
        "132", 
        "133", 
        "134", 
        "135", 
        "136", 
        "137", 
        "138", 
        "139", 
        "140", 
        "141", 
        "142", 
        "143", 
        "144", 
        "145", 
        "146", 
        "147", 
        "148", 
        "149", 
        "150", 
        "151", 
        "152", 
        "153", 
        "154", 
        "155", 
        "156", 
        "157", 
        "158", 
        "159", 
        "160", 
        "161", 
        "162", 
        "163", 
        "164", 
        "165", 
        "166", 
        "167", 
        "168", 
        "169", 
        "170", 
        "171", 
        "172", 
        "173", 
        "174", 
        "175", 
        "176", 
        "177", 
        "178", 
        "179", 
        "180", 
        "181", 
        "182", 
        "183", 
        "184", 
        "185", 
        "186", 
        "187", 
        "188", 
        "189", 
        "190", 
        "191", 
        "192", 
        "193", 
        "194", 
        "195", 
        "196", 
        "197", 
        "198", 
        "199", 
        "200", 
        "201", 
        "202", 
        "203", 
        "204", 
        "205", 
        "206", 
        "207", 
        "208", 
        "209", 
        "210", 
        "211", 
        "212", 
        "213", 
        "214", 
        "215", 
        "216", 
        "217", 
        "218", 
        "219", 
        "220", 
        "221", 
        "222", 
        "223", 
        "224", 
        "225", 
        "226", 
        "227", 
        "228", 
        "229", 
        "230", 
        "231", 
        "232", 
        "233", 
        "234", 
        "235", 
        "236", 
        "237", 
        "238", 
        "239", 
        "240", 
        "241", 
        "242", 
        "243", 
        "244", 
        "245", 
        "246", 
        "247", 
        "248", 
        "249", 
        "250", 
        "251", 
        "252", 
        "253", 
        "254", 
        "255", 
        "256", 
        "257", 
        "258", 
        "259", 
        "260", 
        "261", 
        "262", 
        "263", 
        "264", 
        "265", 
        "266", 
        "267", 
        "268", 
        "269", 
        "270", 
        "271", 
        "272", 
        "273", 
        "274", 
        "275", 
        "276", 
        "277", 
        "278", 
        "279", 
        "280", 
        "281", 
        "282", 
        "283", 
        "284", 
        "285", 
        "286", 
        "287", 
        "288", 
        "289", 
        "290", 
        "291", 
        "292", 
        "293", 
        "294", 
        "295", 
        "296", 
        "297", 
        "298", 
        "299", 
        "300", 
        "301", 
        "302", 
        "303", 
        "304", 
        "305", 
        "306", 
        "307", 
        "308", 
        "309", 
        "310", 
        "311", 
        "312", 
        "313", 
        "314", 
        "315", 
        "316", 
        "317", 
        "318", 
        "319", 
        "320", 
        "321", 
        "322", 
        "323", 
        "324", 
        "325", 
        "326", 
        "327", 
        "328", 
        "329", 
        "330", 
        "331", 
        "332", 
        "333", 
        "334", 
        "335", 
        "336", 
        "337", 
        "338", 
        "339", 
        "340", 
        "341", 
        "342", 
        "343", 
        "344", 
        "345", 
        "346", 
        "347", 
        "348", 
        "349", 
        "350", 
        "351", 
        "352", 
        "353", 
        "354", 
        "355", 
        "356", 
        "357", 
        "358", 
        "359", 
        "360", 
        "361", 
        "362", 
        "363", 
        "364", 
        "365", 
        "366", 
        "367", 
        "368", 
        "369", 
        "370", 
        "371", 
        "372", 
        "373", 
        "374", 
        "375", 
        "376", 
        "377", 
        "378", 
        "379", 
        "380", 
        "381", 
        "382", 
        "383", 
        "384", 
        "385", 
        "386", 
        "387", 
        "388", 
        "389", 
        "390", 
        "391", 
        "392", 
        "393", 
        "394", 
        "395", 
        "396", 
        "397", 
        "398", 
        "399", 
        "400", 
        "401", 
        "402", 
        "403", 
        "404", 
        "405", 
        "406", 
        "407", 
        "408", 
        "409", 
        "410", 
        "411", 
        "412", 
        "413", 
        "414", 
        "415", 
        "416", 
        "417", 
        "418", 
        "419", 
        "420", 
        "421", 
        "422", 
        "423", 
        "424", 
        "425", 
        "426", 
        "427", 
        "428", 
        "429", 
        "430", 
        "431", 
        "432", 
        "433", 
        "434", 
        "435", 
        "436", 
        "437", 
        "438", 
        "439", 
        "440", 
        "441", 
        "442", 
        "443", 
        "444", 
        "445", 
        "446", 
        "447", 
        "448", 
        "449", 
        "450", 
        "451", 
        "452", 
        "453", 
        "454", 
        "455", 
        "456", 
        "457", 
        "458", 
        "459", 
        "460", 
        "461", 
        "462", 
        "463", 
        "464", 
        "465", 
        "466", 
        "467", 
        "468", 
        "469", 
        "470", 
        "471", 
        "472", 
        "473", 
        "474", 
        "475", 
        "476", 
        "477", 
        "478", 
        "479", 
        "480", 
        "481", 
        "482", 
        "483", 
        "484", 
        "485", 
        "486", 
        "487", 
        "488", 
        "489", 
        "490", 
        "491", 
        "492", 
        "493", 
        "494", 
        "495", 
        "496", 
        "497", 
        "498", 
        "499", 
        "500", 
        "501", 
        "502", 
        "503", 
        "504", 
        "505", 
        "506", 
        "507", 
        "508", 
        "509", 
        "510", 
        "511", 
        "512", 
        "513", 
        "514", 
        "515", 
        "516", 
        "517", 
        "518", 
        "519", 
        "520", 
        "521", 
        "522", 
        "523", 
        "524", 
        "525", 
        "526", 
        "527", 
        "528", 
        "529", 
        "530", 
        "531", 
        "532", 
        "533", 
        "534", 
        "535", 
        "536", 
        "537", 
        "538", 
        "539", 
        "540", 
        "541", 
        "542", 
        "543", 
        "544", 
        "545", 
        "546", 
        "547", 
        "548", 
        "549", 
        "550", 
        "551", 
        "552", 
        "553", 
        "554", 
        "555", 
        "556", 
        "557", 
        "558", 
        "559", 
        "560", 
        "561", 
        "562", 
        "563", 
        "564", 
        "565", 
        "566", 
        "567", 
        "568", 
        "569", 
        "570", 
        "571", 
        "572", 
        "573", 
        "574", 
        "575", 
        "576", 
        "577", 
        "578", 
        "579", 
        "580", 
        "581", 
        "582", 
        "583", 
        "584", 
        "585", 
        "586", 
        "587", 
        "588", 
        "589", 
        "590", 
        "591", 
        "592", 
        "593", 
        "594", 
        "595", 
        "596", 
        "597", 
        "598", 
        "599", 
        "600", 
        "601", 
        "602", 
        "603", 
        "604", 
        "605", 
        "606", 
        "607", 
        "608", 
        "609", 
        "610", 
        "611", 
        "612", 
        "613", 
        "614", 
        "615", 
        "616", 
        "617", 
        "618", 
        "619", 
        "620", 
        "621", 
        "622", 
        "623", 
        "624", 
        "625", 
        "626", 
        "627", 
        "628", 
        "629", 
        "630", 
        "631", 
        "632", 
        "633", 
        "634", 
        "635", 
        "636", 
        "637", 
        "638", 
        "639", 
        "640", 
        "641", 
        "642", 
        "643", 
        "644", 
        "645", 
        "646", 
        "647", 
        "648", 
        "649", 
        "650", 
        "651", 
        "652", 
        "653", 
        "654", 
        "655", 
        "656", 
        "657", 
        "658", 
        "659", 
        "660", 
        "661", 
        "662", 
        "663", 
        "664", 
        "665", 
        "666", 
        "667", 
        "668", 
        "669", 
        "670", 
        "671", 
        "672", 
        "673", 
        "674", 
        "675", 
        "676", 
        "677", 
        "678", 
        "679", 
        "680", 
        "681", 
        "682", 
        "683", 
        "684", 
        "685", 
        "686", 
        "687", 
        "688", 
        "689", 
        "690", 
        "691", 
        "692", 
        "693", 
        "694", 
        "695", 
        "696", 
        "697", 
        "698", 
        "699", 
        "700", 
        "701", 
        "702", 
        "703", 
        "704", 
        "705", 
        "706", 
        "707", 
        "708", 
        "709", 
        "710", 
        "711", 
        "712", 
        "713", 
        "714", 
        "715", 
        "716", 
        "717", 
        "718", 
        "719", 
        "720", 
        "721", 
        "722", 
        "723", 
        "724", 
        "725", 
        "726", 
        "727", 
        "728", 
        "729", 
        "730", 
        "731", 
        "732", 
        "733", 
        "734", 
        "735", 
        "736", 
        "737", 
        "738", 
        "739", 
        "740", 
        "741", 
        "742", 
        "743", 
        "744", 
        "745", 
        "746", 
        "747", 
        "748", 
        "749", 
        "750", 
        "751", 
        "752", 
        "753", 
        "754", 
        "755", 
        "756", 
        "757", 
        "758", 
        "759", 
        "760", 
        "761", 
        "762", 
        "763", 
        "764", 
        "765", 
        "766", 
        "767", 
        "768", 
        "769", 
        "770", 
        "771", 
        "772", 
        "773", 
        "774", 
        "775", 
        "776", 
        "777", 
        "778", 
        "779", 
        "780", 
        "781", 
        "782", 
        "783", 
        "784", 
        "785", 
        "786", 
        "787", 
        "788", 
        "789", 
        "790", 
        "791", 
        "792", 
        "793", 
        "794", 
        "795", 
        "796", 
        "797", 
        "798", 
        "799", 
        "800", 
        "801", 
        "802", 
        "803", 
        "804", 
        "805", 
        "806", 
        "807", 
        "808", 
        "809", 
        "810", 
        "811", 
        "812", 
        "813", 
        "814", 
        "815", 
        "816", 
        "817", 
        "818", 
        "819", 
        "820", 
        "821", 
        "822", 
        "823", 
        "824", 
        "825", 
        "826", 
        "827", 
        "828", 
        "829", 
        "830", 
        "831", 
        "832", 
        "833", 
        "834", 
        "835", 
        "836", 
        "837", 
        "838", 
        "839", 
        "840", 
        "841", 
        "842", 
        "843", 
        "844", 
        "845", 
        "846", 
        "847", 
        "848", 
        "849", 
        "850", 
        "851", 
        "852", 
        "853", 
        "854", 
        "855", 
        "856", 
        "857", 
        "858", 
        "859", 
        "860", 
        "861", 
        "862", 
        "863", 
        "864", 
        "865", 
        "866", 
        "867", 
        "868", 
        "869", 
        "870", 
        "871", 
        "872", 
        "873", 
        "874", 
        "875", 
        "876", 
        "877", 
        "878", 
        "879", 
        "880", 
        "881", 
        "882", 
        "883", 
        "884", 
        "885", 
        "886", 
        "887", 
        "888", 
        "889", 
        "890", 
        "891", 
        "892", 
        "893", 
        "894", 
        "895", 
        "896", 
        "897", 
        "898", 
        "899", 
        "900", 
        "901", 
        "902", 
        "903", 
        "904", 
        "905", 
        "906", 
        "907", 
        "908", 
        "909", 
        "910", 
        "911", 
        "912", 
        "913", 
        "914", 
        "915", 
        "916", 
        "917", 
        "918", 
        "919", 
        "920", 
        "921", 
        "922", 
        "923", 
        "924", 
        "925", 
        "926", 
        "927", 
        "928", 
        "929", 
        "930", 
        "931", 
        "932", 
        "933", 
        "934", 
        "935", 
        "936", 
        "937", 
        "938", 
        "939", 
        "940", 
        "941", 
        "942", 
        "943", 
        "944", 
        "945", 
        "946", 
        "947", 
        "948", 
        "949", 
        "950", 
        "951", 
        "952", 
        "953", 
        "954", 
        "955", 
        "956", 
        "957", 
        "958", 
        "959", 
        "960", 
        "961", 
        "962", 
        "963", 
        "964", 
        "965", 
        "966", 
        "967", 
        "968", 
        "969", 
        "970", 
        "971", 
        "972", 
        "973", 
        "974", 
        "975", 
        "976", 
        "977", 
        "978", 
        "979", 
        "980", 
        "981", 
        "982", 
        "983", 
        "984", 
        "985", 
        "986", 
        "987", 
        "988", 
        "989", 
        "990", 
        "991", 
        "992", 
        "993", 
        "994", 
        "995", 
        "996", 
        "997", 
        "998", 
        "999", 
        "INIT_LIST_HEAD", 
        "Nonstub_get_size", 
        "Nonstub_get_usb_device", 
        "Nonstub_return_buflen", 
        "Nonstub_usb_host_interface", 
        "__bad_pda_field", 
        "__builtin_expect", 
        "__builtin_memcpy", 
        "__builtin_prefetch", 
        "__constr_expr_0", 
        "__constr_expr_0___0", 
        "__constr_expr_1", 
        "__constr_expr_10", 
        "__constr_expr_100", 
        "__constr_expr_101", 
        "__constr_expr_102", 
        "__constr_expr_103", 
        "__constr_expr_104", 
        "__constr_expr_105", 
        "__constr_expr_106", 
        "__constr_expr_107", 
        "__constr_expr_108", 
        "__constr_expr_109", 
        "__constr_expr_11", 
        "__constr_expr_110", 
        "__constr_expr_111", 
        "__constr_expr_112", 
        "__constr_expr_113", 
        "__constr_expr_114", 
        "__constr_expr_115", 
        "__constr_expr_116", 
        "__constr_expr_117", 
        "__constr_expr_118", 
        "__constr_expr_119", 
        "__constr_expr_12", 
        "__constr_expr_120", 
        "__constr_expr_121", 
        "__constr_expr_122", 
        "__constr_expr_123", 
        "__constr_expr_124", 
        "__constr_expr_125", 
        "__constr_expr_126", 
        "__constr_expr_127", 
        "__constr_expr_128", 
        "__constr_expr_129", 
        "__constr_expr_13", 
        "__constr_expr_130", 
        "__constr_expr_131", 
        "__constr_expr_132", 
        "__constr_expr_133", 
        "__constr_expr_134", 
        "__constr_expr_135", 
        "__constr_expr_136", 
        "__constr_expr_137", 
        "__constr_expr_138", 
        "__constr_expr_139", 
        "__constr_expr_14", 
        "__constr_expr_140", 
        "__constr_expr_141", 
        "__constr_expr_142", 
        "__constr_expr_143", 
        "__constr_expr_144", 
        "__constr_expr_145", 
        "__constr_expr_146", 
        "__constr_expr_147", 
        "__constr_expr_148", 
        "__constr_expr_149", 
        "__constr_expr_15", 
        "__constr_expr_150", 
        "__constr_expr_151", 
        "__constr_expr_152", 
        "__constr_expr_153", 
        "__constr_expr_154", 
        "__constr_expr_155", 
        "__constr_expr_156", 
        "__constr_expr_157", 
        "__constr_expr_158", 
        "__constr_expr_159", 
        "__constr_expr_16", 
        "__constr_expr_160", 
        "__constr_expr_161", 
        "__constr_expr_162", 
        "__constr_expr_163", 
        "__constr_expr_164", 
        "__constr_expr_165", 
        "__constr_expr_166", 
        "__constr_expr_167", 
        "__constr_expr_168", 
        "__constr_expr_169", 
        "__constr_expr_17", 
        "__constr_expr_170", 
        "__constr_expr_171", 
        "__constr_expr_172", 
        "__constr_expr_173", 
        "__constr_expr_174", 
        "__constr_expr_175", 
        "__constr_expr_176", 
        "__constr_expr_177", 
        "__constr_expr_178", 
        "__constr_expr_179", 
        "__constr_expr_18", 
        "__constr_expr_180", 
        "__constr_expr_181", 
        "__constr_expr_182", 
        "__constr_expr_183", 
        "__constr_expr_184", 
        "__constr_expr_185", 
        "__constr_expr_186", 
        "__constr_expr_187", 
        "__constr_expr_188", 
        "__constr_expr_189", 
        "__constr_expr_19", 
        "__constr_expr_190", 
        "__constr_expr_191", 
        "__constr_expr_192", 
        "__constr_expr_193", 
        "__constr_expr_194", 
        "__constr_expr_195", 
        "__constr_expr_196", 
        "__constr_expr_197", 
        "__constr_expr_198", 
        "__constr_expr_199", 
        "__constr_expr_1___0", 
        "__constr_expr_2", 
        "__constr_expr_20", 
        "__constr_expr_200", 
        "__constr_expr_201", 
        "__constr_expr_202", 
        "__constr_expr_203", 
        "__constr_expr_204", 
        "__constr_expr_205", 
        "__constr_expr_206", 
        "__constr_expr_207", 
        "__constr_expr_208", 
        "__constr_expr_209", 
        "__constr_expr_21", 
        "__constr_expr_210", 
        "__constr_expr_211", 
        "__constr_expr_212", 
        "__constr_expr_213", 
        "__constr_expr_214", 
        "__constr_expr_215", 
        "__constr_expr_216", 
        "__constr_expr_217", 
        "__constr_expr_218", 
        "__constr_expr_219", 
        "__constr_expr_22", 
        "__constr_expr_220", 
        "__constr_expr_221", 
        "__constr_expr_222", 
        "__constr_expr_223", 
        "__constr_expr_224", 
        "__constr_expr_225", 
        "__constr_expr_226", 
        "__constr_expr_227", 
        "__constr_expr_228", 
        "__constr_expr_229", 
        "__constr_expr_23", 
        "__constr_expr_230", 
        "__constr_expr_231", 
        "__constr_expr_232", 
        "__constr_expr_233", 
        "__constr_expr_234", 
        "__constr_expr_235", 
        "__constr_expr_236", 
        "__constr_expr_237", 
        "__constr_expr_238", 
        "__constr_expr_239", 
        "__constr_expr_24", 
        "__constr_expr_240", 
        "__constr_expr_241", 
        "__constr_expr_242", 
        "__constr_expr_243", 
        "__constr_expr_244", 
        "__constr_expr_245", 
        "__constr_expr_246", 
        "__constr_expr_247", 
        "__constr_expr_248", 
        "__constr_expr_249", 
        "__constr_expr_25", 
        "__constr_expr_250", 
        "__constr_expr_251", 
        "__constr_expr_252", 
        "__constr_expr_253", 
        "__constr_expr_254", 
        "__constr_expr_255", 
        "__constr_expr_256", 
        "__constr_expr_257", 
        "__constr_expr_258", 
        "__constr_expr_259", 
        "__constr_expr_26", 
        "__constr_expr_260", 
        "__constr_expr_261", 
        "__constr_expr_262", 
        "__constr_expr_263", 
        "__constr_expr_264", 
        "__constr_expr_265", 
        "__constr_expr_266", 
        "__constr_expr_267", 
        "__constr_expr_268", 
        "__constr_expr_269", 
        "__constr_expr_27", 
        "__constr_expr_270", 
        "__constr_expr_271", 
        "__constr_expr_272", 
        "__constr_expr_273", 
        "__constr_expr_28", 
        "__constr_expr_29", 
        "__constr_expr_2___0", 
        "__constr_expr_3", 
        "__constr_expr_30", 
        "__constr_expr_31", 
        "__constr_expr_32", 
        "__constr_expr_33", 
        "__constr_expr_34", 
        "__constr_expr_35", 
        "__constr_expr_36", 
        "__constr_expr_37", 
        "__constr_expr_38", 
        "__constr_expr_39", 
        "__constr_expr_4", 
        "__constr_expr_40", 
        "__constr_expr_41", 
        "__constr_expr_42", 
        "__constr_expr_43", 
        "__constr_expr_44", 
        "__constr_expr_45", 
        "__constr_expr_46", 
        "__constr_expr_47", 
        "__constr_expr_48", 
        "__constr_expr_49", 
        "__constr_expr_5", 
        "__constr_expr_50", 
        "__constr_expr_51", 
        "__constr_expr_52", 
        "__constr_expr_53", 
        "__constr_expr_54", 
        "__constr_expr_55", 
        "__constr_expr_56", 
        "__constr_expr_57", 
        "__constr_expr_58", 
        "__constr_expr_59", 
        "__constr_expr_6", 
        "__constr_expr_60", 
        "__constr_expr_61", 
        "__constr_expr_62", 
        "__constr_expr_63", 
        "__constr_expr_64", 
        "__constr_expr_65", 
        "__constr_expr_66", 
        "__constr_expr_67", 
        "__constr_expr_68", 
        "__constr_expr_69", 
        "__constr_expr_7", 
        "__constr_expr_70", 
        "__constr_expr_71", 
        "__constr_expr_72", 
        "__constr_expr_73", 
        "__constr_expr_74", 
        "__constr_expr_75", 
        "__constr_expr_76", 
        "__constr_expr_77", 
        "__constr_expr_78", 
        "__constr_expr_79", 
        "__constr_expr_8", 
        "__constr_expr_80", 
        "__constr_expr_81", 
        "__constr_expr_82", 
        "__constr_expr_83", 
        "__constr_expr_84", 
        "__constr_expr_85", 
        "__constr_expr_86", 
        "__constr_expr_87", 
        "__constr_expr_88", 
        "__constr_expr_89", 
        "__constr_expr_9", 
        "__constr_expr_90", 
        "__constr_expr_91", 
        "__constr_expr_92", 
        "__constr_expr_93", 
        "__constr_expr_94", 
        "__constr_expr_95", 
        "__constr_expr_96", 
        "__constr_expr_97", 
        "__constr_expr_98", 
        "__constr_expr_99", 
        "__create_pipe", 
        "__get_free_pages", 
        "__key___4", 
        "__key___5", 
        "__key___6", 
        "__kmalloc", 
        "__kstrtab_snd_usb_create_midi_interface", 
        "__kstrtab_snd_usbmidi_disconnect", 
        "__kstrtab_snd_usbmidi_input_start", 
        "__kstrtab_snd_usbmidi_input_stop", 
        "__list_add", 
        "__memcpy", 
        "__might_sleep", 
        "__param_arr_device_setup", 
        "__param_arr_enable", 
        "__param_arr_id", 
        "__param_arr_index", 
        "__param_arr_pid", 
        "__param_arr_vid", 
        "__param_str_async_unlink", 
        "__param_str_device_setup", 
        "__param_str_enable", 
        "__param_str_id", 
        "__param_str_ignore_ctl_error", 
        "__param_str_index", 
        "__param_str_nrpacks", 
        "__param_str_pid", 
        "__param_str_vid", 
        "__phys_addr", 
        "__snd_bug_on", 
        "__spin_lock_init", 
        "__tasklet_schedule", 
        "__this_module", 
        "__wake_up", 
        "__xchg", 
        "_cond_resched", 
        "_spin_lock", 
        "_spin_lock_irq", 
        "_spin_lock_irqsave", 
        "_spin_unlock", 
        "_spin_unlock_irq", 
        "_spin_unlock_irqrestore", 
        "add_audio_endpoint", 
        "add_control_to_empty", 
        "async_unlink", 
        "audigy2nx_map", 
        "audigy2nx_selectors", 
        "audio_feature_info", 
        "audio_urb_ops", 
        "audio_urb_ops_high_speed", 
        "audiophile_skip_setting_quirk", 
        "aureon_51_2_map", 
        "autoremove_wake_function", 
        "build_audio_procunit", 
        "build_feature_ctl", 
        "build_mixer_unit_ctl", 
        "bytes_to_frames", 
        "check_hw_params_convention", 
        "check_ignored_ctl", 
        "check_input_term", 
        "check_mapped_name", 
        "check_mapped_selector_name", 
        "check_matrix_bitmap", 
        "chorus_proc_info", 
        "cleanup_module", 
        "clear_bit", 
        "convert_bytes_value", 
        "convert_signed_value", 
        "copy_to_user", 
        "create_composite_quirk", 
        "create_fixed_stream_quirk", 
        "create_standard_audio_quirk", 
        "create_ua1000_quirk", 
        "create_ua101_quirk", 
        "create_uaxx_quirk", 
        "dcr_proc_info", 
        "deactivate_urbs", 
        "default_info", 
        "default_value_info", 
        "del_timer_sync", 
        "dev_get_drvdata", 
        "dev_ops", 
        "dev_set_drvdata", 
        "device_setup", 
        "enable", 
        "extigy_map", 
        "ffs", 
        "find_audio_control_unit", 
        "find_format", 
        "find_port_info", 
        "finish_data", 
        "finish_wait", 
        "free_pages", 
        "free_substream", 
        "get_abs_value", 
        "get_ctl_value", 
        "get_cur_ctl_value", 
        "get_cur_mix_value", 
        "get_current", 
        "get_min_max", 
        "get_order", 
        "get_relative_value", 
        "get_term_name", 
        "get_usb_full_speed_rate", 
        "get_usb_high_speed_rate", 
        "heapifyfree", 
        "heapifymalloc", 
        "hw_check_valid_format", 
        "hw_param_interval", 
        "hw_param_mask", 
        "hw_rule_channels", 
        "hw_rule_format", 
        "hw_rule_rate", 
        "id", 
        "ignore_ctl_error", 
        "ignore_interface_quirk", 
        "index", 
        "init_data", 
        "init_module", 
        "init_substream", 
        "init_substream_urbs", 
        "init_timer", 
        "init_usb_pitch", 
        "init_usb_sample_rate", 
        "init_waitqueue_head", 
        "is_big_endian_format", 
        "iterm_names", 
        "jacks_audigy2nx", 
        "jacks_live24ext", 
        "justlink_map", 
        "kcalloc", 
        "kfree", 
        "kmalloc", 
        "kmemdup", 
        "kzalloc", 
        "linex_map", 
        "list_add", 
        "list_add_tail", 
        "list_del", 
        "live24ext_map", 
        "logRead", 
        "logStackFrame", 
        "logWrite", 
        "maya44_map", 
        "memset", 
        "might_fault", 
        "mixer_ctl_feature_get", 
        "mixer_ctl_feature_info", 
        "mixer_ctl_feature_put", 
        "mixer_ctl_procunit_get", 
        "mixer_ctl_procunit_put", 
        "mixer_ctl_selector_get", 
        "mixer_ctl_selector_info", 
        "mixer_ctl_selector_put", 
        "mixer_procunit_ctl", 
        "mixer_selectunit_ctl", 
        "mixer_vol_tlv", 
        "mod_timer", 
        "mp3plus_map", 
        "msecs_to_jiffies", 
        "mutex_lock_nested", 
        "mutex_unlock", 
        "nrpacks", 
        "ops", 
        "param_array_get", 
        "param_array_set", 
        "param_get_bool", 
        "param_get_charp", 
        "param_get_int", 
        "param_set_bool", 
        "param_set_charp", 
        "param_set_int", 
        "parse_audio_endpoints", 
        "parse_audio_extension_unit", 
        "parse_audio_feature_unit", 
        "parse_audio_format", 
        "parse_audio_format_i", 
        "parse_audio_format_i_type", 
        "parse_audio_format_ii", 
        "parse_audio_format_rates", 
        "parse_audio_mixer_unit", 
        "parse_audio_processing_unit", 
        "parse_audio_selector_unit", 
        "parse_audio_unit", 
        "pid", 
        "poll_wait", 
        "prepare_capture_sync_urb", 
        "prepare_capture_sync_urb_hs", 
        "prepare_capture_urb", 
        "prepare_nodata_playback_urb", 
        "prepare_playback_sync_urb", 
        "prepare_playback_sync_urb_hs", 
        "prepare_playback_urb", 
        "prepare_to_wait", 
        "printk", 
        "proc_audio_usbbus_read", 
        "proc_audio_usbid_read", 
        "proc_pcm_format_add", 
        "procunits", 
        "prologic_proc_info", 
        "quirk_funcs", 
        "rc_configs", 
        "register_mutex", 
        "release_substream_urbs", 
        "release_urb_ctx", 
        "retire_capture_sync_urb", 
        "retire_capture_urb", 
        "retire_paused_capture_urb", 
        "retire_playback_sync_urb", 
        "retire_playback_sync_urb_hs", 
        "retire_playback_sync_urb_hs_emu", 
        "retire_playback_urb", 
        "reverb_proc_info", 
        "schedule", 
        "schedule_timeout_uninterruptible", 
        "send_bulk_static_data", 
        "set_bit", 
        "set_ctl_value", 
        "set_cur_ctl_value", 
        "set_cur_mix_value", 
        "set_format", 
        "setup_hw_info", 
        "signal_pending", 
        "snd_audigy2nx_controls", 
        "snd_audigy2nx_controls_create", 
        "snd_audigy2nx_led_get", 
        "snd_audigy2nx_led_put", 
        "snd_audigy2nx_proc_read", 
        "snd_card_disconnect", 
        "snd_card_free", 
        "snd_card_free_when_closed", 
        "snd_card_new", 
        "snd_card_proc_new", 
        "snd_card_register", 
        "snd_complete_sync_urb", 
        "snd_complete_urb", 
        "snd_component_add", 
        "snd_ctl_add", 
        "snd_ctl_boolean_mono_info", 
        "snd_ctl_find_id", 
        "snd_ctl_new1", 
        "snd_ctl_notify", 
        "snd_device_new", 
        "snd_hwdep_new", 
        "snd_info_set_text_ops", 
        "snd_interval_checkempty", 
        "snd_iprintf", 
        "snd_mask_min", 
        "snd_mask_test", 
        "snd_pcm_alloc_vmalloc_buffer", 
        "snd_pcm_format_physical_width", 
        "snd_pcm_free_vmalloc_buffer", 
        "snd_pcm_get_vmalloc_page", 
        "snd_pcm_hw_constraint_list", 
        "snd_pcm_hw_constraint_minmax", 
        "snd_pcm_hw_rule_add_MJR2", 
        "snd_pcm_lib_ioctl", 
        "snd_pcm_new", 
        "snd_pcm_new_stream", 
        "snd_pcm_period_elapsed", 
        "snd_pcm_rate_to_rate_bit", 
        "snd_pcm_set_ops", 
        "snd_pcm_stop", 
        "snd_pcm_suspend_all", 
        "snd_power_change_state", 
        "snd_rawmidi_new", 
        "snd_rawmidi_receive", 
        "snd_rawmidi_set_ops", 
        "snd_rawmidi_transmit", 
        "snd_rawmidi_transmit_ack", 
        "snd_rawmidi_transmit_empty", 
        "snd_rawmidi_transmit_peek", 
        "snd_usb_audigy2nx_boot_quirk", 
        "snd_usb_audio_cleanup", 
        "snd_usb_audio_create", 
        "snd_usb_audio_create_proc", 
        "snd_usb_audio_dev_free", 
        "snd_usb_audio_disconnect", 
        "snd_usb_audio_free", 
        "snd_usb_audio_init", 
        "snd_usb_audio_next_packet_size", 
        "snd_usb_audio_pcm_free", 
        "snd_usb_audio_probe", 
        "snd_usb_audio_stream_free", 
        "snd_usb_capture_close", 
        "snd_usb_capture_open", 
        "snd_usb_capture_ops", 
        "snd_usb_cm106_boot_quirk", 
        "snd_usb_cm106_write_int_reg", 
        "snd_usb_combine_bytes", 
        "snd_usb_copy_string_desc", 
        "snd_usb_create_midi_interface", 
        "snd_usb_create_mixer", 
        "snd_usb_create_quirk", 
        "snd_usb_create_streams", 
        "snd_usb_ctl_msg", 
        "snd_usb_extigy_boot_quirk", 
        "snd_usb_find_csint_desc", 
        "snd_usb_find_desc", 
        "snd_usb_hw_free", 
        "snd_usb_hw_params", 
        "snd_usb_mixer_controls", 
        "snd_usb_mixer_dev_free", 
        "snd_usb_mixer_disconnect", 
        "snd_usb_mixer_free", 
        "snd_usb_mixer_memory_change", 
        "snd_usb_mixer_notify_id", 
        "snd_usb_mixer_status_complete", 
        "snd_usb_mixer_status_create", 
        "snd_usb_pcm_capture_trigger", 
        "snd_usb_pcm_check_knot", 
        "snd_usb_pcm_close", 
        "snd_usb_pcm_open", 
        "snd_usb_pcm_playback_trigger", 
        "snd_usb_pcm_pointer", 
        "snd_usb_pcm_prepare", 
        "snd_usb_playback_close", 
        "snd_usb_playback_open", 
        "snd_usb_playback_ops", 
        "snd_usb_sbrc_hwdep_open", 
        "snd_usb_sbrc_hwdep_poll", 
        "snd_usb_sbrc_hwdep_read", 
        "snd_usb_sbrc_hwdep_release", 
        "snd_usb_soundblaster_remote_complete", 
        "snd_usb_soundblaster_remote_init", 
        "snd_usb_stream_disconnect", 
        "snd_usbmidi_122l_ops", 
        "snd_usbmidi_cin_length", 
        "snd_usbmidi_cme_input", 
        "snd_usbmidi_cme_ops", 
        "snd_usbmidi_count_bits", 
        "snd_usbmidi_create_endpoints", 
        "snd_usbmidi_create_endpoints_midiman", 
        "snd_usbmidi_create_rawmidi", 
        "snd_usbmidi_detect_endpoints", 
        "snd_usbmidi_detect_per_port_endpoints", 
        "snd_usbmidi_detect_yamaha", 
        "snd_usbmidi_disconnect", 
        "snd_usbmidi_do_output", 
        "snd_usbmidi_emagic_finish_out", 
        "snd_usbmidi_emagic_init_out", 
        "snd_usbmidi_emagic_input", 
        "snd_usbmidi_emagic_ops", 
        "snd_usbmidi_emagic_output", 
        "snd_usbmidi_error_timer", 
        "snd_usbmidi_find_substream", 
        "snd_usbmidi_free", 
        "snd_usbmidi_get_ms_info", 
        "snd_usbmidi_get_port_info", 
        "snd_usbmidi_in_endpoint_create", 
        "snd_usbmidi_in_endpoint_delete", 
        "snd_usbmidi_in_urb_complete", 
        "snd_usbmidi_init_substream", 
        "snd_usbmidi_input_close", 
        "snd_usbmidi_input_data", 
        "snd_usbmidi_input_open", 
        "snd_usbmidi_input_ops", 
        "snd_usbmidi_input_start", 
        "snd_usbmidi_input_start_ep", 
        "snd_usbmidi_input_stop", 
        "snd_usbmidi_input_trigger", 
        "snd_usbmidi_maudio_broken_running_status_input", 
        "snd_usbmidi_maudio_broken_running_status_ops", 
        "snd_usbmidi_midiman_input", 
        "snd_usbmidi_midiman_ops", 
        "snd_usbmidi_novation_input", 
        "snd_usbmidi_novation_ops", 
        "snd_usbmidi_novation_output", 
        "snd_usbmidi_ops", 
        "snd_usbmidi_out_endpoint_create", 
        "snd_usbmidi_out_endpoint_delete", 
        "snd_usbmidi_out_tasklet", 
        "snd_usbmidi_out_urb_complete", 
        "snd_usbmidi_output_close", 
        "snd_usbmidi_output_midiman_packet", 
        "snd_usbmidi_output_open", 
        "snd_usbmidi_output_ops", 
        "snd_usbmidi_output_standard_packet", 
        "snd_usbmidi_output_trigger", 
        "snd_usbmidi_port_info", 
        "snd_usbmidi_raw_input", 
        "snd_usbmidi_raw_ops", 
        "snd_usbmidi_raw_output", 
        "snd_usbmidi_rawmidi_free", 
        "snd_usbmidi_standard_input", 
        "snd_usbmidi_standard_ops", 
        "snd_usbmidi_standard_output", 
        "snd_usbmidi_submit_urb", 
        "snd_usbmidi_switch_roland_altsetting", 
        "snd_usbmidi_transmit_byte", 
        "snd_usbmidi_urb_error", 
        "snd_usbmidi_us122l_input", 
        "snd_usbmidi_us122l_output", 
        "snprintf", 
        "sprintf", 
        "stackguard_get_ra", 
        "stackguard_pop", 
        "stackguard_push", 
        "stackguard_set_ra", 
        "stackguard_stack", 
        "start_urbs", 
        "str_0", 
        "str_1004535908", 
        "str_1005803972", 
        "str_1014490587", 
        "str_1015625071", 
        "str_1028937", 
        "str_1030557429", 
        "str_1034644995", 
        "str_1039773507", 
        "str_1040058580", 
        "str_1041397175", 
        "str_1041470126", 
        "str_1042685215", 
        "str_10530917", 
        "str_1054178865", 
        "str_1055203368", 
        "str_10592645", 
        "str_1059676627", 
        "str_1060371900", 
        "str_1060912469", 
        "str_1061019973", 
        "str_106136500", 
        "str_10637825", 
        "str_10641780", 
        "str_1064537007", 
        "str_1068557351", 
        "str_1069376918", 
        "str_1073431585", 
        "str_10753440", 
        "str_10800265", 
        "str_10902533", 
        "str_10915739", 
        "str_10915755", 
        "str_11174419", 
        "str_11181278", 
        "str_11272957", 
        "str_11300298", 
        "str_11300412", 
        "str_11300431", 
        "str_11395627", 
        "str_11480405", 
        "str_11540363", 
        "str_11540368", 
        "str_11554596", 
        "str_11554634", 
        "str_11588601", 
        "str_11694111", 
        "str_11699988", 
        "str_1207", 
        "str_125301167", 
        "str_129785158", 
        "str_129785196", 
        "str_129785201", 
        "str_133922991", 
        "str_1341", 
        "str_14089218", 
        "str_145470558", 
        "str_15231084", 
        "str_154546418", 
        "str_154546420", 
        "str_154546422", 
        "str_154546433", 
        "str_154546776", 
        "str_154546778", 
        "str_154546780", 
        "str_154546782", 
        "str_154546784", 
        "str_158039148", 
        "str_158454992", 
        "str_159293978", 
        "str_16073815", 
        "str_164490267", 
        "str_165493744", 
        "str_165494466", 
        "str_168675912", 
        "str_174936368", 
        "str_178763828", 
        "str_178770687", 
        "str_178901836", 
        "str_178903280", 
        "str_179391037", 
        "str_180244545", 
        "str_180256858", 
        "str_181451660", 
        "str_181728381", 
        "str_182916092", 
        "str_185760420", 
        "str_186466258", 
        "str_199274370", 
        "str_201558875", 
        "str_201558876", 
        "str_201558877", 
        "str_202091287", 
        "str_202098146", 
        "str_204133454", 
        "str_207147453", 
        "str_207539138", 
        "str_208320737", 
        "str_209484720", 
        "str_209941598", 
        "str_21158850", 
        "str_211697793", 
        "str_214582020", 
        "str_21498367", 
        "str_215226995", 
        "str_215619040", 
        "str_216271012", 
        "str_217050626", 
        "str_217733085", 
        "str_218283728", 
        "str_218563518", 
        "str_219266584", 
        "str_219266585", 
        "str_219267023", 
        "str_219267764", 
        "str_219268125", 
        "str_219268750", 
        "str_220831141", 
        "str_220831597", 
        "str_220831975", 
        "str_220833115", 
        "str_221788472", 
        "str_225760646", 
        "str_226407066", 
        "str_228195326", 
        "str_229836041", 
        "str_233798669", 
        "str_236948253", 
        "str_238177709", 
        "str_238745560", 
        "str_239825392", 
        "str_248349902", 
        "str_254016772", 
        "str_256741", 
        "str_25867", 
        "str_25888", 
        "str_25903", 
        "str_26232", 
        "str_267488495", 
        "str_279917523", 
        "str_28835", 
        "str_295955", 
        "str_295956", 
        "str_296432", 
        "str_298493551", 
        "str_298606004", 
        "str_29891", 
        "str_30230", 
        "str_30235", 
        "str_305400396", 
        "str_30931", 
        "str_31094", 
        "str_312378469", 
        "str_312951437", 
        "str_31596", 
        "str_316584895", 
        "str_317885218", 
        "str_32", 
        "str_32155715", 
        "str_32328", 
        "str_324299317", 
        "str_325836133", 
        "str_327960850", 
        "str_333096528", 
        "str_335406018", 
        "str_336410471", 
        "str_346970378", 
        "str_349765498", 
        "str_35173879", 
        "str_351748476", 
        "str_358300541", 
        "str_3623250", 
        "str_376161077", 
        "str_388213389", 
        "str_391949103", 
        "str_400614853", 
        "str_403701822", 
        "str_405545197", 
        "str_405545198", 
        "str_405545199", 
        "str_410776958", 
        "str_411382038", 
        "str_412731004", 
        "str_415308913", 
        "str_427276364", 
        "str_429534546", 
        "str_43365079", 
        "str_433838956", 
        "str_438695472", 
        "str_442778450", 
        "str_444495457", 
        "str_445429857", 
        "str_447048969", 
        "str_449190836", 
        "str_459503637", 
        "str_461878866", 
        "str_461880310", 
        "str_461885725", 
        "str_461892223", 
        "str_468492697", 
        "str_473127585", 
        "str_473778296", 
        "str_482873", 
        "str_489702074", 
        "str_490515", 
        "str_496460573", 
        "str_496506222", 
        "str_496823950", 
        "str_496823969", 
        "str_496823988", 
        "str_496824007", 
        "str_496824026", 
        "str_496824045", 
        "str_496824064", 
        "str_496824083", 
        "str_497625127", 
        "str_501945809", 
        "str_504327", 
        "str_508178660", 
        "str_508915848", 
        "str_515799417", 
        "str_51703753", 
        "str_521161324", 
        "str_522043394", 
        "str_526151313", 
        "str_528878465", 
        "str_532616561", 
        "str_544751132", 
        "str_550941773", 
        "str_556279697", 
        "str_558343", 
        "str_561380", 
        "str_564233269", 
        "str_569364926", 
        "str_570853617", 
        "str_572685", 
        "str_576734707", 
        "str_577592", 
        "str_582837192", 
        "str_585972373", 
        "str_589782702", 
        "str_595159629", 
        "str_595175755", 
        "str_596491274", 
        "str_597637", 
        "str_597914956", 
        "str_599646", 
        "str_599760", 
        "str_600119615", 
        "str_601293204", 
        "str_601293205", 
        "str_601293220", 
        "str_601293221", 
        "str_601554213", 
        "str_607388", 
        "str_607981", 
        "str_608393064", 
        "str_608431467", 
        "str_609203", 
        "str_611716", 
        "str_611717", 
        "str_611719", 
        "str_612180258", 
        "str_612180259", 
        "str_612180260", 
        "str_612180261", 
        "str_615768", 
        "str_615920", 
        "str_615991579", 
        "str_616233", 
        "str_62046100", 
        "str_629245061", 
        "str_631087734", 
        "str_635602341", 
        "str_63622457", 
        "str_639341561", 
        "str_64240467", 
        "str_64261101", 
        "str_647061483", 
        "str_65189559", 
        "str_652131613", 
        "str_652565892", 
        "str_653514840", 
        "str_657372624", 
        "str_657602785", 
        "str_659772121", 
        "str_659921694", 
        "str_6623682", 
        "str_6629097", 
        "str_667951693", 
        "str_677216733", 
        "str_677794626", 
        "str_679801322", 
        "str_680563518", 
        "str_683293777", 
        "str_686943043", 
        "str_687152508", 
        "str_690022538", 
        "str_694732782", 
        "str_698010430", 
        "str_698187463", 
        "str_699349911", 
        "str_706759643", 
        "str_708091878", 
        "str_709717790", 
        "str_721858797", 
        "str_735532888", 
        "str_738260344", 
        "str_743645852", 
        "str_747151802", 
        "str_75292164", 
        "str_752941123", 
        "str_754636363", 
        "str_756280652", 
        "str_75719076", 
        "str_757471119", 
        "str_758343632", 
        "str_761039825", 
        "str_764792676", 
        "str_764993234", 
        "str_765604581", 
        "str_772338763", 
        "str_778694563", 
        "str_781461537", 
        "str_782488767", 
        "str_785022198", 
        "str_790741568", 
        "str_791573890", 
        "str_797487953", 
        "str_799096034", 
        "str_803117500", 
        "str_803851448", 
        "str_806837355", 
        "str_80732848", 
        "str_809021430", 
        "str_812255493", 
        "str_835963836", 
        "str_840389807", 
        "str_841139419", 
        "str_843424035", 
        "str_852258126", 
        "str_85230465", 
        "str_854498725", 
        "str_854499087", 
        "str_854499089", 
        "str_854499811", 
        "str_854501259", 
        "str_855751047", 
        "str_855751104", 
        "str_856339116", 
        "str_857529930", 
        "str_863125700", 
        "str_868332612", 
        "str_870290969", 
        "str_872419140", 
        "str_873074482", 
        "str_877389318", 
        "str_87817340", 
        "str_87930470", 
        "str_882451506", 
        "str_883168199", 
        "str_88429757", 
        "str_884756751", 
        "str_885550103", 
        "str_888942698", 
        "str_892675406", 
        "str_893500057", 
        "str_894397911", 
        "str_902805966", 
        "str_908632785", 
        "str_923436265", 
        "str_924615310", 
        "str_927843941", 
        "str_93429168", 
        "str_934616211", 
        "str_934776571", 
        "str_9378605", 
        "str_9378607", 
        "str_941262301", 
        "str_9415899", 
        "str_941834121", 
        "str_9440451", 
        "str_944839672", 
        "str_944848775", 
        "str_9461004", 
        "str_947601669", 
        "str_948881558", 
        "str_953588697", 
        "str_956433291", 
        "str_956492597", 
        "str_9595539", 
        "str_9597327", 
        "str_960860569", 
        "str_960884417", 
        "str_967653936", 
        "str_968180269", 
        "str_96862090", 
        "str_974050335", 
        "str_974276422", 
        "str_974774143", 
        "str_974799125", 
        "str_9770741", 
        "str_977636194", 
        "str_981105601", 
        "str_981956828", 
        "str_9839312", 
        "str_983984005", 
        "str_984249857", 
        "str_986049528", 
        "str_994182456", 
        "str_9946673", 
        "strcmp", 
        "strcpy", 
        "strlcat", 
        "strlcpy", 
        "strlen", 
        "tasklet_init", 
        "tasklet_kill", 
        "tasklet_schedule", 
        "test_and_set_bit", 
        "test_ti_thread_flag", 
        "test_tsk_thread_flag", 
        "threed_enh_proc_info", 
        "ua1000_format", 
        "ua101_format", 
        "ua700_ep", 
        "ua700_quirk", 
        "ua_format", 
        "uaxx_ep", 
        "uaxx_quirk", 
        "updown_proc_info", 
        "usb_alloc_urb", 
        "usb_audio_disconnect", 
        "usb_audio_driver", 
        "usb_audio_ids", 
        "usb_audio_probe", 
        "usb_audio_resume", 
        "usb_audio_suspend", 
        "usb_buffer_alloc", 
        "usb_buffer_free", 
        "usb_bulk_msg", 
        "usb_chip", 
        "usb_control_msg", 
        "usb_deregister", 
        "usb_driver_claim_interface", 
        "usb_endpoint_dir_in", 
        "usb_endpoint_dir_out", 
        "usb_endpoint_num", 
        "usb_endpoint_xfer_bulk", 
        "usb_endpoint_xfer_int", 
        "usb_error_string", 
        "usb_feature_unit_ctl", 
        "usb_fill_bulk_urb", 
        "usb_fill_control_urb", 
        "usb_fill_int_urb", 
        "usb_free_urb", 
        "usb_get_descriptor", 
        "usb_get_intfdata", 
        "usb_ifnum_to_if", 
        "usb_interface_claimed", 
        "usb_kill_urb", 
        "usb_make_path", 
        "usb_maxpacket", 
        "usb_mixer_elem_free", 
        "usb_mixer_selector_elem_free", 
        "usb_register", 
        "usb_register_driver", 
        "usb_reset_configuration", 
        "usb_set_interface", 
        "usb_set_intfdata", 
        "usb_string", 
        "usb_submit_urb", 
        "usb_unlink_urb", 
        "usbmix_ctl_maps", 
        "variable_test_bit", 
        "vid", 
        "wait_clear_urbs", 
        "warn_slowpath"};
int function_id_map_len  =    2165;
char str_803117500[10]  =    "usb-%s-%s";
char str_934776571[10]  =    "usb_audio";
char str_690022538[25]  =    "register_mutex.wait_lock";
char str_1014490587[15]  =    "register_mutex";
char str_756280652[24]  =    "<3>frame %d active: %d\n";
char str_721858797[33]  =    "<3>cannot submit urb (err = %d)\n";
char str_80732848[38]  =    "<3>cannot submit sync urb (err = %d)\n";
char str_248349902[40]  =    "MJR Added this: Size: %d, new-size: %d\n";
char str_433838956[39]  =    "<3>cannot prepare datapipe for urb %d\n";
char str_639341561[39]  =    "<3>cannot prepare syncpipe for urb %d\n";
char str_868332612[52]  =    "<3>cannot submit datapipe for urb %d, error %d: %s\n";
char str_447048969[52]  =    "<3>cannot submit syncpipe for urb %d, error %d: %s\n";
char str_894397911[36]  =    "<3>timeout: still %d active urbs..\n";
char str_75292164[38]  =    "<3>%d:%d:%d: cannot set enable PITCH\n";
char str_885550103[44]  =    "<3>%d:%d:%d: cannot set freq %d to ep 0x%x\n";
char str_1041397175[41]  =    "<4>%d:%d:%d: cannot get freq at ep 0x%x\n";
char str_515799417[58]  =    "<4>current rate %d is different from the runtime rate %d\n";
char str_585972373[56]  =    "/scratch/sym/ipc_drivers/usb-audio/usbaudio_annotated.c";
char str_986049528[41]  =    "<3>%d:%d:%d: return to setting 0 failed\n";
char str_764993234[39]  =    "<3>%d:%d:%d: usb_set_interface failed\n";
char str_43365079[32]  =    "<6>setting usb interface %d:%d\n";
char str_764792676[34]  =    "<3>%d:%d:%d : invalid synch pipe\n";
char str_473778296[63]  =    "<7>cannot set format: format = 0x%x, rate = %d, channels = %d\n";
char str_597914956[38]  =    "<3>usbaudio: no format is specified!\n";
char str_615991579[14]  =    "Creative Labs";
char str_32155715[19]  =    "Sound Blaster MP3+";
char str_1068557351[15]  =    "Logitech, Inc.";
char str_158454992[18]  =    "QuickCam Pro 9000";
char str_233798669[7]  =    "Yamaha";
char str_11699988[6]  =    "UX256";
char str_202091287[7]  =    "MU1000";
char str_202098146[7]  =    "MU2000";
char str_10637825[6]  =    "MU500";
char str_11694111[6]  =    "UW500";
char str_201558875[7]  =    "MOTIF6";
char str_201558876[7]  =    "MOTIF7";
char str_201558877[7]  =    "MOTIF8";
char str_615920[5]  =    "UX96";
char str_615768[5]  =    "UX16";
char str_181728381[7]  =    "EOS BX";
char str_11554634[6]  =    "UC-MX";
char str_11554596[6]  =    "UC-KX";
char str_30931[4]  =    "S08";
char str_129785158[8]  =    "CLP-150";
char str_129785196[8]  =    "CLP-170";
char str_10753440[6]  =    "P-250";
char str_11588601[6]  =    "TYROS";
char str_207539138[7]  =    "PF-500";
char str_31094[4]  =    "S90";
char str_608393064[8]  =    "MOTIF-R";
char str_10530917[6]  =    "MDP-5";
char str_154546418[8]  =    "CVP-204";
char str_154546420[8]  =    "CVP-206";
char str_154546422[8]  =    "CVP-208";
char str_154546433[8]  =    "CVP-210";
char str_461878866[9]  =    "PSR-1100";
char str_461885725[9]  =    "PSR-2100";
char str_129785201[8]  =    "CLP-175";
char str_209484720[7]  =    "PSR-K1";
char str_182916092[7]  =    "EZ-J24";
char str_254016772[8]  =    "EZ-250i";
char str_405545197[11]  =    "MOTIF ES 6";
char str_405545198[11]  =    "MOTIF ES 7";
char str_405545199[11]  =    "MOTIF ES 8";
char str_154546776[8]  =    "CVP-301";
char str_154546778[8]  =    "CVP-303";
char str_154546780[8]  =    "CVP-305";
char str_154546782[8]  =    "CVP-307";
char str_154546784[8]  =    "CVP-309";
char str_1030557429[10]  =    "CVP-309GP";
char str_461880310[9]  =    "PSR-1500";
char str_461892223[9]  =    "PSR-3000";
char str_652131613[11]  =    "ELS-01/01C";
char str_556279697[12]  =    "PSR-295/293";
char str_85230465[12]  =    "DGX-205/203";
char str_165493744[8]  =    "DGX-305";
char str_165494466[8]  =    "DGX-505";
char str_9378607[6]  =    "DGP-7";
char str_9378605[6]  =    "DGP-5";
char str_490515[5]  =    "CS1D";
char str_9461004[6]  =    "DSP1D";
char str_9415899[6]  =    "DME32";
char str_178770687[7]  =    "DM2000";
char str_6629097[6]  =    "02R96";
char str_14089218[8]  =    "ACU16-C";
char str_635602341[8]  =    "NHB32-C";
char str_178763828[7]  =    "DM1000";
char str_6623682[6]  =    "01V96";
char str_893500057[8]  =    "SPX2000";
char str_577592[5]  =    "PM5D";
char str_178903280[7]  =    "DME64N";
char str_178901836[7]  =    "DME24N";
char str_26232[4]  =    "DTX";
char str_607981[5]  =    "UB99";
char str_218283728[7]  =    "Roland";
char str_219266584[7]  =    "UA-100";
char str_180244545[7]  =    "EDIROL";
char str_611719[5]  =    "UM-4";
char str_855751104[8]  =    "SC-8850";
char str_31596[4]  =    "U-8";
char str_611717[5]  =    "UM-2";
char str_855751047[8]  =    "SC-8820";
char str_207147453[7]  =    "PC-300";
char str_611716[5]  =    "UM-1";
char str_215619040[7]  =    "SK-500";
char str_214582020[7]  =    "SC-D70";
char str_607388[5]  =    "UA-5";
char str_64261101[8]  =    "XV-5050";
char str_220833115[7]  =    "UM-880";
char str_11300431[6]  =    "SD-90";
char str_10592645[6]  =    "MMP-2";
char str_947601669[8]  =    "V-SYNTH";
char str_220831975[7]  =    "UM-550";
char str_11540363[6]  =    "UA-20";
char str_11300298[6]  =    "SD-20";
char str_11300412[6]  =    "SD-80";
char str_219268750[7]  =    "UA-700";
char str_64240467[8]  =    "XV-2020";
char str_226407066[7]  =    "VariOS";
char str_30235[4]  =    "PCR";
char str_657602785[14]  =    "Digital Piano";
char str_482873[5]  =    "BOSS";
char str_9839312[6]  =    "GS-10";
char str_9770741[6]  =    "GI-20";
char str_11272957[6]  =    "RS-70";
char str_944839672[8]  =    "UA-1000";
char str_10915755[6]  =    "PCR-A";
char str_219267764[7]  =    "UA-3FX";
char str_220831141[7]  =    "UM-1SX";
char str_106136500[11]  =    "EXR Series";
char str_10915739[6]  =    "PCR-1";
char str_216271012[7]  =    "SP-606";
char str_335406018[9]  =    "FANTOM-X";
char str_11540368[6]  =    "UA-25";
char str_179391037[7]  =    "DR-880";
char str_219266585[7]  =    "UA-101";
char str_504327[5]  =    "G-70";
char str_10902533[6]  =    "PC-50";
char str_219267023[7]  =    "UA-1EX";
char str_220831597[7]  =    "UM-3EX";
char str_219268125[7]  =    "UA-4FX";
char str_199274370[7]  =    "Juno-G";
char str_215226995[7]  =    "SH-201";
char str_327960850[10]  =    "SonicCell";
char str_944848775[8]  =    "UA-25EX";
char str_686943043[9]  =    "Hercules";
char str_87930470[16]  =    "DJ Console (WE)";
char str_522043394[8]  =    "M-Audio";
char str_854499087[14]  =    "MidiSport 2x2";
char str_854498725[14]  =    "MidiSport 1x1";
char str_63622457[11]  =    "Keystation";
char str_854499811[14]  =    "MidiSport 4x4";
char str_854501259[14]  =    "MidiSport 8x8";
char str_854499089[14]  =    "MidiSport 2x4";
char str_892675406[8]  =    "Quattro";
char str_1005803972[11]  =    "AudioPhile";
char str_11174419[6]  =    "Ozone";
char str_35173879[11]  =    "OmniStudio";
char str_9440451[6]  =    "Casio";
char str_208320737[7]  =    "PL-40R";
char str_164490267[9]  =    "Keyboard";
char str_558343[5]  =    "MOTU";
char str_863125700[9]  =    "Fastlane";
char str_185760420[7]  =    "Emagic";
char str_677794626[9]  =    "TerraTec";
char str_981105601[9]  =    "PHASE 26";
char str_1015625071[9]  =    "Miditech";
char str_902805966[12]  =    "Play\'n Roll";
char str_984249857[8]  =    "Stanton";
char str_21158850[11]  =    "ScratchAmp";
char str_87817340[9]  =    "Novation";
char str_298493551[22]  =    "ReMOTE Audio/XStation";
char str_974799125[8]  =    "Speedio";
char str_941262301[9]  =    "ReMOTE25";
char str_599646[5]  =    "Rane";
char str_597637[5]  =    "SL-1";
char str_799096034[12]  =    "Midistart-2";
char str_496460573[14]  =    "snd-usb-audio";
char str_953588697[12]  =    "&subs->lock";
char str_569364926[10]  =    "USB Audio";
char str_351748476[14]  =    "USB Audio #%d";
char str_908632785[59]  =    "<6>%d:%u:%d : format type 0 is detected, processed as PCM\n";
char str_444495457[58]  =    "<6>%d:%u:%d : sample bitwidth %d in over sample bytes %d\n";
char str_1069376918[58]  =    "<6>%d:%u:%d : unsupported sample bitwidth %d in %d bytes\n";
char str_576734707[42]  =    "<6>%d:%u:%d : unsupported format type %d\n";
char str_1054178865[40]  =    "<3>%d:%u:%d : invalid FORMAT_TYPE desc\n";
char str_967653936[18]  =    "<3>cannot malloc\n";
char str_564233269[35]  =    "<3>%d:%u:%d : invalid channels %d\n";
char str_1039773507[72]  =    "<6>%d:%u:%d : unknown format tag 0x%x is detected.  processed as MPEG.\n";
char str_589782702[57]  =    "<6>found format II with max.bitrate = %d, frame size=%d\n";
char str_595175755[51]  =    "<6>%d:%u:%d : format type %d is not supported yet\n";
char str_882451506[47]  =    "<3>%d:%u:%d : AS_GENERAL descriptor not found\n";
char str_857529930[39]  =    "<3>%d:%u:%d : invalid AS_GENERAL desc\n";
char str_51703753[35]  =    "<3>%d:%u:%d : no FORMAT_TYPE desc\n";
char str_528878465[64]  =    "<4>%d:%u:%d : no or invalid class specific endpoint descriptor\n";
char str_677216733[38]  =    "<6>%d:%u:%d: add audio endpoint 0x%x\n";
char str_15231084[23]  =    "<3>cannot find HEADER\n";
char str_960860569[19]  =    "<3>invalid HEADER\n";
char str_496506222[30]  =    "<3>%d:%u:%d : does not exist\n";
char str_376161077[40]  =    "<6>%d:%d:%d: skipping, already claimed\n";
char str_706759643[45]  =    "<3>%d:%u:%d: cannot create sequencer device\n";
char str_698010430[50]  =    "<3>%d:%u:%d: skipping non-supported interface %d\n";
char str_667951693[44]  =    "<3>low speed audio streaming not supported\n";
char str_977636194[18]  =    "<3>cannot memdup\n";
char str_449190836[33]  =    "<3>cannot setup if %d: error %d\n";
char str_797487953[24]  =    "<3>unknown sample rate\n";
char str_1034644995[33]  =    "sending Extigy boot sequence...\n";
char str_747151802[32]  =    "error sending boot message: %d\n";
char str_159293978[30]  =    "error usb_get_descriptor: %d\n";
char str_679801322[35]  =    "error usb_reset_configuration: %d\n";
char str_600119615[35]  =    "extigy_boot: new boot length = %d\n";
char str_608431467[26]  =    "<3>invalid quirk type %d\n";
char str_698187463[11]  =    "%03d/%03d\n";
char str_412731004[11]  =    "%04x:%04x\n";
char str_305400396[7]  =    "usbbus";
char str_16073815[6]  =    "usbid";
char str_388213389[28]  =    "<3>unknown device speed %d\n";
char str_596491274[35]  =    "<3>cannot create card instance %d\n";
char str_601554213[10]  =    "USB-Audio";
char str_209941598[13]  =    "USB%04x:%04x";
char str_856339116[23]  =    "USB Device %#04x:%#04x";
char str_32[2]  =    " ";
char str_256741[5]  =    " at ";
char str_884756751[12]  =    ", low speed";
char str_410776958[13]  =    ", full speed";
char str_312951437[13]  =    ", high speed";
char str_496823950[15]  =    "%s Location 1\n";
char str_974276422[20]  =    "snd_usb_audio_probe";
char str_496823969[15]  =    "%s Location 2\n";
char str_496823988[15]  =    "%s Location 3\n";
char str_496824007[15]  =    "%s Location 4\n";
char str_496824026[15]  =    "%s Location 5\n";
char str_778694563[34]  =    "<3>no available usb audio device\n";
char str_496824045[15]  =    "%s Location 6\n";
char str_496824064[15]  =    "%s Location 7\n";
char str_496824083[15]  =    "%s Location 8\n";
char str_358300541[16]  =    "%s failure: %d\n";
char str_738260344[16]  =    "%s success: %d\n";
char str_21498367[19]  =    "%s Location ERROR\n";
char str_652565892[27]  =    "<4>invalid nrpacks value.\n";
char str_438695472[20]  =    "include/linux/usb.h";
char str_473127585[23]  =    "<3>usb_submit_urb: %d\n";
char str_843424035[18]  =    "<3>urb status %d\n";
char str_174936368[17]  =    "&ep->buffer_lock";
char str_316584895[11]  =    "%s Control";
char str_612180258[10]  =    "%s Part A";
char str_612180259[10]  =    "%s Part B";
char str_612180260[10]  =    "%s Part C";
char str_612180261[10]  =    "%s Part D";
char str_601293204[10]  =    "%s MIDI 1";
char str_601293205[10]  =    "%s MIDI 2";
char str_956433291[8]  =    "%s MIDI";
char str_93429168[17]  =    "%s External MIDI";
char str_956492597[8]  =    "%s Sync";
char str_295955[5]  =    "%s 1";
char str_295956[5]  =    "%s 2";
char str_601293220[10]  =    "%s MIDI A";
char str_601293221[10]  =    "%s MIDI B";
char str_125301167[13]  =    "%s Broadcast";
char str_687152508[11]  =    "%s MIDI %d";
char str_544751132[41]  =    "<6>created %d output and %d input ports\n";
char str_752941123[36]  =    "<6>MIDIStreaming version %02x.%02x\n";
char str_791573890[49]  =    "<4>MIDIStreaming interface descriptor not found\n";
char str_754636363[23]  =    "<4>too many endpoints\n";
char str_994182456[24]  =    "<6>EP %02X: %d jack(s)\n";
char str_974050335[43]  =    "<6>switching to altsetting %d with int ep\n";
char str_872419140[25]  =    "<3>not enough endpoints\n";
char str_349765498[32]  =    "<3>endpoint[0] isn\'t interrupt\n";
char str_1060371900[34]  =    "<3>endpoint[2] isn\'t bulk output\n";
char str_145470558[34]  =    "<3>endpoint[4] isn\'t bulk output\n";
char str_595159629[9]  =    "USB MIDI";
char str_427276364[18]  =    "&umidi->disc_lock";
char str_501945809[23]  =    "include/linux/kernel.h";
char str_968180269[13]  =    "PCM Playback";
char str_236948253[11]  =    "Digital In";
char str_65189559[14]  =    "Line Playback";
char str_508178660[13]  =    "Mic Playback";
char str_699349911[21]  =    "Capture Input Source";
char str_186466258[8]  =    "Capture";
char str_941834121[16]  =    "Channel Routing";
char str_336410471[20]  =    "Tone Control - Bass";
char str_158039148[22]  =    "Tone Control - Treble";
char str_1060912469[16]  =    "Master Playback";
char str_238177709[21]  =    "Digital Out Playback";
char str_62046100[22]  =    "Digital Out1 Playback";
char str_852258126[24]  =    "IEC958 Optical Playback";
char str_809021430[10]  =    "Mic Boost";
char str_948881558[13]  =    "Line Capture";
char str_3623250[20]  =    "Digital In Playback";
char str_960884417[20]  =    "What-U-Hear Capture";
char str_267488495[19]  =    "Digital In Capture";
char str_312378469[15]  =    "Capture Source";
char str_735532888[17]  =    "Speaker Playback";
char str_526151313[19]  =    "Digital Out Source";
char str_781461537[19]  =    "Headphone Playback";
char str_765604581[17]  =    "Headphone Source";
char str_561380[5]  =    "Line";
char str_840389807[12]  =    "What-U-Hear";
char str_9946673[6]  =    "Front";
char str_30230[4]  =    "PCM";
char str_609203[5]  =    "Side";
char str_11480405[12]  =    "Mic Capture";
char str_204133454[7]  =    "Master";
char str_403701822[18]  =    "IEC958 In Capture";
char str_211697793[7]  =    "Output";
char str_974774143[8]  =    "Speaker";
char str_442778450[10]  =    "Headphone";
char str_1073431585[10]  =    "HMD Audio";
char str_391949103[16]  =    "Desktop Speaker";
char str_785022198[13]  =    "Room Speaker";
char str_75719076[12]  =    "Com Speaker";
char str_28835[4]  =    "LFE";
char str_346970378[12]  =    "External In";
char str_217733085[10]  =    "Analog In";
char str_1004535908[10]  =    "Legacy In";
char str_181451660[10]  =    "IEC958 In";
char str_835963836[15]  =    "1394 DA Stream";
char str_279917523[15]  =    "1394 DV Stream";
char str_489702074[9]  =    "Embedded";
char str_629245061[13]  =    "Noise Source";
char str_694732782[19]  =    "Equalization Noise";
char str_1341[3]  =    "CD";
char str_25867[4]  =    "DAT";
char str_25888[4]  =    "DCC";
char str_1040058580[9]  =    "MiniDisk";
char str_218563518[12]  =    "Analog Tape";
char str_631087734[11]  =    "Phonograph";
char str_782488767[10]  =    "VCR Audio";
char str_803851448[17]  =    "Video Disk Audio";
char str_239825392[10]  =    "DVD Audio";
char str_317885218[15]  =    "TV Tuner Audio";
char str_812255493[20]  =    "Satellite Rec Audio";
char str_659772121[18]  =    "Cable Tuner Audio";
char str_411382038[10]  =    "DSS Audio";
char str_743645852[15]  =    "Radio Receiver";
char str_521161324[18]  =    "Radio Transmitter";
char str_883168199[21]  =    "Multi-Track Recorder";
char str_1055203368[12]  =    "Synthesizer";
char str_841139419[9]  =    "Selector";
char str_415308913[13]  =    "Process Unit";
char str_1042685215[9]  =    "Ext Unit";
char str_10800265[6]  =    "Mixer";
char str_1064537007[8]  =    "Unit %d";
char str_29891[4]  =    "Mic";
char str_429534546[8]  =    "Headset";
char str_11181278[6]  =    "Phone";
char str_572685[5]  =    "Mute";
char str_228195326[7]  =    "Volume";
char str_582837192[19]  =    "Tone Control - Mid";
char str_877389318[18]  =    "Graphic Equalizer";
char str_324299317[18]  =    "Auto Gain Control";
char str_790741568[14]  =    "Delay Control";
char str_924615310[11]  =    "Bass Boost";
char str_445429857[9]  =    "Loudness";
char str_0[1]  =    "";
char str_680563518[27]  =    "<3>cannot malloc kcontrol\n";
char str_532616561[11]  =    "Feature %d";
char str_873074482[9]  =    " Capture";
char str_772338763[10]  =    " Playback";
char str_653514840[8]  =    " Switch";
char str_659921694[8]  =    " Volume";
char str_88429757[20]  =    "PCM Playback Volume";
char str_647061483[57]  =    "<6>using volume control quirk for the UDA1321/N101 chip\n";
char str_758343632[55]  =    "<3>usbaudio: unit %u: invalid FEATURE_UNIT descriptor\n";
char str_1028937[16]  =    "Mixer Source %d";
char str_757471119[37]  =    "<3>invalid MIXER UNIT descriptor %d\n";
char str_221788472[7]  =    "Switch";
char str_923436265[12]  =    "Mode Select";
char str_225760646[13]  =    "Spaciousness";
char str_10641780[6]  =    "Level";
char str_616233[5]  =    "Time";
char str_9595539[6]  =    "Delay";
char str_599760[5]  =    "Rate";
char str_9597327[6]  =    "Depth";
char str_11395627[6]  =    "Ratio";
char str_657372624[8]  =    "Max Amp";
char str_497625127[10]  =    "Threshold";
char str_229836041[12]  =    "Attack Time";
char str_96862090[13]  =    "Release Time";
char str_1059676627[8]  =    "Up Down";
char str_468492697[15]  =    "Dolby Prologic";
char str_168675912[19]  =    "3D Stereo Extender";
char str_217050626[7]  =    "Reverb";
char str_180256858[7]  =    "Chorus";
char str_25903[4]  =    "DCR";
char str_981956828[34]  =    "<3>invalid %s descriptor (id %d)\n";
char str_870290969[16]  =    "Processing Unit";
char str_400614853[15]  =    "Extension Unit";
char str_761039825[40]  =    "<3>invalid SELECTOR UNIT descriptor %d\n";
char str_927843941[9]  =    "Input %d";
char str_32328[4]  =    "USB";
char str_983984005[16]  =    " Capture Source";
char str_508915848[17]  =    " Playback Source";
char str_709717790[33]  =    "<3>usbaudio: unit %d not found!\n";
char str_133922991[46]  =    "<3>usbaudio: unit %u: unexpected type 0x%02x\n";
char str_238745560[18]  =    "SB remote control";
char str_459503637[18]  =    "%s remote control";
char str_934616211[16]  =    "CMSS LED Switch";
char str_298606004[17]  =    "Power LED Switch";
char str_550941773[25]  =    "Dolby Digital LED Switch";
char str_683293777[8]  =    "dig in ";
char str_1061019973[8]  =    "line in";
char str_333096528[8]  =    "spk out";
char str_888942698[8]  =    "hph out";
char str_806837355[8]  =    "RC     ";
char str_1041470126[11]  =    "%s jacks\n\n";
char str_296432[5]  =    "%s: ";
char str_708091878[11]  =    "%02x %02x\n";
char str_1207[3]  =    "?\n";
char str_570853617[10]  =    "USB Mixer";
char str_325836133[10]  =    "audigy2nx";

void  heapifyfree (void *);
void* heapifymalloc (size_t); 
  
//#line  5 "usb-audio.merged.sym.c"
typedef signed char __s8;
//#line  7 "usb-audio.merged.sym.c"
typedef unsigned char __u8;
//#line  9 "usb-audio.merged.sym.c"
typedef short __s16;
//#line  11 "usb-audio.merged.sym.c"
typedef unsigned short __u16;
//#line  13 "usb-audio.merged.sym.c"
typedef int __s32;
//#line  15 "usb-audio.merged.sym.c"
typedef unsigned int __u32;
//#line  17 "usb-audio.merged.sym.c"
typedef long long __s64;
//#line  19 "usb-audio.merged.sym.c"
typedef unsigned long long __u64;
//#line  21 "usb-audio.merged.sym.c"
typedef signed char s8;
//#line  23 "usb-audio.merged.sym.c"
typedef unsigned char u8;
//#line  25 "usb-audio.merged.sym.c"
typedef unsigned short u16;
//#line  27 "usb-audio.merged.sym.c"
typedef unsigned int u32;
//#line  29 "usb-audio.merged.sym.c"
typedef long long s64;
//#line  31 "usb-audio.merged.sym.c"
typedef unsigned long long u64;
//#line  33 "usb-audio.merged.sym.c"
typedef unsigned short umode_t;
//#line  35 "usb-audio.merged.sym.c"
typedef u64 dma_addr_t;
//#line  37 "usb-audio.merged.sym.c"
typedef unsigned int __kernel_mode_t;
//#line  39 "usb-audio.merged.sym.c"
typedef unsigned long __kernel_nlink_t;
//#line  41 "usb-audio.merged.sym.c"
typedef long __kernel_off_t;
//#line  43 "usb-audio.merged.sym.c"
typedef int __kernel_pid_t;
//#line  45 "usb-audio.merged.sym.c"
typedef unsigned int __kernel_uid_t;
//#line  47 "usb-audio.merged.sym.c"
typedef unsigned int __kernel_gid_t;
//#line  49 "usb-audio.merged.sym.c"
typedef unsigned long __kernel_size_t;
//#line  51 "usb-audio.merged.sym.c"
typedef long __kernel_ssize_t;
//#line  53 "usb-audio.merged.sym.c"
typedef long __kernel_time_t;
//#line  55 "usb-audio.merged.sym.c"
typedef long __kernel_clock_t;
//#line  57 "usb-audio.merged.sym.c"
typedef int __kernel_timer_t;
//#line  59 "usb-audio.merged.sym.c"
typedef int __kernel_clockid_t;
//#line  61 "usb-audio.merged.sym.c"
typedef long long __kernel_loff_t;
//#line  63 "usb-audio.merged.sym.c"
typedef __kernel_uid_t __kernel_uid32_t;
//#line  65 "usb-audio.merged.sym.c"
typedef __kernel_gid_t __kernel_gid32_t;
//#line  67 "usb-audio.merged.sym.c"
typedef __u32 __kernel_dev_t;
//#line  69 "usb-audio.merged.sym.c"
typedef __kernel_dev_t dev_t;
//#line  71 "usb-audio.merged.sym.c"
typedef __kernel_mode_t mode_t;
//#line  73 "usb-audio.merged.sym.c"
typedef __kernel_nlink_t nlink_t;
//#line  75 "usb-audio.merged.sym.c"
typedef __kernel_off_t off_t;
//#line  77 "usb-audio.merged.sym.c"
typedef __kernel_pid_t pid_t;
//#line  79 "usb-audio.merged.sym.c"
typedef __kernel_timer_t timer_t;
//#line  81 "usb-audio.merged.sym.c"
typedef __kernel_clockid_t clockid_t;
//#line  83 "usb-audio.merged.sym.c"
typedef __kernel_uid32_t uid_t;
//#line  85 "usb-audio.merged.sym.c"
typedef __kernel_gid32_t gid_t;
//#line  87 "usb-audio.merged.sym.c"
typedef __kernel_loff_t loff_t;
//#line  89 "usb-audio.merged.sym.c"
typedef __kernel_size_t size_t;
//#line  91 "usb-audio.merged.sym.c"
typedef __kernel_ssize_t ssize_t;
//#line  93 "usb-audio.merged.sym.c"
typedef __kernel_time_t time_t;
//#line  95 "usb-audio.merged.sym.c"
typedef __kernel_clock_t clock_t;
//#line  97 "usb-audio.merged.sym.c"
typedef __s8 int8_t;
//#line  99 "usb-audio.merged.sym.c"
typedef __s16 int16_t;
//#line  101 "usb-audio.merged.sym.c"
typedef __u32 u_int32_t;
//#line  103 "usb-audio.merged.sym.c"
typedef __s32 int32_t;
//#line  105 "usb-audio.merged.sym.c"
typedef __u8 uint8_t;
//#line  107 "usb-audio.merged.sym.c"
typedef __u16 uint16_t;
//#line  109 "usb-audio.merged.sym.c"
typedef __u32 uint32_t;
//#line  111 "usb-audio.merged.sym.c"
typedef unsigned long sector_t;
//#line  113 "usb-audio.merged.sym.c"
typedef unsigned long blkcnt_t;
//#line  115 "usb-audio.merged.sym.c"
typedef __u16 __le16;
//#line  117 "usb-audio.merged.sym.c"
typedef unsigned int gfp_t;
//#line  119 "usb-audio.merged.sym.c"
typedef unsigned int fmode_t;
//#line  121 "usb-audio.merged.sym.c"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
//#line  125 "usb-audio.merged.sym.c"
typedef struct __anonstruct_atomic_t_7 atomic_t;
//#line  127 "usb-audio.merged.sym.c"
struct __anonstruct_atomic64_t_8 {
   long volatile   counter ;
};
//#line  131 "usb-audio.merged.sym.c"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
//#line  133
struct module;
struct module;
//#line  135
struct task_struct;
struct task_struct;
//#line  137
struct mm_struct;
struct mm_struct;
//#line  139 "usb-audio.merged.sym.c"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
//#line  163 "usb-audio.merged.sym.c"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
//#line  175 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_9 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
//#line  180 "usb-audio.merged.sym.c"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_9 __annonCompField4 ;
};
//#line  185 "usb-audio.merged.sym.c"
typedef __builtin_va_list __gnuc_va_list;
//#line  187 "usb-audio.merged.sym.c"
typedef __gnuc_va_list va_list;
//#line  189 "usb-audio.merged.sym.c"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
//#line  196
struct completion;
struct completion;
//#line  198
struct pid;
struct pid;
//#line  200 "usb-audio.merged.sym.c"
typedef unsigned long pgdval_t;
//#line  202 "usb-audio.merged.sym.c"
typedef unsigned long pgprotval_t;
//#line  204
struct page;
struct page;
//#line  206 "usb-audio.merged.sym.c"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
//#line  210 "usb-audio.merged.sym.c"
typedef struct __anonstruct_pgd_t_13 pgd_t;
//#line  212 "usb-audio.merged.sym.c"
struct __anonstruct_pgprot_t_14 {
   pgprotval_t pgprot ;
};
//#line  216 "usb-audio.merged.sym.c"
typedef struct __anonstruct_pgprot_t_14 pgprot_t;
//#line  218 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_18 {
   unsigned int a ;
   unsigned int b ;
};
//#line  223 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_19 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
//#line  239 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_17 {
   struct __anonstruct____missing_field_name_18 __annonCompField6 ;
   struct __anonstruct____missing_field_name_19 __annonCompField7 ;
};
//#line  244 "usb-audio.merged.sym.c"
struct desc_struct {
   union __anonunion____missing_field_name_17 __annonCompField8 ;
} __attribute__((__packed__)) ;
//#line  248
struct ds_context;
struct ds_context;
//#line  250
struct bts_tracer;
struct bts_tracer;
//#line  252
struct exec_domain;
struct exec_domain;
//#line  254
struct map_segment;
struct map_segment;
//#line  256 "usb-audio.merged.sym.c"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
//#line  271 "usb-audio.merged.sym.c"
struct cpumask {
   unsigned long bits[((255UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
//#line  275 "usb-audio.merged.sym.c"
typedef struct cpumask cpumask_t;
//#line  277
struct thread_struct;
struct thread_struct;
//#line  279 "usb-audio.merged.sym.c"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
//#line  291 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_28 {
   u64 rip ;
   u64 rdp ;
};
//#line  296 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_29 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
//#line  303 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_27 {
   struct __anonstruct____missing_field_name_28 __annonCompField9 ;
   struct __anonstruct____missing_field_name_29 __annonCompField10 ;
};
//#line  308 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_30 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
//#line  313 "usb-audio.merged.sym.c"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_27 __annonCompField11 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_30 __annonCompField12 ;
} __attribute__((__aligned__(16))) ;
//#line  327 "usb-audio.merged.sym.c"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
//#line  346 "usb-audio.merged.sym.c"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
//#line  352 "usb-audio.merged.sym.c"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
} __attribute__((__packed__, __aligned__(64))) ;
//#line  357 "usb-audio.merged.sym.c"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
//#line  364
struct kmem_cache;
struct kmem_cache;
//#line  366 "usb-audio.merged.sym.c"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   struct ds_context *ds_ctx ;
   unsigned int bts_ovfl_signal ;
};
//#line  396 "usb-audio.merged.sym.c"
struct __anonstruct_mm_segment_t_31 {
   unsigned long seg ;
};
//#line  400 "usb-audio.merged.sym.c"
typedef struct __anonstruct_mm_segment_t_31 mm_segment_t;
//#line  402 "usb-audio.merged.sym.c"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
//#line  407
struct hlist_node;
struct hlist_node;
//#line  409 "usb-audio.merged.sym.c"
struct hlist_head {
   struct hlist_node *first ;
};
//#line  413 "usb-audio.merged.sym.c"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
//#line  418
struct timespec;
struct timespec;
//#line  420
struct compat_timespec;
struct compat_timespec;
//#line  422 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_33 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
//#line  429 "usb-audio.merged.sym.c"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
//#line  437 "usb-audio.merged.sym.c"
struct __anonstruct_nanosleep_35 {
   clockid_t index ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
//#line  444
struct pollfd;
struct pollfd;
//#line  446 "usb-audio.merged.sym.c"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
//#line  454 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_32 {
   struct __anonstruct____missing_field_name_33 __annonCompField13 ;
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
//#line  461 "usb-audio.merged.sym.c"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField14 ;
};
//#line  466 "usb-audio.merged.sym.c"
typedef atomic64_t atomic_long_t;
//#line  468 "usb-audio.merged.sym.c"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
};
//#line  480 "usb-audio.merged.sym.c"
struct raw_spinlock {
   unsigned int slock ;
};
//#line  484 "usb-audio.merged.sym.c"
typedef struct raw_spinlock raw_spinlock_t;
//#line  486 "usb-audio.merged.sym.c"
struct __anonstruct_raw_rwlock_t_37 {
   unsigned int lock ;
};
//#line  490 "usb-audio.merged.sym.c"
typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
//#line  492
struct lockdep_map;
struct lockdep_map;
//#line  494 "usb-audio.merged.sym.c"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
//#line  501 "usb-audio.merged.sym.c"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
//#line  505 "usb-audio.merged.sym.c"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
//#line  509 "usb-audio.merged.sym.c"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[9] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
};
//#line  525 "usb-audio.merged.sym.c"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache ;
   char const   *name ;
};
//#line  531 "usb-audio.merged.sym.c"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
};
//#line  544 "usb-audio.merged.sym.c"
struct __anonstruct_spinlock_t_38 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  552 "usb-audio.merged.sym.c"
typedef struct __anonstruct_spinlock_t_38 spinlock_t;
//#line  554 "usb-audio.merged.sym.c"
struct __anonstruct_rwlock_t_39 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  562 "usb-audio.merged.sym.c"
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
//#line  564
struct __wait_queue;
struct __wait_queue;
//#line  566 "usb-audio.merged.sym.c"
typedef struct __wait_queue wait_queue_t;
//#line  568 "usb-audio.merged.sym.c"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
//#line  575 "usb-audio.merged.sym.c"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
//#line  580 "usb-audio.merged.sym.c"
typedef struct __wait_queue_head wait_queue_head_t;
//#line  582 "usb-audio.merged.sym.c"
struct __anonstruct_nodemask_t_41 {
   unsigned long bits[(((unsigned long )(1 << 6) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
//#line  586 "usb-audio.merged.sym.c"
typedef struct __anonstruct_nodemask_t_41 nodemask_t;
//#line  588 "usb-audio.merged.sym.c"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
//#line  598 "usb-audio.merged.sym.c"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct mutex *lock ;
   void *magic ;
};
//#line  605
struct rw_semaphore;
struct rw_semaphore;
//#line  607 "usb-audio.merged.sym.c"
struct rw_semaphore {
   __s32 activity ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
//#line  614
struct file;
struct file;
//#line  616
struct device;
struct device;
//#line  618 "usb-audio.merged.sym.c"
struct pm_message {
   int event ;
};
//#line  622 "usb-audio.merged.sym.c"
typedef struct pm_message pm_message_t;
//#line  624 "usb-audio.merged.sym.c"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
//#line  641
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
//#line  651 "usb-audio.merged.sym.c"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
//#line  659 "usb-audio.merged.sym.c"
struct __anonstruct_mm_context_t_90 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
//#line  666 "usb-audio.merged.sym.c"
typedef struct __anonstruct_mm_context_t_90 mm_context_t;
//#line  668
struct vm_area_struct;
struct vm_area_struct;
//#line  670 "usb-audio.merged.sym.c"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
//#line  675 "usb-audio.merged.sym.c"
union ktime {
   s64 tv64 ;
};
//#line  679 "usb-audio.merged.sym.c"
typedef union ktime ktime_t;
//#line  681
struct tvec_base;
struct tvec_base;
//#line  683 "usb-audio.merged.sym.c"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   void *data ;
   struct tvec_base *base ;
};
//#line  691
struct hrtimer;
struct hrtimer;
//#line  693
enum hrtimer_restart;
enum hrtimer_restart;
//#line  695
struct work_struct;
struct work_struct;
//#line  697 "usb-audio.merged.sym.c"
struct work_struct {
   atomic_long_t data ;
   struct list_head entry ;
   void (*func)(struct work_struct *work ) ;
   struct lockdep_map lockdep_map ;
};
//#line  704 "usb-audio.merged.sym.c"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
//#line  709
struct kobject;
struct kobject;
//#line  711 "usb-audio.merged.sym.c"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
//#line  717 "usb-audio.merged.sym.c"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
//#line  723 "usb-audio.merged.sym.c"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
//#line  728
struct sysfs_dirent;
struct sysfs_dirent;
//#line  730 "usb-audio.merged.sym.c"
struct kref {
   atomic_t refcount ;
};
//#line  734
struct kset;
struct kset;
//#line  736
struct kobj_type;
struct kobj_type;
//#line  738 "usb-audio.merged.sym.c"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
//#line  752 "usb-audio.merged.sym.c"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
//#line  758 "usb-audio.merged.sym.c"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
//#line  765 "usb-audio.merged.sym.c"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
//#line  771 "usb-audio.merged.sym.c"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
//#line  778 "usb-audio.merged.sym.c"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
//#line  786 "usb-audio.merged.sym.c"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
//#line  796 "usb-audio.merged.sym.c"
struct kmem_cache_order_objects {
   unsigned long x ;
};
//#line  800 "usb-audio.merged.sym.c"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[255] ;
};
//#line  822
struct snd_usb_audio_quirk;
struct snd_usb_audio_quirk;
//#line  824 "usb-audio.merged.sym.c"
struct usb_device_id {
   __u16 match_flags ;
   __u16 idVendor ;
   __u16 idProduct ;
   __u16 bcdDevice_lo ;
   __u16 bcdDevice_hi ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   struct snd_usb_audio_quirk *driver_info ;
};
//#line  839 "usb-audio.merged.sym.c"
struct usb_device_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 bcdUSB ;
   __u8 bDeviceClass ;
   __u8 bDeviceSubClass ;
   __u8 bDeviceProtocol ;
   __u8 bMaxPacketSize0 ;
   __le16 idVendor ;
   __le16 idProduct ;
   __le16 bcdDevice ;
   __u8 iManufacturer ;
   __u8 iProduct ;
   __u8 iSerialNumber ;
   __u8 bNumConfigurations ;
} __attribute__((__packed__)) ;
//#line  856 "usb-audio.merged.sym.c"
struct usb_config_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __le16 wTotalLength ;
   __u8 bNumInterfaces ;
   __u8 bConfigurationValue ;
   __u8 iConfiguration ;
   __u8 bmAttributes ;
   __u8 bMaxPower ;
} __attribute__((__packed__)) ;
//#line  867 "usb-audio.merged.sym.c"
struct usb_interface_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bInterfaceNumber ;
   __u8 bAlternateSetting ;
   __u8 bNumEndpoints ;
   __u8 bInterfaceClass ;
   __u8 bInterfaceSubClass ;
   __u8 bInterfaceProtocol ;
   __u8 iInterface ;
} __attribute__((__packed__)) ;
//#line  879 "usb-audio.merged.sym.c"
struct usb_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bEndpointAddress ;
   __u8 bmAttributes ;
   __le16 wMaxPacketSize ;
   __u8 bInterval ;
   __u8 bRefresh ;
   __u8 bSynchAddress ;
} __attribute__((__packed__)) ;
//#line  890 "usb-audio.merged.sym.c"
struct usb_interface_assoc_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bFirstInterface ;
   __u8 bInterfaceCount ;
   __u8 bFunctionClass ;
   __u8 bFunctionSubClass ;
   __u8 bFunctionProtocol ;
   __u8 iFunction ;
} __attribute__((__packed__)) ;
//#line  901
enum usb_device_speed {
    USB_SPEED_UNKNOWN = 0,
    USB_SPEED_LOW = 1,
    USB_SPEED_FULL = 2,
    USB_SPEED_HIGH = 3,
    USB_SPEED_VARIABLE = 4
} ;
//#line  909
enum usb_device_state {
    USB_STATE_NOTATTACHED = 0,
    USB_STATE_ATTACHED = 1,
    USB_STATE_POWERED = 2,
    USB_STATE_UNAUTHENTICATED = 3,
    USB_STATE_RECONNECTING = 4,
    USB_STATE_DEFAULT = 5,
    USB_STATE_ADDRESS = 6,
    USB_STATE_CONFIGURED = 7,
    USB_STATE_SUSPENDED = 8
} ;
//#line  921 "usb-audio.merged.sym.c"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
//#line  925 "usb-audio.merged.sym.c"
typedef struct kernel_cap_struct kernel_cap_t;
//#line  927
struct dentry;
struct dentry;
//#line  929 "usb-audio.merged.sym.c"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  935 "usb-audio.merged.sym.c"
struct rb_root {
   struct rb_node *rb_node ;
};
//#line  939
struct prio_tree_node;
struct prio_tree_node;
//#line  941 "usb-audio.merged.sym.c"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
//#line  947 "usb-audio.merged.sym.c"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
//#line  955 "usb-audio.merged.sym.c"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
//#line  961 "usb-audio.merged.sym.c"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
//#line  966
struct address_space;
struct address_space;
//#line  968 "usb-audio.merged.sym.c"
typedef atomic_long_t mm_counter_t;
//#line  970 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_99 {
   u16 inuse ;
   u16 objects ;
};
//#line  975 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_98 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_99 __annonCompField15 ;
};
//#line  980 "usb-audio.merged.sym.c"
struct __anonstruct____missing_field_name_101 {
   unsigned long private ;
   struct address_space *mapping ;
};
//#line  985 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_100 {
   struct __anonstruct____missing_field_name_101 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
//#line  992 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_102 {
   unsigned long index ;
   void *freelist ;
};
//#line  997 "usb-audio.merged.sym.c"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_98 __annonCompField16 ;
   union __anonunion____missing_field_name_100 __annonCompField18 ;
   union __anonunion____missing_field_name_102 __annonCompField19 ;
   struct list_head lru ;
};
//#line  1006 "usb-audio.merged.sym.c"
struct __anonstruct_vm_set_104 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
//#line  1012 "usb-audio.merged.sym.c"
union __anonunion_shared_103 {
   struct __anonstruct_vm_set_104 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
//#line  1017
struct anon_vma;
struct anon_vma;
//#line  1019
struct vm_operations_struct;
struct vm_operations_struct;
//#line  1021
struct mempolicy;
struct mempolicy;
//#line  1023 "usb-audio.merged.sym.c"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_103 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
//#line  1042 "usb-audio.merged.sym.c"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
//#line  1047 "usb-audio.merged.sym.c"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
//#line  1053 "usb-audio.merged.sym.c"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
//#line  1108 "usb-audio.merged.sym.c"
typedef unsigned long cputime_t;
//#line  1110 "usb-audio.merged.sym.c"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
//#line  1115
struct sem_undo_list;
struct sem_undo_list;
//#line  1117 "usb-audio.merged.sym.c"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
//#line  1123 "usb-audio.merged.sym.c"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
//#line  1127
struct siginfo;
struct siginfo;
//#line  1129 "usb-audio.merged.sym.c"
struct __anonstruct_sigset_t_105 {
   unsigned long sig[1] ;
};
//#line  1133 "usb-audio.merged.sym.c"
typedef struct __anonstruct_sigset_t_105 sigset_t;
//#line  1135 "usb-audio.merged.sym.c"
typedef void __signalfn_t(int  );
//#line  1137 "usb-audio.merged.sym.c"
typedef __signalfn_t *__sighandler_t;
//#line  1139 "usb-audio.merged.sym.c"
typedef void __restorefn_t(void);
//#line  1141 "usb-audio.merged.sym.c"
typedef __restorefn_t *__sigrestore_t;
//#line  1143 "usb-audio.merged.sym.c"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
//#line  1150 "usb-audio.merged.sym.c"
struct k_sigaction {
   struct sigaction sa ;
};
//#line  1154 "usb-audio.merged.sym.c"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
//#line  1159 "usb-audio.merged.sym.c"
typedef union sigval sigval_t;
//#line  1161 "usb-audio.merged.sym.c"
struct __anonstruct__kill_107 {
   pid_t _pid ;
   uid_t _uid ;
};
//#line  1166 "usb-audio.merged.sym.c"
struct __anonstruct__timer_108 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
//#line  1174 "usb-audio.merged.sym.c"
struct __anonstruct__rt_109 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
//#line  1180 "usb-audio.merged.sym.c"
struct __anonstruct__sigchld_110 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
//#line  1188 "usb-audio.merged.sym.c"
struct __anonstruct__sigfault_111 {
   void *_addr ;
};
//#line  1192 "usb-audio.merged.sym.c"
struct __anonstruct__sigpoll_112 {
   long _band ;
   int _fd ;
};
//#line  1197 "usb-audio.merged.sym.c"
union __anonunion__sifields_106 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_107 _kill ;
   struct __anonstruct__timer_108 _timer ;
   struct __anonstruct__rt_109 _rt ;
   struct __anonstruct__sigchld_110 _sigchld ;
   struct __anonstruct__sigfault_111 _sigfault ;
   struct __anonstruct__sigpoll_112 _sigpoll ;
};
//#line  1207 "usb-audio.merged.sym.c"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_106 _sifields ;
};
//#line  1214 "usb-audio.merged.sym.c"
typedef struct siginfo siginfo_t;
//#line  1216
struct user_struct;
struct user_struct;
//#line  1218 "usb-audio.merged.sym.c"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
//#line  1223
struct vfsmount;
struct vfsmount;
//#line  1225 "usb-audio.merged.sym.c"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
//#line  1230 "usb-audio.merged.sym.c"
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct path root ;
   struct path pwd ;
};
//#line  1238
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
//#line  1245
struct pid_namespace;
struct pid_namespace;
//#line  1247 "usb-audio.merged.sym.c"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
//#line  1253 "usb-audio.merged.sym.c"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
//#line  1261 "usb-audio.merged.sym.c"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
//#line  1266 "usb-audio.merged.sym.c"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
//#line  1273 "usb-audio.merged.sym.c"
struct __anonstruct_seccomp_t_115 {

};
//#line  1277 "usb-audio.merged.sym.c"
typedef struct __anonstruct_seccomp_t_115 seccomp_t;
//#line  1279 "usb-audio.merged.sym.c"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
   spinlock_t *lock ;
};
//#line  1285
struct rt_mutex_waiter;
struct rt_mutex_waiter;
//#line  1287 "usb-audio.merged.sym.c"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
//#line  1292
struct hrtimer_clock_base;
struct hrtimer_clock_base;
//#line  1294
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
//#line  1296
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
//#line  1301 "usb-audio.merged.sym.c"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
};
//#line  1311 "usb-audio.merged.sym.c"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
};
//#line  1321 "usb-audio.merged.sym.c"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
};
//#line  1326 "usb-audio.merged.sym.c"
struct task_io_accounting {

};
//#line  1330 "usb-audio.merged.sym.c"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
//#line  1337
struct nsproxy;
struct nsproxy;
//#line  1339 "usb-audio.merged.sym.c"
typedef int32_t key_serial_t;
//#line  1341 "usb-audio.merged.sym.c"
typedef uint32_t key_perm_t;
//#line  1343
struct key;
struct key;
//#line  1345
struct seq_file;
struct seq_file;
//#line  1347
struct signal_struct;
struct signal_struct;
//#line  1349
struct cred;
struct cred;
//#line  1351
struct key_type;
struct key_type;
//#line  1353
struct keyring_list;
struct keyring_list;
//#line  1355
struct key_user;
struct key_user;
//#line  1357 "usb-audio.merged.sym.c"
union __anonunion_type_data_170 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
//#line  1363 "usb-audio.merged.sym.c"
union __anonunion_payload_171 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
//#line  1369 "usb-audio.merged.sym.c"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_170 type_data ;
   union __anonunion_payload_171 payload ;
};
//#line  1389
struct inode;
struct inode;
//#line  1391 "usb-audio.merged.sym.c"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
//#line  1399 "usb-audio.merged.sym.c"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
//#line  1408 "usb-audio.merged.sym.c"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
//#line  1433
struct futex_pi_state;
struct futex_pi_state;
//#line  1435
struct robust_list_head;
struct robust_list_head;
//#line  1437
struct bio;
struct bio;
//#line  1439
struct user_namespace;
struct user_namespace;
//#line  1441 "usb-audio.merged.sym.c"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
//#line  1448 "usb-audio.merged.sym.c"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
//#line  1453
struct kioctx;
struct kioctx;
//#line  1455 "usb-audio.merged.sym.c"
union __anonunion_ki_obj_173 {
   void *user ;
   struct task_struct *tsk ;
};
//#line  1460 "usb-audio.merged.sym.c"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_173 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
//#line  1487 "usb-audio.merged.sym.c"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
//#line  1498 "usb-audio.merged.sym.c"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
//#line  1515 "usb-audio.merged.sym.c"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
//#line  1522 "usb-audio.merged.sym.c"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
//#line  1532 "usb-audio.merged.sym.c"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
//#line  1538 "usb-audio.merged.sym.c"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
//#line  1544 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_174 {
   pid_t pgrp  __attribute__((__deprecated__)) ;
   pid_t __pgrp ;
};
//#line  1549 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_175 {
   pid_t session  __attribute__((__deprecated__)) ;
   pid_t __session ;
};
//#line  1554
struct tty_struct;
struct tty_struct;
//#line  1556
struct taskstats;
struct taskstats;
//#line  1558
struct tty_audit_buf;
struct tty_audit_buf;
//#line  1560 "usb-audio.merged.sym.c"
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   union __anonunion____missing_field_name_174 __annonCompField20 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_175 __annonCompField21 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
//#line  1614 "usb-audio.merged.sym.c"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
//#line  1631
struct backing_dev_info;
struct backing_dev_info;
//#line  1633
struct reclaim_state;
struct reclaim_state;
//#line  1635 "usb-audio.merged.sym.c"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
//#line  1643 "usb-audio.merged.sym.c"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
//#line  1658
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
//#line  1665 "usb-audio.merged.sym.c"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
//#line  1672
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
//#line  1682 "usb-audio.merged.sym.c"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   char *name ;
   unsigned long span[] ;
};
//#line  1726
struct io_context;
struct io_context;
//#line  1728
struct audit_context;
struct audit_context;
//#line  1730
struct pipe_inode_info;
struct pipe_inode_info;
//#line  1732
struct rq;
struct rq;
//#line  1734 "usb-audio.merged.sym.c"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
};
//#line  1763 "usb-audio.merged.sym.c"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
//#line  1768 "usb-audio.merged.sym.c"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
//#line  1808 "usb-audio.merged.sym.c"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
//#line  1816
struct linux_binfmt;
struct linux_binfmt;
//#line  1818
struct files_struct;
struct files_struct;
//#line  1820
struct compat_robust_list_head;
struct compat_robust_list_head;
//#line  1822 "usb-audio.merged.sym.c"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct bts_tracer *bts ;
   void *bts_buffer ;
   size_t bts_size ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_timestamp ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48UL] ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mempolicy *mempolicy ;
   short il_next ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
//#line  1952
struct proc_dir_entry;
struct proc_dir_entry;
//#line  1954
struct klist_node;
struct klist_node;
//#line  1956 "usb-audio.merged.sym.c"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
//#line  1963 "usb-audio.merged.sym.c"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
//#line  1969 "usb-audio.merged.sym.c"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
//#line  1985 "usb-audio.merged.sym.c"
typedef __u64 Elf64_Addr;
//#line  1987 "usb-audio.merged.sym.c"
typedef __u16 Elf64_Half;
//#line  1989 "usb-audio.merged.sym.c"
typedef __u32 Elf64_Word;
//#line  1991 "usb-audio.merged.sym.c"
typedef __u64 Elf64_Xword;
//#line  1993 "usb-audio.merged.sym.c"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
//#line  2002 "usb-audio.merged.sym.c"
typedef struct elf64_sym Elf64_Sym;
//#line  2004
struct kernel_param;
struct kernel_param;
//#line  2006
struct kparam_string;
struct kparam_string;
//#line  2008
struct kparam_array;
struct kparam_array;
//#line  2010 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_182 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
//#line  2016 "usb-audio.merged.sym.c"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_182 __annonCompField22 ;
};
//#line  2024 "usb-audio.merged.sym.c"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
//#line  2029 "usb-audio.merged.sym.c"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
//#line  2038
struct marker;
struct marker;
//#line  2040 "usb-audio.merged.sym.c"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
//#line  2043 "usb-audio.merged.sym.c"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
//#line  2048 "usb-audio.merged.sym.c"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
//#line  2060
struct tracepoint;
struct tracepoint;
//#line  2062 "usb-audio.merged.sym.c"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
//#line  2068 "usb-audio.merged.sym.c"
struct mod_arch_specific {

};
//#line  2072 "usb-audio.merged.sym.c"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
//#line  2077 "usb-audio.merged.sym.c"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
//#line  2087
struct module_param_attrs;
struct module_param_attrs;
//#line  2089 "usb-audio.merged.sym.c"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
//#line  2096
struct exception_table_entry;
struct exception_table_entry;
//#line  2098
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
//#line  2104
struct module_sect_attrs;
struct module_sect_attrs;
//#line  2106
struct module_notes_attrs;
struct module_notes_attrs;
//#line  2108 "usb-audio.merged.sym.c"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
//#line  2157
struct device_driver;
struct device_driver;
//#line  2159 "usb-audio.merged.sym.c"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
//#line  2165
struct dma_mapping_ops;
struct dma_mapping_ops;
//#line  2167 "usb-audio.merged.sym.c"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_mapping_ops *dma_ops ;
   void *iommu ;
};
//#line  2173
struct driver_private;
struct driver_private;
//#line  2175
struct class;
struct class;
//#line  2177
struct class_private;
struct class_private;
//#line  2179
struct bus_type;
struct bus_type;
//#line  2181
struct bus_type_private;
struct bus_type_private;
//#line  2183 "usb-audio.merged.sym.c"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
//#line  2189
struct device_attribute;
struct device_attribute;
//#line  2191
struct driver_attribute;
struct driver_attribute;
//#line  2193 "usb-audio.merged.sym.c"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
//#line  2211 "usb-audio.merged.sym.c"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
//#line  2226 "usb-audio.merged.sym.c"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
//#line  2232
struct class_attribute;
struct class_attribute;
//#line  2234 "usb-audio.merged.sym.c"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
//#line  2249
struct device_type;
struct device_type;
//#line  2251 "usb-audio.merged.sym.c"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
//#line  2257 "usb-audio.merged.sym.c"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
//#line  2267 "usb-audio.merged.sym.c"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
//#line  2274 "usb-audio.merged.sym.c"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
//#line  2279
struct dma_coherent_mem;
struct dma_coherent_mem;
//#line  2281 "usb-audio.merged.sym.c"
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   unsigned int uevent_suppress : 1 ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   void *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
//#line  2314
struct nameidata;
struct nameidata;
//#line  2316 "usb-audio.merged.sym.c"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
//#line  2322 "usb-audio.merged.sym.c"
union __anonunion_d_u_184 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
//#line  2327
struct dentry_operations;
struct dentry_operations;
//#line  2329
struct super_block;
struct super_block;
//#line  2331 "usb-audio.merged.sym.c"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_184 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[32] ;
};
//#line  2351 "usb-audio.merged.sym.c"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
//#line  2361
struct radix_tree_node;
struct radix_tree_node;
//#line  2363 "usb-audio.merged.sym.c"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
//#line  2369 "usb-audio.merged.sym.c"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
//#line  2378
struct export_operations;
struct export_operations;
//#line  2380
struct poll_table_struct;
struct poll_table_struct;
//#line  2382
struct kstatfs;
struct kstatfs;
//#line  2384 "usb-audio.merged.sym.c"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
//#line  2396 "usb-audio.merged.sym.c"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
//#line  2408 "usb-audio.merged.sym.c"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
//#line  2415 "usb-audio.merged.sym.c"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
//#line  2440 "usb-audio.merged.sym.c"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
//#line  2446 "usb-audio.merged.sym.c"
typedef struct fs_qfilestat fs_qfilestat_t;
//#line  2448 "usb-audio.merged.sym.c"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
//#line  2462
struct dquot;
struct dquot;
//#line  2464 "usb-audio.merged.sym.c"
typedef __kernel_uid32_t qid_t;
//#line  2466 "usb-audio.merged.sym.c"
typedef long long qsize_t;
//#line  2468 "usb-audio.merged.sym.c"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
//#line  2479
struct quota_format_type;
struct quota_format_type;
//#line  2481 "usb-audio.merged.sym.c"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
//#line  2493 "usb-audio.merged.sym.c"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
//#line  2509 "usb-audio.merged.sym.c"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
//#line  2519 "usb-audio.merged.sym.c"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
//#line  2536 "usb-audio.merged.sym.c"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
//#line  2550 "usb-audio.merged.sym.c"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
//#line  2557 "usb-audio.merged.sym.c"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
//#line  2567
struct writeback_control;
struct writeback_control;
//#line  2569 "usb-audio.merged.sym.c"
union __anonunion_arg_190 {
   char *buf ;
   void *data ;
};
//#line  2574 "usb-audio.merged.sym.c"
struct __anonstruct_read_descriptor_t_189 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_190 arg ;
   int error ;
};
//#line  2581 "usb-audio.merged.sym.c"
typedef struct __anonstruct_read_descriptor_t_189 read_descriptor_t;
//#line  2583 "usb-audio.merged.sym.c"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
//#line  2607 "usb-audio.merged.sym.c"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  2626
struct hd_struct;
struct hd_struct;
//#line  2628
struct gendisk;
struct gendisk;
//#line  2630 "usb-audio.merged.sym.c"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
//#line  2654
struct inode_operations;
struct inode_operations;
//#line  2656
struct file_operations;
struct file_operations;
//#line  2658
struct file_lock;
struct file_lock;
//#line  2660
struct cdev;
struct cdev;
//#line  2662 "usb-audio.merged.sym.c"
union __anonunion____missing_field_name_191 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
//#line  2668
struct dnotify_struct;
struct dnotify_struct;
//#line  2670 "usb-audio.merged.sym.c"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_191 __annonCompField23 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
//#line  2716 "usb-audio.merged.sym.c"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
//#line  2725 "usb-audio.merged.sym.c"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
//#line  2734 "usb-audio.merged.sym.c"
union __anonunion_f_u_192 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
//#line  2739 "usb-audio.merged.sym.c"
struct file {
   union __anonunion_f_u_192 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
//#line  2758 "usb-audio.merged.sym.c"
typedef struct files_struct *fl_owner_t;
//#line  2760 "usb-audio.merged.sym.c"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
//#line  2765 "usb-audio.merged.sym.c"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
//#line  2776
struct nlm_lockowner;
struct nlm_lockowner;
//#line  2778 "usb-audio.merged.sym.c"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
//#line  2784
struct nfs4_lock_state;
struct nfs4_lock_state;
//#line  2786 "usb-audio.merged.sym.c"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
//#line  2790
struct fasync_struct;
struct fasync_struct;
//#line  2792 "usb-audio.merged.sym.c"
struct __anonstruct_afs_194 {
   struct list_head link ;
   int state ;
};
//#line  2797 "usb-audio.merged.sym.c"
union __anonunion_fl_u_193 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_194 afs ;
};
//#line  2803 "usb-audio.merged.sym.c"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_193 fl_u ;
};
//#line  2823 "usb-audio.merged.sym.c"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
//#line  2830
struct file_system_type;
struct file_system_type;
//#line  2832
struct super_operations;
struct super_operations;
//#line  2834
struct xattr_handler;
struct xattr_handler;
//#line  2836
struct mtd_info;
struct mtd_info;
//#line  2838 "usb-audio.merged.sym.c"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
//#line  2884 "usb-audio.merged.sym.c"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
//#line  2891 "usb-audio.merged.sym.c"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
//#line  2927 "usb-audio.merged.sym.c"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
//#line  2953 "usb-audio.merged.sym.c"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
//#line  2977 "usb-audio.merged.sym.c"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
//#line  2993
struct usb_device;
struct usb_device;
//#line  2995
struct usb_driver;
struct usb_driver;
//#line  2997
struct wusb_dev;
struct wusb_dev;
//#line  2999
struct ep_device;
struct ep_device;
//#line  3001 "usb-audio.merged.sym.c"
struct usb_host_endpoint {
   struct usb_endpoint_descriptor desc ;
   struct list_head urb_list ;
   void *hcpriv ;
   struct ep_device *ep_dev ;
   unsigned char *extra ;
   int extralen ;
   int enabled ;
};
//#line  3011 "usb-audio.merged.sym.c"
struct usb_host_interface {
   struct usb_interface_descriptor desc ;
   struct usb_host_endpoint *endpoint ;
   char *string ;
   unsigned char *extra ;
   int extralen ;
};
//#line  3019
enum usb_interface_condition {
    USB_INTERFACE_UNBOUND = 0,
    USB_INTERFACE_BINDING = 1,
    USB_INTERFACE_BOUND = 2,
    USB_INTERFACE_UNBINDING = 3
} ;
//#line  3026 "usb-audio.merged.sym.c"
struct usb_interface {
   struct usb_host_interface *altsetting ;
   struct usb_host_interface *cur_altsetting ;
   unsigned int num_altsetting ;
   struct usb_interface_assoc_descriptor *intf_assoc ;
   int minor ;
   enum usb_interface_condition condition ;
   unsigned int is_active : 1 ;
   unsigned int sysfs_files_created : 1 ;
   unsigned int ep_devs_created : 1 ;
   unsigned int unregistering : 1 ;
   unsigned int needs_remote_wakeup : 1 ;
   unsigned int needs_altsetting0 : 1 ;
   unsigned int needs_binding : 1 ;
   unsigned int reset_running : 1 ;
   struct device dev ;
   struct device *usb_dev ;
   int pm_usage_cnt ;
   struct work_struct reset_ws ;
};
//#line  3047 "usb-audio.merged.sym.c"
struct usb_interface_cache {
   unsigned int num_altsetting ;
   struct kref ref ;
   struct usb_host_interface altsetting[0] ;
};
//#line  3053 "usb-audio.merged.sym.c"
struct usb_host_config {
   struct usb_config_descriptor desc ;
   char *string ;
   struct usb_interface_assoc_descriptor *intf_assoc[16] ;
   struct usb_interface *interface[32] ;
   struct usb_interface_cache *intf_cache[32] ;
   unsigned char *extra ;
   int extralen ;
};
//#line  3063 "usb-audio.merged.sym.c"
struct usb_devmap {
   unsigned long devicemap[128UL / (8UL * sizeof(unsigned long ))] ;
};
//#line  3067
struct mon_bus;
struct mon_bus;
//#line  3069 "usb-audio.merged.sym.c"
struct usb_bus {
   struct device *controller ;
   int busnum ;
   char const   *bus_name ;
   u8 uses_dma ;
   u8 otg_port ;
   unsigned int is_b_host : 1 ;
   unsigned int b_hnp_enable : 1 ;
   int devnum_next ;
   struct usb_devmap devmap ;
   struct usb_device *root_hub ;
   struct list_head bus_list ;
   int bandwidth_allocated ;
   int bandwidth_int_reqs ;
   int bandwidth_isoc_reqs ;
   struct dentry *usbfs_dentry ;
   struct device *dev ;
   struct mon_bus *mon_bus ;
   int monitored ;
};
//#line  3090
struct usb_tt;
struct usb_tt;
//#line  3092 "usb-audio.merged.sym.c"
struct usb_device {
   int devnum ;
   char devpath[16] ;
   enum usb_device_state state ;
   enum usb_device_speed speed ;
   struct usb_tt *tt ;
   int ttport ;
   unsigned int toggle[2] ;
   struct usb_device *parent ;
   struct usb_bus *bus ;
   struct usb_host_endpoint ep0 ;
   struct device dev ;
   struct usb_device_descriptor descriptor ;
   struct usb_host_config *config ;
   struct usb_host_config *actconfig ;
   struct usb_host_endpoint *ep_in[16] ;
   struct usb_host_endpoint *ep_out[16] ;
   char **rawdescriptors ;
   unsigned short bus_mA ;
   u8 portnum ;
   u8 level ;
   unsigned int can_submit : 1 ;
   unsigned int discon_suspended : 1 ;
   unsigned int persist_enabled : 1 ;
   unsigned int have_langid : 1 ;
   unsigned int authorized : 1 ;
   unsigned int authenticated : 1 ;
   unsigned int wusb : 1 ;
   int string_langid ;
   char *product ;
   char *manufacturer ;
   char *serial ;
   struct list_head filelist ;
   struct device *usb_classdev ;
   struct dentry *usbfs_dentry ;
   int maxchild ;
   struct usb_device *children[31] ;
   int pm_usage_cnt ;
   u32 quirks ;
   atomic_t urbnum ;
   unsigned long active_duration ;
   struct delayed_work autosuspend ;
   struct work_struct autoresume ;
   struct mutex pm_mutex ;
   unsigned long last_busy ;
   int autosuspend_delay ;
   unsigned long connect_time ;
   unsigned int auto_pm : 1 ;
   unsigned int do_remote_wakeup : 1 ;
   unsigned int reset_resume : 1 ;
   unsigned int autosuspend_disabled : 1 ;
   unsigned int autoresume_disabled : 1 ;
   unsigned int skip_sys_resume : 1 ;
   struct wusb_dev *wusb_dev ;
};
//#line  3148 "usb-audio.merged.sym.c"
struct usb_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
//#line  3153 "usb-audio.merged.sym.c"
struct usbdrv_wrap {
   struct device_driver driver ;
   int for_devices ;
};
//#line  3158 "usb-audio.merged.sym.c"
struct usb_driver {
   char const   *name ;
   int (*probe)(struct usb_interface *intf , struct usb_device_id  const  *id ) ;
   void (*disconnect)(struct usb_interface *intf ) ;
   int (*ioctl)(struct usb_interface *intf , unsigned int code , void *buf ) ;
   int (*suspend)(struct usb_interface *intf , pm_message_t message ) ;
   int (*resume)(struct usb_interface *intf ) ;
   int (*reset_resume)(struct usb_interface *intf ) ;
   int (*pre_reset)(struct usb_interface *intf ) ;
   int (*post_reset)(struct usb_interface *intf ) ;
   struct usb_device_id  const  *id_table ;
   struct usb_dynids dynids ;
   struct usbdrv_wrap drvwrap ;
   unsigned int no_dynamic_id : 1 ;
   unsigned int supports_autosuspend : 1 ;
   unsigned int soft_unbind : 1 ;
};
//#line  3176 "usb-audio.merged.sym.c"
struct usb_iso_packet_descriptor {
   unsigned int offset ;
   unsigned int length ;
   unsigned int actual_length ;
   int status ;
};
//#line  3183
struct urb;
struct urb;
//#line  3185 "usb-audio.merged.sym.c"
struct usb_anchor {
   struct list_head urb_list ;
   wait_queue_head_t wait ;
   spinlock_t lock ;
   unsigned int poisoned : 1 ;
};
//#line  3192 "usb-audio.merged.sym.c"
struct urb {
   struct kref kref ;
   void *hcpriv ;
   atomic_t use_count ;
   atomic_t reject ;
   int unlinked ;
   struct list_head urb_list ;
   struct list_head anchor_list ;
   struct usb_anchor *anchor ;
   struct usb_device *dev ;
   struct usb_host_endpoint *ep ;
   unsigned int pipe ;
   int status ;
   unsigned int transfer_flags ;
   u8 *transfer_buffer ;
   dma_addr_t transfer_dma ;
   int transfer_buffer_length ;
   int actual_length ;
   unsigned char *setup_packet ;
   dma_addr_t setup_dma ;
   int start_frame ;
   int number_of_packets ;
   int interval ;
   int error_count ;
   u8 * __attribute__((__noderef__)) context ;
   void (*complete)(struct urb * ) ;
   struct usb_iso_packet_descriptor iso_frame_desc[0] ;
};
//#line  3221 "usb-audio.merged.sym.c"
typedef int snd_device_type_t;
//#line  3223 "usb-audio.merged.sym.c"
typedef int snd_device_state_t;
//#line  3225
struct snd_device;
struct snd_device;
//#line  3227 "usb-audio.merged.sym.c"
struct snd_device_ops {
   int (*dev_free)(struct snd_device *dev ) ;
   int (*dev_register)(struct snd_device *dev ) ;
   int (*dev_disconnect)(struct snd_device *dev ) ;
};
//#line  3233
struct snd_card;
struct snd_card;
//#line  3235 "usb-audio.merged.sym.c"
struct snd_device {
   struct list_head list ;
   struct snd_card *card ;
   snd_device_state_t state ;
   snd_device_type_t type ;
   void * __attribute__((__noderef__)) device_data ;
   struct snd_device_ops *ops ;
};
//#line  3244 "usb-audio.merged.sym.c"
struct snd_monitor_file {
   struct file *file ;
   struct snd_monitor_file *next ;
   struct file_operations  const  *disconnected_f_op ;
   struct list_head shutdown_list ;
};
//#line  3251
struct snd_info_entry;
struct snd_info_entry;
//#line  3253
struct snd_shutdown_f_ops;
struct snd_shutdown_f_ops;
//#line  3255
struct snd_mixer_oss;
struct snd_mixer_oss;
//#line  3257 "usb-audio.merged.sym.c"
struct snd_card {
   int number ;
   char id[16] ;
   char driver[16] ;
   char shortname[32] ;
   char longname[80] ;
   char mixername[80] ;
   char components[128] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card *card ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct snd_monitor_file *files ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   struct device *dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
//#line  3293 "usb-audio.merged.sym.c"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
//#line  3299 "usb-audio.merged.sym.c"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
//#line  3304 "usb-audio.merged.sym.c"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
//#line  3308 "usb-audio.merged.sym.c"
typedef struct poll_table_struct poll_table;
//#line  3310 "usb-audio.merged.sym.c"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
//#line  3319 "usb-audio.merged.sym.c"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
   void (*write)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
};
//#line  3324 "usb-audio.merged.sym.c"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry *entry , unsigned short mode , void **file_private_data ) ;
   int (*release)(struct snd_info_entry *entry , unsigned short mode , void *file_private_data ) ;
   long (*read)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                char *buf , unsigned long count , unsigned long pos ) ;
   long (*write)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                 char const   *buf , unsigned long count , unsigned long pos ) ;
   long long (*llseek)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                       long long offset , int orig ) ;
   unsigned int (*poll)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                        poll_table *wait ) ;
   int (*ioctl)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                unsigned int cmd , unsigned long arg ) ;
   int (*mmap)(struct snd_info_entry *entry , void *file_private_data , struct inode *inode ,
               struct file *file , struct vm_area_struct *vma ) ;
};
//#line  3341 "usb-audio.merged.sym.c"
union __anonunion_c_198 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
//#line  3346 "usb-audio.merged.sym.c"
struct snd_info_entry {
   char const   *name ;
   mode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_198 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   void * __attribute__((__noderef__)) private_data ;
   void (*private_free)(struct snd_info_entry *entry ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
//#line  3363 "usb-audio.merged.sym.c"
typedef unsigned long snd_pcm_uframes_t;
//#line  3365 "usb-audio.merged.sym.c"
typedef long snd_pcm_sframes_t;
//#line  3367 "usb-audio.merged.sym.c"
typedef int snd_pcm_access_t;
//#line  3369 "usb-audio.merged.sym.c"
typedef int snd_pcm_format_t;
//#line  3371 "usb-audio.merged.sym.c"
typedef int snd_pcm_subformat_t;
//#line  3373 "usb-audio.merged.sym.c"
typedef int snd_pcm_state_t;
//#line  3375 "usb-audio.merged.sym.c"
union snd_pcm_sync_id {
   unsigned char id[16] ;
   unsigned short id16[8] ;
   unsigned int id32[4] ;
};
//#line  3381 "usb-audio.merged.sym.c"
typedef int snd_pcm_hw_param_t;
//#line  3383 "usb-audio.merged.sym.c"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned int openmin : 1 ;
   unsigned int openmax : 1 ;
   unsigned int integer : 1 ;
   unsigned int empty : 1 ;
};
//#line  3392 "usb-audio.merged.sym.c"
struct snd_mask {
   u_int32_t bits[8] ;
};
//#line  3396 "usb-audio.merged.sym.c"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3] ;
   struct snd_mask mres[5] ;
   struct snd_interval intervals[12] ;
   struct snd_interval ires[9] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64] ;
};
//#line  3412 "usb-audio.merged.sym.c"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
//#line  3420 "usb-audio.merged.sym.c"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
//#line  3425 "usb-audio.merged.sym.c"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
//#line  3430 "usb-audio.merged.sym.c"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
//#line  3438 "usb-audio.merged.sym.c"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void *virtual_address ;
   struct page *page ;
};
//#line  3445 "usb-audio.merged.sym.c"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
//#line  3458 "usb-audio.merged.sym.c"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned int disable : 1 ;
   unsigned int direct : 1 ;
   unsigned int block : 1 ;
   unsigned int nonblock : 1 ;
   unsigned int partialfrag : 1 ;
   unsigned int nosilence : 1 ;
   unsigned int buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
//#line  3472
struct snd_pcm_plugin;
struct snd_pcm_plugin;
//#line  3474 "usb-audio.merged.sym.c"
struct snd_pcm_oss_runtime {
   unsigned int params : 1 ;
   unsigned int prepare : 1 ;
   unsigned int trigger : 1 ;
   unsigned int sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_interrupt ;
};
//#line  3500
struct snd_pcm_substream;
struct snd_pcm_substream;
//#line  3502 "usb-audio.merged.sym.c"
struct snd_pcm_oss_substream {
   unsigned int oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
//#line  3507 "usb-audio.merged.sym.c"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
//#line  3513 "usb-audio.merged.sym.c"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
//#line  3518 "usb-audio.merged.sym.c"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
//#line  3534 "usb-audio.merged.sym.c"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream *substream ) ;
   int (*close)(struct snd_pcm_substream *substream ) ;
   int (*ioctl)(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
   int (*hw_params)(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *params ) ;
   int (*hw_free)(struct snd_pcm_substream *substream ) ;
   int (*prepare)(struct snd_pcm_substream *substream ) ;
   int (*trigger)(struct snd_pcm_substream *substream , int cmd ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream ) ;
   int (*copy)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
               void *buf , snd_pcm_uframes_t count ) ;
   int (*silence)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
                  snd_pcm_uframes_t count ) ;
   struct page *(*page)(struct snd_pcm_substream *substream , unsigned long offset ) ;
   int (*mmap)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ) ;
   int (*ack)(struct snd_pcm_substream *substream ) ;
};
//#line  3552
struct snd_pcm_hw_rule;
struct snd_pcm_hw_rule;
//#line  3554 "usb-audio.merged.sym.c"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) ;
   int var ;
   int deps[4] ;
   void *private ;
};
//#line  3562 "usb-audio.merged.sym.c"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3] ;
   struct snd_interval intervals[12] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
//#line  3570 "usb-audio.merged.sym.c"
struct snd_pcm_hw_constraint_list {
   unsigned int count ;
   unsigned int *list ;
   unsigned int mask ;
};
//#line  3576 "usb-audio.merged.sym.c"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   wait_queue_head_t sleep ;
   struct fasync_struct *fasync ;
   void *private_data ;
   void (*private_free)(struct snd_pcm_runtime *runtime ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream *substream ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream *substream ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char *dma_area ;
   dma_addr_t dma_addr ;
   size_t dma_bytes ;
   struct snd_dma_buffer *dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
};
//#line  3627 "usb-audio.merged.sym.c"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
//#line  3633
struct snd_pcm;
struct snd_pcm;
//#line  3635
struct snd_pcm_str;
struct snd_pcm_str;
//#line  3637
struct snd_timer;
struct snd_timer;
//#line  3639 "usb-audio.merged.sym.c"
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   void *private_data ;
   int number ;
   char name[32] ;
   int stream ;
   char latency_id[20] ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime *runtime ;
   struct snd_timer *timer ;
   unsigned int timer_running : 1 ;
   spinlock_t timer_lock ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned int hw_opened : 1 ;
};
//#line  3676 "usb-audio.merged.sym.c"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
};
//#line  3687 "usb-audio.merged.sym.c"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64] ;
   char name[80] ;
   struct snd_pcm_str streams[2] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_pcm *pcm ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
//#line  3705 "usb-audio.merged.sym.c"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
//#line  3708 "usb-audio.merged.sym.c"
typedef int write_proc_t(struct file *file , char const   *buffer , unsigned long count ,
                         void *data );
//#line  3711 "usb-audio.merged.sym.c"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
//#line  3736 "usb-audio.merged.sym.c"
struct snd_usb_audio {
   int index ;
   struct usb_device *dev ;
   struct snd_card *card ;
   u32 usb_id ;
   int shutdown ;
   int num_interfaces ;
   int num_suspended_intf ;
   struct list_head pcm_list ;
   int pcm_devs ;
   struct list_head midi_list ;
   int next_midi_device ;
   struct list_head mixer_list ;
};
//#line  3751 "usb-audio.merged.sym.c"
struct snd_usb_audio_quirk {
   char const   *vendor_name ;
   char const   *product_name ;
   int16_t ifnum ;
   uint16_t type ;
   void const   *data ;
};
//#line  3759 "usb-audio.merged.sym.c"
struct snd_usb_midi_endpoint_info {
   int8_t out_ep ;
   uint8_t out_interval ;
   int8_t in_ep ;
   uint8_t in_interval ;
   uint16_t out_cables ;
   uint16_t in_cables ;
};
//#line  3768 "usb-audio.merged.sym.c"
struct audioformat {
   struct list_head list ;
   snd_pcm_format_t format ;
   unsigned int channels ;
   unsigned int fmt_type ;
   unsigned int frame_size ;
   int iface ;
   unsigned char altsetting ;
   unsigned char altset_idx ;
   unsigned char attributes ;
   unsigned char endpoint ;
   unsigned char ep_attr ;
   unsigned int maxpacksize ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int nr_rates ;
   unsigned int *rate_table ;
};
//#line  3788
struct snd_usb_substream;
struct snd_usb_substream;
//#line  3790 "usb-audio.merged.sym.c"
struct snd_urb_ctx {
   struct urb *urb ;
   unsigned int buffer_size ;
   struct snd_usb_substream *subs ;
   int index ;
   int packets ;
};
//#line  3798 "usb-audio.merged.sym.c"
struct snd_urb_ops {
   int (*prepare)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                  struct urb *u ) ;
   int (*retire)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                 struct urb *u ) ;
   int (*prepare_sync)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                       struct urb *u ) ;
   int (*retire_sync)(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                      struct urb *u ) ;
};
//#line  3809
struct snd_usb_stream;
struct snd_usb_stream;
//#line  3811 "usb-audio.merged.sym.c"
struct snd_usb_substream {
   struct snd_usb_stream *stream ;
   struct usb_device *dev ;
   struct snd_pcm_substream *pcm_substream ;
   int direction ;
   int interface ;
   int endpoint ;
   struct audioformat *cur_audiofmt ;
   unsigned int cur_rate ;
   unsigned int period_bytes ;
   unsigned int format ;
   unsigned int datapipe ;
   unsigned int syncpipe ;
   unsigned int datainterval ;
   unsigned int syncinterval ;
   unsigned int freqn ;
   unsigned int freqm ;
   unsigned int freqmax ;
   unsigned int phase ;
   unsigned int maxpacksize ;
   unsigned int maxframesize ;
   unsigned int curpacksize ;
   unsigned int curframesize ;
   unsigned int fill_max : 1 ;
   unsigned int fmt_type ;
   unsigned int packs_per_ms ;
   unsigned int running : 1 ;
   unsigned int hwptr_done ;
   unsigned int transfer_done ;
   unsigned long active_mask ;
   unsigned long unlink_mask ;
   unsigned int nurbs ;
   struct snd_urb_ctx dataurb[8] ;
   struct snd_urb_ctx syncurb[4] ;
   char *syncbuf ;
   dma_addr_t sync_dma ;
   u64 formats ;
   unsigned int num_formats ;
   struct list_head fmt_list ;
   struct snd_pcm_hw_constraint_list rate_list ;
   spinlock_t lock ;
   struct snd_urb_ops ops ;
};
//#line  3855 "usb-audio.merged.sym.c"
struct snd_usb_stream {
   struct snd_usb_audio *chip ;
   struct snd_pcm *pcm ;
   int pcm_index ;
   unsigned int fmt_type ;
   struct snd_usb_substream substream[2] ;
   struct list_head list ;
};
//#line  3864
struct snd_usb_midi_in_endpoint;
struct snd_usb_midi_in_endpoint;
//#line  3866
struct snd_usb_midi_out_endpoint;
struct snd_usb_midi_out_endpoint;
//#line  3868 "usb-audio.merged.sym.c"
struct usb_protocol_ops {
   void (*input)(struct snd_usb_midi_in_endpoint * , uint8_t * , int  ) ;
   void (*output)(struct snd_usb_midi_out_endpoint * ) ;
   void (*output_packet)(struct urb * , uint8_t  , uint8_t  , uint8_t  , uint8_t  ) ;
   void (*init_out_endpoint)(struct snd_usb_midi_out_endpoint * ) ;
   void (*finish_out_endpoint)(struct snd_usb_midi_out_endpoint * ) ;
};
//#line  3876 "usb-audio.merged.sym.c"
typedef int (*quirk_func_t)(struct snd_usb_audio * , struct usb_interface * , struct snd_usb_audio_quirk  const  * );
//#line  3878
enum hrtimer_restart;
//#line  3880 "usb-audio.merged.sym.c"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
//#line  3888 "usb-audio.merged.sym.c"
struct snd_seq_device {
   struct snd_card *card ;
   int device ;
   char id[32] ;
   char name[80] ;
   int argsize ;
   void *driver_data ;
   int status ;
   void *private_data ;
   void (*private_free)(struct snd_seq_device *device ) ;
   struct list_head list ;
};
//#line  3901
struct snd_rawmidi;
struct snd_rawmidi;
//#line  3903
struct snd_rawmidi_substream;
struct snd_rawmidi_substream;
//#line  3905
struct snd_seq_port_info;
struct snd_seq_port_info;
//#line  3907 "usb-audio.merged.sym.c"
struct snd_rawmidi_ops {
   int (*open)(struct snd_rawmidi_substream *substream ) ;
   int (*close)(struct snd_rawmidi_substream *substream ) ;
   void (*trigger)(struct snd_rawmidi_substream *substream , int up ) ;
   void (*drain)(struct snd_rawmidi_substream *substream ) ;
};
//#line  3914 "usb-audio.merged.sym.c"
struct snd_rawmidi_global_ops {
   int (*dev_register)(struct snd_rawmidi *rmidi ) ;
   int (*dev_unregister)(struct snd_rawmidi *rmidi ) ;
   void (*get_port_info)(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *info ) ;
};
//#line  3920 "usb-audio.merged.sym.c"
struct snd_rawmidi_runtime {
   unsigned int drain : 1 ;
   unsigned int oss : 1 ;
   unsigned char *buffer ;
   size_t buffer_size ;
   size_t appl_ptr ;
   size_t hw_ptr ;
   size_t avail_min ;
   size_t avail ;
   size_t xruns ;
   spinlock_t lock ;
   wait_queue_head_t sleep ;
   void (*event)(struct snd_rawmidi_substream *substream ) ;
   struct tasklet_struct tasklet ;
   void *private_data ;
   void (*private_free)(struct snd_rawmidi_substream *substream ) ;
};
//#line  3938
struct snd_rawmidi_str;
struct snd_rawmidi_str;
//#line  3940 "usb-audio.merged.sym.c"
struct snd_rawmidi_substream {
   struct list_head  __attribute__((__noderef__)) list ;
   int stream ;
   int number ;
   unsigned int opened : 1 ;
   unsigned int append : 1 ;
   unsigned int active_sensing : 1 ;
   int use_count ;
   size_t bytes ;
   struct snd_rawmidi *rmidi ;
   struct snd_rawmidi_str *pstr ;
   char name[32] ;
   struct snd_rawmidi_runtime *runtime ;
   struct snd_rawmidi_ops *ops ;
};
//#line  3956 "usb-audio.merged.sym.c"
struct snd_rawmidi_str {
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct list_head  __attribute__((__noderef__)) substreams ;
};
//#line  3962 "usb-audio.merged.sym.c"
struct snd_rawmidi {
   struct snd_card *card ;
   struct list_head list ;
   unsigned int device ;
   unsigned int info_flags ;
   char id[64] ;
   char name[80] ;
   int ossreg ;
   struct snd_rawmidi_global_ops *ops ;
   struct snd_rawmidi_str streams[2] ;
   void * __attribute__((__noderef__)) private_data ;
   void (*private_free)(struct snd_rawmidi *rmidi ) ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   struct snd_info_entry *dev ;
   struct snd_info_entry *proc_entry ;
   struct snd_seq_device *seq_dev ;
};
//#line  3981 "usb-audio.merged.sym.c"
struct snd_seq_addr {
   unsigned char client ;
   unsigned char port ;
};
//#line  3986 "usb-audio.merged.sym.c"
struct snd_seq_port_info {
   struct snd_seq_addr addr ;
   char name[64] ;
   unsigned int capability ;
   unsigned int type ;
   int midi_channels ;
   int midi_voices ;
   int synth_voices ;
   int read_use ;
   int write_use ;
   void *kernel ;
   unsigned int flags ;
   unsigned char time_queue ;
   char reserved[59] ;
};
//#line  4002 "usb-audio.merged.sym.c"
struct usb_ms_header_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDescriptorSubtype ;
   __u8 bcdMSC[2] ;
   __le16 wTotalLength ;
} __attribute__((__packed__)) ;
//#line  4010 "usb-audio.merged.sym.c"
struct usb_ms_endpoint_descriptor {
   __u8 bLength ;
   __u8 bDescriptorType ;
   __u8 bDescriptorSubtype ;
   __u8 bNumEmbMIDIJack ;
   __u8 baAssocJackID[0] ;
} __attribute__((__packed__)) ;
//#line  4018
struct snd_usb_midi_endpoint;
struct snd_usb_midi_endpoint;
//#line  4020 "usb-audio.merged.sym.c"
struct snd_usb_midi_endpoint {
   struct snd_usb_midi_out_endpoint *out ;
   struct snd_usb_midi_in_endpoint *in ;
};
//#line  4025 "usb-audio.merged.sym.c"
struct snd_usb_midi {
   struct snd_usb_audio *chip ;
   struct usb_interface *iface ;
   struct snd_usb_audio_quirk  const  *quirk ;
   struct snd_rawmidi *rmidi ;
   struct usb_protocol_ops *usb_protocol_ops ;
   struct list_head list ;
   struct timer_list error_timer ;
   spinlock_t disc_lock ;
   struct snd_usb_midi_endpoint endpoints[2] ;
   unsigned long input_triggered ;
   unsigned char disconnected ;
};
//#line  4039 "usb-audio.merged.sym.c"
struct usbmidi_out_port {
   struct snd_usb_midi_out_endpoint *ep ;
   struct snd_rawmidi_substream *substream ;
   int active ;
   uint8_t cable ;
   uint8_t state ;
   uint8_t data[2] ;
};
//#line  4048 "usb-audio.merged.sym.c"
struct snd_usb_midi_out_endpoint {
   struct snd_usb_midi *umidi ;
   struct urb *urb ;
   int urb_active ;
   int max_transfer ;
   struct tasklet_struct tasklet ;
   spinlock_t buffer_lock ;
   struct usbmidi_out_port ports[16] ;
   int current_port ;
};
//#line  4059 "usb-audio.merged.sym.c"
struct usbmidi_in_port {
   struct snd_rawmidi_substream *substream ;
   u8 running_status_length ;
};
//#line  4064 "usb-audio.merged.sym.c"
struct snd_usb_midi_in_endpoint {
   struct snd_usb_midi *umidi ;
   struct urb *urb ;
   struct usbmidi_in_port ports[16] ;
   u8 seen_f5 ;
   u8 error_resubmit ;
   int current_port ;
};
//#line  4073 "usb-audio.merged.sym.c"
struct port_info {
   u32 id ;
   short port ;
   short voices ;
   char const   *name ;
   unsigned int seq_flags ;
};
//#line  4081 "usb-audio.merged.sym.c"
struct x8664_pda {
   struct task_struct *pcurrent ;
   unsigned long data_offset ;
   unsigned long kernelstack ;
   unsigned long oldrsp ;
   int irqcount ;
   unsigned int cpunumber ;
   char *irqstackptr ;
   short nodenumber ;
   short in_bootmem ;
   unsigned int __softirq_pending ;
   unsigned int __nmi_count ;
   short mmu_state ;
   short isidle ;
   struct mm_struct *active_mm ;
   unsigned int apic_timer_irqs ;
   unsigned int irq0_irqs ;
   unsigned int irq_resched_count ;
   unsigned int irq_call_count ;
   unsigned int irq_tlb_count ;
   unsigned int irq_thermal_count ;
   unsigned int irq_threshold_count ;
   unsigned int irq_spurious_count ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
//#line  4106
enum hrtimer_restart;
//#line  4108 "usb-audio.merged.sym.c"
struct usb_ctrlrequest {
   __u8 bRequestType ;
   __u8 bRequest ;
   __le16 wValue ;
   __le16 wIndex ;
   __le16 wLength ;
} __attribute__((__packed__)) ;
//#line  4116 "usb-audio.merged.sym.c"
struct snd_aes_iec958 {
   unsigned char status[24] ;
   unsigned char subcode[147] ;
   unsigned char pad ;
   unsigned char dig_subframe[4] ;
};
//#line  4123 "usb-audio.merged.sym.c"
struct snd_hwdep_dsp_status {
   unsigned int version ;
   unsigned char id[32] ;
   unsigned int num_dsps ;
   unsigned int dsp_loaded ;
   unsigned int chip_ready ;
   unsigned char reserved[16] ;
};
//#line  4132 "usb-audio.merged.sym.c"
struct snd_hwdep_dsp_image {
   unsigned int index ;
   unsigned char name[64] ;
   unsigned char *image ;
   size_t length ;
   unsigned long driver_data ;
};
//#line  4140 "usb-audio.merged.sym.c"
typedef int snd_ctl_elem_type_t;
//#line  4142 "usb-audio.merged.sym.c"
typedef int snd_ctl_elem_iface_t;
//#line  4144 "usb-audio.merged.sym.c"
struct snd_ctl_elem_id {
   unsigned int numid ;
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char name[44] ;
   unsigned int index ;
};
//#line  4153 "usb-audio.merged.sym.c"
struct __anonstruct_integer_215 {
   long min ;
   long max ;
   long step ;
};
//#line  4159 "usb-audio.merged.sym.c"
struct __anonstruct_integer64_216 {
   long long min ;
   long long max ;
   long long step ;
};
//#line  4165 "usb-audio.merged.sym.c"
struct __anonstruct_enumerated_217 {
   unsigned int items ;
   unsigned int item ;
   char name[64] ;
};
//#line  4171 "usb-audio.merged.sym.c"
union __anonunion_value_214 {
   struct __anonstruct_integer_215 integer ;
   struct __anonstruct_integer64_216 integer64 ;
   struct __anonstruct_enumerated_217 enumerated ;
   unsigned char reserved[128] ;
};
//#line  4178 "usb-audio.merged.sym.c"
union __anonunion_dimen_218 {
   unsigned short d[4] ;
   unsigned short *d_ptr ;
};
//#line  4183 "usb-audio.merged.sym.c"
struct snd_ctl_elem_info {
   struct snd_ctl_elem_id id ;
   snd_ctl_elem_type_t type ;
   unsigned int access ;
   unsigned int count ;
   pid_t owner ;
   union __anonunion_value_214 value ;
   union __anonunion_dimen_218 dimen ;
   unsigned char reserved[64UL - 4UL * sizeof(unsigned short )] ;
};
//#line  4194 "usb-audio.merged.sym.c"
union __anonunion_integer_220 {
   long value[128] ;
   long *value_ptr ;
};
//#line  4199 "usb-audio.merged.sym.c"
union __anonunion_integer64_221 {
   long long value[64] ;
   long long *value_ptr ;
};
//#line  4204 "usb-audio.merged.sym.c"
union __anonunion_enumerated_222 {
   unsigned int item[128] ;
   unsigned int *item_ptr ;
};
//#line  4209 "usb-audio.merged.sym.c"
union __anonunion_bytes_223 {
   unsigned char data[512] ;
   unsigned char *data_ptr ;
};
//#line  4214 "usb-audio.merged.sym.c"
union __anonunion_value_219 {
   union __anonunion_integer_220 integer ;
   union __anonunion_integer64_221 integer64 ;
   union __anonunion_enumerated_222 enumerated ;
   union __anonunion_bytes_223 bytes ;
   struct snd_aes_iec958 iec958 ;
};
//#line  4222 "usb-audio.merged.sym.c"
struct snd_ctl_elem_value {
   struct snd_ctl_elem_id id ;
   unsigned int indirect : 1 ;
   union __anonunion_value_219 value ;
   struct timespec tstamp ;
   unsigned char reserved[128UL - sizeof(struct timespec )] ;
};
//#line  4230
struct snd_kcontrol;
struct snd_kcontrol;
//#line  4232 "usb-audio.merged.sym.c"
typedef int snd_kcontrol_info_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo );
//#line  4234 "usb-audio.merged.sym.c"
typedef int snd_kcontrol_get_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  4236 "usb-audio.merged.sym.c"
typedef int snd_kcontrol_put_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  4238 "usb-audio.merged.sym.c"
typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                                  unsigned int *tlv );
//#line  4241 "usb-audio.merged.sym.c"
union __anonunion_tlv_228 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
//#line  4246 "usb-audio.merged.sym.c"
struct snd_kcontrol_new {
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char *name ;
   unsigned int index ;
   unsigned int access ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_228 tlv ;
   unsigned long private_value ;
};
//#line  4261
struct snd_ctl_file;
struct snd_ctl_file;
//#line  4263 "usb-audio.merged.sym.c"
struct snd_kcontrol_volatile {
   struct snd_ctl_file *owner ;
   pid_t owner_pid ;
   unsigned int access ;
};
//#line  4269 "usb-audio.merged.sym.c"
union __anonunion_tlv_229 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
//#line  4274 "usb-audio.merged.sym.c"
struct snd_kcontrol {
   struct list_head list ;
   struct snd_ctl_elem_id id ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_229 tlv ;
   unsigned long private_value ;
   char *private_data ;
   void (*private_free)(struct snd_kcontrol *kcontrol ) ;
   struct snd_kcontrol_volatile vd[0] ;
};
//#line  4288
struct usb_mixer_interface;
struct usb_mixer_interface;
//#line  4290
struct usb_mixer_elem_info;
struct usb_mixer_elem_info;
//#line  4292 "usb-audio.merged.sym.c"
struct snd_ctl_file {
   struct list_head list ;
   struct snd_card *card ;
   pid_t pid ;
   int prefer_pcm_subdevice ;
   int prefer_rawmidi_subdevice ;
   wait_queue_head_t change_sleep ;
   spinlock_t read_lock ;
   struct fasync_struct *fasync ;
   int subscribed ;
   struct list_head events ;
};
//#line  4305
struct snd_hwdep;
struct snd_hwdep;
//#line  4307 "usb-audio.merged.sym.c"
struct snd_hwdep_ops {
   long long (*llseek)(struct snd_hwdep *hw , struct file *file , long long offset ,
                       int orig ) ;
   long (*read)(struct snd_hwdep *hw , char *buf , long count , loff_t *offset ) ;
   long (*write)(struct snd_hwdep *hw , char const   *buf , long count , loff_t *offset ) ;
   int (*open)(struct snd_hwdep *hw , struct file *file ) ;
   int (*release)(struct snd_hwdep *hw , struct file *file ) ;
   unsigned int (*poll)(struct snd_hwdep *hw , struct file *file , poll_table *wait ) ;
   int (*ioctl)(struct snd_hwdep *hw , struct file *file , unsigned int cmd , unsigned long arg ) ;
   int (*ioctl_compat)(struct snd_hwdep *hw , struct file *file , unsigned int cmd ,
                       unsigned long arg ) ;
   int (*mmap)(struct snd_hwdep *hw , struct file *file , struct vm_area_struct *vma ) ;
   int (*dsp_status)(struct snd_hwdep *hw , struct snd_hwdep_dsp_status *status ) ;
   int (*dsp_load)(struct snd_hwdep *hw , struct snd_hwdep_dsp_image *image ) ;
};
//#line  4323 "usb-audio.merged.sym.c"
struct snd_hwdep {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   char id[32] ;
   char name[80] ;
   int iface ;
   char oss_dev[32] ;
   int oss_type ;
   int ossreg ;
   struct snd_hwdep_ops ops ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_hwdep *hwdep ) ;
   struct mutex open_mutex ;
   int used ;
   unsigned int dsp_loaded ;
   unsigned int exclusive : 1 ;
};
//#line  4343 "usb-audio.merged.sym.c"
struct rc_config {
   u32 usb_id ;
   u8 offset ;
   u8 length ;
   u8 packet_length ;
   u8 min_packet_length ;
   u8 mute_mixer_id ;
   u32 mute_code ;
} __attribute__((__noderef__, __address_space__(2))) ;
//#line  4353 "usb-audio.merged.sym.c"
struct usb_mixer_interface {
   struct snd_usb_audio *chip ;
   unsigned int ctrlif ;
   struct list_head list ;
   unsigned int ignore_ctl_error ;
   struct urb *urb ;
   struct usb_mixer_elem_info **id_elems ;
   struct rc_config  const  *rc_cfg ;
   unsigned long rc_hwdep_open ;
   u32 rc_code ;
   wait_queue_head_t rc_waitq ;
   struct urb *rc_urb ;
   struct usb_ctrlrequest *rc_setup_packet ;
   u8 rc_buffer[6] ;
   u8 audigy2nx_leds[3] ;
};
//#line  4370 "usb-audio.merged.sym.c"
struct usb_audio_term {
   int id ;
   int type ;
   int channels ;
   unsigned int chconfig ;
   int name ;
};
//#line  4378
struct usbmix_name_map;
struct usbmix_name_map;
//#line  4380
struct usbmix_selector_map;
struct usbmix_selector_map;
//#line  4382 "usb-audio.merged.sym.c"
struct mixer_build {
   struct snd_usb_audio *chip ;
   struct usb_mixer_interface *mixer ;
   unsigned char * __attribute__((__expfld__(buflen))) buffer ;
   unsigned int buflen ;
   unsigned long unitbitmap[((256UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   struct usb_audio_term oterm ;
   struct usbmix_name_map  const  *map ;
   struct usbmix_selector_map  const  *selector_map ;
};
//#line  4393 "usb-audio.merged.sym.c"
struct usb_mixer_elem_info {
   struct usb_mixer_interface *mixer ;
   struct usb_mixer_elem_info *next_id_elem ;
   struct snd_ctl_elem_id *elem_id ;
   unsigned int id ;
   unsigned int control ;
   unsigned int cmask ;
   int channels ;
   int val_type ;
   int min ;
   int max ;
   int res ;
   u8 initialized ;
};
//#line  4408 "usb-audio.merged.sym.c"
struct usbmix_name_map {
   int id ;
   char const   *name ;
   int control ;
};
//#line  4414 "usb-audio.merged.sym.c"
struct usbmix_selector_map {
   int id ;
   int count ;
   char const   **names ;
};
//#line  4420 "usb-audio.merged.sym.c"
struct usbmix_ctl_map {
   u32 id ;
   struct usbmix_name_map  const  *map ;
   struct usbmix_selector_map  const  *selector_map ;
   int ignore_ctl_error ;
};
//#line  4427 "usb-audio.merged.sym.c"
struct iterm_name_combo {
   int type ;
   char *name ;
} __attribute__((__noderef__, __address_space__(2))) ;
//#line  4432 "usb-audio.merged.sym.c"
struct usb_feature_control_info {
   char const   *name ;
   unsigned int type ;
};
//#line  4437 "usb-audio.merged.sym.c"
struct procunit_value_info {
   int control ;
   char *suffix ;
   int val_type ;
   int min_value ;
};
//#line  4444 "usb-audio.merged.sym.c"
struct procunit_info {
   int type ;
   char *name ;
   struct procunit_value_info *values ;
};
//#line  4450 "usb-audio.merged.sym.c"
struct sb_jack {
   int unitid ;
   char const   *name ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
//#line  4461
#pragma merger(0,"./usbaudio_annotated.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  4463 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) set_bit)(unsigned int nr ,
                                                                   unsigned long volatile   *addr ) 
{ 


  {
  record_function("set_bit");
//#line  4470
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
//#line  4483
  return;
}
}
//#line  4487 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) clear_bit)(int nr , unsigned long volatile   *addr ) 
{ 


  {
  record_function("clear_bit");
//#line  4493
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
//#line  4506
  return;
}
}
//#line  4510 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) test_and_set_bit)(int nr ,
                                                                           unsigned long volatile   *addr ) 
{ 
  int oldbit ;

  {
  record_function("test_and_set_bit");
//#line  4517
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit), "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
//#line  4531
  return (oldbit);
}
}
//#line  4535 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) variable_test_bit)(int nr ,
                                                                            unsigned long const volatile   *addr ) 
{ 
  int oldbit ;

  {
  record_function("variable_test_bit");
//#line  4542
  __asm__  volatile   ("bt %2,%1\n\t"
                       "sbb %0,%0": "=r" (oldbit): "m" (*((unsigned long *)addr)),
                       "Ir" (nr));
//#line  4546
  return (oldbit);
}
}
//#line  4550 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) ffs)(int x ) 
{ 
  int r ;

  {
  record_function("ffs");
//#line  4556
  __asm__  ("bsfl %1,%0\n\t"
            "cmovzl %2,%0": "=r" (r): "rm" (x), "r" (-1));
//#line  4559
  return (r + 1);
}
}
//#line  4563
void warn_slowpath(char const   *file , int line , char const   *fmt  , ...) ;
//#line  4568
int snprintf(char *buf , size_t size , char const   *fmt  , ...) ;
//#line  4571
int printk(char const   *fmt  , ...) ;
//#line  4573
static unsigned long __phys_addr(unsigned long  ) ;
//#line  4575
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size )  __attribute__((__const__)) ;
//#line  4577
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size )  __attribute__((__const__)) ;
__inline static int ( __attribute__((__always_inline__)) get_order)(unsigned long size ) 
{ 
  int order ;

  {
  record_function("get_order");
//#line  4583
  size = (size - 1UL) >> 11;
//#line  4585
  order = -1;
  {
  {
//#line  4587
  while (1) {


//#line  4589
    size >>= 1;
//#line  4591
    order ++;
//#line  4593
    if (! size) {
//#line  4595
      goto while_break;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  4599
  return (order);
}
}
//#line  4603
static void *__memcpy(void *to , void const   *from , size_t len ) ;
//#line  4605
void *memset(void *s , int c , size_t n ) ;
//#line  4607
char *strcpy(char *dest , char const   *src ) ;
//#line  4609
size_t strlcpy(char * , char const   * , size_t  ) ;
//#line  4611
size_t strlcat(char * , char const   * , __kernel_size_t  ) ;
//#line  4613
void *kmemdup(void const   *src , size_t len , gfp_t gfp ) ;
//#line  4615 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ 


  {
  record_function("INIT_LIST_HEAD");
//#line  4621
  list->next = (struct list_head *)list;
//#line  4623
  list->prev = (struct list_head *)list;
//#line  4625
  return;
}
}
//#line  4629
static void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) ;
//#line  4631 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) list_add)(struct list_head *new ,
                                                                    struct list_head *head ) 
{ 


  {
  record_function("list_add");
  {
//#line  4638
  __list_add(new, head, (struct list_head *)head->next);
  }
//#line  4640
  return;
}
}
//#line  4644 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) list_add_tail)(struct list_head *new ,
                                                                         struct list_head *head ) 
{ 


  {
  record_function("list_add_tail");
  {
//#line  4651
  __list_add(new, (struct list_head *)head->prev, head);
  }
//#line  4653
  return;
}
}
//#line  4657
static void list_del(struct list_head *entry ) ;
//#line  4659
static void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
//#line  4661
static void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  4663
static unsigned long _spin_lock_irqsave(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  4665
static void _spin_unlock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  4667
static void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags )  __attribute__((__section__(".spinlock.text"))) ;
//#line  4669
static void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
//#line  4671
static void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) ;
//#line  4673
static void mutex_unlock(struct mutex *lock ) ;
//#line  4675
unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
//#line  4677
void free_pages(unsigned long addr , unsigned int order ) ;
//#line  4679
void kfree(void const   * ) ;
//#line  4681
unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
//#line  4683
static unsigned long msecs_to_jiffies(unsigned int m ) ;
//#line  4685
void *__kmalloc(size_t size , gfp_t flags ) ;
//#line  4687 "usb-audio.merged.sym.c"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  record_function("kmalloc");
  {
//#line  4694
  tmp___2 = __kmalloc(size, flags);
  }
//#line  4696
  return (tmp___2);
}
}
//#line  4700 "usb-audio.merged.sym.c"
__inline static void *( __attribute__((__always_inline__)) kcalloc)(size_t n , size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
  record_function("kcalloc");
//#line  4707
  if (size != 0UL) {
//#line  4709
    if (n > 0xffffffffffffffffUL / size) {
//#line  4711
      return ((void *)0);
    }
  }
  {
//#line  4715
  tmp = __kmalloc(n * size, flags | 32768U);
  }
//#line  4717
  return (tmp);
}
}
//#line  4721 "usb-audio.merged.sym.c"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
  record_function("kzalloc");
  {
//#line  4728
  tmp = kmalloc(size, flags | 32768U);
  }
//#line  4730
  return (tmp);
}
}
//#line  4734
static long schedule_timeout_uninterruptible(long timeout ) ;
//#line  4736
int param_set_int(char const   *val , struct kernel_param *kp ) ;
//#line  4738
int param_get_int(char *buffer , struct kernel_param *kp ) ;
//#line  4740
int param_set_charp(char const   *val , struct kernel_param *kp ) ;
//#line  4742
int param_get_charp(char *buffer , struct kernel_param *kp ) ;
//#line  4744
int param_set_bool(char const   *val , struct kernel_param *kp ) ;
//#line  4746
int param_get_bool(char *buffer , struct kernel_param *kp ) ;
//#line  4748
int param_array_set(char const   *val , struct kernel_param *kp ) ;
//#line  4750
int param_array_get(char *buffer , struct kernel_param *kp ) ;
//#line  4754
void cleanup_module(void) ;
//#line  4756
extern struct module __this_module ;
//#line  4758 "usb-audio.merged.sym.c"
__inline static void *( __attribute__((__always_inline__)) dev_get_drvdata)(struct device  const  *dev ) 
{ 


  {
  record_function("dev_get_drvdata");
//#line  4764
  return ((void *)dev->driver_data);
}
}
//#line  4768 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) dev_set_drvdata)(struct device *dev ,
                                                                           void *data ) 
{ 


  {
  record_function("dev_set_drvdata");
//#line  4775
  dev->driver_data = data;
//#line  4777
  return;
}
}
//#line  4781
unsigned long Nonstub_usb_host_interface(struct usb_interface_descriptor desc ) ;
//#line  4783
unsigned long Nonstub_get_size(unsigned long size ) ;
//#line  4785 "usb-audio.merged.sym.c"
__inline static void *( __attribute__((__always_inline__)) usb_get_intfdata)(struct usb_interface *intf ) 
{ 
  void *tmp ;

  {
  record_function("usb_get_intfdata");
  {
//#line  4791
  tmp = dev_get_drvdata((struct device  const  *)(& intf->dev));
  }
//#line  4793
  return (tmp);
}
}
//#line  4797 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) usb_set_intfdata)(struct usb_interface *intf ,
                                                                            void *data ) 
{ 


  {
  record_function("usb_set_intfdata");
  {
//#line  4804
  dev_set_drvdata(& intf->dev, data);
  }
//#line  4806
  return;
}
}
//#line  4810
static int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                                      void *priv ) ;
//#line  4813 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_interface_claimed)(struct usb_interface *iface ) 
{ 


  {
  record_function("usb_interface_claimed");
//#line  4819
  return ((unsigned long )iface->dev.driver != (unsigned long )((void *)0));
}
}
//#line  4823
static struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) ;
//#line  4825 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_make_path)(struct usb_device *dev ,
                                                                        char *buf ,
                                                                        size_t size ) 
{ 
  int actual ;
  int tmp ;

  {
  record_function("usb_make_path");
  {
//#line  4834
  actual = snprintf(buf, size, str_803117500, (dev->bus)->bus_name, dev->devpath);
  }
//#line  4836
  if (actual >= (int )size) {
//#line  4838
    tmp = -1;
  } else {
//#line  4841
    tmp = actual;
  }
//#line  4844
  return (tmp);
}
}
//#line  4862
static void usb_deregister(struct usb_driver * ) ;
//#line  4864
static struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) ;
//#line  4866
static void usb_free_urb(struct urb *urb ) ;
//#line  4868
static int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) ;
//#line  4870
static int usb_unlink_urb(struct urb *urb ) ;
//#line  4872
static void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags ,
                              dma_addr_t *dma ) ;
//#line  4875
static void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) ;
//#line  4877
static int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index , void *data ,
                           __u16 size , int timeout ) ;
//#line  4881
static int usb_get_descriptor(struct usb_device *dev , unsigned char desctype , unsigned char descindex ,
                              void *buf , int size ) ;
//#line  4884
static int usb_string(struct usb_device *dev , int index , char * __attribute__((__exp__(Nonstub_get_size("size")))) buf ,
                      size_t size ) ;
//#line  4887
static int usb_reset_configuration(struct usb_device *dev ) ;
//#line  4889
static int usb_set_interface(struct usb_device *dev , int ifnum , int alternate ) ;
//#line  4891 "usb-audio.merged.sym.c"
__inline static unsigned int ( __attribute__((__always_inline__)) __create_pipe)(struct usb_device *dev ,
                                                                                 unsigned int endpoint ) 
{ 


  {
  record_function("__create_pipe");
//#line  4898
  return ((unsigned int )(dev->devnum << 8) | (endpoint << 15));
}
}
//#line  4902 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) snd_power_change_state)(struct snd_card *card ,
                                                                                  unsigned int state ) 
{ 


  {
  record_function("snd_power_change_state");
  {
//#line  4909
  card->power_state = state;
//#line  4911
  __wake_up(& card->power_sleep, 3U, 1, (void *)0);
  }
//#line  4913
  return;
}
}
//#line  4917
static struct snd_card *snd_card_new(int idx , char const   *id , struct module *module ,
                                     int extra_size ) ;
//#line  4920
static int snd_card_disconnect(struct snd_card *card ) ;
//#line  4922
static int snd_card_free(struct snd_card *card ) ;
//#line  4924
static int snd_card_free_when_closed(struct snd_card *card ) ;
//#line  4926
static int snd_card_register(struct snd_card *card ) ;
//#line  4928
static int snd_component_add(struct snd_card *card , char const   *component ) ;
//#line  4930
static int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                          struct snd_device_ops *ops ) ;
//#line  4933 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) __snd_bug_on)(int cond ) 
{ 


  {
  record_function("__snd_bug_on");
//#line  4939
  return (0);
}
}
//#line  4943
int snd_iprintf(struct snd_info_buffer *buffer , char *fmt  , ...) ;
//#line  4946
static int snd_card_proc_new(struct snd_card *card , char const   *name , struct snd_info_entry **entryp ) ;
//#line  4949 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) snd_info_set_text_ops)(struct snd_info_entry *entry ,
                                                                                 void *private_data ,
                                                                                 void (*read)(struct snd_info_entry * ,
                                                                                              struct snd_info_buffer * ) ) 
{ 


  {
  record_function("snd_info_set_text_ops");
//#line  4958
  entry->private_data = (void * __attribute__((__noderef__)) )private_data;
//#line  4960
  entry->c.text.read = read;
//#line  4962
  return;
}
}
//#line  4966
static int snd_pcm_new(struct snd_card *card , char *id , int device , int playback_count ,
                       int capture_count , struct snd_pcm **rpcm ) ;
//#line  4969
static int snd_pcm_new_stream(struct snd_pcm *pcm , int stream , int substream_count ) ;
//#line  4971
static int snd_pcm_stop(struct snd_pcm_substream *substream , int status ) ;
//#line  4973
static int snd_pcm_suspend_all(struct snd_pcm *pcm ) ;
//#line  4975 "usb-audio.merged.sym.c"
__inline static snd_pcm_sframes_t ( __attribute__((__always_inline__)) bytes_to_frames)(struct snd_pcm_runtime *runtime ,
                                                                                        ssize_t size ) 
{ 


  {
  record_function("bytes_to_frames");
//#line  4982
  return ((size * 8L) / (ssize_t )runtime->frame_bits);
}
}
//#line  4986 "usb-audio.merged.sym.c"
__inline static struct snd_mask *( __attribute__((__always_inline__)) hw_param_mask)(struct snd_pcm_hw_params *params ,
                                                                                     snd_pcm_hw_param_t var ) 
{ 


  {
  record_function("hw_param_mask");
//#line  4993
  return (& params->masks[var]);
}
}
//#line  4997 "usb-audio.merged.sym.c"
__inline static struct snd_interval *( __attribute__((__always_inline__)) hw_param_interval)(struct snd_pcm_hw_params *params ,
                                                                                             snd_pcm_hw_param_t var ) 
{ 


  {
  record_function("hw_param_interval");
//#line  5004
  return (& params->intervals[var - 8]);
}
}
//#line  5008
static int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime , snd_pcm_hw_param_t var ,
                                        unsigned int min , unsigned int max ) ;
//#line  5011
static int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                      snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_list *l ) ;
//#line  5014
static int snd_pcm_format_physical_width(snd_pcm_format_t format ) ;
//#line  5016
static void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) ;
//#line  5018
int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
//#line  5021
static void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) ;
//#line  5023
static unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate ) ;
//#line  5025 "usb-audio.merged.sym.c"
__inline static unsigned int ( __attribute__((__always_inline__)) snd_mask_min)(struct snd_mask  const  *mask ) 
{ 
  int i ;
  int tmp ;

  {
  record_function("snd_mask_min");
//#line  5032
  i = 0;
  {
  {
//#line  5034
  while (1) {


    if (! (i < 2)) {
//#line  5034
      goto while_break;
    }
//#line  5036
    if (mask->bits[i]) {
      {
//#line  5038
      tmp = ffs((int )mask->bits[i]);
      }
//#line  5040
      return ((unsigned int )((tmp - 1) + (i << 5)));
    }
//#line  5043
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  5046
  return (0U);
}
}
//#line  5050 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) snd_mask_test)(struct snd_mask  const  *mask ,
                                                                        unsigned int val ) 
{ 


  {
  record_function("snd_mask_test");
//#line  5057
  return ((int )(mask->bits[val >> 5] & (1U << (val & 31U))));
}
}
//#line  5061 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) snd_interval_checkempty)(struct snd_interval  const  *i ) 
{ 
  int tmp ;

  {
  record_function("snd_interval_checkempty");
//#line  5067
  if (i->min > i->max) {
//#line  5069
    tmp = 1;
  } else
//#line  5072
  if (i->min == i->max) {
//#line  5074
    if (i->openmin) {
//#line  5076
      tmp = 1;
    } else
//#line  5079
    if (i->openmax) {
//#line  5081
      tmp = 1;
    } else {
//#line  5084
      tmp = 0;
    }
  } else {
//#line  5088
    tmp = 0;
  }
//#line  5091
  return (tmp);
}
}
//#line  5095
static unsigned int snd_usb_combine_bytes(unsigned char *bytes , int size ) ;
//#line  5097
static void *snd_usb_find_desc(void *descstart , int desclen , void *after , u8 dtype ) ;
//#line  5099
static void *snd_usb_find_csint_desc(void *buffer , int buflen , void *after , u8 dsubtype ) ;
//#line  5101
static int snd_usb_ctl_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index___0 , void *data ,
                           __u16 size , int timeout ) ;
//#line  5104
static int snd_usb_create_mixer(struct snd_usb_audio *chip , int ctrlif , int ignore_error ) ;
//#line  5106
static void snd_usb_mixer_disconnect(struct list_head *p ) ;
//#line  5108
static int snd_usb_create_midi_interface(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                         struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5111
static void snd_usbmidi_disconnect(struct list_head *p ) ;
//#line  5113 "usb-audio.merged.sym.c"
unsigned long Nonstub_get_size(unsigned long size ) 
{ 


  {
  record_function("Nonstub_get_size");
//#line  5119
  return (size);
}
}
//#line  5123 "usb-audio.merged.sym.c"
unsigned long Nonstub_usb_host_interface(struct usb_interface_descriptor desc ) 
{ 


  {
  record_function("Nonstub_usb_host_interface");
//#line  5129
  return ((unsigned long )desc.bNumEndpoints);
}
}
static char const   __mod_author74[36]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5133
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'T', 
        (char const   )'a',      (char const   )'k',      (char const   )'a',      (char const   )'s', 
        (char const   )'h',      (char const   )'i',      (char const   )' ',      (char const   )'I', 
        (char const   )'w',      (char const   )'a',      (char const   )'i',      (char const   )' ', 
        (char const   )'<',      (char const   )'t',      (char const   )'i',      (char const   )'w', 
        (char const   )'a',      (char const   )'i',      (char const   )'@',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'.', 
        (char const   )'d',      (char const   )'e',      (char const   )'>',      (char const   )'\000'};
static char const   __mod_description75[22]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  5145
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'A',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )'\000'};
static char const   __mod_license76[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5155
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
static int index[32]  = 
//#line  5161
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
static char *id[32]  = 
//#line  5172
  {      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0)};
static int enable[32]  = 
//#line  5183
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
static int vid[32]  = 
//#line  5194
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
static int pid[32]  = 
//#line  5205
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
//#line  5216 "usb-audio.merged.sym.c"
static int nrpacks  =    8;
//#line  5218 "usb-audio.merged.sym.c"
static int async_unlink  =    1;
//#line  5220 "usb-audio.merged.sym.c"
static int device_setup[32]  ;
//#line  5222 "usb-audio.merged.sym.c"
static int ignore_ctl_error  ;
//#line  5224 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_index  =    {(unsigned int )(sizeof(index) / sizeof(index[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(index[0]),
    (void *)(index)};
//#line  5228 "usb-audio.merged.sym.c"
static char const   __param_str_index[6]  = {      (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000'};
//#line  5231 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_index  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_index, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_index}};
static char const   __mod_indextype91[28]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5234
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_index92[50]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5244
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'I', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )'\000'};
//#line  5260 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_id  =    {(unsigned int )(sizeof(id) / sizeof(id[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_charp, & param_get_charp, (unsigned int )sizeof(id[0]), (void *)(id)};
//#line  5263 "usb-audio.merged.sym.c"
static char const   __param_str_id[3]  = {      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  5265 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_id  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_id, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_id}};
static char const   __mod_idtype93[27]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5268
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'p',      (char const   )'\000'};
static char const   __mod_id94[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5278
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'U',      (char const   )'S', 
        (char const   )'B',      (char const   )' ',      (char const   )'a',      (char const   )'u', 
        (char const   )'d',      (char const   )'i',      (char const   )'o',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'a',      (char const   )'p', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'.', 
        (char const   )'\000'};
//#line  5293 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_enable  =    {(unsigned int )(sizeof(enable) / sizeof(enable[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_bool, & param_get_bool, (unsigned int )sizeof(enable[0]),
    (void *)(enable)};
//#line  5297 "usb-audio.merged.sym.c"
static char const   __param_str_enable[7]  = {      (char const   )'e',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
//#line  5300 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_enable  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_enable}};
static char const   __mod_enabletype95[30]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5303
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
static char const   __mod_enable96[38]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5314
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'E',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'a', 
        (char const   )'p',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'.',      (char const   )'\000'};
//#line  5327 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_vid  =    {(unsigned int )(sizeof(vid) / sizeof(vid[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_int, & param_get_int, (unsigned int )sizeof(vid[0]), (void *)(vid)};
//#line  5330 "usb-audio.merged.sym.c"
static char const   __param_str_vid[4]  = {      (char const   )'v',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  5332 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_vid  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_vid, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_vid}};
static char const   __mod_vidtype97[26]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5335
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'v',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static char const   __mod_vid98[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5345
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'v',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'V',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )' ',      (char const   )'U', 
        (char const   )'S',      (char const   )'B',      (char const   )' ',      (char const   )'a', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )' ',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'.', 
        (char const   )'\000'};
//#line  5360 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_pid  =    {(unsigned int )(sizeof(pid) / sizeof(pid[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_int, & param_get_int, (unsigned int )sizeof(pid[0]), (void *)(pid)};
//#line  5363 "usb-audio.merged.sym.c"
static char const   __param_str_pid[4]  = {      (char const   )'p',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
//#line  5365 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_pid  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_pid, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_pid}};
static char const   __mod_pidtype99[26]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5368
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'p',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static char const   __mod_pid100[46]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5378
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'p',      (char const   )'i',      (char const   )'d', 
        (char const   )':',      (char const   )'P',      (char const   )'r',      (char const   )'o', 
        (char const   )'d',      (char const   )'u',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'I',      (char const   )'D',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'t',      (char const   )'h',      (char const   )'e',      (char const   )' ', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'a',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'.',      (char const   )'\000'};
static char const   __param_str_nrpacks[8]  = 
//#line  5393
  {      (char const   )'n',      (char const   )'r',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'\000'};
//#line  5398 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_nrpacks  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_nrpacks, 420U, & param_set_int, & param_get_int, {(void *)(& nrpacks)}};
static char const   __mod_nrpackstype101[21]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5401
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'n',      (char const   )'r',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'s', 
        (char const   )':',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static char const   __mod_nrpacks102[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  5411
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'n',      (char const   )'r',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'s', 
        (char const   )':',      (char const   )'M',      (char const   )'a',      (char const   )'x', 
        (char const   )'.',      (char const   )' ',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'b',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'p',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'e',      (char const   )'t',      (char const   )'s',      (char const   )' ', 
        (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'U',      (char const   )'R',      (char const   )'B',      (char const   )'.', 
        (char const   )'\000'};
static char const   __param_str_async_unlink[13]  = 
//#line  5426
  {      (char const   )'a',      (char const   )'s',      (char const   )'y',      (char const   )'n', 
        (char const   )'c',      (char const   )'_',      (char const   )'u',      (char const   )'n', 
        (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'k', 
        (char const   )'\000'};
//#line  5433 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_async_unlink  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_async_unlink, 292U, & param_set_bool, & param_get_bool, {(void *)(& async_unlink)}};
static char const   __mod_async_unlinktype103[27]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5436
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'k',      (char const   )':',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'\000'};
static char const   __mod_async_unlink104[41]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  5447
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'a',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'_',      (char const   )'u', 
        (char const   )'n',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'k',      (char const   )':',      (char const   )'U',      (char const   )'s', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )' ', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'k',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'.', 
        (char const   )'\000'};
//#line  5462 "usb-audio.merged.sym.c"
static struct kparam_array  const  __param_arr_device_setup  =    {(unsigned int )(sizeof(device_setup) / sizeof(device_setup[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(device_setup[0]),
    (void *)(device_setup)};
static char const   __param_str_device_setup[13]  = 
//#line  5466
  {      (char const   )'d',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'c',      (char const   )'e',      (char const   )'_',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'u',      (char const   )'p', 
        (char const   )'\000'};
//#line  5473 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_device_setup  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_device_setup, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_device_setup}};
static char const   __mod_device_setuptype105[35]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5476
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'u', 
        (char const   )'p',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_device_setup106[53]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  5489
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'i',      (char const   )'c',      (char const   )'e',      (char const   )'_', 
        (char const   )'s',      (char const   )'e',      (char const   )'t',      (char const   )'u', 
        (char const   )'p',      (char const   )':',      (char const   )'S',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'i',      (char const   )'c',      (char const   )' ',      (char const   )'d', 
        (char const   )'e',      (char const   )'v',      (char const   )'i',      (char const   )'c', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'u',      (char const   )'p',      (char const   )' ', 
        (char const   )'(',      (char const   )'i',      (char const   )'f',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'e',      (char const   )'d', 
        (char const   )'e',      (char const   )'d',      (char const   )')',      (char const   )'.', 
        (char const   )'\000'};
static char const   __param_str_ignore_ctl_error[17]  = 
//#line  5507
  {      (char const   )'i',      (char const   )'g',      (char const   )'n',      (char const   )'o', 
        (char const   )'r',      (char const   )'e',      (char const   )'_',      (char const   )'c', 
        (char const   )'t',      (char const   )'l',      (char const   )'_',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )'\000'};
//#line  5515 "usb-audio.merged.sym.c"
static struct kernel_param  const  __param_ignore_ctl_error  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_ignore_ctl_error, 292U, & param_set_bool, & param_get_bool, {(void *)(& ignore_ctl_error)}};
static char const   __mod_ignore_ctl_errortype107[31]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  5518
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'c',      (char const   )'t',      (char const   )'l',      (char const   )'_', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'b',      (char const   )'o', 
        (char const   )'o',      (char const   )'l',      (char const   )'\000'};
static char const   __mod_ignore_ctl_error109[78]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  5530
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'g',      (char const   )'n', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )'_', 
        (char const   )'c',      (char const   )'t',      (char const   )'l',      (char const   )'_', 
        (char const   )'e',      (char const   )'r',      (char const   )'r',      (char const   )'o', 
        (char const   )'r',      (char const   )':',      (char const   )'I',      (char const   )'g', 
        (char const   )'n',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'e',      (char const   )'r',      (char const   )'r', 
        (char const   )'o',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'f',      (char const   )'r',      (char const   )'o',      (char const   )'m', 
        (char const   )' ',      (char const   )'U',      (char const   )'S',      (char const   )'B', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'n', 
        (char const   )'t',      (char const   )'r',      (char const   )'o',      (char const   )'l', 
        (char const   )'l',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'i',      (char const   )'x',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'f', 
        (char const   )'a',      (char const   )'c',      (char const   )'e',      (char const   )'s', 
        (char const   )'.',      (char const   )'\000'};
//#line  5554
void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) ;
//#line  5557
void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5559 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_122l_ops  =    {& snd_usbmidi_us122l_input, & snd_usbmidi_us122l_output, (void (*)(struct urb * ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5566
static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                       int buffer_length ) ;
//#line  5569
void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5571
void snd_usbmidi_output_standard_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                        uint8_t p2 , uint8_t p3 ) ;
//#line  5574 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_standard_ops  =    {& snd_usbmidi_standard_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_standard_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5577
void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                               int buffer_length ) ;
//#line  5580
void snd_usbmidi_output_midiman_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                       uint8_t p2 , uint8_t p3 ) ;
//#line  5583 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_midiman_ops  =    {& snd_usbmidi_midiman_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_midiman_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5586
void snd_usbmidi_maudio_broken_running_status_input(struct snd_usb_midi_in_endpoint *ep ,
                                                    uint8_t *buffer , int buffer_length ) ;
//#line  5589 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_maudio_broken_running_status_ops  =    {& snd_usbmidi_maudio_broken_running_status_input, & snd_usbmidi_standard_output,
    & snd_usbmidi_output_standard_packet, (void (*)(struct snd_usb_midi_out_endpoint * ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5593
void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) ;
//#line  5596 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_cme_ops  =    {& snd_usbmidi_cme_input, & snd_usbmidi_standard_output, & snd_usbmidi_output_standard_packet,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5599
void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) ;
//#line  5602
void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5604
void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5606
void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5608 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_emagic_ops  =    {& snd_usbmidi_emagic_input, & snd_usbmidi_emagic_output, (void (*)(struct urb * ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ,
                                                                       uint8_t  ))0,
    & snd_usbmidi_emagic_init_out, & snd_usbmidi_emagic_finish_out};
//#line  5615
void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) ;
//#line  5618
void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5620 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_novation_ops  =    {& snd_usbmidi_novation_input, & snd_usbmidi_novation_output, (void (*)(struct urb * ,
                                                                           uint8_t  ,
                                                                           uint8_t  ,
                                                                           uint8_t  ,
                                                                           uint8_t  ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5627
void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) ;
//#line  5630
void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep ) ;
//#line  5632 "usb-audio.merged.sym.c"
struct usb_protocol_ops snd_usbmidi_raw_ops  =    {& snd_usbmidi_raw_input, & snd_usbmidi_raw_output, (void (*)(struct urb * , uint8_t  ,
                                                                 uint8_t  , uint8_t  ,
                                                                 uint8_t  ))0, (void (*)(struct snd_usb_midi_out_endpoint * ))0,
    (void (*)(struct snd_usb_midi_out_endpoint * ))0};
//#line  5637
static int ignore_interface_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5640
static int create_composite_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5643
static int create_standard_audio_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                       struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5646
static int create_fixed_stream_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                     struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5649
static int create_ua1000_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                               struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5652
static int create_ua101_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                              struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  5655
static int create_uaxx_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                             struct snd_usb_audio_quirk  const  *quirk ) ;
static quirk_func_t const   quirk_funcs[16]  = 
//#line  5658
  {      (int (* const  )(struct snd_usb_audio * , struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& ignore_interface_quirk),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_composite_quirk),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface), 
        (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface), 
        (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& snd_usb_create_midi_interface),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))0,      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_standard_audio_quirk), 
        (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_fixed_stream_quirk),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_ua1000_quirk),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_ua101_quirk),      (int (* const  )(struct snd_usb_audio * ,
                      struct usb_interface * , struct snd_usb_audio_quirk  const  * ))(& create_uaxx_quirk)};
//#line  5665 "usb-audio.merged.sym.c"
static struct mutex register_mutex  =    {{(int volatile   )1}, {{0U}, 3735899821U, 4294967295U, (void *)-1L, {(struct lock_class_key *)0,
                                                                         (struct lock_class *)0,
                                                                         str_690022538}},
    {(struct list_head *)(& register_mutex.wait_list), (struct list_head *)(& register_mutex.wait_list)},
    (struct thread_info *)0, (char const   *)0, (void *)(& register_mutex), {(struct lock_class_key *)0,
                                                                             (struct lock_class *)0,
                                                                             str_1014490587}};
//#line  5674 "usb-audio.merged.sym.c"
static struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) usb_chip[32]  ;
//#line  5676 "usb-audio.merged.sym.c"
__inline static unsigned int ( __attribute__((__always_inline__)) get_usb_full_speed_rate)(unsigned int rate ) 
{ 


  {
  record_function("get_usb_full_speed_rate");
//#line  5682
  return (((rate << 13) + 62U) / 125U);
}
}
//#line  5686 "usb-audio.merged.sym.c"
__inline static unsigned int ( __attribute__((__always_inline__)) get_usb_high_speed_rate)(unsigned int rate ) 
{ 


  {
  record_function("get_usb_high_speed_rate");
//#line  5692
  return (((rate << 10) + 62U) / 125U);
}
}
//#line  5696 "usb-audio.merged.sym.c"
static int prepare_capture_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                    struct urb *urb ) 
{ 
  unsigned char *cp ;
  struct snd_urb_ctx *ctx ;

  {
  record_function("prepare_capture_sync_urb");
//#line  5704
  cp = urb->transfer_buffer;
//#line  5706
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  5708
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  5710
  urb->iso_frame_desc[0].length = 3U;
//#line  5712
  urb->iso_frame_desc[0].offset = 0U;
//#line  5714
  *(cp + 0) = (unsigned char )(subs->freqn >> 2);
//#line  5716
  *(cp + 1) = (unsigned char )(subs->freqn >> 10);
//#line  5718
  *(cp + 2) = (unsigned char )(subs->freqn >> 18);
//#line  5720
  return (0);
}
}
//#line  5724 "usb-audio.merged.sym.c"
static int prepare_capture_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned char *cp ;
  struct snd_urb_ctx *ctx ;

  {
  record_function("prepare_capture_sync_urb_hs");
//#line  5732
  cp = urb->transfer_buffer;
//#line  5734
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  5736
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  5738
  urb->iso_frame_desc[0].length = 4U;
//#line  5740
  urb->iso_frame_desc[0].offset = 0U;
//#line  5742
  *(cp + 0) = (unsigned char )subs->freqn;
//#line  5744
  *(cp + 1) = (unsigned char )(subs->freqn >> 8);
//#line  5746
  *(cp + 2) = (unsigned char )(subs->freqn >> 16);
//#line  5748
  *(cp + 3) = (unsigned char )(subs->freqn >> 24);
//#line  5750
  return (0);
}
}
//#line  5754 "usb-audio.merged.sym.c"
static int retire_capture_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                   struct urb *urb ) 
{ 


  {
  record_function("retire_capture_sync_urb");
//#line  5761
  return (0);
}
}
//#line  5765 "usb-audio.merged.sym.c"
static int prepare_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                               struct urb *urb ) 
{ 
  int i ;
  int offs ;
  struct snd_urb_ctx *ctx ;

  {
  record_function("prepare_capture_urb");
//#line  5774
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  5776
  offs = 0;
//#line  5778
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  5780
  i = 0;
  {
  {
//#line  5782
  while (1) {


    if (! (i < ctx->packets)) {
//#line  5782
      goto while_break;
    }
//#line  5784
    urb->iso_frame_desc[i].offset = (unsigned int )offs;
//#line  5786
    urb->iso_frame_desc[i].length = subs->curpacksize;
//#line  5788
    offs = (int )((unsigned int )offs + subs->curpacksize);
//#line  5790
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  5793
  urb->transfer_buffer_length = offs;
//#line  5795
  urb->number_of_packets = ctx->packets;
//#line  5797
  return (0);
}
}
//#line  5801 "usb-audio.merged.sym.c"
static int retire_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                              struct urb *urb ) 
{ 
  unsigned long flags ;
  unsigned char *cp ;
  int i ;
  unsigned int stride ;
  unsigned int len ;
  unsigned int oldptr ;
  int period_elapsed ;
  unsigned int cnt ;
  unsigned int blen ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
  record_function("retire_capture_urb");
//#line  5822
  period_elapsed = 0;
//#line  5824
  stride = runtime->frame_bits >> 3;
//#line  5826
  i = 0;
  {
  {
//#line  5828
  while (1) {


    if (! (i < urb->number_of_packets)) {
//#line  5828
      goto while_break;
    }
//#line  5830
    cp = urb->transfer_buffer + urb->iso_frame_desc[i].offset;
//#line  5832
    if (urb->iso_frame_desc[i].status) {
      {
//#line  5834
      printk(str_756280652, i, urb->iso_frame_desc[i].status);
      }
    }
//#line  5837
    len = urb->iso_frame_desc[i].actual_length / stride;
//#line  5839
    if (! len) {
//#line  5841
      goto __Cont;
    }
    {
    {
//#line  5844
    while (1) {


      {
//#line  5846
      flags = _spin_lock_irqsave(& subs->lock);
      }
//#line  5848
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  5851
    oldptr = subs->hwptr_done;
//#line  5853
    subs->hwptr_done += len;
//#line  5855
    if ((snd_pcm_uframes_t )subs->hwptr_done >= runtime->buffer_size) {
//#line  5857
      subs->hwptr_done = (unsigned int )((snd_pcm_uframes_t )subs->hwptr_done - runtime->buffer_size);
    }
//#line  5860
    subs->transfer_done += len;
//#line  5862
    if ((snd_pcm_uframes_t )subs->transfer_done >= runtime->period_size) {
//#line  5864
      subs->transfer_done = (unsigned int )((snd_pcm_uframes_t )subs->transfer_done - runtime->period_size);
//#line  5866
      period_elapsed = 1;
    }
    {
    {
//#line  5869
    while (1) {


      {
//#line  5871
      _spin_unlock_irqrestore(& subs->lock, flags);
      }
//#line  5873
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
//#line  5876
    if ((snd_pcm_uframes_t )(oldptr + len) > runtime->buffer_size) {
      {
//#line  5878
      cnt = (unsigned int )(runtime->buffer_size - (snd_pcm_uframes_t )oldptr);
//#line  5880
      blen = cnt * stride;
//#line  5882
      __len = (size_t )blen;
//#line  5884
      __ret = __builtin_memcpy((void *)(runtime->dma_area + oldptr * stride), (void const   *)cp,
                               __len);
//#line  5887
      __len___0 = (size_t )(len * stride - blen);
//#line  5889
      __ret___0 = __builtin_memcpy((void *)runtime->dma_area, (void const   *)(cp + blen),
                                   __len___0);
      }
    } else {
      {
//#line  5893
      __len___1 = (size_t )(len * stride);
//#line  5895
      __ret___1 = __builtin_memcpy((void *)(runtime->dma_area + oldptr * stride),
                                   (void const   *)cp, __len___1);
      }
    }
    __Cont: 
//#line  5900
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  5903
  if (period_elapsed) {
    {
//#line  5905
    snd_pcm_period_elapsed((struct snd_pcm_substream *)subs->pcm_substream);
    }
  }
//#line  5908
  return (0);
}
}
//#line  5912 "usb-audio.merged.sym.c"
static int retire_paused_capture_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                     struct urb *urb ) 
{ 


  {
  record_function("retire_paused_capture_urb");
//#line  5919
  return (0);
}
}
//#line  5923 "usb-audio.merged.sym.c"
static int prepare_playback_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                     struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;

  {
  record_function("prepare_playback_sync_urb");
//#line  5930
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  5932
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  5934
  urb->iso_frame_desc[0].length = 3U;
//#line  5936
  urb->iso_frame_desc[0].offset = 0U;
//#line  5938
  return (0);
}
}
//#line  5942 "usb-audio.merged.sym.c"
static int prepare_playback_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                        struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;

  {
  record_function("prepare_playback_sync_urb_hs");
//#line  5949
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  5951
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  5953
  urb->iso_frame_desc[0].length = 4U;
//#line  5955
  urb->iso_frame_desc[0].offset = 0U;
//#line  5957
  return (0);
}
}
//#line  5961 "usb-audio.merged.sym.c"
static int retire_playback_sync_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                    struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
  record_function("retire_playback_sync_urb");
//#line  5969
  if (urb->iso_frame_desc[0].status == 0) {
//#line  5971
    if (urb->iso_frame_desc[0].actual_length == 3U) {
//#line  5973
      f = (((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) << 2;
//#line  5975
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  5977
        if (f <= subs->freqmax) {
          {
          {
//#line  5979
          while (1) {


            {
//#line  5981
            flags = _spin_lock_irqsave(& subs->lock);
            }
//#line  5983
            goto while_break;
          }

          }
          while_break: /* CIL Label */ ;
          }
//#line  5986
          subs->freqm = f;
          {
          {
//#line  5988
          while (1) {


            {
//#line  5990
            _spin_unlock_irqrestore(& subs->lock, flags);
            }
//#line  5992
            goto while_break___0;
          }

          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
//#line  5999
  return (0);
}
}
//#line  6003 "usb-audio.merged.sym.c"
static int retire_playback_sync_urb_hs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
  record_function("retire_playback_sync_urb_hs");
//#line  6011
  if (urb->iso_frame_desc[0].status == 0) {
//#line  6013
    if (urb->iso_frame_desc[0].actual_length == 4U) {
//#line  6015
      f = ((((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) | ((unsigned int )*(urb->transfer_buffer + 3) << 24)) & 268435455U;
//#line  6017
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  6019
        if (f <= subs->freqmax) {
          {
          {
//#line  6021
          while (1) {


            {
//#line  6023
            flags = _spin_lock_irqsave(& subs->lock);
            }
//#line  6025
            goto while_break;
          }

          }
          while_break: /* CIL Label */ ;
          }
//#line  6028
          subs->freqm = f;
          {
          {
//#line  6030
          while (1) {


            {
//#line  6032
            _spin_unlock_irqrestore(& subs->lock, flags);
            }
//#line  6034
            goto while_break___0;
          }

          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
//#line  6041
  return (0);
}
}
//#line  6045 "usb-audio.merged.sym.c"
static int retire_playback_sync_urb_hs_emu(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                           struct urb *urb ) 
{ 
  unsigned int f ;
  unsigned long flags ;

  {
  record_function("retire_playback_sync_urb_hs_emu");
//#line  6053
  if (urb->iso_frame_desc[0].status == 0) {
//#line  6055
    if (urb->iso_frame_desc[0].actual_length == 4U) {
//#line  6057
      f = ((((unsigned int )*(urb->transfer_buffer) | ((unsigned int )*(urb->transfer_buffer + 1) << 8)) | ((unsigned int )*(urb->transfer_buffer + 2) << 16)) | ((unsigned int )*(urb->transfer_buffer + 3) << 24)) & 268435455U;
//#line  6059
      f >>= subs->datainterval;
//#line  6061
      if (f >= subs->freqn - subs->freqn / 8U) {
//#line  6063
        if (f <= subs->freqmax) {
          {
          {
//#line  6065
          while (1) {


            {
//#line  6067
            flags = _spin_lock_irqsave(& subs->lock);
            }
//#line  6069
            goto while_break;
          }

          }
          while_break: /* CIL Label */ ;
          }
//#line  6072
          subs->freqm = f;
          {
          {
//#line  6074
          while (1) {


            {
//#line  6076
            _spin_unlock_irqrestore(& subs->lock, flags);
            }
//#line  6078
            goto while_break___0;
          }

          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
    }
  }
//#line  6085
  return (0);
}
}
//#line  6089 "usb-audio.merged.sym.c"
static int snd_usb_audio_next_packet_size(struct snd_usb_substream *subs ) 
{ 
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp ;

  {
  record_function("snd_usb_audio_next_packet_size");
//#line  6097
  if (subs->fill_max) {
//#line  6099
    return ((int )subs->maxframesize);
  } else {
//#line  6102
    subs->phase = (subs->phase & 65535U) + (subs->freqm << subs->datainterval);
//#line  6104
    _min1 = subs->phase >> 16;
//#line  6106
    _min2 = subs->maxframesize;
//#line  6108
    if (_min1 < _min2) {
//#line  6110
      tmp = _min1;
    } else {
//#line  6113
      tmp = _min2;
    }
//#line  6116
    return ((int )tmp);
  }
}
}
//#line  6121 "usb-audio.merged.sym.c"
static int prepare_nodata_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                       struct urb *urb ) 
{ 
  unsigned int i ;
  unsigned int offs ;
  unsigned int counts ;
  struct snd_urb_ctx *ctx ;
  int stride ;
  int tmp ;
  int tmp___0 ;

  {
  record_function("prepare_nodata_playback_urb");
//#line  6134
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  6136
  stride = (int )(runtime->frame_bits >> 3);
//#line  6138
  offs = 0U;
//#line  6140
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  6142
  urb->number_of_packets = (int )subs->packs_per_ms;
//#line  6144
  i = 0U;
  {
  {
//#line  6146
  while (1) {


    if (! (i < subs->packs_per_ms)) {
//#line  6146
      goto while_break;
    }
    {
//#line  6148
    tmp = snd_usb_audio_next_packet_size(subs);
//#line  6150
    counts = (unsigned int )tmp;
//#line  6152
    urb->iso_frame_desc[i].offset = offs * (unsigned int )stride;
//#line  6154
    urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  6156
    offs += counts;
//#line  6158
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6161
  urb->transfer_buffer_length = (int )(offs * (unsigned int )stride);
//#line  6163
  if ((subs->cur_audiofmt)->format == 1) {
//#line  6165
    tmp___0 = 128;
  } else {
//#line  6168
    tmp___0 = 0;
  }
  {
//#line  6171
  memset((void *)urb->transfer_buffer, tmp___0, (size_t )(offs * (unsigned int )stride));
  }
//#line  6173
  return (0);
}
}
//#line  6177 "usb-audio.merged.sym.c"
static int prepare_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                                struct urb *urb ) 
{ 
  int i ;
  int stride ;
  int offs ;
  unsigned int counts ;
  unsigned long flags ;
  int period_elapsed ;
  struct snd_urb_ctx *ctx ;
  int tmp ;
  unsigned int len ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;

  {
  record_function("prepare_playback_urb");
//#line  6198
  period_elapsed = 0;
//#line  6200
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  6202
  stride = (int )(runtime->frame_bits >> 3);
//#line  6204
  offs = 0;
//#line  6206
  urb->dev = (struct usb_device *)(ctx->subs)->dev;
//#line  6208
  urb->number_of_packets = 0;
  {
  {
//#line  6210
  while (1) {


    {
//#line  6212
    flags = _spin_lock_irqsave(& subs->lock);
    }
//#line  6214
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6217
  i = 0;
  {
  {
//#line  6219
  while (1) {


    if (! (i < ctx->packets)) {
//#line  6219
      goto while_break___0;
    }
    {
//#line  6221
    tmp = snd_usb_audio_next_packet_size(subs);
//#line  6223
    counts = (unsigned int )tmp;
//#line  6225
    urb->iso_frame_desc[i].offset = (unsigned int )(offs * stride);
//#line  6227
    urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  6229
    offs = (int )((unsigned int )offs + counts);
//#line  6231
    (urb->number_of_packets) ++;
//#line  6233
    subs->transfer_done += counts;
    }
//#line  6235
    if ((snd_pcm_uframes_t )subs->transfer_done >= runtime->period_size) {
//#line  6237
      subs->transfer_done = (unsigned int )((snd_pcm_uframes_t )subs->transfer_done - runtime->period_size);
//#line  6239
      period_elapsed = 1;
//#line  6241
      if (subs->fmt_type == 2U) {
//#line  6243
        if (subs->transfer_done > 0U) {
//#line  6245
          offs = (int )((unsigned int )offs - subs->transfer_done);
//#line  6247
          counts -= subs->transfer_done;
//#line  6249
          urb->iso_frame_desc[i].length = counts * (unsigned int )stride;
//#line  6251
          subs->transfer_done = 0U;
        }
//#line  6254
        i ++;
//#line  6256
        if (i < ctx->packets) {
//#line  6258
          urb->iso_frame_desc[i].offset = (unsigned int )(offs * stride);
//#line  6260
          urb->iso_frame_desc[i].length = 0U;
//#line  6262
          (urb->number_of_packets) ++;
        }
//#line  6265
        goto while_break___0;
      }
    }
//#line  6269
    if (period_elapsed) {
//#line  6271
      if (((unsigned int )i & (subs->packs_per_ms - 1U)) == subs->packs_per_ms - 1U) {
//#line  6273
        goto while_break___0;
      }
    }
//#line  6277
    i ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  6280
  if ((snd_pcm_uframes_t )(subs->hwptr_done + (unsigned int )offs) > runtime->buffer_size) {
    {
//#line  6282
    len = (unsigned int )(runtime->buffer_size - (snd_pcm_uframes_t )subs->hwptr_done);
//#line  6284
    __len = (size_t )(len * (unsigned int )stride);
//#line  6286
    __ret = __builtin_memcpy((void *)urb->transfer_buffer, (void const   *)(runtime->dma_area + subs->hwptr_done * (unsigned int )stride),
                             __len);
//#line  6289
    __len___0 = (size_t )(((unsigned int )offs - len) * (unsigned int )stride);
//#line  6291
    __ret___0 = __builtin_memcpy((void *)(urb->transfer_buffer + len * (unsigned int )stride),
                                 (void const   *)runtime->dma_area, __len___0);
    }
  } else {
    {
//#line  6295
    __len___1 = (size_t )(offs * stride);
//#line  6297
    __ret___1 = __builtin_memcpy((void *)urb->transfer_buffer, (void const   *)(runtime->dma_area + subs->hwptr_done * (unsigned int )stride),
                                 __len___1);
    }
  }
//#line  6301
  subs->hwptr_done += (unsigned int )offs;
//#line  6303
  if ((snd_pcm_uframes_t )subs->hwptr_done >= runtime->buffer_size) {
//#line  6305
    subs->hwptr_done = (unsigned int )((snd_pcm_uframes_t )subs->hwptr_done - runtime->buffer_size);
  }
  {
  {
//#line  6308
  while (1) {


    {
//#line  6310
    _spin_unlock_irqrestore(& subs->lock, flags);
    }
//#line  6312
    goto while_break___1;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  6315
  urb->transfer_buffer_length = offs * stride;
//#line  6317
  if (period_elapsed) {
    {
//#line  6319
    snd_pcm_period_elapsed((struct snd_pcm_substream *)subs->pcm_substream);
    }
  }
//#line  6322
  return (0);
}
}
//#line  6326 "usb-audio.merged.sym.c"
static int retire_playback_urb(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ,
                               struct urb *urb ) 
{ 


  {
  record_function("retire_playback_urb");
//#line  6333
  return (0);
}
}
//#line  6337 "usb-audio.merged.sym.c"
static struct snd_urb_ops ( __attribute__((__noderef__, __address_space__(2))) audio_urb_ops)[2]  = {      {& prepare_nodata_playback_urb,
      & retire_playback_urb, & prepare_playback_sync_urb, & retire_playback_sync_urb}, 
        {& prepare_capture_urb,
      & retire_capture_urb, & prepare_capture_sync_urb, & retire_capture_sync_urb}};
//#line  6342 "usb-audio.merged.sym.c"
static struct snd_urb_ops ( __attribute__((__noderef__, __address_space__(2))) audio_urb_ops_high_speed)[2]  = {      {& prepare_nodata_playback_urb,
      & retire_playback_urb, & prepare_playback_sync_urb_hs, & retire_playback_sync_urb_hs}, 
        {& prepare_capture_urb,
      & retire_capture_urb, & prepare_capture_sync_urb_hs, & retire_capture_sync_urb}};
//#line  6347 "usb-audio.merged.sym.c"
static void snd_complete_urb(struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;
  struct snd_usb_substream *subs ;
  struct snd_pcm_substream *substream ;
  int err ;
  int tmp ;

  {
  record_function("snd_complete_urb");
//#line  6357
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  6359
  subs = ctx->subs;
//#line  6361
  substream = (struct snd_pcm_substream *)(ctx->subs)->pcm_substream;
//#line  6363
  err = 0;
//#line  6365
  if (subs->running) {
    {
//#line  6367
    tmp = (*(subs->ops.retire))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                urb);
    }
//#line  6370
    if (tmp) {
//#line  6372
      goto _L;
    } else {
//#line  6375
      goto _L___0;
    }
  } else
  _L___0: 
//#line  6380
  if (! subs->running) {
//#line  6382
    goto _L;
  } else {
    {
//#line  6385
    err = (*(subs->ops.prepare))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                 urb);
    }
//#line  6388
    if (err < 0) {
//#line  6390
      goto _L;
    } else {
      {
//#line  6393
      err = usb_submit_urb(urb, 32U);
      }
//#line  6395
      if (err < 0) {
        _L: 
        {
//#line  6398
        clear_bit(ctx->index, (unsigned long volatile   *)(& subs->active_mask));
        }
//#line  6400
        if (err < 0) {
          {
//#line  6402
          printk(str_721858797, err);
//#line  6404
          snd_pcm_stop(substream, 4);
          }
        }
      }
    }
  }
//#line  6410
  return;
}
}
//#line  6414 "usb-audio.merged.sym.c"
static void snd_complete_sync_urb(struct urb *urb ) 
{ 
  struct snd_urb_ctx *ctx ;
  struct snd_usb_substream *subs ;
  struct snd_pcm_substream *substream ;
  int err ;
  int tmp ;

  {
  record_function("snd_complete_sync_urb");
//#line  6424
  ctx = (struct snd_urb_ctx *)urb->context;
//#line  6426
  subs = ctx->subs;
//#line  6428
  substream = (struct snd_pcm_substream *)(ctx->subs)->pcm_substream;
//#line  6430
  err = 0;
//#line  6432
  if (subs->running) {
    {
//#line  6434
    tmp = (*(subs->ops.retire_sync))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                     urb);
    }
//#line  6437
    if (tmp) {
//#line  6439
      goto _L;
    } else {
//#line  6442
      goto _L___0;
    }
  } else
  _L___0: 
//#line  6447
  if (! subs->running) {
//#line  6449
    goto _L;
  } else {
    {
//#line  6452
    err = (*(subs->ops.prepare_sync))(subs, (struct snd_pcm_runtime *)substream->runtime,
                                      urb);
    }
//#line  6455
    if (err < 0) {
//#line  6457
      goto _L;
    } else {
      {
//#line  6460
      err = usb_submit_urb(urb, 32U);
      }
//#line  6462
      if (err < 0) {
        _L: 
        {
//#line  6465
        clear_bit(ctx->index + 16, (unsigned long volatile   *)(& subs->active_mask));
        }
//#line  6467
        if (err < 0) {
          {
//#line  6469
          printk(str_80732848, err);
//#line  6471
          snd_pcm_stop(substream, 4);
          }
        }
      }
    }
  }
//#line  6477
  return;
}
}
//#line  6481 "usb-audio.merged.sym.c"
static struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs , unsigned long offset ) 
{ 
  void *pageptr ;
  unsigned long tmp ;

  {
  record_function("snd_pcm_get_vmalloc_page");
  {
//#line  6488
  pageptr = (void *)((subs->runtime)->dma_area + offset);
//#line  6490
  tmp = __phys_addr((unsigned long )pageptr);
  }
//#line  6492
  return ((struct page *)0xffffe20000000000UL + (tmp >> 12));
}
}
//#line  6496 "usb-audio.merged.sym.c"
static int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs , size_t size ) 
{ 
  struct snd_pcm_runtime *runtime ;
  int new_size ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  record_function("snd_pcm_alloc_vmalloc_buffer");
  {
//#line  6506
  runtime = (struct snd_pcm_runtime *)subs->runtime;
//#line  6508
  tmp = get_order(size);
//#line  6510
  new_size = (1 << tmp) * 4096;
//#line  6512
  printk(str_248349902, size, new_size);
  }
//#line  6514
  if (runtime->dma_area) {
//#line  6516
    if (runtime->dma_bytes >= (size_t )new_size) {
//#line  6518
      return (0);
    }
    {
//#line  6521
    free_pages((unsigned long )runtime->dma_area, 4294967295U);
    }
  }
  {
//#line  6524
  tmp___0 = get_order(size);
//#line  6526
  tmp___1 = __get_free_pages(208U, (unsigned int )tmp___0);
//#line  6528
  runtime->dma_area = (unsigned char *)tmp___1;
  }
//#line  6530
  if (! runtime->dma_area) {
//#line  6532
    return (-12);
  }
//#line  6535
  runtime->dma_bytes = (size_t )new_size;
//#line  6537
  return (0);
}
}
//#line  6541 "usb-audio.merged.sym.c"
static int snd_pcm_free_vmalloc_buffer(struct snd_pcm_substream *subs ) 
{ 
  struct snd_pcm_runtime *runtime ;

  {
  record_function("snd_pcm_free_vmalloc_buffer");
  {
//#line  6547
  runtime = (struct snd_pcm_runtime *)subs->runtime;
//#line  6549
  free_pages((unsigned long )runtime->dma_area, 4294967295U);
//#line  6551
  runtime->dma_area = (unsigned char *)((void *)0);
  }
//#line  6553
  return (0);
}
}
//#line  6557 "usb-audio.merged.sym.c"
static int deactivate_urbs(struct snd_usb_substream *subs , int force , int can_sleep ) 
{ 
  unsigned int i ;
  struct urb *u ;
  int tmp ;
  int tmp___1 ;
  struct urb *u___0 ;
  int tmp___2 ;
  int tmp___4 ;

  {
  record_function("deactivate_urbs");
//#line  6569
  subs->running = 0U;
//#line  6571
  if (! force) {
//#line  6573
    if (((subs->stream)->chip)->shutdown) {
//#line  6575
      return (-77);
    }
  }
//#line  6579
  i = 0U;
  {
  {
//#line  6581
  while (1) {


    if (! (i < subs->nurbs)) {
//#line  6581
      goto while_break;
    }
    {
//#line  6583
    tmp___1 = variable_test_bit((int )i, (unsigned long const volatile   *)(& subs->active_mask));
    }
//#line  6585
    if (tmp___1) {
      {
//#line  6587
      tmp = test_and_set_bit((int )i, (unsigned long volatile   *)(& subs->unlink_mask));
      }
//#line  6589
      if (! tmp) {
        {
//#line  6591
        u = (struct urb *)subs->dataurb[i].urb;
//#line  6593
        usb_unlink_urb(u);
        }
      }
    }
//#line  6597
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6600
  if (subs->syncpipe) {
//#line  6602
    i = 0U;
    {
    {
//#line  6604
    while (1) {


      if (! (i < 4U)) {
//#line  6604
        goto while_break___0;
      }
      {
//#line  6606
      tmp___4 = variable_test_bit((int )(i + 16U), (unsigned long const volatile   *)(& subs->active_mask));
      }
//#line  6608
      if (tmp___4) {
        {
//#line  6610
        tmp___2 = test_and_set_bit((int )(i + 16U), (unsigned long volatile   *)(& subs->unlink_mask));
        }
//#line  6612
        if (! tmp___2) {
          {
//#line  6614
          u___0 = (struct urb *)subs->syncurb[i].urb;
//#line  6616
          usb_unlink_urb(u___0);
          }
        }
      }
//#line  6620
      i ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
  }
//#line  6624
  return (0);
}
}
//#line  6628 "usb-audio.merged.sym.c"
static char const   *usb_error_string(int err ) 
{ 


  {
  record_function("usb_error_string");
  {
  if (err == -19) {
//#line  6635
    goto case_neg_19;
  }
  if (err == -2) {
//#line  6638
    goto case_neg_2;
  }
  if (err == -32) {
//#line  6641
    goto case_neg_32;
  }
  if (err == -28) {
//#line  6644
    goto case_neg_28;
  }
  if (err == -108) {
//#line  6647
    goto case_neg_108;
  }
  if (err == -113) {
//#line  6650
    goto case_neg_113;
  }
  if (err == -22) {
//#line  6653
    goto case_neg_22;
  }
  if (err == -11) {
//#line  6654
    goto case_neg_22;
  }
  if (err == -27) {
//#line  6655
    goto case_neg_22;
  }
  if (err == -90) {
//#line  6656
    goto case_neg_22;
  }
//#line  6659
  goto switch_default;
  case_neg_19: /* CIL Label */ 
//#line  6637
  return ("no device");
  case_neg_2: /* CIL Label */ 
//#line  6640
  return ("endpoint not enabled");
  case_neg_32: /* CIL Label */ 
//#line  6643
  return ("endpoint stalled");
  case_neg_28: /* CIL Label */ 
//#line  6646
  return ("not enough bandwidth");
  case_neg_108: /* CIL Label */ 
//#line  6649
  return ("device disabled");
  case_neg_113: /* CIL Label */ 
//#line  6652
  return ("device suspended");
  case_neg_22: /* CIL Label */ 
//#line  6658
  return ("internal error");
  switch_default: /* CIL Label */ 
//#line  6661
  return ("unknown error");

  }
}
}
//#line  6666 "usb-audio.merged.sym.c"
static int start_urbs(struct snd_usb_substream *subs , struct snd_pcm_runtime *runtime ) 
{ 
  unsigned int i ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  record_function("start_urbs");
//#line  6679
  if (((subs->stream)->chip)->shutdown) {
//#line  6681
    return (-77);
  }
//#line  6684
  i = 0U;
  {
  {
//#line  6686
  while (1) {


    if (! (i < subs->nurbs)) {
//#line  6686
      goto while_break;
    }
    {
//#line  6688
    tmp = __snd_bug_on(0);
    }
//#line  6690
    if (tmp) {
//#line  6692
      return (-22);
    }
    {
//#line  6695
    tmp___0 = (*(subs->ops.prepare))(subs, runtime, (struct urb *)subs->dataurb[i].urb);
    }
//#line  6697
    if (tmp___0 < 0) {
      {
//#line  6699
      printk(str_433838956, i);
      }
//#line  6701
      goto __error;
    }
//#line  6704
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6707
  if (subs->syncpipe) {
//#line  6709
    i = 0U;
    {
    {
//#line  6711
    while (1) {


      if (! (i < 4U)) {
//#line  6711
        goto while_break___0;
      }
      {
//#line  6713
      tmp___1 = __snd_bug_on(0);
      }
//#line  6715
      if (tmp___1) {
//#line  6717
        return (-22);
      }
      {
//#line  6720
      tmp___2 = (*(subs->ops.prepare_sync))(subs, runtime, (struct urb *)subs->syncurb[i].urb);
      }
//#line  6722
      if (tmp___2 < 0) {
        {
//#line  6724
        printk(str_639341561, i);
        }
//#line  6726
        goto __error;
      }
//#line  6729
      i ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
  }
//#line  6733
  subs->active_mask = 0UL;
//#line  6735
  subs->unlink_mask = 0UL;
//#line  6737
  subs->running = 1U;
//#line  6739
  i = 0U;
  {
  {
//#line  6741
  while (1) {


    if (! (i < subs->nurbs)) {
//#line  6741
      goto while_break___1;
    }
    {
//#line  6743
    err = usb_submit_urb((struct urb *)subs->dataurb[i].urb, 32U);
    }
//#line  6745
    if (err < 0) {
      {
//#line  6747
      tmp___3 = usb_error_string(err);
//#line  6749
      printk(str_868332612, i, err, tmp___3);
      }
//#line  6751
      goto __error;
    }
    {
//#line  6754
    set_bit(i, (unsigned long volatile   *)(& subs->active_mask));
//#line  6756
    i ++;
    }
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  6759
  if (subs->syncpipe) {
//#line  6761
    i = 0U;
    {
    {
//#line  6763
    while (1) {


      if (! (i < 4U)) {
//#line  6763
        goto while_break___2;
      }
      {
//#line  6765
      err = usb_submit_urb((struct urb *)subs->syncurb[i].urb, 32U);
      }
//#line  6767
      if (err < 0) {
        {
//#line  6769
        tmp___4 = usb_error_string(err);
//#line  6771
        printk(str_447048969, i, err, tmp___4);
        }
//#line  6773
        goto __error;
      }
      {
//#line  6776
      set_bit(i + 16U, (unsigned long volatile   *)(& subs->active_mask));
//#line  6778
      i ++;
      }
    }

    }
    while_break___2: /* CIL Label */ ;
    }
  }
//#line  6782
  return (0);
  __error: 
  {
//#line  6785
  deactivate_urbs(subs, 0, 0);
  }
//#line  6787
  return (-32);
}
}
//#line  6791 "usb-audio.merged.sym.c"
static int wait_clear_urbs(struct snd_usb_substream *subs ) 
{ 
  unsigned long end_time ;
  unsigned long tmp ;
  unsigned int i ;
  int alive ;
  int tmp___1 ;
  int tmp___3 ;

  {
  record_function("wait_clear_urbs");
  {
//#line  6802
  tmp = msecs_to_jiffies(1000U);
//#line  6804
  end_time = (unsigned long )(jiffies + (unsigned long volatile   )tmp);
  }
  {
  {
//#line  6806
  while (1) {


//#line  6808
    alive = 0;
//#line  6810
    i = 0U;
    {
    {
//#line  6812
    while (1) {


      if (! (i < subs->nurbs)) {
//#line  6812
        goto while_break___0;
      }
      {
//#line  6814
      tmp___1 = variable_test_bit((int )i, (unsigned long const volatile   *)(& subs->active_mask));
      }
//#line  6816
      if (tmp___1) {
//#line  6818
        alive ++;
      }
//#line  6821
      i ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  6824
    if (subs->syncpipe) {
//#line  6826
      i = 0U;
      {
      {
//#line  6828
      while (1) {


        if (! (i < 4U)) {
//#line  6828
          goto while_break___1;
        }
        {
//#line  6830
        tmp___3 = variable_test_bit((int )(i + 16U), (unsigned long const volatile   *)(& subs->active_mask));
        }
//#line  6832
        if (tmp___3) {
//#line  6834
          alive ++;
        }
//#line  6837
        i ++;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
    }
//#line  6841
    if (! alive) {
//#line  6843
      goto while_break;
    }
    {
//#line  6846
    schedule_timeout_uninterruptible(1L);
    }
//#line  6848
    if (! ((long )jiffies - (long )end_time < 0L)) {
//#line  6850
      goto while_break;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6854
  if (alive) {
    {
//#line  6856
    printk(str_894397911, alive);
    }
  }
//#line  6859
  return (0);
}
}
//#line  6863 "usb-audio.merged.sym.c"
static snd_pcm_uframes_t snd_usb_pcm_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct snd_usb_substream *subs ;
  snd_pcm_uframes_t hwptr_done ;

  {
  record_function("snd_usb_pcm_pointer");
  {
//#line  6870
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  6872
  _spin_lock(& subs->lock);
//#line  6874
  hwptr_done = (snd_pcm_uframes_t )subs->hwptr_done;
//#line  6876
  _spin_unlock(& subs->lock);
  }
//#line  6878
  return (hwptr_done);
}
}
//#line  6882 "usb-audio.merged.sym.c"
static int snd_usb_pcm_playback_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;

  {
  record_function("snd_usb_pcm_playback_trigger");
//#line  6889
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
  {
  if (cmd == 1) {
//#line  6892
    goto case_1;
  }
  if (cmd == 4) {
//#line  6893
    goto case_1;
  }
  if (cmd == 0) {
//#line  6898
    goto case_0;
  }
  if (cmd == 3) {
//#line  6903
    goto case_3;
  }
//#line  6908
  goto switch_default;
  case_1: /* CIL Label */ 
//#line  6895
  subs->ops.prepare = & prepare_playback_urb;
//#line  6897
  return (0);
  case_0: /* CIL Label */ 
  {
//#line  6900
  tmp = deactivate_urbs(subs, 0, 0);
  }
//#line  6902
  return (tmp);
  case_3: /* CIL Label */ 
//#line  6905
  subs->ops.prepare = & prepare_nodata_playback_urb;
//#line  6907
  return (0);
  switch_default: /* CIL Label */ 
//#line  6910
  return (-22);

  }
}
}
//#line  6915 "usb-audio.merged.sym.c"
static int snd_usb_pcm_capture_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;
  int tmp___0 ;

  {
  record_function("snd_usb_pcm_capture_trigger");
//#line  6923
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
  {
  if (cmd == 1) {
//#line  6926
    goto case_1;
  }
  if (cmd == 0) {
//#line  6933
    goto case_0;
  }
  if (cmd == 3) {
//#line  6938
    goto case_3;
  }
  if (cmd == 4) {
//#line  6943
    goto case_4;
  }
//#line  6948
  goto switch_default;
  case_1: /* CIL Label */ 
  {
//#line  6928
  subs->ops.retire = & retire_capture_urb;
//#line  6930
  tmp = start_urbs(subs, (struct snd_pcm_runtime *)substream->runtime);
  }
//#line  6932
  return (tmp);
  case_0: /* CIL Label */ 
  {
//#line  6935
  tmp___0 = deactivate_urbs(subs, 0, 0);
  }
//#line  6937
  return (tmp___0);
  case_3: /* CIL Label */ 
//#line  6940
  subs->ops.retire = & retire_paused_capture_urb;
//#line  6942
  return (0);
  case_4: /* CIL Label */ 
//#line  6945
  subs->ops.retire = & retire_capture_urb;
//#line  6947
  return (0);
  switch_default: /* CIL Label */ 
//#line  6950
  return (-22);

  }
}
}
//#line  6955 "usb-audio.merged.sym.c"
static void release_urb_ctx(struct snd_urb_ctx *u ) 
{ 


  {
  record_function("release_urb_ctx");
//#line  6961
  if (u->urb) {
//#line  6963
    if (u->buffer_size) {
      {
//#line  6965
      usb_buffer_free((u->subs)->dev, (size_t )u->buffer_size, (void *)(u->urb)->transfer_buffer,
                      (u->urb)->transfer_dma);
      }
    }
    {
//#line  6969
    usb_free_urb((struct urb *)u->urb);
//#line  6971
    u->urb = (struct urb *)((void *)0);
    }
  }
//#line  6974
  return;
}
}
//#line  6978 "usb-audio.merged.sym.c"
static void release_substream_urbs(struct snd_usb_substream *subs , int force ) 
{ 
  int i ;

  {
  record_function("release_substream_urbs");
  {
//#line  6984
  deactivate_urbs(subs, force, 1);
//#line  6986
  wait_clear_urbs(subs);
//#line  6988
  i = 0;
  }
  {
  {
//#line  6990
  while (1) {


    if (! (i < 8)) {
//#line  6990
      goto while_break;
    }
    {
//#line  6992
    release_urb_ctx(& subs->dataurb[i]);
//#line  6994
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6997
  i = 0;
  {
  {
//#line  6999
  while (1) {


    if (! (i < 4)) {
//#line  6999
      goto while_break___0;
    }
    {
//#line  7001
    release_urb_ctx(& subs->syncurb[i]);
//#line  7003
    i ++;
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  7006
  usb_buffer_free(subs->dev, (size_t )16, (void *)subs->syncbuf, subs->sync_dma);
//#line  7008
  subs->syncbuf = (char *)((void *)0);
//#line  7010
  subs->nurbs = 0U;
  }
//#line  7012
  return;
}
}
//#line  7016 "usb-audio.merged.sym.c"
static int init_substream_urbs(struct snd_usb_substream *subs , unsigned int period_bytes ,
                               unsigned int rate , unsigned int frame_bits ) 
{ 
  unsigned int maxsize ;
  unsigned int n ;
  unsigned int i ;
  int is_playback ;
  unsigned int npacks[8] ;
  unsigned int urb_packs ;
  unsigned int total_packs ;
  unsigned int packs_per_ms ;
  unsigned int _max1 ;
  unsigned int _max2 ;
  unsigned int tmp ;
  unsigned int _min1 ;
  unsigned int _min2 ;
  unsigned int tmp___0 ;
  unsigned int minsize ;
  unsigned int _max1___0 ;
  unsigned int _max2___0 ;
  unsigned int tmp___1 ;
  struct snd_urb_ctx *u ;
  struct urb *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  struct snd_urb_ctx *u___0 ;
  struct urb *tmp___5 ;

  {
  record_function("init_substream_urbs");
//#line  7046
  is_playback = subs->direction == 0;
//#line  7048
  if ((unsigned int )(subs->dev)->speed == 2U) {
    {
//#line  7050
    subs->freqn = get_usb_full_speed_rate(rate);
    }
  } else {
    {
//#line  7053
    subs->freqn = get_usb_high_speed_rate(rate);
    }
  }
//#line  7056
  subs->freqm = subs->freqn;
//#line  7058
  if (subs->maxpacksize) {
//#line  7060
    maxsize = subs->maxpacksize;
//#line  7062
    subs->freqmax = maxsize / (frame_bits >> 3) << (16U - subs->datainterval);
  } else {
//#line  7065
    subs->freqmax = subs->freqn + (subs->freqn >> 2);
//#line  7067
    maxsize = (subs->freqmax + 65535U) * (frame_bits >> 3) >> (16U - subs->datainterval);
  }
//#line  7070
  subs->phase = 0U;
//#line  7072
  if (subs->fill_max) {
//#line  7074
    subs->curpacksize = subs->maxpacksize;
  } else {
//#line  7077
    subs->curpacksize = maxsize;
  }
//#line  7080
  if ((unsigned int )(subs->dev)->speed == 3U) {
//#line  7082
    packs_per_ms = (unsigned int )(8 >> subs->datainterval);
  } else {
//#line  7085
    packs_per_ms = 1U;
  }
//#line  7088
  subs->packs_per_ms = packs_per_ms;
//#line  7090
  if (is_playback) {
//#line  7092
    urb_packs = (unsigned int )nrpacks;
//#line  7094
    _max1 = urb_packs;
//#line  7096
    _max2 = 1U;
//#line  7098
    if (_max1 > _max2) {
//#line  7100
      tmp = _max1;
    } else {
//#line  7103
      tmp = _max2;
    }
//#line  7106
    urb_packs = tmp;
//#line  7108
    _min1 = urb_packs;
//#line  7110
    _min2 = 20U;
//#line  7112
    if (_min1 < _min2) {
//#line  7114
      tmp___0 = _min1;
    } else {
//#line  7117
      tmp___0 = _min2;
    }
//#line  7120
    urb_packs = tmp___0;
  } else {
//#line  7123
    urb_packs = 1U;
  }
//#line  7126
  urb_packs *= packs_per_ms;
//#line  7128
  if (is_playback) {
//#line  7130
    minsize = (subs->freqn >> (16U - subs->datainterval)) * (frame_bits >> 3);
//#line  7132
    if (subs->syncpipe) {
//#line  7134
      minsize -= minsize >> 3;
    }
//#line  7137
    _max1___0 = minsize;
//#line  7139
    _max2___0 = 1U;
//#line  7141
    if (_max1___0 > _max2___0) {
//#line  7143
      tmp___1 = _max1___0;
    } else {
//#line  7146
      tmp___1 = _max2___0;
    }
//#line  7149
    minsize = tmp___1;
//#line  7151
    total_packs = ((period_bytes + minsize) - 1U) / minsize;
//#line  7153
    total_packs = ((total_packs + packs_per_ms) - 1U) & ~ (packs_per_ms - 1U);
//#line  7155
    if (total_packs < 2U * packs_per_ms) {
//#line  7157
      total_packs = 2U * packs_per_ms;
    }
  } else {
//#line  7161
    total_packs = 8U * urb_packs;
  }
//#line  7164
  subs->nurbs = ((total_packs + urb_packs) - 1U) / urb_packs;
//#line  7166
  if (subs->nurbs > 8U) {
//#line  7168
    subs->nurbs = 8U;
//#line  7170
    total_packs = 8U * urb_packs;
  }
//#line  7173
  n = total_packs;
//#line  7175
  i = 0U;
  {
  {
//#line  7177
  while (1) {


    if (! (i < subs->nurbs)) {
//#line  7177
      goto while_break;
    }
//#line  7179
    if (n > urb_packs) {
//#line  7181
      npacks[i] = urb_packs;
    } else {
//#line  7184
      npacks[i] = n;
    }
//#line  7187
    n -= urb_packs;
//#line  7189
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  7192
  if (subs->nurbs <= 1U) {
//#line  7194
    subs->nurbs = 2U;
//#line  7196
    npacks[0] = (total_packs + 1U) / 2U;
//#line  7198
    npacks[1] = total_packs - npacks[0];
  } else
//#line  7201
  if (npacks[subs->nurbs - 1U] < packs_per_ms) {
//#line  7203
    if (subs->nurbs > 2U) {
//#line  7205
      npacks[0] += npacks[subs->nurbs - 1U];
//#line  7207
      (subs->nurbs) --;
    } else {
//#line  7210
      subs->nurbs = 2U;
//#line  7212
      npacks[0] = (total_packs + 1U) / 2U;
//#line  7214
      npacks[1] = total_packs - npacks[0];
    }
  }
//#line  7218
  i = 0U;
  {
  {
//#line  7220
  while (1) {


    if (! (i < subs->nurbs)) {
//#line  7220
      goto while_break___0;
    }
//#line  7222
    u = & subs->dataurb[i];
//#line  7224
    u->index = (int )i;
//#line  7226
    u->subs = subs;
//#line  7228
    u->packets = (int )npacks[i];
//#line  7230
    u->buffer_size = maxsize * (unsigned int )u->packets;
//#line  7232
    if (subs->fmt_type == 2U) {
//#line  7234
      (u->packets) ++;
    }
    {
//#line  7237
    tmp___2 = usb_alloc_urb(u->packets, 208U);
//#line  7239
    u->urb = (struct urb *)tmp___2;
    }
//#line  7241
    if (! u->urb) {
//#line  7243
      goto out_of_memory;
    }
    {
//#line  7246
    tmp___3 = usb_buffer_alloc(subs->dev, (size_t )u->buffer_size, 208U, & (u->urb)->transfer_dma);
//#line  7248
    (u->urb)->transfer_buffer = (u8 *)tmp___3;
    }
//#line  7250
    if (! (u->urb)->transfer_buffer) {
//#line  7252
      goto out_of_memory;
    }
//#line  7255
    (u->urb)->pipe = subs->datapipe;
//#line  7257
    (u->urb)->transfer_flags = 6U;
//#line  7259
    (u->urb)->interval = 1 << subs->datainterval;
//#line  7261
    (u->urb)->context = (u8 * __attribute__((__noderef__)) )u;
//#line  7263
    (u->urb)->complete = & snd_complete_urb;
//#line  7265
    i ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  7268
  if (subs->syncpipe) {
    {
//#line  7270
    tmp___4 = usb_buffer_alloc(subs->dev, (size_t )16, 208U, & subs->sync_dma);
//#line  7272
    subs->syncbuf = (char *)tmp___4;
    }
//#line  7274
    if (! subs->syncbuf) {
//#line  7276
      goto out_of_memory;
    }
//#line  7279
    i = 0U;
    {
    {
//#line  7281
    while (1) {


      if (! (i < 4U)) {
//#line  7281
        goto while_break___1;
      }
      {
//#line  7283
      u___0 = & subs->syncurb[i];
//#line  7285
      u___0->index = (int )i;
//#line  7287
      u___0->subs = subs;
//#line  7289
      u___0->packets = 1;
//#line  7291
      tmp___5 = usb_alloc_urb(1, 208U);
//#line  7293
      u___0->urb = (struct urb *)tmp___5;
      }
//#line  7295
      if (! u___0->urb) {
//#line  7297
        goto out_of_memory;
      }
//#line  7300
      (u___0->urb)->transfer_buffer = (u8 *)(subs->syncbuf + i * 4U);
//#line  7302
      (u___0->urb)->transfer_dma = subs->sync_dma + (dma_addr_t )(i * 4U);
//#line  7304
      (u___0->urb)->transfer_buffer_length = 4;
//#line  7306
      (u___0->urb)->pipe = subs->syncpipe;
//#line  7308
      (u___0->urb)->transfer_flags = 6U;
//#line  7310
      (u___0->urb)->number_of_packets = 1;
//#line  7312
      (u___0->urb)->interval = 1 << subs->syncinterval;
//#line  7314
      (u___0->urb)->context = (u8 * __attribute__((__noderef__)) )u___0;
//#line  7316
      (u___0->urb)->complete = & snd_complete_sync_urb;
//#line  7318
      i ++;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
  }
//#line  7322
  return (0);
  out_of_memory: 
  {
//#line  7325
  release_substream_urbs(subs, 0);
  }
//#line  7327
  return (-12);
}
}
//#line  7331 "usb-audio.merged.sym.c"
static struct audioformat *find_format(struct snd_usb_substream *subs , unsigned int format ,
                                       unsigned int rate , unsigned int channels ) 
{ 
  struct list_head *p ;
  struct audioformat *found ;
  int cur_attr ;
  int attr ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  unsigned int i ;

  {
  record_function("find_format");
//#line  7344
  found = (struct audioformat *)((void *)0);
//#line  7346
  cur_attr = 0;
//#line  7348
  p = (struct list_head *)subs->fmt_list.next;
  {
  {
//#line  7350
  while (1) {


    {
//#line  7352
    __builtin_prefetch((void const   *)p->next);
    }
//#line  7354
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  7356
      goto while_break;
    }
//#line  7359
    __mptr = (struct list_head  const  *)p;
//#line  7361
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  7363
    if ((unsigned int )fp->format != format) {
//#line  7365
      goto __Cont;
    } else
//#line  7368
    if (fp->channels != channels) {
//#line  7370
      goto __Cont;
    }
//#line  7373
    if (rate < fp->rate_min) {
//#line  7375
      goto __Cont;
    } else
//#line  7378
    if (rate > fp->rate_max) {
//#line  7380
      goto __Cont;
    }
//#line  7383
    if (! (fp->rates & (unsigned int )(1 << 30))) {
//#line  7385
      i = 0U;
      {
      {
//#line  7387
      while (1) {


        if (! (i < fp->nr_rates)) {
//#line  7387
          goto while_break___0;
        }
//#line  7389
        if (*(fp->rate_table + i) == rate) {
//#line  7391
          goto while_break___0;
        }
//#line  7394
        i ++;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
//#line  7397
      if (i >= fp->nr_rates) {
//#line  7399
        goto __Cont;
      }
    }
//#line  7403
    attr = (int )fp->ep_attr & 12;
//#line  7405
    if (! found) {
//#line  7407
      found = fp;
//#line  7409
      cur_attr = attr;
//#line  7411
      goto __Cont;
    }
//#line  7414
    if (attr != cur_attr) {
//#line  7416
      if (attr == 4) {
//#line  7418
        if (subs->direction == 0) {
//#line  7420
          goto __Cont;
        } else {
//#line  7423
          goto _L;
        }
      } else
      _L: 
//#line  7428
      if (attr == 8) {
//#line  7430
        if (subs->direction == 1) {
//#line  7432
          goto __Cont;
        }
      }
//#line  7436
      if (cur_attr == 4) {
//#line  7438
        if (subs->direction == 0) {
//#line  7440
          found = fp;
//#line  7442
          cur_attr = attr;
//#line  7444
          goto __Cont;
        } else {
//#line  7447
          goto _L___0;
        }
      } else
      _L___0: 
//#line  7452
      if (cur_attr == 8) {
//#line  7454
        if (subs->direction == 1) {
//#line  7456
          found = fp;
//#line  7458
          cur_attr = attr;
//#line  7460
          goto __Cont;
        }
      }
    }
//#line  7465
    if (fp->maxpacksize > found->maxpacksize) {
//#line  7467
      found = fp;
//#line  7469
      cur_attr = attr;
    }
    __Cont: 
//#line  7473
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  7476
  return (found);
}
}
//#line  7480 "usb-audio.merged.sym.c"
static int init_usb_pitch(struct usb_device *dev , int iface , struct usb_host_interface *alts ,
                          struct audioformat *fmt ) 
{ 
  unsigned int ep ;
  unsigned char data[1] ;
  int err ;
  unsigned int tmp ;

  {
  record_function("init_usb_pitch");
//#line  7490
  ep = (unsigned int )(alts->endpoint + 0)->desc.bEndpointAddress;
//#line  7492
  if ((int )fmt->attributes & 2) {
    {
//#line  7494
    data[0] = (unsigned char)1;
//#line  7496
    tmp = __create_pipe(dev, 0U);
//#line  7498
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )1, (__u8 )((1 << 5) | 2),
                          (__u16 )(2 << 8), (__u16 )ep, (void *)(data), (__u16 )1,
                          1000);
    }
//#line  7502
    if (err < 0) {
      {
//#line  7504
      printk(str_75292164, dev->devnum, iface, ep);
      }
//#line  7506
      return (err);
    }
  }
//#line  7510
  return (0);
}
}
//#line  7514 "usb-audio.merged.sym.c"
static int init_usb_sample_rate(struct usb_device *dev , int iface , struct usb_host_interface *alts ,
                                struct audioformat *fmt , int rate ) 
{ 
  unsigned int ep ;
  unsigned char data[3] ;
  int err ;
  int crate ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  record_function("init_usb_sample_rate");
//#line  7526
  ep = (unsigned int )(alts->endpoint + 0)->desc.bEndpointAddress;
//#line  7528
  if ((int )fmt->attributes & 1) {
    {
//#line  7530
    data[0] = (unsigned char )rate;
//#line  7532
    data[1] = (unsigned char )(rate >> 8);
//#line  7534
    data[2] = (unsigned char )(rate >> 16);
//#line  7536
    tmp = __create_pipe(dev, 0U);
//#line  7538
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )1, (__u8 )((1 << 5) | 2),
                          (__u16 )(1 << 8), (__u16 )ep, (void *)(data), (__u16 )3,
                          1000);
    }
//#line  7542
    if (err < 0) {
      {
//#line  7544
      printk(str_885550103, dev->devnum, iface, (int )fmt->altsetting, rate, ep);
      }
//#line  7547
      return (err);
    }
    {
//#line  7550
    tmp___0 = __create_pipe(dev, 0U);
//#line  7552
    err = snd_usb_ctl_msg(dev, ((unsigned int )(2 << 30) | tmp___0) | 128U, (__u8 )129,
                          (__u8 )(((1 << 5) | 2) | 128), (__u16 )(1 << 8), (__u16 )ep,
                          (void *)(data), (__u16 )3, 1000);
    }
//#line  7556
    if (err < 0) {
      {
//#line  7558
      printk(str_1041397175, dev->devnum, iface, (int )fmt->altsetting, ep);
      }
//#line  7561
      return (0);
    }
//#line  7564
    crate = ((int )data[0] | ((int )data[1] << 8)) | ((int )data[2] << 16);
//#line  7566
    if (crate != rate) {
      {
//#line  7568
      printk(str_515799417, crate, rate);
      }
    }
  }
//#line  7573
  return (0);
}
}
//#line  7577 "usb-audio.merged.sym.c"
static int set_format(struct snd_usb_substream *subs , struct audioformat *fmt ) 
{ 
  struct usb_device *dev ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct usb_interface *iface ;
  unsigned int ep ;
  unsigned int attr ;
  int is_playback ;
  int err ;
  int __ret_warn_on ;
  long tmp ;
  long tmp___0 ;
  int __ret_warn_on___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
  record_function("set_format");
  {
//#line  7603
  dev = subs->dev;
//#line  7605
  is_playback = subs->direction == 0;
//#line  7607
  iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )fmt->iface);
//#line  7609
  __ret_warn_on = ! (! (! iface));
//#line  7611
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
//#line  7613
  if (tmp) {
    {
//#line  7615
    warn_slowpath(str_585972373, 1490, (char const   *)((void *)0));
    }
  }
  {
//#line  7619
  tmp___0 = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
//#line  7621
  if (tmp___0) {
//#line  7623
    return (-22);
  }
  {
//#line  7626
  alts = iface->altsetting + (int )fmt->altset_idx;
//#line  7628
  altsd = & alts->desc;
//#line  7630
  __ret_warn_on___0 = ! (! ((int )altsd->bAlternateSetting != (int )fmt->altsetting));
//#line  7632
  tmp___1 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
  }
//#line  7634
  if (tmp___1) {
    {
//#line  7636
    warn_slowpath(str_585972373, 1494, (char const   *)((void *)0));
    }
  }
  {
//#line  7640
  tmp___2 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
  }
//#line  7642
  if (tmp___2) {
//#line  7644
    return (-22);
  }
//#line  7647
  if ((unsigned long )fmt == (unsigned long )subs->cur_audiofmt) {
//#line  7649
    return (0);
  }
//#line  7652
  if (subs->interface >= 0) {
//#line  7654
    if (subs->interface != fmt->iface) {
      {
//#line  7656
      tmp___3 = usb_set_interface(subs->dev, subs->interface, 0);
      }
//#line  7658
      if (tmp___3 < 0) {
        {
//#line  7660
        printk(str_986049528, dev->devnum, fmt->iface, (int )fmt->altsetting);
        }
//#line  7663
        return (-5);
      }
//#line  7666
      subs->interface = -1;
//#line  7668
      subs->format = 0U;
    }
  }
//#line  7672
  if (subs->interface != fmt->iface) {
//#line  7674
    goto _L;
  } else
//#line  7677
  if (subs->format != (unsigned int )fmt->altset_idx) {
    _L: 
    {
//#line  7680
    tmp___4 = usb_set_interface(dev, fmt->iface, (int )fmt->altsetting);
    }
//#line  7682
    if (tmp___4 < 0) {
      {
//#line  7684
      printk(str_764993234, dev->devnum, fmt->iface, (int )fmt->altsetting);
      }
//#line  7686
      return (-5);
    }
    {
//#line  7689
    printk(str_43365079, fmt->iface, (int )fmt->altsetting);
//#line  7691
    subs->interface = fmt->iface;
//#line  7693
    subs->format = (unsigned int )fmt->altset_idx;
    }
  }
//#line  7696
  ep = (unsigned int )((int )fmt->endpoint & 15);
//#line  7698
  if (is_playback) {
    {
//#line  7700
    tmp___5 = __create_pipe(dev, ep);
//#line  7702
    subs->datapipe = tmp___5;
    }
  } else {
    {
//#line  7705
    tmp___6 = __create_pipe(dev, ep);
//#line  7707
    subs->datapipe = tmp___6 | 128U;
    }
  }
//#line  7710
  if ((unsigned int )(subs->dev)->speed == 3U) {
//#line  7712
    if ((int )(alts->endpoint + 0)->desc.bInterval >= 1) {
//#line  7714
      if ((int )(alts->endpoint + 0)->desc.bInterval <= 4) {
//#line  7716
        subs->datainterval = (unsigned int )((int )(alts->endpoint + 0)->desc.bInterval - 1);
      } else {
//#line  7719
        subs->datainterval = 0U;
      }
    } else {
//#line  7723
      subs->datainterval = 0U;
    }
  } else {
//#line  7727
    subs->datainterval = 0U;
  }
//#line  7730
  tmp___7 = 0U;
//#line  7732
  subs->syncinterval = tmp___7;
//#line  7734
  subs->syncpipe = tmp___7;
//#line  7736
  subs->maxpacksize = fmt->maxpacksize;
//#line  7738
  subs->fill_max = 0U;
//#line  7740
  attr = (unsigned int )((int )fmt->ep_attr & 12);
//#line  7742
  if (is_playback) {
//#line  7744
    if (attr == 4U) {
//#line  7746
      goto _L___3;
    } else {
//#line  7749
      goto _L___4;
    }
  } else
  _L___4: 
//#line  7754
  if (! is_playback) {
//#line  7756
    if (attr == 8U) {
      _L___3: 
//#line  7759
      if ((int )altsd->bNumEndpoints >= 2) {
//#line  7761
        if (((int )(alts->endpoint + 1)->desc.bmAttributes & 3) != 1) {
          {
//#line  7763
          printk(str_764792676, dev->devnum, fmt->iface, (int )fmt->altsetting);
          }
//#line  7765
          return (-22);
        } else
//#line  7768
        if ((int )(alts->endpoint + 1)->desc.bLength >= 9) {
//#line  7770
          if ((int )(alts->endpoint + 1)->desc.bSynchAddress != 0) {
            {
//#line  7772
            printk(str_764792676, dev->devnum, fmt->iface, (int )fmt->altsetting);
            }
//#line  7775
            return (-22);
          }
        }
//#line  7779
        ep = (unsigned int )(alts->endpoint + 1)->desc.bEndpointAddress;
//#line  7781
        if ((int )(alts->endpoint + 0)->desc.bLength >= 9) {
//#line  7783
          if (is_playback) {
//#line  7785
            if (ep != (unsigned int )((int )(alts->endpoint + 0)->desc.bSynchAddress | 128)) {
              {
//#line  7787
              printk(str_764792676, dev->devnum, fmt->iface, (int )fmt->altsetting);
              }
//#line  7790
              return (-22);
            } else {
//#line  7793
              goto _L___0;
            }
          } else
          _L___0: 
//#line  7798
          if (! is_playback) {
//#line  7800
            if (ep != (unsigned int )((int )(alts->endpoint + 0)->desc.bSynchAddress & -129)) {
              {
//#line  7802
              printk(str_764792676, dev->devnum, fmt->iface, (int )fmt->altsetting);
              }
//#line  7805
              return (-22);
            }
          }
        }
//#line  7810
        ep &= 15U;
//#line  7812
        if (is_playback) {
          {
//#line  7814
          tmp___8 = __create_pipe(dev, ep);
//#line  7816
          subs->syncpipe = tmp___8 | 128U;
          }
        } else {
          {
//#line  7819
          tmp___9 = __create_pipe(dev, ep);
//#line  7821
          subs->syncpipe = tmp___9;
          }
        }
//#line  7824
        if ((int )(alts->endpoint + 1)->desc.bLength >= 9) {
//#line  7826
          if ((int )(alts->endpoint + 1)->desc.bRefresh >= 1) {
//#line  7828
            if ((int )(alts->endpoint + 1)->desc.bRefresh <= 9) {
//#line  7830
              subs->syncinterval = (unsigned int )(alts->endpoint + 1)->desc.bRefresh;
            } else {
//#line  7833
              goto _L___2;
            }
          } else {
//#line  7837
            goto _L___2;
          }
        } else
        _L___2: 
//#line  7842
        if ((unsigned int )(subs->dev)->speed == 2U) {
//#line  7844
          subs->syncinterval = 1U;
        } else
//#line  7847
        if ((int )(alts->endpoint + 1)->desc.bInterval >= 1) {
//#line  7849
          if ((int )(alts->endpoint + 1)->desc.bInterval <= 16) {
//#line  7851
            subs->syncinterval = (unsigned int )((int )(alts->endpoint + 1)->desc.bInterval - 1);
          } else {
//#line  7854
            subs->syncinterval = 3U;
          }
        } else {
//#line  7858
          subs->syncinterval = 3U;
        }
      }
    }
  }
//#line  7864
  if ((int )fmt->attributes & 128) {
//#line  7866
    subs->fill_max = 1U;
  }
  {
//#line  7869
  err = init_usb_pitch(dev, subs->interface, alts, fmt);
  }
//#line  7871
  if (err < 0) {
//#line  7873
    return (err);
  }
//#line  7876
  subs->cur_audiofmt = fmt;
//#line  7878
  return (0);
}
}
//#line  7882 "usb-audio.merged.sym.c"
static int snd_usb_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_usb_substream *subs ;
  struct audioformat *fmt ;
  unsigned int channels ;
  unsigned int rate ;
  unsigned int format ;
  int ret ;
  int changed ;
  struct snd_interval *tmp ;
  struct snd_mask *tmp___0 ;
  struct snd_interval *tmp___1 ;
  struct snd_interval *tmp___2 ;
  struct snd_interval *tmp___3 ;
  struct snd_mask *tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  struct snd_interval *tmp___7 ;
  int tmp___8 ;
  struct usb_host_interface *alts ;
  struct usb_interface *iface ;
  struct snd_mask *tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  struct snd_interval *tmp___12 ;
  struct snd_interval *tmp___13 ;
  struct snd_interval *tmp___14 ;
  struct snd_mask *tmp___15 ;
  unsigned int tmp___16 ;
  int tmp___17 ;
  struct snd_interval *tmp___18 ;

  {
  record_function("snd_usb_hw_params");
  {
//#line  7916
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  7918
  tmp = hw_param_interval(hw_params, 18);
//#line  7920
  ret = snd_pcm_alloc_vmalloc_buffer(substream, (size_t )tmp->min);
  }
//#line  7922
  if (ret < 0) {
//#line  7924
    return (ret);
  }
  {
//#line  7927
  tmp___0 = hw_param_mask(hw_params, 1);
//#line  7929
  format = snd_mask_min((struct snd_mask  const  *)tmp___0);
//#line  7931
  tmp___1 = hw_param_interval(hw_params, 11);
//#line  7933
  rate = tmp___1->min;
//#line  7935
  tmp___2 = hw_param_interval(hw_params, 10);
//#line  7937
  channels = tmp___2->min;
//#line  7939
  fmt = find_format(subs, format, rate, channels);
  }
//#line  7941
  if (! fmt) {
    {
//#line  7943
    printk(str_473778296, format, rate, channels);
    }
//#line  7946
    return (-22);
  }
//#line  7949
  if ((unsigned long )subs->cur_audiofmt != (unsigned long )fmt) {
//#line  7951
    tmp___8 = 1;
  } else {
    {
//#line  7954
    tmp___3 = hw_param_interval(hw_params, 13);
//#line  7956
    tmp___4 = hw_param_mask(hw_params, 1);
//#line  7958
    tmp___5 = snd_mask_min((struct snd_mask  const  *)tmp___4);
//#line  7960
    tmp___6 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___5);
//#line  7962
    tmp___7 = hw_param_interval(hw_params, 10);
    }
//#line  7964
    if (subs->period_bytes != ((tmp___3->min * (unsigned int )tmp___6) * tmp___7->min) / 8U) {
//#line  7966
      tmp___8 = 1;
    } else
//#line  7969
    if (subs->cur_rate != rate) {
//#line  7971
      tmp___8 = 1;
    } else {
//#line  7974
      tmp___8 = 0;
    }
  }
  {
//#line  7978
  changed = tmp___8;
//#line  7980
  ret = set_format(subs, fmt);
  }
//#line  7982
  if (ret < 0) {
//#line  7984
    return (ret);
  }
//#line  7987
  if (subs->cur_rate != rate) {
    {
//#line  7989
    iface = usb_ifnum_to_if((struct usb_device  const  *)subs->dev, (unsigned int )fmt->iface);
//#line  7991
    alts = iface->altsetting + (int )fmt->altset_idx;
//#line  7993
    ret = init_usb_sample_rate(subs->dev, subs->interface, alts, fmt, (int )rate);
    }
//#line  7995
    if (ret < 0) {
//#line  7997
      return (ret);
    }
//#line  8000
    subs->cur_rate = rate;
  }
//#line  8003
  if (changed) {
    {
//#line  8005
    release_substream_urbs(subs, 0);
//#line  8007
    tmp___9 = hw_param_mask(hw_params, 1);
//#line  8009
    tmp___10 = snd_mask_min((struct snd_mask  const  *)tmp___9);
//#line  8011
    tmp___11 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___10);
//#line  8013
    tmp___12 = hw_param_interval(hw_params, 10);
//#line  8015
    tmp___13 = hw_param_interval(hw_params, 11);
//#line  8017
    tmp___14 = hw_param_interval(hw_params, 13);
//#line  8019
    tmp___15 = hw_param_mask(hw_params, 1);
//#line  8021
    tmp___16 = snd_mask_min((struct snd_mask  const  *)tmp___15);
//#line  8023
    tmp___17 = snd_pcm_format_physical_width((snd_pcm_format_t )tmp___16);
//#line  8025
    tmp___18 = hw_param_interval(hw_params, 10);
//#line  8027
    ret = init_substream_urbs(subs, ((tmp___14->min * (unsigned int )tmp___17) * tmp___18->min) / 8U,
                              tmp___13->min, (unsigned int )tmp___11 * tmp___12->min);
    }
  }
//#line  8031
  return (ret);
}
}
//#line  8035 "usb-audio.merged.sym.c"
static int snd_usb_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct snd_usb_substream *subs ;
  int tmp ;

  {
  record_function("snd_usb_hw_free");
//#line  8042
  subs = (struct snd_usb_substream *)(substream->runtime)->private_data;
//#line  8044
  subs->cur_audiofmt = (struct audioformat *)((void *)0);
//#line  8046
  subs->cur_rate = 0U;
//#line  8048
  subs->period_bytes = 0U;
//#line  8050
  if (! ((subs->stream)->chip)->shutdown) {
    {
//#line  8052
    release_substream_urbs(subs, 0);
    }
  }
  {
//#line  8055
  tmp = snd_pcm_free_vmalloc_buffer(substream);
  }
//#line  8057
  return (tmp);
}
}
//#line  8061 "usb-audio.merged.sym.c"
static int snd_usb_pcm_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  struct snd_usb_substream *subs ;
  snd_pcm_sframes_t tmp ;
  snd_pcm_sframes_t tmp___0 ;
  int tmp___1 ;

  {
  record_function("snd_usb_pcm_prepare");
//#line  8071
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  8073
  subs = (struct snd_usb_substream *)runtime->private_data;
//#line  8075
  if (! subs->cur_audiofmt) {
    {
//#line  8077
    printk(str_597914956);
    }
//#line  8079
    return (-6);
  }
  {
//#line  8082
  tmp = bytes_to_frames(runtime, (ssize_t )subs->maxpacksize);
//#line  8084
  subs->maxframesize = (unsigned int )tmp;
//#line  8086
  tmp___0 = bytes_to_frames(runtime, (ssize_t )subs->curpacksize);
//#line  8088
  subs->curframesize = (unsigned int )tmp___0;
//#line  8090
  subs->hwptr_done = 0U;
//#line  8092
  subs->transfer_done = 0U;
//#line  8094
  subs->phase = 0U;
//#line  8096
  deactivate_urbs(subs, 0, 1);
//#line  8098
  wait_clear_urbs(subs);
  }
//#line  8100
  if (subs->direction == 0) {
    {
//#line  8102
    subs->ops.prepare = & prepare_nodata_playback_urb;
//#line  8104
    tmp___1 = start_urbs(subs, runtime);
    }
//#line  8106
    return (tmp___1);
  } else {
//#line  8109
    return (0);
  }
}
}
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_usb_hardware  = 
//#line  8114
     {590099U, 0ULL, 0U, 0U, 0U, 0U, 0U, (size_t )1048576, (size_t )64, (size_t )524288,
    2U, 1024U, 0UL};
//#line  8119 "usb-audio.merged.sym.c"
static int hw_check_valid_format(struct snd_pcm_hw_params *params , struct audioformat *fp ) 
{ 
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  struct snd_interval *ct ;
  struct snd_interval *tmp___0 ;
  struct snd_mask *fmts ;
  struct snd_mask *tmp___1 ;
  int tmp___2 ;

  {
  record_function("hw_check_valid_format");
  {
//#line  8131
  tmp = hw_param_interval(params, 11);
//#line  8133
  it = tmp;
//#line  8135
  tmp___0 = hw_param_interval(params, 10);
//#line  8137
  ct = tmp___0;
//#line  8139
  tmp___1 = hw_param_mask(params, 1);
//#line  8141
  fmts = tmp___1;
//#line  8143
  tmp___2 = snd_mask_test((struct snd_mask  const  *)fmts, (unsigned int )fp->format);
  }
//#line  8145
  if (! tmp___2) {
//#line  8147
    return (0);
  }
//#line  8150
  if (fp->channels < ct->min) {
//#line  8152
    return (0);
  } else
//#line  8155
  if (fp->channels > ct->max) {
//#line  8157
    return (0);
  }
//#line  8160
  if (fp->rate_min > it->max) {
//#line  8162
    return (0);
  } else
//#line  8165
  if (fp->rate_min == it->max) {
//#line  8167
    if (it->openmax) {
//#line  8169
      return (0);
    }
  }
//#line  8173
  if (fp->rate_max < it->min) {
//#line  8175
    return (0);
  } else
//#line  8178
  if (fp->rate_max == it->min) {
//#line  8180
    if (it->openmin) {
//#line  8182
      return (0);
    }
  }
//#line  8186
  return (1);
}
}
//#line  8190 "usb-audio.merged.sym.c"
static int hw_rule_rate(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  unsigned int rmin ;
  unsigned int rmax ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  record_function("hw_rule_rate");
  {
//#line  8207
  subs = (struct snd_usb_substream *)rule->private;
//#line  8209
  tmp = hw_param_interval(params, 11);
//#line  8211
  it = tmp;
//#line  8213
  changed = 0;
//#line  8215
  rmax = 0U;
//#line  8217
  rmin = rmax;
//#line  8219
  p = (struct list_head *)subs->fmt_list.next;
  }
  {
  {
//#line  8221
  while (1) {


    {
//#line  8223
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8225
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8227
      goto while_break;
    }
    {
//#line  8230
    __mptr = (struct list_head  const  *)p;
//#line  8232
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8234
    tmp___0 = hw_check_valid_format(params, fp);
    }
//#line  8236
    if (! tmp___0) {
//#line  8238
      goto __Cont;
    }
//#line  8241
    tmp___1 = changed;
//#line  8243
    changed ++;
//#line  8245
    if (tmp___1) {
//#line  8247
      if (rmin > fp->rate_min) {
//#line  8249
        rmin = fp->rate_min;
      }
//#line  8252
      if (rmax < fp->rate_max) {
//#line  8254
        rmax = fp->rate_max;
      }
    } else {
//#line  8258
      rmin = fp->rate_min;
//#line  8260
      rmax = fp->rate_max;
    }
    __Cont: 
//#line  8264
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  8267
  if (! changed) {
//#line  8269
    it->empty = 1U;
//#line  8271
    return (-22);
  }
//#line  8274
  changed = 0;
//#line  8276
  if (it->min < rmin) {
//#line  8278
    it->min = rmin;
//#line  8280
    it->openmin = 0U;
//#line  8282
    changed = 1;
  }
//#line  8285
  if (it->max > rmax) {
//#line  8287
    it->max = rmax;
//#line  8289
    it->openmax = 0U;
//#line  8291
    changed = 1;
  }
  {
//#line  8294
  tmp___2 = snd_interval_checkempty((struct snd_interval  const  *)it);
  }
//#line  8296
  if (tmp___2) {
//#line  8298
    it->empty = 1U;
//#line  8300
    return (-22);
  }
//#line  8303
  return (changed);
}
}
//#line  8307 "usb-audio.merged.sym.c"
static int hw_rule_channels(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_interval *it ;
  struct snd_interval *tmp ;
  unsigned int rmin ;
  unsigned int rmax ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  record_function("hw_rule_channels");
  {
//#line  8324
  subs = (struct snd_usb_substream *)rule->private;
//#line  8326
  tmp = hw_param_interval(params, 10);
//#line  8328
  it = tmp;
//#line  8330
  changed = 0;
//#line  8332
  rmax = 0U;
//#line  8334
  rmin = rmax;
//#line  8336
  p = (struct list_head *)subs->fmt_list.next;
  }
  {
  {
//#line  8338
  while (1) {


    {
//#line  8340
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8342
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8344
      goto while_break;
    }
    {
//#line  8347
    __mptr = (struct list_head  const  *)p;
//#line  8349
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8351
    tmp___0 = hw_check_valid_format(params, fp);
    }
//#line  8353
    if (! tmp___0) {
//#line  8355
      goto __Cont;
    }
//#line  8358
    tmp___1 = changed;
//#line  8360
    changed ++;
//#line  8362
    if (tmp___1) {
//#line  8364
      if (rmin > fp->channels) {
//#line  8366
        rmin = fp->channels;
      }
//#line  8369
      if (rmax < fp->channels) {
//#line  8371
        rmax = fp->channels;
      }
    } else {
//#line  8375
      rmin = fp->channels;
//#line  8377
      rmax = fp->channels;
    }
    __Cont: 
//#line  8381
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  8384
  if (! changed) {
//#line  8386
    it->empty = 1U;
//#line  8388
    return (-22);
  }
//#line  8391
  changed = 0;
//#line  8393
  if (it->min < rmin) {
//#line  8395
    it->min = rmin;
//#line  8397
    it->openmin = 0U;
//#line  8399
    changed = 1;
  }
//#line  8402
  if (it->max > rmax) {
//#line  8404
    it->max = rmax;
//#line  8406
    it->openmax = 0U;
//#line  8408
    changed = 1;
  }
  {
//#line  8411
  tmp___2 = snd_interval_checkempty((struct snd_interval  const  *)it);
  }
//#line  8413
  if (tmp___2) {
//#line  8415
    it->empty = 1U;
//#line  8417
    return (-22);
  }
//#line  8420
  return (changed);
}
}
//#line  8424 "usb-audio.merged.sym.c"
static int hw_rule_format(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) 
{ 
  struct snd_usb_substream *subs ;
  struct list_head *p ;
  struct snd_mask *fmt ;
  struct snd_mask *tmp ;
  u64 fbits ;
  u32 oldbits[2] ;
  int changed ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;
  int tmp___1 ;

  {
  record_function("hw_rule_format");
  {
//#line  8440
  subs = (struct snd_usb_substream *)rule->private;
//#line  8442
  tmp = hw_param_mask(params, 1);
//#line  8444
  fmt = tmp;
//#line  8446
  fbits = (u64 )0;
//#line  8448
  p = (struct list_head *)subs->fmt_list.next;
  }
  {
  {
//#line  8450
  while (1) {


    {
//#line  8452
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8454
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8456
      goto while_break;
    }
    {
//#line  8459
    __mptr = (struct list_head  const  *)p;
//#line  8461
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8463
    tmp___0 = hw_check_valid_format(params, fp);
    }
//#line  8465
    if (! tmp___0) {
//#line  8467
      goto __Cont;
    }
//#line  8470
    fbits |= 1ULL << fp->format;
    __Cont: 
//#line  8473
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  8476
  oldbits[0] = fmt->bits[0];
//#line  8478
  oldbits[1] = fmt->bits[1];
//#line  8480
  fmt->bits[0] &= (u32 )fbits;
//#line  8482
  fmt->bits[1] &= (u32 )(fbits >> 32);
//#line  8484
  if (! fmt->bits[0]) {
//#line  8486
    if (! fmt->bits[1]) {
//#line  8488
      return (-22);
    }
  }
//#line  8492
  if (oldbits[0] != fmt->bits[0]) {
//#line  8494
    tmp___1 = 1;
  } else
//#line  8497
  if (oldbits[1] != fmt->bits[1]) {
//#line  8499
    tmp___1 = 1;
  } else {
//#line  8502
    tmp___1 = 0;
  }
//#line  8505
  changed = tmp___1;
//#line  8507
  return (changed);
}
}
//#line  8511 "usb-audio.merged.sym.c"
static int check_hw_params_convention(struct snd_usb_substream *subs ) 
{ 
  int i ;
  u32 *channels ;
  u32 *rates ;
  u32 cmaster ;
  u32 rmaster ;
  u32 rate_min ;
  u32 rate_max ;
  struct list_head *p ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct audioformat *f ;
  struct list_head  const  *__mptr ;
  struct audioformat *f___0 ;
  struct list_head  const  *__mptr___0 ;

  {
  record_function("check_hw_params_convention");
  {
//#line  8531
  rate_min = (u32 )0;
//#line  8533
  rate_max = (u32 )0;
//#line  8535
  err = 1;
//#line  8537
  tmp = kcalloc((size_t )64, sizeof(u32 ), 208U);
//#line  8539
  channels = (u32 *)tmp;
//#line  8541
  tmp___0 = kcalloc((size_t )64, sizeof(u32 ), 208U);
//#line  8543
  rates = (u32 *)tmp___0;
  }
//#line  8545
  if (! channels) {
//#line  8547
    err = -12;
//#line  8549
    goto __out;
  } else
//#line  8552
  if (! rates) {
//#line  8554
    err = -12;
//#line  8556
    goto __out;
  }
//#line  8559
  p = (struct list_head *)subs->fmt_list.next;
  {
  {
//#line  8561
  while (1) {


    {
//#line  8563
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8565
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8567
      goto while_break;
    }
//#line  8570
    __mptr = (struct list_head  const  *)p;
//#line  8572
    f = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8574
    if (f->channels > 32U) {
//#line  8576
      goto __out;
    }
//#line  8579
    if (f->rates & (unsigned int )(1 << 30)) {
//#line  8581
      if (rate_min) {
//#line  8583
        if (f->rate_min != rate_min) {
//#line  8585
          goto __out;
        }
      }
//#line  8589
      if (rate_max) {
//#line  8591
        if (f->rate_max != rate_max) {
//#line  8593
          goto __out;
        }
      }
//#line  8597
      rate_min = f->rate_min;
//#line  8599
      rate_max = f->rate_max;
    }
//#line  8602
    if (*(rates + f->format) & (unsigned int )(1 << 30)) {
//#line  8604
      if (f->rates != *(rates + f->format)) {
//#line  8606
        goto __out;
      }
    }
//#line  8610
    if (f->rates & (unsigned int )(1 << 30)) {
//#line  8612
      if (*(rates + f->format)) {
//#line  8614
        if (*(rates + f->format) != f->rates) {
//#line  8616
          goto __out;
        }
      }
    }
//#line  8621
    *(channels + f->format) |= (unsigned int )(1 << f->channels);
//#line  8623
    *(rates + f->format) |= f->rates;
//#line  8625
    if (f->rates & (unsigned int )(1 << 31)) {
//#line  8627
      goto __out;
    }
//#line  8630
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  8633
  rmaster = (u32 )0;
//#line  8635
  cmaster = rmaster;
//#line  8637
  i = 0;
  {
  {
//#line  8639
  while (1) {


    if (! (i < 64)) {
//#line  8639
      goto while_break___0;
    }
//#line  8641
    if (cmaster != *(channels + i)) {
//#line  8643
      if (cmaster) {
//#line  8645
        if (*(channels + i)) {
//#line  8647
          goto __out;
        }
      }
    }
//#line  8652
    if (rmaster != *(rates + i)) {
//#line  8654
      if (rmaster) {
//#line  8656
        if (*(rates + i)) {
//#line  8658
          goto __out;
        }
      }
    }
//#line  8663
    if (*(channels + i)) {
//#line  8665
      cmaster = *(channels + i);
    }
//#line  8668
    if (*(rates + i)) {
//#line  8670
      rmaster = *(rates + i);
    }
//#line  8673
    i ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  8676
  memset((void *)channels, 0, 64UL * sizeof(u32 ));
//#line  8678
  p = (struct list_head *)subs->fmt_list.next;
  }
  {
  {
//#line  8680
  while (1) {


    {
//#line  8682
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8684
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8686
      goto while_break___1;
    }
//#line  8689
    __mptr___0 = (struct list_head  const  *)p;
//#line  8691
    f___0 = (struct audioformat *)((char *)__mptr___0 - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8693
    if (f___0->rates & (unsigned int )(1 << 30)) {
//#line  8695
      goto __Cont;
    }
//#line  8698
    i = 0;
    {
    {
//#line  8700
    while (1) {


      if (! (i < 32)) {
//#line  8700
        goto while_break___2;
      }
//#line  8702
      if (f___0->rates & (unsigned int )(1 << i)) {
//#line  8704
        *(channels + i) |= (unsigned int )(1 << f___0->channels);
      }
//#line  8707
      i ++;
    }

    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: 
//#line  8711
    p = (struct list_head *)p->next;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  8714
  cmaster = (u32 )0;
//#line  8716
  i = 0;
  {
  {
//#line  8718
  while (1) {


    if (! (i < 32)) {
//#line  8718
      goto while_break___3;
    }
//#line  8720
    if (cmaster != *(channels + i)) {
//#line  8722
      if (cmaster) {
//#line  8724
        if (*(channels + i)) {
//#line  8726
          goto __out;
        }
      }
    }
//#line  8731
    if (*(channels + i)) {
//#line  8733
      cmaster = *(channels + i);
    }
//#line  8736
    i ++;
  }

  }
  while_break___3: /* CIL Label */ ;
  }
//#line  8739
  err = 0;
  __out: 
  {
//#line  8742
  kfree((void const   *)channels);
//#line  8744
  kfree((void const   *)rates);
  }
//#line  8746
  return (err);
}
}
//#line  8750 "usb-audio.merged.sym.c"
static int snd_usb_pcm_check_knot(struct snd_pcm_runtime *runtime , struct snd_usb_substream *subs ) 
{ 
  struct audioformat *fp ;
  int count ;
  int needs_knot ;
  int err ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;
  int i ;
  int tmp___0 ;

  {
  record_function("snd_usb_pcm_check_knot");
//#line  8766
  count = 0;
//#line  8768
  needs_knot = 0;
//#line  8770
  __mptr = (struct list_head  const  *)subs->fmt_list.next;
//#line  8772
  fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
  {
  {
//#line  8774
  while (1) {


    {
//#line  8776
    __builtin_prefetch((void const   *)fp->list.next);
    }
//#line  8778
    if (! ((unsigned long )(& fp->list) != (unsigned long )(& subs->fmt_list))) {
//#line  8780
      goto while_break;
    }
//#line  8783
    if (fp->rates & (unsigned int )(1 << 30)) {
//#line  8785
      return (0);
    }
//#line  8788
    count = (int )((unsigned int )count + fp->nr_rates);
//#line  8790
    if (fp->rates & (unsigned int )(1 << 31)) {
//#line  8792
      needs_knot = 1;
    }
//#line  8795
    __mptr___0 = (struct list_head  const  *)fp->list.next;
//#line  8797
    fp = (struct audioformat *)((char *)__mptr___0 - (unsigned int )(& ((struct audioformat *)0)->list));
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  8800
  if (! needs_knot) {
//#line  8802
    return (0);
  }
  {
//#line  8805
  subs->rate_list.count = (unsigned int )count;
//#line  8807
  tmp = kmalloc(sizeof(int ) * (unsigned long )count, 208U);
//#line  8809
  subs->rate_list.list = (unsigned int *)tmp;
//#line  8811
  subs->rate_list.mask = 0U;
//#line  8813
  count = 0;
//#line  8815
  __mptr___1 = (struct list_head  const  *)subs->fmt_list.next;
//#line  8817
  fp = (struct audioformat *)((char *)__mptr___1 - (unsigned int )(& ((struct audioformat *)0)->list));
  }
  {
  {
//#line  8819
  while (1) {


    {
//#line  8821
    __builtin_prefetch((void const   *)fp->list.next);
    }
//#line  8823
    if (! ((unsigned long )(& fp->list) != (unsigned long )(& subs->fmt_list))) {
//#line  8825
      goto while_break___0;
    }
//#line  8828
    i = 0;
    {
    {
//#line  8830
    while (1) {


      if (! ((unsigned int )i < fp->nr_rates)) {
//#line  8830
        goto while_break___1;
      }
//#line  8832
      tmp___0 = count;
//#line  8834
      count ++;
//#line  8836
      *(subs->rate_list.list + tmp___0) = *(fp->rate_table + i);
//#line  8838
      i ++;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
//#line  8841
    __mptr___2 = (struct list_head  const  *)fp->list.next;
//#line  8843
    fp = (struct audioformat *)((char *)__mptr___2 - (unsigned int )(& ((struct audioformat *)0)->list));
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  8846
  err = snd_pcm_hw_constraint_list(runtime, 0U, 11, & subs->rate_list);
  }
//#line  8848
  if (err < 0) {
//#line  8850
    return (err);
  }
//#line  8853
  return (0);
}
}
//#line  8857
static int snd_pcm_hw_rule_add_MJR2() ;
//#line  8859 "usb-audio.merged.sym.c"
static int setup_hw_info(struct snd_pcm_runtime *runtime , struct snd_usb_substream *subs ) 
{ 
  struct list_head *p ;
  int err ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;
  size_t tmp ;

  {
  record_function("setup_hw_info");
//#line  8869
  runtime->hw.formats = subs->formats;
//#line  8871
  runtime->hw.rate_min = 2147483647U;
//#line  8873
  runtime->hw.rate_max = 0U;
//#line  8875
  runtime->hw.channels_min = 256U;
//#line  8877
  runtime->hw.channels_max = 0U;
//#line  8879
  runtime->hw.rates = 0U;
//#line  8881
  p = (struct list_head *)subs->fmt_list.next;
  {
  {
//#line  8883
  while (1) {


    {
//#line  8885
    __builtin_prefetch((void const   *)p->next);
    }
//#line  8887
    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  8889
      goto while_break;
    }
//#line  8892
    __mptr = (struct list_head  const  *)p;
//#line  8894
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  8896
    runtime->hw.rates |= fp->rates;
//#line  8898
    if (runtime->hw.rate_min > fp->rate_min) {
//#line  8900
      runtime->hw.rate_min = fp->rate_min;
    }
//#line  8903
    if (runtime->hw.rate_max < fp->rate_max) {
//#line  8905
      runtime->hw.rate_max = fp->rate_max;
    }
//#line  8908
    if (runtime->hw.channels_min > fp->channels) {
//#line  8910
      runtime->hw.channels_min = fp->channels;
    }
//#line  8913
    if (runtime->hw.channels_max < fp->channels) {
//#line  8915
      runtime->hw.channels_max = fp->channels;
    }
//#line  8918
    if (fp->fmt_type == 2U) {
//#line  8920
      if (fp->frame_size > 0U) {
//#line  8922
        tmp = (size_t )fp->frame_size;
//#line  8924
        runtime->hw.period_bytes_max = tmp;
//#line  8926
        runtime->hw.period_bytes_min = tmp;
      }
    }
//#line  8930
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  8933
  snd_pcm_hw_constraint_minmax(runtime, 12, 1000U, ~ 0U);
//#line  8935
  err = check_hw_params_convention(subs);
  }
//#line  8937
  if (err < 0) {
//#line  8939
    return (err);
  } else
//#line  8942
  if (err) {
    {
//#line  8944
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 11, & hw_rule_rate, subs, 1, 10, -1);
    }
//#line  8946
    if (err < 0) {
//#line  8948
      return (err);
    }
    {
//#line  8951
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 10, & hw_rule_channels, subs, 1, 11,
                                   -1);
    }
//#line  8954
    if (err < 0) {
//#line  8956
      return (err);
    }
    {
//#line  8959
    err = snd_pcm_hw_rule_add_MJR2(runtime, 0, 1, & hw_rule_format, subs, 11, 10,
                                   -1);
    }
//#line  8962
    if (err < 0) {
//#line  8964
      return (err);
    }
    {
//#line  8967
    err = snd_usb_pcm_check_knot(runtime, subs);
    }
//#line  8969
    if (err < 0) {
//#line  8971
      return (err);
    }
  }
//#line  8975
  return (0);
}
}
//#line  8979 "usb-audio.merged.sym.c"
static int snd_usb_pcm_open(struct snd_pcm_substream *substream , int direction ) 
{ 
  struct snd_usb_stream *as ;
  struct snd_pcm_runtime *runtime ;
  struct snd_usb_substream *subs ;
  int tmp ;

  {
  record_function("snd_usb_pcm_open");
  {
//#line  8988
  as = (struct snd_usb_stream *)substream->private_data;
//#line  8990
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  8992
  subs = & as->substream[direction];
//#line  8994
  subs->interface = -1;
//#line  8996
  subs->format = 0U;
//#line  8998
  runtime->hw = (struct snd_pcm_hardware )snd_usb_hardware;
//#line  9000
  runtime->private_data = (void *)subs;
//#line  9002
  subs->pcm_substream = (struct snd_pcm_substream *)substream;
//#line  9004
  tmp = setup_hw_info(runtime, subs);
  }
//#line  9006
  return (tmp);
}
}
//#line  9010 "usb-audio.merged.sym.c"
static int snd_usb_pcm_close(struct snd_pcm_substream *substream , int direction ) 
{ 
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;

  {
  record_function("snd_usb_pcm_close");
//#line  9017
  as = (struct snd_usb_stream *)substream->private_data;
//#line  9019
  subs = & as->substream[direction];
//#line  9021
  if (subs->interface >= 0) {
    {
//#line  9023
    usb_set_interface(subs->dev, subs->interface, 0);
//#line  9025
    subs->interface = -1;
    }
  }
//#line  9028
  subs->pcm_substream = (struct snd_pcm_substream *)((void *)0);
//#line  9030
  return (0);
}
}
//#line  9034 "usb-audio.merged.sym.c"
static int snd_usb_playback_open(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_playback_open");
  {
//#line  9040
  tmp = snd_usb_pcm_open(substream, 0);
  }
//#line  9042
  return (tmp);
}
}
//#line  9046 "usb-audio.merged.sym.c"
static int snd_usb_playback_close(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_playback_close");
  {
//#line  9052
  tmp = snd_usb_pcm_close(substream, 0);
  }
//#line  9054
  return (tmp);
}
}
//#line  9058 "usb-audio.merged.sym.c"
static int snd_usb_capture_open(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_capture_open");
  {
//#line  9064
  tmp = snd_usb_pcm_open(substream, 1);
  }
//#line  9066
  return (tmp);
}
}
//#line  9070 "usb-audio.merged.sym.c"
static int snd_usb_capture_close(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_capture_close");
  {
//#line  9076
  tmp = snd_usb_pcm_close(substream, 1);
  }
//#line  9078
  return (tmp);
}
}
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_usb_playback_ops  = 
//#line  9082
     {& snd_usb_playback_open, & snd_usb_playback_close, & snd_pcm_lib_ioctl, & snd_usb_hw_params,
    & snd_usb_hw_free, & snd_usb_pcm_prepare, & snd_usb_pcm_playback_trigger, & snd_usb_pcm_pointer,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             void *buf , snd_pcm_uframes_t count ))0, (int (*)(struct snd_pcm_substream *substream ,
                                                               int channel , snd_pcm_uframes_t pos ,
                                                               snd_pcm_uframes_t count ))0,
    & snd_pcm_get_vmalloc_page, (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_usb_capture_ops  = 
//#line  9093
     {& snd_usb_capture_open, & snd_usb_capture_close, & snd_pcm_lib_ioctl, & snd_usb_hw_params,
    & snd_usb_hw_free, & snd_usb_pcm_prepare, & snd_usb_pcm_capture_trigger, & snd_usb_pcm_pointer,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             void *buf , snd_pcm_uframes_t count ))0, (int (*)(struct snd_pcm_substream *substream ,
                                                               int channel , snd_pcm_uframes_t pos ,
                                                               snd_pcm_uframes_t count ))0,
    & snd_pcm_get_vmalloc_page, (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
//#line  9104 "usb-audio.merged.sym.c"
static unsigned int snd_usb_combine_bytes(unsigned char *bytes , int size ) 
{ 


  {
  record_function("snd_usb_combine_bytes");
  {
  if (size == 1) {
//#line  9111
    goto case_1;
  }
  if (size == 2) {
//#line  9114
    goto case_2;
  }
  if (size == 3) {
//#line  9117
    goto case_3;
  }
  if (size == 4) {
//#line  9120
    goto case_4;
  }
//#line  9123
  goto switch_default;
  case_1: /* CIL Label */ 
//#line  9113
  return ((unsigned int )*bytes);
  case_2: /* CIL Label */ 
//#line  9116
  return ((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8));
  case_3: /* CIL Label */ 
//#line  9119
  return (((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8)) | ((unsigned int )*(bytes + 2) << 16));
  case_4: /* CIL Label */ 
//#line  9122
  return ((((unsigned int )*bytes | ((unsigned int )*(bytes + 1) << 8)) | ((unsigned int )*(bytes + 2) << 16)) | ((unsigned int )*(bytes + 3) << 24));
  switch_default: /* CIL Label */ 
//#line  9125
  return (0U);

  }
}
}
//#line  9130 "usb-audio.merged.sym.c"
static void *snd_usb_find_desc(void *descstart , int desclen , void *after , u8 dtype ) 
{ 
  u8 *p ;
  u8 *end ;
  u8 *next ;

  {
  record_function("snd_usb_find_desc");
//#line  9138
  p = (u8 *)descstart;
//#line  9140
  end = p + desclen;
  {
  {
//#line  9142
  while (1) {


    if (! ((unsigned long )p < (unsigned long )end)) {
//#line  9142
      goto while_break;
    }
//#line  9144
    if ((int )*(p + 0) < 2) {
//#line  9146
      return ((void *)0);
    }
//#line  9149
    next = p + (int )*(p + 0);
//#line  9151
    if ((unsigned long )next > (unsigned long )end) {
//#line  9153
      return ((void *)0);
    }
//#line  9156
    if ((int )*(p + 1) == (int )dtype) {
//#line  9158
      if (! after) {
//#line  9160
        return ((void *)p);
      } else
//#line  9163
      if ((unsigned long )((void *)p) > (unsigned long )after) {
//#line  9165
        return ((void *)p);
      }
    }
//#line  9169
    p = next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  9172
  return ((void *)0);
}
}
//#line  9176 "usb-audio.merged.sym.c"
static void *snd_usb_find_csint_desc(void *buffer , int buflen , void *after , u8 dsubtype ) 
{ 
  unsigned char *p ;
  void *tmp ;

  {
  record_function("snd_usb_find_csint_desc");
//#line  9183
  p = (unsigned char *)after;
  {
  {
//#line  9185
  while (1) {


    {
//#line  9187
    tmp = snd_usb_find_desc(buffer, buflen, (void *)p, (u8 )((1 << 5) | 4));
//#line  9189
    p = (unsigned char *)tmp;
    }
//#line  9191
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
//#line  9193
      goto while_break;
    }
//#line  9196
    if ((int )*(p + 0) >= 3) {
//#line  9198
      if ((int )*(p + 2) == (int )dsubtype) {
//#line  9200
        return ((void *)p);
      }
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  9205
  return ((void *)0);
}
}
//#line  9209 "usb-audio.merged.sym.c"
static int snd_usb_ctl_msg(struct usb_device *dev , unsigned int pipe , __u8 request ,
                           __u8 requesttype , __u16 value , __u16 index___0 , void *data ,
                           __u16 size , int timeout ) 
{ 
  int err ;
  void *buf ;
  size_t __len ;
  void *__ret ;

  {
  record_function("snd_usb_ctl_msg");
//#line  9219
  buf = (void *)0;
//#line  9221
  if ((int )size > 0) {
    {
//#line  9223
    buf = kmemdup((void const   *)data, (size_t )size, 208U);
    }
//#line  9225
    if (! buf) {
//#line  9227
      return (-12);
    }
  }
  {
//#line  9231
  err = usb_control_msg(dev, pipe, request, requesttype, value, index___0, buf, size,
                        timeout);
  }
//#line  9234
  if ((int )size > 0) {
    {
//#line  9236
    __len = (size_t )size;
//#line  9238
    __ret = __builtin_memcpy(data, (void const   *)buf, __len);
//#line  9240
    kfree((void const   *)buf);
    }
  }
//#line  9243
  return (err);
}
}
//#line  9247
static int usb_audio_probe(struct usb_interface * __attribute__((__extraptr__(sizeof(struct usb_device *),"Nonstub_get_usb_device"))) intf ,
                           struct usb_device_id  const  *id___0 ) ;
//#line  9250
static void usb_audio_disconnect(struct usb_interface * __attribute__((__noderef__,
                                 __address_space__(2))) intf ) ;
//#line  9253
static int usb_audio_suspend(struct usb_interface *intf , pm_message_t message ) ;
//#line  9255
static int usb_audio_resume(struct usb_interface *intf ) ;
//#line  9257 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_0  =    {(char const   *)str_615991579, (char const   *)str_32155715, (int16_t )-2, (unsigned short)0,
    (void const   *)0};
//#line  9260 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_1  =    {(char const   *)str_1068557351, (char const   *)str_158454992, (int16_t )-2, (unsigned short)0,
    (void const   *)0};
//#line  9263 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_2  =    {(char const   *)str_233798669, (char const   *)str_11699988, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9266 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_3  =    {(char const   *)str_233798669, (char const   *)str_202091287, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9269 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_4  =    {(char const   *)str_233798669, (char const   *)str_202098146, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9272 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_5  =    {(char const   *)str_233798669, (char const   *)str_10637825, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9275 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_6  =    {(char const   *)str_233798669, (char const   *)str_11694111, (int16_t )3, (uint16_t )4,
    (void const   *)0};
//#line  9278 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_7  =    {(char const   *)str_233798669, (char const   *)str_201558875, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9281 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_8  =    {(char const   *)str_233798669, (char const   *)str_201558876, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9284 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_9  =    {(char const   *)str_233798669, (char const   *)str_201558877, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9287 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_10  =    {(char const   *)str_233798669, (char const   *)str_615920, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9290 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_11  =    {(char const   *)str_233798669, (char const   *)str_615768, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9293 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_12  =    {(char const   *)str_233798669, (char const   *)str_181728381, (int16_t )3, (uint16_t )4,
    (void const   *)0};
//#line  9296 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_13  =    {(char const   *)str_233798669, (char const   *)str_11554634, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9299 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_14  =    {(char const   *)str_233798669, (char const   *)str_11554596, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9302 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_15  =    {(char const   *)str_233798669, (char const   *)str_30931, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9305 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_16  =    {(char const   *)str_233798669, (char const   *)str_129785158, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9308 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_17  =    {(char const   *)str_233798669, (char const   *)str_129785196, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9311 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_18  =    {(char const   *)str_233798669, (char const   *)str_10753440, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9314 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_19  =    {(char const   *)str_233798669, (char const   *)str_11588601, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9317 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_20  =    {(char const   *)str_233798669, (char const   *)str_207539138, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9320 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_21  =    {(char const   *)str_233798669, (char const   *)str_31094, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9323 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_22  =    {(char const   *)str_233798669, (char const   *)str_608393064, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9326 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_23  =    {(char const   *)str_233798669, (char const   *)str_10530917, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9329 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_24  =    {(char const   *)str_233798669, (char const   *)str_154546418, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9332 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_25  =    {(char const   *)str_233798669, (char const   *)str_154546420, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9335 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_26  =    {(char const   *)str_233798669, (char const   *)str_154546422, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9338 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_27  =    {(char const   *)str_233798669, (char const   *)str_154546433, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9341 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_28  =    {(char const   *)str_233798669, (char const   *)str_461878866, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9344 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_29  =    {(char const   *)str_233798669, (char const   *)str_461885725, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9347 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_30  =    {(char const   *)str_233798669, (char const   *)str_129785201, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9350 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_31  =    {(char const   *)str_233798669, (char const   *)str_209484720, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9353 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_32  =    {(char const   *)str_233798669, (char const   *)str_182916092, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9356 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_33  =    {(char const   *)str_233798669, (char const   *)str_254016772, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9359 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_34  =    {(char const   *)str_233798669, (char const   *)str_405545197, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9362 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_35  =    {(char const   *)str_233798669, (char const   *)str_405545198, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9365 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_36  =    {(char const   *)str_233798669, (char const   *)str_405545199, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9368 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_37  =    {(char const   *)str_233798669, (char const   *)str_154546776, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9371 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_38  =    {(char const   *)str_233798669, (char const   *)str_154546778, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9374 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_39  =    {(char const   *)str_233798669, (char const   *)str_154546780, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9377 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_40  =    {(char const   *)str_233798669, (char const   *)str_154546782, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9380 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_41  =    {(char const   *)str_233798669, (char const   *)str_154546784, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9383 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_42  =    {(char const   *)str_233798669, (char const   *)str_1030557429, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9386 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_43  =    {(char const   *)str_233798669, (char const   *)str_461880310, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9389 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_44  =    {(char const   *)str_233798669, (char const   *)str_461892223, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9392 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_45  =    {(char const   *)str_233798669, (char const   *)str_652131613, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9395 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_46  =    {(char const   *)str_233798669, (char const   *)str_556279697, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9398 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_47  =    {(char const   *)str_233798669, (char const   *)str_85230465, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9401 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_48  =    {(char const   *)str_233798669, (char const   *)str_165493744, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9404 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_49  =    {(char const   *)str_233798669, (char const   *)str_165494466, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9407 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_50  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9410 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_51  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9413 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_52  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9416 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_53  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9419 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_54  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9422 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_55  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9425 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_56  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9428 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_57  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9431 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_58  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9434 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_59  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9437 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_60  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9440 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_61  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9443 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_62  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9446 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_63  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9449 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_64  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9452 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_65  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9455 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_66  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9458 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_67  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9461 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_68  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )0, (uint16_t )4,
    (void const   *)0};
//#line  9464 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_69  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9467 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_70  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9470 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_71  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9473 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_72  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9476 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_73  =    {(char const   *)str_233798669, (char const   *)str_9378607, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9479 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_74  =    {(char const   *)str_233798669, (char const   *)str_9378605, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9482 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_75  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9485 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_76  =    {(char const   *)str_233798669, (char const   *)str_490515, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9488 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_77  =    {(char const   *)str_233798669, (char const   *)str_9461004, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9491 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_78  =    {(char const   *)str_233798669, (char const   *)str_9415899, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9494 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_79  =    {(char const   *)str_233798669, (char const   *)str_178770687, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9497 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_80  =    {(char const   *)str_233798669, (char const   *)str_6629097, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9500 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_81  =    {(char const   *)str_233798669, (char const   *)str_14089218, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9503 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_82  =    {(char const   *)str_233798669, (char const   *)str_635602341, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9506 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_83  =    {(char const   *)str_233798669, (char const   *)str_178763828, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9509 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_84  =    {(char const   *)str_233798669, (char const   *)str_6623682, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9512 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_85  =    {(char const   *)str_233798669, (char const   *)str_893500057, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9515 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_86  =    {(char const   *)str_233798669, (char const   *)str_577592, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9518 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_87  =    {(char const   *)str_233798669, (char const   *)str_178903280, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9521 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_88  =    {(char const   *)str_233798669, (char const   *)str_178901836, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9524 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_89  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9527 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_90  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9530 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_91  =    {(char const   *)str_233798669, (char const   *)((void *)0), (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9533 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_92  =    {(char const   *)str_233798669, (char const   *)str_26232, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
//#line  9536 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_93  =    {(char const   *)str_233798669, (char const   *)str_607981, (int16_t )-1, (uint16_t )4,
    (void const   *)0};
static struct audioformat  const  __constr_expr_96  = 
//#line  9539
     {{(struct list_head *)0, (struct list_head *)0}, 2, 4U, 0U, 0U, 0, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)9, 0U, (unsigned int )(1 << 30),
    44100U, 44100U, 0U, (unsigned int *)0};
static struct audioformat  const  __constr_expr_97  = 
//#line  9545
     {{(struct list_head *)0, (struct list_head *)0}, 2, 2U, 0U, 0U, 1, (unsigned char)1,
    (unsigned char)1, (unsigned char)128, (unsigned char)129, (unsigned char)5, 0U,
    (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  9551 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_98  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  9554 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_95[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )12, (void const   *)(& __constr_expr_96)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )12, (void const   *)(& __constr_expr_97)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_98)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9565 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_94  =    {(char const   *)str_218283728, (char const   *)str_219266584, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_95)};
//#line  9568 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_101  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  9571 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_100[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_101)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9582 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_99  =    {(char const   *)str_180244545, (char const   *)str_611719, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_100)};
//#line  9585 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_104  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )63,
    (uint16_t )63};
//#line  9588 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_103[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_104)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9599 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_102  =    {(char const   *)str_218283728, (char const   *)str_855751104, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_103)};
//#line  9602 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_107  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )5,
    (uint16_t )5};
//#line  9605 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_106[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_107)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9616 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_105  =    {(char const   *)str_218283728, (char const   *)str_31596, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_106)};
//#line  9619 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_110  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  9622 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_109[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_110)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9633 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_108  =    {(char const   *)str_180244545, (char const   *)str_611717, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_109)};
//#line  9636 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_113  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )19,
    (uint16_t )19};
//#line  9639 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_112[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_113)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9650 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_111  =    {(char const   *)str_218283728, (char const   *)str_855751047, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_112)};
//#line  9653 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_116  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9656 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_115[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_116)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9667 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_114  =    {(char const   *)str_218283728, (char const   *)str_207147453, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_115)};
//#line  9670 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_119  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9673 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_118[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_119)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9684 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_117  =    {(char const   *)str_180244545, (char const   *)str_611716, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_118)};
//#line  9687 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_122  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )19,
    (uint16_t )19};
//#line  9690 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_121[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_122)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9701 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_120  =    {(char const   *)str_218283728, (char const   *)str_215619040, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_121)};
static struct audioformat  const  __constr_expr_125  = 
//#line  9704
     {{(struct list_head *)0, (struct list_head *)0}, 32, 2U, 0U, 0U, 0, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, 0U, (unsigned int )(1 << 30),
    44100U, 44100U, 0U, (unsigned int *)0};
static struct audioformat  const  __constr_expr_126  = 
//#line  9710
     {{(struct list_head *)0, (struct list_head *)0}, 32, 2U, 0U, 0U, 1, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)129, (unsigned char)1, 0U,
    (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  9716 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_127  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  9719 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_124[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )12, (void const   *)(& __constr_expr_125)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )12, (void const   *)(& __constr_expr_126)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_127)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9730 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_123  =    {(char const   *)str_218283728, (char const   *)str_214582020, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_124)};
//#line  9733 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_129[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9741 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_128  =    {(char const   *)str_180244545, (char const   *)str_607388, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_129)};
//#line  9744 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_131  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9747 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_130  =    {(char const   *)str_218283728, (char const   *)str_64261101, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_131)};
//#line  9750 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_133  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  9753 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_132  =    {(char const   *)str_180244545, (char const   *)str_220833115, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_133)};
//#line  9756 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_136  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  9759 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_135[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_136)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9770 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_134  =    {(char const   *)str_180244545, (char const   *)str_11300431, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_135)};
//#line  9773 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_139  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9776 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_138[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_139)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9787 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_137  =    {(char const   *)str_218283728, (char const   *)str_10592645, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_138)};
//#line  9790 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_141  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9793 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_140  =    {(char const   *)str_218283728, (char const   *)str_947601669, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_141)};
//#line  9796 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_143  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )63,
    (uint16_t )63};
//#line  9799 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_142  =    {(char const   *)str_180244545, (char const   *)str_220831975, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_143)};
static struct audioformat  const  __constr_expr_146  = 
//#line  9802
     {{(struct list_head *)0, (struct list_head *)0}, 32, 2U, 0U, 0U, 1, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1, 0U, (unsigned int )(1 << 30),
    44100U, 44100U, 0U, (unsigned int *)0};
static struct audioformat  const  __constr_expr_147  = 
//#line  9808
     {{(struct list_head *)0, (struct list_head *)0}, 32, 2U, 0U, 0U, 2, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)130, (unsigned char)1, 0U,
    (unsigned int )(1 << 30), 44100U, 44100U, 0U, (unsigned int *)0};
//#line  9814 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_148  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9817 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_145[5]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )12, (void const   *)(& __constr_expr_146)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )12, (void const   *)(& __constr_expr_147)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )3, (uint16_t )3, (void const   *)(& __constr_expr_148)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9830 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_144  =    {(char const   *)str_180244545, (char const   *)str_11540363, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_145)};
//#line  9833 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_150  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  9836 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_149  =    {(char const   *)str_180244545, (char const   *)str_11300298, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_150)};
//#line  9839 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_152  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  9842 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_151  =    {(char const   *)str_180244545, (char const   *)str_11300412, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_152)};
//#line  9845 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_154[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )3, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9856 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_153  =    {(char const   *)str_180244545, (char const   *)str_219268750, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_154)};
//#line  9859 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_156  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9862 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_155  =    {(char const   *)str_218283728, (char const   *)str_64240467, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_156)};
//#line  9865 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_158  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )7,
    (uint16_t )7};
//#line  9868 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_157  =    {(char const   *)str_218283728, (char const   *)str_226407066, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_158)};
//#line  9871 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_160  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  9874 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_159  =    {(char const   *)str_180244545, (char const   *)str_30235, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_160)};
//#line  9877 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_162  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9880 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_161  =    {(char const   *)str_218283728, (char const   *)str_657602785, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_162)};
//#line  9883 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_164[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )3, (uint16_t )2, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9894 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_163  =    {(char const   *)str_482873, (char const   *)str_9839312, (int16_t )-1, (uint16_t )1,
    (void const   *)(& __constr_expr_164)};
//#line  9897 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_166  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9900 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_165  =    {(char const   *)str_218283728, (char const   *)str_9770741, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_166)};
//#line  9903 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_168  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9906 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_167  =    {(char const   *)str_218283728, (char const   *)str_11272957, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_168)};
//#line  9909 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_171  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  9912 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_170[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )13, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )13, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )3, (uint16_t )3, (void const   *)(& __constr_expr_171)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9923 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_169  =    {(char const   *)str_218283728, (char const   *)str_944839672, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_170)};
//#line  9926 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_173[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9934 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_172  =    {(char const   *)0, (char const   *)0, (int16_t )-1, (uint16_t )1, (void const   *)(__constr_expr_173)};
//#line  9937 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_175  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  9940 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_174  =    {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )3, (void const   *)(& __constr_expr_175)};
//#line  9943 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_177[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9951 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_176  =    {(char const   *)str_180244545, (char const   *)str_10915755, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_177)};
//#line  9954 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_179  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )7};
//#line  9957 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_178  =    {(char const   *)str_180244545, (char const   *)str_10915755, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_179)};
//#line  9960 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_181[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  9968 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_180  =    {(char const   *)str_180244545, (char const   *)str_219267764, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_181)};
//#line  9971 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_182  =    {(char const   *)str_180244545, (char const   *)str_220831141, (int16_t )0, (uint16_t )2,
    (void const   *)0};
//#line  9974 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_183  =    {(char const   *)str_218283728, (char const   *)str_106136500, (int16_t )0, (uint16_t )2,
    (void const   *)0};
//#line  9977 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_185  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )3};
//#line  9980 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_184  =    {(char const   *)str_180244545, (char const   *)str_10915739, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_185)};
//#line  9983 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_187  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9986 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_186  =    {(char const   *)str_218283728, (char const   *)str_216271012, (int16_t )3, (uint16_t )3,
    (void const   *)(& __constr_expr_187)};
//#line  9989 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_189  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  9992 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_188  =    {(char const   *)str_218283728, (char const   *)str_335406018, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_189)};
//#line  9995 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_191[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10006 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_190  =    {(char const   *)str_180244545, (char const   *)str_11540368, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_191)};
//#line  10009 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_193  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10012 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_192  =    {(char const   *)str_482873, (char const   *)str_179391037, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_193)};
//#line  10015 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_195  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  10018 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_194  =    {(char const   *)str_218283728, (char const   *)0, (int16_t )0, (uint16_t )3, (void const   *)(& __constr_expr_195)};
//#line  10021 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_198  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10024 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_197[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )14, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )14, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_198)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10035 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_196  =    {(char const   *)str_218283728, (char const   *)str_219266585, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_197)};
//#line  10038 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_200  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10041 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_199  =    {(char const   *)str_218283728, (char const   *)str_504327, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_200)};
//#line  10044 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_202  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10047 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_201  =    {(char const   *)str_180244545, (char const   *)str_10902533, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_202)};
//#line  10050 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_204[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10058 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_203  =    {(char const   *)str_180244545, (char const   *)str_219267023, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_204)};
//#line  10061 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_206  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  10064 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_205  =    {(char const   *)str_180244545, (char const   *)str_220831597, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_206)};
//#line  10067 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_208[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10078 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_207  =    {(char const   *)str_180244545, (char const   *)str_219268125, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_208)};
//#line  10081 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_210  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10084 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_209  =    {(char const   *)str_218283728, (char const   *)str_199274370, (int16_t )0, (uint16_t )3,
    (void const   *)(& __constr_expr_210)};
//#line  10087 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_213  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10090 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_212[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_213)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10101 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_211  =    {(char const   *)str_218283728, (char const   *)str_215226995, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_212)};
//#line  10104 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_216  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10107 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_215[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_216)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10118 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_214  =    {(char const   *)str_218283728, (char const   *)str_327960850, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_215)};
//#line  10121 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_219  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10124 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_218[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )3, (void const   *)(& __constr_expr_219)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10135 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_217  =    {(char const   *)0, (char const   *)0, (int16_t )-1, (uint16_t )1, (void const   *)(__constr_expr_218)};
//#line  10138 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_221[4]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )15, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10149 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_220  =    {(char const   *)str_180244545, (char const   *)str_944848775, (int16_t )-1, (uint16_t )1,
    (void const   *)(__constr_expr_221)};
//#line  10152 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_223  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10155 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_222  =    {(char const   *)str_686943043, (char const   *)str_87930470, (int16_t )4, (uint16_t )3,
    (void const   *)(& __constr_expr_223)};
//#line  10158 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_225  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  10161 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_224  =    {(char const   *)str_522043394, (char const   *)str_854499087, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_225)};
//#line  10164 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_227  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10167 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_226  =    {(char const   *)str_522043394, (char const   *)str_854498725, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_227)};
//#line  10170 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_229  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10173 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_228  =    {(char const   *)str_522043394, (char const   *)str_63622457, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_229)};
//#line  10176 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_231  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )15};
//#line  10179 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_230  =    {(char const   *)str_522043394, (char const   *)str_854499811, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_231)};
//#line  10182 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_233  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  10185 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_232  =    {(char const   *)str_522043394, (char const   *)str_854501259, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_233)};
//#line  10188 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_235  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )511,
    (uint16_t )511};
//#line  10191 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_234  =    {(char const   *)str_522043394, (char const   *)str_854501259, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_235)};
//#line  10194 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_237  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )15,
    (uint16_t )3};
//#line  10197 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_236  =    {(char const   *)str_522043394, (char const   *)str_854499089, (int16_t )-1, (uint16_t )5,
    (void const   *)(& __constr_expr_237)};
//#line  10200 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_240  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
static struct snd_usb_audio_quirk  const  __constr_expr_239[11]  = 
//#line  10203
  {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )3, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )4, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )5, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )6, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )7, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )8, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )9, (uint16_t )5, (void const   *)(& __constr_expr_240)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10233 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_238  =    {(char const   *)str_522043394, (char const   *)str_892675406, (int16_t )-1, (uint16_t )1,
    (void const   *)(& __constr_expr_239)};
//#line  10236 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_242  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10239 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_241  =    {(char const   *)str_522043394, (char const   *)str_1005803972, (int16_t )6, (uint16_t )5,
    (void const   *)(& __constr_expr_242)};
//#line  10242 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_244  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10245 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_243  =    {(char const   *)str_522043394, (char const   *)str_11174419, (int16_t )3, (uint16_t )5,
    (void const   *)(& __constr_expr_244)};
//#line  10248 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_247  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
static struct snd_usb_audio_quirk  const  __constr_expr_246[11]  = 
//#line  10251
  {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )3, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )4, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )5, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )6, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )7, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )8, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )9, (uint16_t )5, (void const   *)(& __constr_expr_247)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10281 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_245  =    {(char const   *)str_522043394, (char const   *)str_35173879, (int16_t )-1, (uint16_t )1,
    (void const   *)(& __constr_expr_246)};
//#line  10284 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_250  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  10287 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_249[5]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )2, (uint16_t )11, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )3, (uint16_t )5, (void const   *)(& __constr_expr_250)}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10300 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_248  =    {(char const   *)0, (char const   *)0, (int16_t )-1, (uint16_t )1, (void const   *)(& __constr_expr_249)};
//#line  10303 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_251  =    {(char const   *)str_9440451, (char const   *)str_208320737, (int16_t )0, (uint16_t )4,
    (void const   *)0};
//#line  10306 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_252  =    {(char const   *)str_9440451, (char const   *)str_164490267, (int16_t )0, (uint16_t )4,
    (void const   *)0};
//#line  10309 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_254[3]  = {      {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )7, (void const   *)0}, 
        {(char const   *)0,
      (char const   *)0, (int16_t )1, (uint16_t )0, (void const   *)0}, 
        {(char const   *)0, (char const   *)0, (int16_t )-1, (unsigned short)0, (void const   *)0}};
//#line  10317 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_253  =    {(char const   *)str_558343, (char const   *)str_863125700, (int16_t )-1, (uint16_t )1,
    (void const   *)(& __constr_expr_254)};
//#line  10320 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_256  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )33023,
    (uint16_t )33023};
//#line  10323 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_255  =    {(char const   *)str_185760420, (char const   *)0, (int16_t )2, (uint16_t )8, (void const   *)(& __constr_expr_256)};
//#line  10326 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_258  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )33023,
    (uint16_t )33023};
//#line  10329 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_257  =    {(char const   *)str_185760420, (char const   *)0, (int16_t )2, (uint16_t )8, (void const   *)(& __constr_expr_258)};
//#line  10332 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  __constr_expr_260  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )32783,
    (uint16_t )32771};
//#line  10335 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_259  =    {(char const   *)str_185760420, (char const   *)0, (int16_t )2, (uint16_t )8, (void const   *)(& __constr_expr_260)};
//#line  10338 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_261  =    {(char const   *)str_677794626, (char const   *)str_981105601, (int16_t )3, (uint16_t )2,
    (void const   *)0};
//#line  10341 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_262  =    {(char const   *)str_677794626, (char const   *)str_981105601, (int16_t )3, (uint16_t )2,
    (void const   *)0};
//#line  10344 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_263  =    {(char const   *)str_677794626, (char const   *)str_981105601, (int16_t )3, (uint16_t )2,
    (void const   *)0};
//#line  10347 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_264  =    {(char const   *)str_1015625071, (char const   *)str_902805966, (int16_t )0, (uint16_t )9,
    (void const   *)0};
//#line  10350 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_265  =    {(char const   *)str_984249857, (char const   *)str_21158850, (int16_t )-2, (unsigned short)0,
    (void const   *)0};
//#line  10353 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_266  =    {(char const   *)str_984249857, (char const   *)str_21158850, (int16_t )-2, (unsigned short)0,
    (void const   *)0};
//#line  10356 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_267  =    {(char const   *)str_87817340, (char const   *)str_298493551, (int16_t )4, (uint16_t )6,
    (void const   *)0};
//#line  10359 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_268  =    {(char const   *)str_87817340, (char const   *)str_974799125, (int16_t )3, (uint16_t )6,
    (void const   *)0};
//#line  10362 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_269  =    {(char const   *)str_87817340, (char const   *)str_941262301, (int16_t )0, (uint16_t )6,
    (void const   *)0};
//#line  10365 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_270  =    {(char const   *)str_599646, (char const   *)str_597637, (int16_t )-2, (unsigned short)0,
    (void const   *)0};
//#line  10368 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_271  =    {(char const   *)str_1015625071, (char const   *)str_799096034, (int16_t )0, (uint16_t )9,
    (void const   *)0};
//#line  10371 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_272  =    {(char const   *)0, (char const   *)0, (int16_t )0, (uint16_t )9, (void const   *)0};
//#line  10374 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  __constr_expr_273  =    {(char const   *)0, (char const   *)0, (int16_t )-1, (uint16_t )2, (void const   *)0};
static struct usb_device_id usb_audio_ids[190]  = 
//#line  10377
  {      {(__u16 )3, (__u16 )1054, (__u16 )12304, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_0))}, 
        {(__u16 )3,
      (__u16 )1054, (__u16 )16130, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1054, (__u16 )16132, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1054, (__u16 )16138, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2128, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2222, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2246, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2288, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2293, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )387, (__u16 )1133, (__u16 )2294, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )3, (__u16 )1133, (__u16 )2448, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_1))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4096, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_2))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4097, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_3))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4098, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_4))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4099, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_5))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4100, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_6))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4101, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_7))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4102, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_8))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4103, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_9))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4104, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_10))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4105, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_11))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4106, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_12))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4108, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_13))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4109, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_14))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4110, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_15))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4111, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_16))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4112, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_17))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4113, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_18))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4114, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_19))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4115, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_20))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4116, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_21))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4117, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_22))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4118, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_23))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4119, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_24))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4120, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_25))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4121, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_26))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4122, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_27))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4123, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_28))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4124, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_29))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4125, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_30))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4126, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_31))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4127, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_32))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4128, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_33))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4129, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_34))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4130, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_35))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4131, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_36))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4132, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_37))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4133, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_38))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4134, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_39))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4135, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_40))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4136, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_41))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4137, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_42))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4138, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_43))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4139, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_44))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4142, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_45))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4144, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_46))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4145, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_47))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4146, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_48))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4147, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_49))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4148, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_50))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4149, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_51))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4150, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_52))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4151, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_53))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4152, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_54))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4153, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_55))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4154, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_56))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4155, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_57))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4156, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_58))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4157, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_59))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4158, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_60))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4159, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_61))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4160, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_62))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4161, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_63))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4162, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_64))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4163, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_65))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4164, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_66))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4165, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_67))}, 
        {(__u16 )131,
      (__u16 )1177, (__u16 )4174, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_68))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4175, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_69))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4176, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_70))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )4177, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_71))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )4178, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_72))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )8192, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_73))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )8193, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_74))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )8194, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_75))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20480, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_76))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20481, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_77))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20482, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_78))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20483, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_79))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20484, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_80))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20485, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_81))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20486, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_82))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20487, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_83))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20488, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_84))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20489, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_85))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20490, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_86))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20491, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_87))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20492, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_88))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20493, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_89))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )20494, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_90))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )20495, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_91))}, 
        {(__u16 )3,
      (__u16 )1177, (__u16 )28672, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_92))}, 
        {(__u16 )3, (__u16 )1177, (__u16 )28688, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_93))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )0, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_94))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_99))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )3, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_102))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )4, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_105))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )5, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_108))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )7, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_111))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )8, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_114))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )9, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_117))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )11, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_120))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )12, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_123))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )16, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_128))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )18, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_130))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )20, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_132))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )22, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_134))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )27, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_137))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )29, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_140))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )35, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_142))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )37, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_144))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )39, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_149))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )41, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_151))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )43, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_153))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )45, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_155))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )47, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_157))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )51, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_159))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )55, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_161))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )59, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_163))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )64, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_165))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )66, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_167))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )68, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_169))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )71, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_172))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )72, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_174))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )76, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_176))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )77, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_178))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )80, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_180))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )82, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_182))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )96, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_183))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )101, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_184))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )106, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_186))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )109, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_188))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )116, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_190))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )117, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_192))}, 
        {(__u16 )131,
      (__u16 )1410, (__u16 )122, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_194))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )125, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_196))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )128, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_199))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )139, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_201))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )150, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_203))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )154, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_205))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )163, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_207))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )166, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_209))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )173, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_211))}, 
        {(__u16 )3, (__u16 )1410, (__u16 )194, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_214))}, 
        {(__u16 )3,
      (__u16 )1410, (__u16 )218, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_217))}, 
        {(__u16 )131, (__u16 )1410, (__u16 )230, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_220))}, 
        {(__u16 )131,
      (__u16 )1784, (__u16 )45056, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_222))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4098, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_224))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4113, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_226))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4117, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_228))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4129, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_230))}, 
        {(__u16 )15, (__u16 )1891, (__u16 )4145, (__u16 )256, (__u16 )265, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_232))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )4147, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_234))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )4161, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_236))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )8193, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_238))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )8195, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_241))}, 
        {(__u16 )131, (__u16 )1891, (__u16 )8200, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_243))}, 
        {(__u16 )131,
      (__u16 )1891, (__u16 )8205, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_245))}, 
        {(__u16 )3, (__u16 )1891, (__u16 )8217, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_248))}, 
        {(__u16 )3,
      (__u16 )1999, (__u16 )26625, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_251))}, 
        {(__u16 )3, (__u16 )1999, (__u16 )26626, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_252))}, 
        {(__u16 )35,
      (__u16 )2045, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (__u8 )2, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_253))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_255))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_257))}, 
        {(__u16 )3, (__u16 )2154, (__u16 )3, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_259))}, 
        {(__u16 )131, (__u16 )3277, (__u16 )18, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_261))}, 
        {(__u16 )131,
      (__u16 )3277, (__u16 )19, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_262))}, 
        {(__u16 )131, (__u16 )3277, (__u16 )20, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_263))}, 
        {(__u16 )3,
      (__u16 )3277, (__u16 )53, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_264))}, 
        {(__u16 )3, (__u16 )4157, (__u16 )256, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_265))}, 
        {(__u16 )3,
      (__u16 )4157, (__u16 )257, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_266))}, 
        {(__u16 )131, (__u16 )4661, (__u16 )1, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_267))}, 
        {(__u16 )131,
      (__u16 )4661, (__u16 )2, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_268))}, 
        {(__u16 )131, (__u16 )4661, (__u16 )18017, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )255, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_269))}, 
        {(__u16 )3,
      (__u16 )5093, (__u16 )1, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_270))}, 
        {(__u16 )3, (__u16 )18258, (__u16 )17, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (unsigned char)0, (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_271))}, 
        {(__u16 )3,
      (__u16 )28932, (__u16 )8706, (unsigned short)0, (unsigned short)0, (unsigned char)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_272))}, 
        {(__u16 )384, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )3, (unsigned char)0,
      (struct snd_usb_audio_quirk *)((unsigned long )(& __constr_expr_273))}, 
        {(__u16 )384, (unsigned short)0, (unsigned short)0, (unsigned short)0, (unsigned short)0,
      (unsigned char)0, (unsigned char)0, (unsigned char)0, (__u8 )1, (__u8 )1, (unsigned char)0,
      (struct snd_usb_audio_quirk *)0}, 
        {(__u16 )0, (__u16 )0, (__u16 )0, (__u16 )0, (__u16 )0, (__u8 )0, (__u8 )0, (__u8 )0,
      (__u8 )0, (__u8 )0, (__u8 )0, (struct snd_usb_audio_quirk *)0}};
//#line  11021
extern struct usb_device_id  const  __mod_usb_device_table  __attribute__((__unused__,
__alias__("usb_audio_ids"))) ;
static struct usb_driver usb_audio_driver  = 
//#line  11024
     {str_496460573, (int (*)(struct usb_interface *intf , struct usb_device_id  const  *id ))(& usb_audio_probe),
    (void (*)(struct usb_interface *intf ))(& usb_audio_disconnect), (int (*)(struct usb_interface *intf ,
                                                                              unsigned int code ,
                                                                              void *buf ))0,
    & usb_audio_suspend, & usb_audio_resume, (int (*)(struct usb_interface *intf ))0,
    (int (*)(struct usb_interface *intf ))0, (int (*)(struct usb_interface *intf ))0,
    (struct usb_device_id  const  *)(usb_audio_ids), {{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0,
                                                                                 (struct lock_class *)0,
                                                                                 (char const   *)0}},
                                                      {(struct list_head *)0, (struct list_head *)0}},
    {{(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
      (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
      (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
      (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
     0}, 0U, 0U, 0U};
//#line  11042 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) proc_pcm_format_add)(struct snd_usb_stream *stream ) 
{ 


  {
  record_function("proc_pcm_format_add");
//#line  11048
  return;
}
}
//#line  11052 "usb-audio.merged.sym.c"
static struct lock_class_key __key___5  ;
//#line  11054 "usb-audio.merged.sym.c"
static void init_substream(struct snd_usb_stream *as , int stream , struct audioformat *fp ) 
{ 
  struct snd_usb_substream *subs ;
  struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) *tmp ;

  {
  record_function("init_substream");
  {
//#line  11061
  subs = & as->substream[stream];
//#line  11063
  INIT_LIST_HEAD(& subs->fmt_list);
  }
  {
  {
//#line  11065
  while (1) {


    {
//#line  11067
    __spin_lock_init(& subs->lock, str_953588697, & __key___5);
    }
//#line  11069
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  11072
  subs->stream = (struct snd_usb_stream *)as;
//#line  11074
  subs->direction = stream;
//#line  11076
  subs->dev = (as->chip)->dev;
//#line  11078
  if ((unsigned int )(subs->dev)->speed == 2U) {
//#line  11080
    subs->ops = audio_urb_ops[stream];
  } else {
//#line  11083
    subs->ops = audio_urb_ops_high_speed[stream];
    {
    if ((int )(as->chip)->usb_id == ((1054 << 16) | 16130)) {
//#line  11086
      goto case_exp;
    }
    if ((int )(as->chip)->usb_id == ((1054 << 16) | 16132)) {
//#line  11087
      goto case_exp;
    }
    if ((int )(as->chip)->usb_id == ((1054 << 16) | 16138)) {
//#line  11088
      goto case_exp;
    }
//#line  11085
    goto switch_break;
    case_exp: /* CIL Label */ 
//#line  11090
    subs->ops.retire_sync = & retire_playback_sync_urb_hs_emu;
//#line  11092
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
//#line  11096
  if (stream == 0) {
//#line  11098
    tmp = & snd_usb_playback_ops;
  } else {
//#line  11101
    tmp = & snd_usb_capture_ops;
  }
  {
//#line  11104
  snd_pcm_set_ops((struct snd_pcm *)as->pcm, stream, (struct snd_pcm_ops *)tmp);
//#line  11106
  list_add_tail(& fp->list, & subs->fmt_list);
//#line  11108
  subs->formats |= 1ULL << fp->format;
//#line  11110
  subs->endpoint = (int )fp->endpoint;
//#line  11112
  (subs->num_formats) ++;
//#line  11114
  subs->fmt_type = fp->fmt_type;
  }
//#line  11116
  return;
}
}
//#line  11120 "usb-audio.merged.sym.c"
static void free_substream(struct snd_usb_substream *subs ) 
{ 
  struct list_head *p ;
  struct list_head *n ;
  struct audioformat *fp ;
  struct list_head  const  *__mptr ;

  {
  record_function("free_substream");
//#line  11129
  if (! subs->num_formats) {
//#line  11131
    return;
  }
//#line  11134
  p = (struct list_head *)subs->fmt_list.next;
//#line  11136
  n = (struct list_head *)p->next;
  {
  {
//#line  11138
  while (1) {


    if (! ((unsigned long )p != (unsigned long )(& subs->fmt_list))) {
//#line  11138
      goto while_break;
    }
    {
//#line  11140
    __mptr = (struct list_head  const  *)p;
//#line  11142
    fp = (struct audioformat *)((char *)__mptr - (unsigned int )(& ((struct audioformat *)0)->list));
//#line  11144
    kfree((void const   *)fp->rate_table);
//#line  11146
    kfree((void const   *)fp);
//#line  11148
    p = n;
//#line  11150
    n = (struct list_head *)p->next;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  11153
  kfree((void const   *)subs->rate_list.list);
  }
//#line  11155
  return;
}
}
//#line  11159 "usb-audio.merged.sym.c"
static void snd_usb_audio_stream_free(struct snd_usb_stream *stream ) 
{ 


  {
  record_function("snd_usb_audio_stream_free");
  {
//#line  11165
  free_substream(& stream->substream[0]);
//#line  11167
  free_substream(& stream->substream[1]);
//#line  11169
  list_del(& stream->list);
//#line  11171
  kfree((void const   *)stream);
  }
//#line  11173
  return;
}
}
//#line  11177 "usb-audio.merged.sym.c"
static void snd_usb_audio_pcm_free(struct snd_pcm *pcm ) 
{ 
  struct snd_usb_stream *stream ;

  {
  record_function("snd_usb_audio_pcm_free");
//#line  11183
  stream = (struct snd_usb_stream *)pcm->private_data;
//#line  11185
  if (stream) {
    {
//#line  11187
    stream->pcm = (struct snd_pcm *)((void *)0);
//#line  11189
    snd_usb_audio_stream_free(stream);
    }
  }
//#line  11192
  return;
}
}
//#line  11196 "usb-audio.merged.sym.c"
static int add_audio_endpoint(struct snd_usb_audio *chip , int stream , struct audioformat *fp ) 
{ 
  struct list_head *p ;
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;
  struct snd_pcm *pcm ;
  int err ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  record_function("add_audio_endpoint");
//#line  11211
  p = (struct list_head *)chip->pcm_list.next;
  {
  {
//#line  11213
  while (1) {


    {
//#line  11215
    __builtin_prefetch((void const   *)p->next);
    }
//#line  11217
    if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  11219
      goto while_break;
    }
//#line  11222
    __mptr = (struct list_head  const  *)p;
//#line  11224
    as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  11226
    if (as->fmt_type != fp->fmt_type) {
//#line  11228
      goto __Cont;
    }
//#line  11231
    subs = & as->substream[stream];
//#line  11233
    if (! subs->endpoint) {
//#line  11235
      goto __Cont;
    }
//#line  11238
    if (subs->endpoint == (int )fp->endpoint) {
      {
//#line  11240
      list_add_tail(& fp->list, & subs->fmt_list);
//#line  11242
      (subs->num_formats) ++;
//#line  11244
      subs->formats |= 1ULL << fp->format;
      }
//#line  11246
      return (0);
    }
    __Cont: 
//#line  11250
    p = (struct list_head *)p->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  11253
  p = (struct list_head *)chip->pcm_list.next;
  {
  {
//#line  11255
  while (1) {


    {
//#line  11257
    __builtin_prefetch((void const   *)p->next);
    }
//#line  11259
    if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  11261
      goto while_break___0;
    }
//#line  11264
    __mptr___0 = (struct list_head  const  *)p;
//#line  11266
    as = (struct snd_usb_stream *)((char *)__mptr___0 - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  11268
    if (as->fmt_type != fp->fmt_type) {
//#line  11270
      goto __Cont___0;
    }
//#line  11273
    subs = & as->substream[stream];
//#line  11275
    if (subs->endpoint) {
//#line  11277
      goto __Cont___0;
    }
    {
//#line  11280
    err = snd_pcm_new_stream((struct snd_pcm *)as->pcm, stream, 1);
    }
//#line  11282
    if (err < 0) {
//#line  11284
      return (err);
    }
    {
//#line  11287
    init_substream(as, stream, fp);
    }
//#line  11289
    return (0);
    __Cont___0: 
//#line  11292
    p = (struct list_head *)p->next;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  11295
  tmp = kzalloc(sizeof(*as), 208U);
//#line  11297
  as = (struct snd_usb_stream *)tmp;
  }
//#line  11299
  if (! as) {
//#line  11301
    return (-12);
  }
//#line  11304
  as->pcm_index = chip->pcm_devs;
//#line  11306
  as->chip = chip;
//#line  11308
  as->fmt_type = fp->fmt_type;
//#line  11310
  if (stream == 0) {
//#line  11312
    tmp___0 = 0;
  } else {
//#line  11315
    tmp___0 = 1;
  }
//#line  11318
  if (stream == 0) {
//#line  11320
    tmp___1 = 1;
  } else {
//#line  11323
    tmp___1 = 0;
  }
  {
//#line  11326
  err = snd_pcm_new(chip->card, (char *)str_569364926, chip->pcm_devs, tmp___1, tmp___0,
                    & pcm);
  }
//#line  11329
  if (err < 0) {
    {
//#line  11331
    kfree((void const   *)as);
    }
//#line  11333
    return (err);
  }
//#line  11336
  as->pcm = (struct snd_pcm *)pcm;
//#line  11338
  pcm->private_data = (void *)as;
//#line  11340
  pcm->private_free = & snd_usb_audio_pcm_free;
//#line  11342
  pcm->info_flags = 0U;
//#line  11344
  if (chip->pcm_devs > 0) {
    {
//#line  11346
    sprintf(pcm->name, str_351748476, chip->pcm_devs);
    }
  } else {
    {
//#line  11349
    strcpy(pcm->name, str_569364926);
    }
  }
  {
//#line  11352
  init_substream(as, stream, fp);
//#line  11354
  list_add(& as->list, & chip->pcm_list);
//#line  11356
  (chip->pcm_devs) ++;
//#line  11358
  proc_pcm_format_add(as);
  }
//#line  11360
  return (0);
}
}
//#line  11364 "usb-audio.merged.sym.c"
static int is_big_endian_format(struct snd_usb_audio *chip , struct audioformat *fp ) 
{ 


  {
  record_function("is_big_endian_format");
  {
  if ((int )chip->usb_id == ((1891 << 16) | 8193)) {
//#line  11371
    goto case_exp;
  }
  if ((int )chip->usb_id == ((1891 << 16) | 8195)) {
//#line  11379
    goto case_exp___0;
  }
//#line  11370
  goto switch_break;
  case_exp: /* CIL Label */ 
//#line  11373
  if ((int )fp->endpoint & 128) {
//#line  11375
    return (1);
  }
//#line  11378
  goto switch_break;
  case_exp___0: /* CIL Label */ 
//#line  11381
  if (device_setup[chip->index] == 0) {
//#line  11383
    return (1);
  } else
//#line  11386
  if ((int )fp->altsetting == 1) {
//#line  11388
    return (1);
  } else
//#line  11391
  if ((int )fp->altsetting == 2) {
//#line  11393
    return (1);
  } else
//#line  11396
  if ((int )fp->altsetting == 3) {
//#line  11398
    return (1);
  }
  switch_break: /* CIL Label */ ;
  }
//#line  11402
  return (0);
}
}
//#line  11406 "usb-audio.merged.sym.c"
static int parse_audio_format_i_type(struct snd_usb_audio *chip , struct audioformat *fp ,
                                     int format , unsigned char *fmt ) 
{ 
  int pcm_format ;
  int sample_width ;
  int sample_bytes ;
  int tmp ;
  int tmp___0 ;

  {
  record_function("parse_audio_format_i_type");
//#line  11417
  pcm_format = -1;
//#line  11419
  sample_width = (int )*(fmt + 6);
//#line  11421
  sample_bytes = (int )*(fmt + 5);
  {
  if (format == 0) {
//#line  11424
    goto case_0;
  }
  if (format == 1) {
//#line  11428
    goto case_1;
  }
  if (format == 2) {
//#line  11482
    goto case_2___0;
  }
  if (format == 3) {
//#line  11492
    goto case_3___0;
  }
  if (format == 4) {
//#line  11497
    goto case_4___0;
  }
  if (format == 5) {
//#line  11502
    goto case_5;
  }
//#line  11507
  goto switch_default___0;
  case_0: /* CIL Label */ 
  {
//#line  11426
  printk(str_908632785, (chip->dev)->devnum, fp->iface, (int )fp->altsetting);
  }
  case_1: /* CIL Label */ 
//#line  11430
  if (sample_width > sample_bytes * 8) {
    {
//#line  11432
    printk(str_444495457, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, sample_width,
           sample_bytes);
    }
  }
  {
  if ((int )*(fmt + 5) == 1) {
//#line  11437
    goto case_1___0;
  }
  if ((int )*(fmt + 5) == 2) {
//#line  11442
    goto case_2;
  }
  if ((int )*(fmt + 5) == 3) {
//#line  11455
    goto case_3;
  }
  if ((int )*(fmt + 5) == 4) {
//#line  11468
    goto case_4;
  }
//#line  11473
  goto switch_default;
  case_1___0: /* CIL Label */ 
//#line  11439
  pcm_format = 0;
//#line  11441
  goto switch_break___0;
  case_2: /* CIL Label */ 
  {
//#line  11444
  tmp = is_big_endian_format(chip, fp);
  }
//#line  11446
  if (tmp) {
//#line  11448
    pcm_format = 3;
  } else {
//#line  11451
    pcm_format = 2;
  }
//#line  11454
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
//#line  11457
  tmp___0 = is_big_endian_format(chip, fp);
  }
//#line  11459
  if (tmp___0) {
//#line  11461
    pcm_format = 33;
  } else {
//#line  11464
    pcm_format = 32;
  }
//#line  11467
  goto switch_break___0;
  case_4: /* CIL Label */ 
//#line  11470
  pcm_format = 10;
//#line  11472
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
//#line  11475
  printk(str_1069376918, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, sample_width,
         sample_bytes);
  }
//#line  11478
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
//#line  11481
  goto switch_break;
  case_2___0: /* CIL Label */ 
//#line  11484
  pcm_format = 1;
//#line  11486
  if (chip->usb_id == (u32 )((1274 << 16) | 16897)) {
//#line  11488
    pcm_format = 0;
  }
//#line  11491
  goto switch_break;
  case_3___0: /* CIL Label */ 
//#line  11494
  pcm_format = 14;
//#line  11496
  goto switch_break;
  case_4___0: /* CIL Label */ 
//#line  11499
  pcm_format = 21;
//#line  11501
  goto switch_break;
  case_5: /* CIL Label */ 
//#line  11504
  pcm_format = 20;
//#line  11506
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
//#line  11509
  printk(str_576734707, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, format);
  }
//#line  11512
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  11515
  return (pcm_format);
}
}
//#line  11519 "usb-audio.merged.sym.c"
static int parse_audio_format_rates(struct snd_usb_audio *chip , struct audioformat *fp ,
                                    unsigned char *fmt , int offset ) 
{ 
  int nr_rates ;
  int tmp ;
  int r ;
  int idx ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int rate ;
  unsigned int tmp___2 ;

  {
  record_function("parse_audio_format_rates");
//#line  11533
  nr_rates = (int )*(fmt + offset);
//#line  11535
  if (nr_rates) {
//#line  11537
    tmp = nr_rates;
  } else {
//#line  11540
    tmp = 2;
  }
//#line  11543
  if ((int )*(fmt + 0) < (offset + 1) + 3 * tmp) {
    {
//#line  11545
    printk(str_1054178865, (chip->dev)->devnum, fp->iface, (int )fp->altsetting);
    }
//#line  11548
    return (-1);
  }
//#line  11551
  if (nr_rates) {
    {
//#line  11553
    tmp___0 = kmalloc(sizeof(int ) * (unsigned long )nr_rates, 208U);
//#line  11555
    fp->rate_table = (unsigned int *)tmp___0;
    }
//#line  11557
    if ((unsigned long )fp->rate_table == (unsigned long )((void *)0)) {
      {
//#line  11559
      printk(str_967653936);
      }
//#line  11561
      return (-1);
    }
//#line  11564
    fp->nr_rates = 0U;
//#line  11566
    tmp___1 = 0U;
//#line  11568
    fp->rate_max = tmp___1;
//#line  11570
    fp->rate_min = tmp___1;
//#line  11572
    r = 0;
//#line  11574
    idx = offset + 1;
    {
    {
//#line  11576
    while (1) {


      if (! (r < nr_rates)) {
//#line  11576
        goto while_break;
      }
//#line  11578
      rate = ((unsigned int )*(fmt + idx) | ((unsigned int )*((fmt + idx) + 1) << 8)) | ((unsigned int )*((fmt + idx) + 2) << 16);
//#line  11580
      if (! rate) {
//#line  11582
        goto __Cont;
      }
//#line  11585
      if (rate == 48000U) {
//#line  11587
        if (nr_rates == 1) {
//#line  11589
          if (chip->usb_id == (u32 )((3468 << 16) | 513)) {
//#line  11591
            goto _L;
          } else
//#line  11594
          if (chip->usb_id == (u32 )((3468 << 16) | 258)) {
            _L: 
//#line  11597
            if ((int )fp->altsetting == 5) {
//#line  11599
              if (fp->maxpacksize == 392U) {
//#line  11601
                rate = 96000U;
              }
            }
          }
        }
      }
//#line  11608
      *(fp->rate_table + fp->nr_rates) = rate;
//#line  11610
      if (! fp->rate_min) {
//#line  11612
        fp->rate_min = rate;
      } else
//#line  11615
      if (rate < fp->rate_min) {
//#line  11617
        fp->rate_min = rate;
      }
//#line  11620
      if (! fp->rate_max) {
//#line  11622
        fp->rate_max = rate;
      } else
//#line  11625
      if (rate > fp->rate_max) {
//#line  11627
        fp->rate_max = rate;
      }
      {
//#line  11630
      tmp___2 = snd_pcm_rate_to_rate_bit(rate);
//#line  11632
      fp->rates |= tmp___2;
//#line  11634
      (fp->nr_rates) ++;
      }
      __Cont: 
//#line  11637
      r ++;
//#line  11639
      idx += 3;
    }

    }
    while_break: /* CIL Label */ ;
    }
//#line  11642
    if (! fp->nr_rates) {
//#line  11644
      return (-1);
    }
  } else {
//#line  11648
    fp->rates = (unsigned int )(1 << 30);
//#line  11650
    fp->rate_min = ((unsigned int )*(fmt + (offset + 1)) | ((unsigned int )*((fmt + (offset + 1)) + 1) << 8)) | ((unsigned int )*((fmt + (offset + 1)) + 2) << 16);
//#line  11652
    fp->rate_max = ((unsigned int )*(fmt + (offset + 4)) | ((unsigned int )*((fmt + (offset + 4)) + 1) << 8)) | ((unsigned int )*((fmt + (offset + 4)) + 2) << 16);
  }
//#line  11655
  return (0);
}
}
//#line  11659 "usb-audio.merged.sym.c"
static int parse_audio_format_i(struct snd_usb_audio *chip , struct audioformat *fp ,
                                int format , unsigned char *fmt ) 
{ 
  int pcm_format ;
  int tmp ;

  {
  record_function("parse_audio_format_i");
//#line  11667
  if ((int )*(fmt + 3) == 3) {
    {
    if ((int )chip->usb_id == ((1891 << 16) | 8195)) {
//#line  11670
      goto case_exp;
    }
//#line  11687
    goto switch_default;
    case_exp: /* CIL Label */ 
//#line  11672
    if (device_setup[chip->index] == 0) {
//#line  11674
      if ((int )fp->altsetting == 6) {
//#line  11676
        pcm_format = 3;
      } else {
//#line  11679
        pcm_format = 2;
      }
    } else {
//#line  11683
      pcm_format = 2;
    }
//#line  11686
    goto switch_break;
    switch_default: /* CIL Label */ 
//#line  11689
    pcm_format = 2;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
//#line  11693
    pcm_format = parse_audio_format_i_type(chip, fp, format, fmt);
    }
//#line  11695
    if (pcm_format < 0) {
//#line  11697
      return (-1);
    }
  }
//#line  11701
  fp->format = pcm_format;
//#line  11703
  fp->channels = (unsigned int )*(fmt + 4);
//#line  11705
  if (fp->channels < 1U) {
    {
//#line  11707
    printk(str_564233269, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, fp->channels);
    }
//#line  11710
    return (-1);
  }
  {
//#line  11713
  tmp = parse_audio_format_rates(chip, fp, fmt, 7);
  }
//#line  11715
  return (tmp);
}
}
//#line  11719 "usb-audio.merged.sym.c"
static int parse_audio_format_ii(struct snd_usb_audio *chip , struct audioformat *fp ,
                                 int format , unsigned char *fmt ) 
{ 
  int brate ;
  int framesize ;
  int tmp ;

  {
  record_function("parse_audio_format_ii");
  {
  if (format == 4098) {
//#line  11729
    goto case_4098;
  }
  if (format == 4097) {
//#line  11734
    goto case_4097;
  }
//#line  11739
  goto switch_default;
  case_4098: /* CIL Label */ 
//#line  11731
  fp->format = 1;
//#line  11733
  goto switch_break;
  case_4097: /* CIL Label */ 
//#line  11736
  fp->format = 23;
//#line  11738
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  11741
  printk(str_1039773507, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, format);
//#line  11744
  fp->format = 23;
  }
//#line  11746
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
//#line  11749
  fp->channels = 1U;
//#line  11751
  brate = (int )((unsigned int )*(fmt + 4) | ((unsigned int )*((fmt + 4) + 1) << 8));
//#line  11753
  framesize = (int )((unsigned int )*(fmt + 6) | ((unsigned int )*((fmt + 6) + 1) << 8));
//#line  11755
  printk(str_589782702, brate, framesize);
//#line  11757
  fp->frame_size = (unsigned int )framesize;
//#line  11759
  tmp = parse_audio_format_rates(chip, fp, fmt, 8);
  }
//#line  11761
  return (tmp);
}
}
//#line  11765 "usb-audio.merged.sym.c"
static int parse_audio_format(struct snd_usb_audio *chip , struct audioformat *fp ,
                              int format , unsigned char *fmt , int stream ) 
{ 
  int err ;

  {
  record_function("parse_audio_format");
  {
  if ((int )*(fmt + 3) == 1) {
//#line  11773
    goto case_1;
  }
  if ((int )*(fmt + 3) == 3) {
//#line  11774
    goto case_1;
  }
  if ((int )*(fmt + 3) == 2) {
//#line  11779
    goto case_2;
  }
//#line  11784
  goto switch_default;
  case_1: /* CIL Label */ 
  {
//#line  11776
  err = parse_audio_format_i(chip, fp, format, fmt);
  }
//#line  11778
  goto switch_break;
  case_2: /* CIL Label */ 
  {
//#line  11781
  err = parse_audio_format_ii(chip, fp, format, fmt);
  }
//#line  11783
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  11786
  printk(str_595175755, (chip->dev)->devnum, fp->iface, (int )fp->altsetting, (int )*(fmt + 3));
  }
//#line  11789
  return (-1);
  switch_break: /* CIL Label */ ;
  }
//#line  11792
  fp->fmt_type = (unsigned int )*(fmt + 3);
//#line  11794
  if (err < 0) {
//#line  11796
    return (err);
  }
//#line  11799
  if (chip->usb_id == (u32 )((1054 << 16) | 12288)) {
//#line  11801
    goto _L;
  } else
//#line  11804
  if (chip->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  11806
    goto _L;
  } else
//#line  11809
  if (chip->usb_id == (u32 )((1054 << 16) | 12385)) {
    _L: 
//#line  11812
    if ((int )*(fmt + 3) == 1) {
//#line  11814
      if (fp->rates != (unsigned int )(1 << 7)) {
//#line  11816
        if (fp->rates != (unsigned int )(1 << 10)) {
//#line  11818
          return (-1);
        }
      }
    }
  }
//#line  11824
  return (0);
}
}
//#line  11828
static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip , int iface ,
                                         int altno ) ;
//#line  11831 "usb-audio.merged.sym.c"
static int parse_audio_endpoints(struct snd_usb_audio *chip , int iface_no ) 
{ 
  struct usb_device *dev ;
  struct usb_interface *iface ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int i ;
  int altno ;
  int err ;
  int stream ;
  int format ;
  struct audioformat *fp ;
  unsigned char *fmt ;
  unsigned char *csep ;
  int num ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;

  {
  record_function("parse_audio_endpoints");
  {
//#line  11856
  dev = chip->dev;
//#line  11858
  iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )iface_no);
//#line  11860
  num = (int )iface->num_altsetting;
  }
//#line  11862
  if (chip->usb_id == (u32 )((1274 << 16) | 16897)) {
//#line  11864
    num = 4;
  }
//#line  11867
  i = 0;
  {
  {
//#line  11869
  while (1) {


    if (! (i < num)) {
//#line  11869
      goto while_break;
    }
//#line  11871
    alts = iface->altsetting + i;
//#line  11873
    altsd = & alts->desc;
//#line  11875
    if ((int )altsd->bInterfaceClass != 1) {
//#line  11877
      if ((int )altsd->bInterfaceClass != 255) {
//#line  11879
        goto __Cont;
      } else {
//#line  11882
        goto _L___0;
      }
    } else
    _L___0: 
//#line  11887
    if ((int )altsd->bInterfaceSubClass != 2) {
//#line  11889
      if ((int )altsd->bInterfaceSubClass != 255) {
//#line  11891
        goto __Cont;
      } else {
//#line  11894
        goto _L;
      }
    } else
    _L: 
//#line  11899
    if ((int )altsd->bNumEndpoints < 1) {
//#line  11901
      goto __Cont;
    } else
//#line  11904
    if ((int )(alts->endpoint + 0)->desc.wMaxPacketSize == 0) {
//#line  11906
      goto __Cont;
    }
//#line  11909
    if (((int )(alts->endpoint + 0)->desc.bmAttributes & 3) != 1) {
//#line  11911
      goto __Cont;
    }
//#line  11914
    if ((int )(alts->endpoint + 0)->desc.bEndpointAddress & 128) {
//#line  11916
      stream = 1;
    } else {
//#line  11919
      stream = 0;
    }
//#line  11922
    altno = (int )altsd->bAlternateSetting;
//#line  11924
    if (chip->usb_id == (u32 )((1891 << 16) | 8195)) {
      {
//#line  11926
      tmp = audiophile_skip_setting_quirk(chip, iface_no, altno);
      }
//#line  11928
      if (tmp) {
//#line  11930
        goto __Cont;
      }
    }
    {
//#line  11934
    tmp___0 = snd_usb_find_csint_desc((void *)alts->extra, alts->extralen, (void *)0,
                                      (u8 )1);
//#line  11937
    fmt = (unsigned char *)tmp___0;
    }
//#line  11939
    if (! fmt) {
      {
//#line  11941
      printk(str_882451506, dev->devnum, iface_no, altno);
      }
//#line  11944
      goto __Cont;
    }
//#line  11947
    if ((int )*(fmt + 0) < 7) {
      {
//#line  11949
      printk(str_857529930, dev->devnum, iface_no, altno);
      }
//#line  11951
      goto __Cont;
    }
    {
//#line  11954
    format = ((int )*(fmt + 6) << 8) | (int )*(fmt + 5);
//#line  11956
    tmp___1 = snd_usb_find_csint_desc((void *)alts->extra, alts->extralen, (void *)0,
                                      (u8 )2);
//#line  11959
    fmt = (unsigned char *)tmp___1;
    }
//#line  11961
    if (! fmt) {
      {
//#line  11963
      printk(str_51703753, dev->devnum, iface_no, altno);
      }
//#line  11965
      goto __Cont;
    }
//#line  11968
    if ((int )*(fmt + 0) < 8) {
      {
//#line  11970
      printk(str_1054178865, dev->devnum, iface_no, altno);
      }
//#line  11972
      goto __Cont;
    }
    {
//#line  11975
    tmp___2 = snd_usb_find_desc((void *)(alts->endpoint + 0)->extra, (alts->endpoint + 0)->extralen,
                                (void *)0, (u8 )((1 << 5) | 5));
//#line  11978
    csep = (unsigned char *)tmp___2;
    }
//#line  11980
    if (! csep) {
//#line  11982
      if ((int )altsd->bNumEndpoints >= 2) {
        {
//#line  11984
        tmp___3 = snd_usb_find_desc((void *)(alts->endpoint + 1)->extra, (alts->endpoint + 1)->extralen,
                                    (void *)0, (u8 )((1 << 5) | 5));
//#line  11987
        csep = (unsigned char *)tmp___3;
        }
      }
    }
//#line  11991
    if (! csep) {
      {
//#line  11993
      printk(str_528878465, dev->devnum, iface_no, altno);
//#line  11996
      csep = (unsigned char *)((void *)0);
      }
    } else
//#line  11999
    if ((int )*(csep + 0) < 7) {
      {
//#line  12001
      printk(str_528878465, dev->devnum, iface_no, altno);
//#line  12004
      csep = (unsigned char *)((void *)0);
      }
    } else
//#line  12007
    if ((int )*(csep + 2) != 1) {
      {
//#line  12009
      printk(str_528878465, dev->devnum, iface_no, altno);
//#line  12012
      csep = (unsigned char *)((void *)0);
      }
    }
    {
//#line  12015
    tmp___4 = kzalloc(sizeof(*fp), 208U);
//#line  12017
    fp = (struct audioformat *)tmp___4;
    }
//#line  12019
    if (! fp) {
      {
//#line  12021
      printk(str_967653936);
      }
//#line  12023
      return (-12);
    }
//#line  12026
    fp->iface = iface_no;
//#line  12028
    fp->altsetting = (unsigned char )altno;
//#line  12030
    fp->altset_idx = (unsigned char )i;
//#line  12032
    fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  12034
    fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  12036
    fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  12038
    if ((unsigned int )dev->speed == 3U) {
//#line  12040
      fp->maxpacksize = (((fp->maxpacksize >> 11) & 3U) + 1U) * (fp->maxpacksize & 2047U);
    }
//#line  12043
    if (csep) {
//#line  12045
      fp->attributes = *(csep + 3);
    } else {
//#line  12048
      fp->attributes = (unsigned char)0;
    }
    {
    if ((int )chip->usb_id == ((2706 << 16) | 83)) {
//#line  12052
      goto case_exp;
    }
    if ((int )chip->usb_id == ((1054 << 16) | 12320)) {
//#line  12057
      goto case_exp___0;
    }
    if ((int )chip->usb_id == ((1891 << 16) | 8195)) {
//#line  12058
      goto case_exp___0;
    }
    if ((int )chip->usb_id == ((1151 << 16) | 3233)) {
//#line  12063
      goto case_exp___2;
    }
    if ((int )chip->usb_id == ((1917 << 16) | 1967)) {
//#line  12064
      goto case_exp___2;
    }
//#line  12051
    goto switch_break;
    case_exp: /* CIL Label */ 
//#line  12054
    fp->attributes = (unsigned char )((int )fp->attributes & -2);
//#line  12056
    goto switch_break;
    case_exp___0: /* CIL Label */ 
//#line  12060
    fp->attributes = (unsigned char )((int )fp->attributes | 1);
//#line  12062
    goto switch_break;
    case_exp___2: /* CIL Label */ 
//#line  12066
    fp->ep_attr = (unsigned char )((int )fp->ep_attr & -13);
//#line  12068
    if (stream == 0) {
//#line  12070
      fp->ep_attr = (unsigned char )((int )fp->ep_attr | 8);
    } else {
//#line  12073
      fp->ep_attr = (unsigned char )((int )fp->ep_attr | 12);
    }
//#line  12076
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
//#line  12079
    tmp___5 = parse_audio_format(chip, fp, format, fmt, stream);
    }
//#line  12081
    if (tmp___5 < 0) {
      {
//#line  12083
      kfree((void const   *)fp->rate_table);
//#line  12085
      kfree((void const   *)fp);
      }
//#line  12087
      goto __Cont;
    }
    {
//#line  12090
    printk(str_677216733, dev->devnum, iface_no, altno, (int )fp->endpoint);
//#line  12093
    err = add_audio_endpoint(chip, stream, fp);
    }
//#line  12095
    if (err < 0) {
      {
//#line  12097
      kfree((void const   *)fp->rate_table);
//#line  12099
      kfree((void const   *)fp);
      }
//#line  12101
      return (err);
    }
    {
//#line  12104
    usb_set_interface(chip->dev, iface_no, altno);
//#line  12106
    init_usb_pitch(chip->dev, iface_no, alts, fp);
//#line  12108
    init_usb_sample_rate(chip->dev, iface_no, alts, fp, (int )fp->rate_max);
    }
    __Cont: 
//#line  12111
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  12114
  return (0);
}
}
//#line  12118 "usb-audio.merged.sym.c"
static void snd_usb_stream_disconnect(struct list_head *head ) 
{ 
  int idx ;
  struct snd_usb_stream *as ;
  struct snd_usb_substream *subs ;
  struct list_head  const  *__mptr ;

  {
  record_function("snd_usb_stream_disconnect");
//#line  12127
  __mptr = (struct list_head  const  *)head;
//#line  12129
  as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  12131
  idx = 0;
  {
  {
//#line  12133
  while (1) {


    if (! (idx < 2)) {
//#line  12133
      goto while_break;
    }
//#line  12135
    subs = & as->substream[idx];
//#line  12137
    if (! subs->num_formats) {
//#line  12139
      return;
    }
    {
//#line  12142
    release_substream_urbs(subs, 1);
//#line  12144
    subs->interface = -1;
//#line  12146
    idx ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  12149
  return;
}
}
//#line  12153 "usb-audio.merged.sym.c"
static int snd_usb_create_streams(struct snd_usb_audio *chip , int ctrlif ) 
{ 
  struct usb_device *dev ;
  struct usb_host_interface *host_iface ;
  struct usb_interface *iface ;
  unsigned char *p1 ;
  int i ;
  int j ;
  struct usb_interface *tmp ;
  void *tmp___0 ;
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  record_function("snd_usb_create_streams");
  {
//#line  12171
  dev = chip->dev;
//#line  12173
  tmp = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )ctrlif);
//#line  12175
  host_iface = tmp->altsetting + 0;
//#line  12177
  tmp___0 = snd_usb_find_csint_desc((void *)host_iface->extra, host_iface->extralen,
                                    (void *)0, (u8 )1);
//#line  12180
  p1 = (unsigned char *)tmp___0;
  }
//#line  12182
  if (! p1) {
    {
//#line  12184
    printk(str_15231084);
    }
//#line  12186
    return (-22);
  }
//#line  12189
  if (! *(p1 + 7)) {
    {
//#line  12191
    printk(str_960860569);
    }
//#line  12193
    return (-22);
  } else
//#line  12196
  if ((int )*(p1 + 0) < 8 + (int )*(p1 + 7)) {
    {
//#line  12198
    printk(str_960860569);
    }
//#line  12200
    return (-22);
  }
//#line  12203
  i = 0;
  {
  {
//#line  12205
  while (1) {


    if (! (i < (int )*(p1 + 7))) {
//#line  12205
      goto while_break;
    }
    {
//#line  12207
    j = (int )*(p1 + (8 + i));
//#line  12209
    iface = usb_ifnum_to_if((struct usb_device  const  *)dev, (unsigned int )j);
    }
//#line  12211
    if (! iface) {
      {
//#line  12213
      printk(str_496506222, dev->devnum, ctrlif, j);
      }
//#line  12215
      goto __Cont;
    }
    {
//#line  12218
    tmp___1 = usb_interface_claimed(iface);
    }
//#line  12220
    if (tmp___1) {
      {
//#line  12222
      printk(str_376161077, dev->devnum, ctrlif, j);
      }
//#line  12224
      goto __Cont;
    }
//#line  12227
    alts = iface->altsetting + 0;
//#line  12229
    altsd = & alts->desc;
//#line  12231
    if ((int )altsd->bInterfaceClass == 1) {
//#line  12233
      goto _L;
    } else
//#line  12236
    if ((int )altsd->bInterfaceClass == 255) {
      _L: 
//#line  12239
      if ((int )altsd->bInterfaceSubClass == 3) {
        {
//#line  12241
        tmp___2 = snd_usb_create_midi_interface(chip, iface, (struct snd_usb_audio_quirk  const  *)((void *)0));
        }
//#line  12243
        if (tmp___2 < 0) {
          {
//#line  12245
          printk(str_706759643, dev->devnum, ctrlif, j);
          }
//#line  12248
          goto __Cont;
        }
        {
//#line  12251
        usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
        }
//#line  12253
        goto __Cont;
      }
    }
//#line  12257
    if ((int )altsd->bInterfaceClass != 1) {
//#line  12259
      if ((int )altsd->bInterfaceClass != 255) {
        {
//#line  12261
        printk(str_698010430, dev->devnum, ctrlif, j, (int )altsd->bInterfaceClass);
        }
//#line  12264
        goto __Cont;
      } else {
//#line  12267
        goto _L___0;
      }
    } else
    _L___0: 
//#line  12272
    if ((int )altsd->bInterfaceSubClass != 2) {
      {
//#line  12274
      printk(str_698010430, dev->devnum, ctrlif, j, (int )altsd->bInterfaceClass);
      }
//#line  12277
      goto __Cont;
    }
//#line  12280
    if ((unsigned int )dev->speed == 1U) {
      {
//#line  12282
      printk(str_667951693);
      }
//#line  12284
      goto __Cont;
    }
    {
//#line  12287
    tmp___3 = parse_audio_endpoints(chip, j);
    }
//#line  12289
    if (! tmp___3) {
      {
//#line  12291
      usb_set_interface(dev, j, 0);
//#line  12293
      usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
      }
    }
    __Cont: 
//#line  12297
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  12300
  return (0);
}
}
//#line  12304 "usb-audio.merged.sym.c"
static int create_fixed_stream_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                     struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct audioformat *fp ;
  struct usb_host_interface *alts ;
  int stream ;
  int err ;
  unsigned int *rate_table ;
  void *tmp ;
  void *tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
  record_function("create_fixed_stream_quirk");
  {
//#line  12319
  rate_table = (unsigned int *)((void *)0);
//#line  12321
  tmp = kmemdup((void const   *)quirk->data, sizeof(*fp), 208U);
//#line  12323
  fp = (struct audioformat *)tmp;
  }
//#line  12325
  if (! fp) {
    {
//#line  12327
    printk(str_977636194);
    }
//#line  12329
    return (-12);
  }
//#line  12332
  if (fp->nr_rates > 0U) {
    {
//#line  12334
    tmp___0 = kmalloc(sizeof(int ) * (unsigned long )fp->nr_rates, 208U);
//#line  12336
    rate_table = (unsigned int *)tmp___0;
    }
//#line  12338
    if (! rate_table) {
      {
//#line  12340
      kfree((void const   *)fp);
      }
//#line  12342
      return (-12);
    }
    {
//#line  12345
    __len = sizeof(int ) * (unsigned long )fp->nr_rates;
//#line  12347
    __ret = __builtin_memcpy((void *)rate_table, (void const   *)fp->rate_table, __len);
//#line  12349
    fp->rate_table = rate_table;
    }
  }
//#line  12352
  if ((int )fp->endpoint & 128) {
//#line  12354
    stream = 1;
  } else {
//#line  12357
    stream = 0;
  }
  {
//#line  12360
  err = add_audio_endpoint(chip, stream, fp);
  }
//#line  12362
  if (err < 0) {
    {
//#line  12364
    kfree((void const   *)fp);
//#line  12366
    kfree((void const   *)rate_table);
    }
//#line  12368
    return (err);
  }
//#line  12371
  if (fp->iface != (int )(iface->altsetting + 0)->desc.bInterfaceNumber) {
    {
//#line  12373
    kfree((void const   *)fp);
//#line  12375
    kfree((void const   *)rate_table);
    }
//#line  12377
    return (-22);
  } else
//#line  12380
  if ((unsigned int )fp->altset_idx >= iface->num_altsetting) {
    {
//#line  12382
    kfree((void const   *)fp);
//#line  12384
    kfree((void const   *)rate_table);
    }
//#line  12386
    return (-22);
  }
  {
//#line  12389
  alts = iface->altsetting + (int )fp->altset_idx;
//#line  12391
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  12393
  usb_set_interface(chip->dev, fp->iface, 0);
//#line  12395
  init_usb_pitch(chip->dev, fp->iface, alts, fp);
//#line  12397
  init_usb_sample_rate(chip->dev, fp->iface, alts, fp, (int )fp->rate_max);
  }
//#line  12399
  return (0);
}
}
//#line  12403 "usb-audio.merged.sym.c"
static int create_standard_audio_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                       struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  int err ;

  {
  record_function("create_standard_audio_quirk");
  {
//#line  12412
  alts = iface->altsetting + 0;
//#line  12414
  altsd = & alts->desc;
//#line  12416
  err = parse_audio_endpoints(chip, (int )altsd->bInterfaceNumber);
  }
//#line  12418
  if (err < 0) {
    {
//#line  12420
    printk(str_449190836, (int )altsd->bInterfaceNumber, err);
    }
//#line  12422
    return (err);
  }
  {
//#line  12425
  usb_set_interface(chip->dev, (int )altsd->bInterfaceNumber, 0);
  }
//#line  12427
  return (0);
}
}
static struct audioformat  const  ua_format  = 
//#line  12431
     {{(struct list_head *)0, (struct list_head *)0}, 32, 2U, 1U, 0U, 0, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (unsigned int )(1 << 30),
    0U, 0U, 0U, (unsigned int *)0};
//#line  12437 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  ua700_ep  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )3,
    (uint16_t )3};
//#line  12440 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  ua700_quirk  =    {(char const   *)0, (char const   *)0, (short)0, (uint16_t )3, (void const   *)(& ua700_ep)};
//#line  12443 "usb-audio.merged.sym.c"
static struct snd_usb_midi_endpoint_info  const  uaxx_ep  =    {(signed char)0, (unsigned char)0, (signed char)0, (unsigned char)0, (uint16_t )1,
    (uint16_t )1};
//#line  12446 "usb-audio.merged.sym.c"
static struct snd_usb_audio_quirk  const  uaxx_quirk  =    {(char const   *)0, (char const   *)0, (short)0, (uint16_t )3, (void const   *)(& uaxx_ep)};
//#line  12449 "usb-audio.merged.sym.c"
static int create_uaxx_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                             struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  size_t __len ;
  void *__ret ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
  record_function("create_uaxx_quirk");
//#line  12468
  if (iface->num_altsetting < 2U) {
//#line  12470
    return (-6);
  }
//#line  12473
  alts = iface->altsetting + 1;
//#line  12475
  altsd = & alts->desc;
//#line  12477
  if ((int )altsd->bNumEndpoints == 2) {
//#line  12479
    if (chip->usb_id == (u32 )((1410 << 16) | 43)) {
      {
//#line  12481
      tmp = snd_usb_create_midi_interface(chip, iface, & ua700_quirk);
      }
//#line  12483
      return (tmp);
    } else {
      {
//#line  12486
      tmp___0 = snd_usb_create_midi_interface(chip, iface, & uaxx_quirk);
      }
//#line  12488
      return (tmp___0);
    }
  }
//#line  12492
  if ((int )altsd->bNumEndpoints != 1) {
//#line  12494
    return (-6);
  }
  {
//#line  12497
  tmp___1 = kmalloc(sizeof(*fp), 208U);
//#line  12499
  fp = (struct audioformat *)tmp___1;
  }
//#line  12501
  if (! fp) {
//#line  12503
    return (-12);
  }
//#line  12506
  __len = sizeof(*fp);
//#line  12508
  if (__len >= 64UL) {
    {
//#line  12510
    __ret = __memcpy((void *)fp, (void const   *)(& ua_format), __len);
    }
  } else {
    {
//#line  12513
    __ret = __builtin_memcpy((void *)fp, (void const   *)(& ua_format), __len);
    }
  }
//#line  12516
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  12518
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  12520
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  12522
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
  {
  if ((int )fp->maxpacksize == 288) {
//#line  12525
    goto case_288;
  }
  if ((int )fp->maxpacksize == 312) {
//#line  12534
    goto case_312;
  }
  if ((int )fp->maxpacksize == 320) {
//#line  12535
    goto case_312;
  }
  if ((int )fp->maxpacksize == 600) {
//#line  12544
    goto case_600;
  }
  if ((int )fp->maxpacksize == 608) {
//#line  12545
    goto case_600;
  }
//#line  12554
  goto switch_default;
  case_288: /* CIL Label */ 
//#line  12527
  tmp___2 = 44100U;
//#line  12529
  fp->rate_min = tmp___2;
//#line  12531
  fp->rate_max = tmp___2;
//#line  12533
  goto switch_break;
  case_312: /* CIL Label */ 
//#line  12537
  tmp___3 = 48000U;
//#line  12539
  fp->rate_min = tmp___3;
//#line  12541
  fp->rate_max = tmp___3;
//#line  12543
  goto switch_break;
  case_600: /* CIL Label */ 
//#line  12547
  tmp___4 = 96000U;
//#line  12549
  fp->rate_min = tmp___4;
//#line  12551
  fp->rate_max = tmp___4;
//#line  12553
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  12556
  printk(str_797487953);
//#line  12558
  kfree((void const   *)fp);
  }
//#line  12560
  return (-6);
  switch_break: /* CIL Label */ ;
  }
//#line  12563
  if ((int )fp->endpoint & 128) {
//#line  12565
    stream = 1;
  } else {
//#line  12568
    stream = 0;
  }
  {
//#line  12571
  err = add_audio_endpoint(chip, stream, fp);
  }
//#line  12573
  if (err < 0) {
    {
//#line  12575
    kfree((void const   *)fp);
    }
//#line  12577
    return (err);
  }
  {
//#line  12580
  usb_set_interface(chip->dev, fp->iface, 0);
  }
//#line  12582
  return (0);
}
}
static struct audioformat  const  ua1000_format  = 
//#line  12586
     {{(struct list_head *)0, (struct list_head *)0}, 10, 0U, 1U, 0U, 0, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (unsigned int )(1 << 30),
    0U, 0U, 0U, (unsigned int *)0};
//#line  12592 "usb-audio.merged.sym.c"
static int create_ua1000_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                               struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  record_function("create_ua1000_quirk");
//#line  12605
  if (iface->num_altsetting != 2U) {
//#line  12607
    return (-6);
  }
//#line  12610
  alts = iface->altsetting + 1;
//#line  12612
  altsd = & alts->desc;
//#line  12614
  if (alts->extralen != 11) {
//#line  12616
    return (-6);
  } else
//#line  12619
  if ((int )*(alts->extra + 1) != ((1 << 5) | 4)) {
//#line  12621
    return (-6);
  } else
//#line  12624
  if ((int )altsd->bNumEndpoints != 1) {
//#line  12626
    return (-6);
  }
  {
//#line  12629
  tmp = kmemdup((void const   *)(& ua1000_format), sizeof(*fp), 208U);
//#line  12631
  fp = (struct audioformat *)tmp;
  }
//#line  12633
  if (! fp) {
//#line  12635
    return (-12);
  }
//#line  12638
  fp->channels = (unsigned int )*(alts->extra + 4);
//#line  12640
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  12642
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  12644
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  12646
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  12648
  tmp___0 = ((unsigned int )*(alts->extra + 8) | ((unsigned int )*((alts->extra + 8) + 1) << 8)) | ((unsigned int )*((alts->extra + 8) + 2) << 16);
//#line  12650
  fp->rate_min = tmp___0;
//#line  12652
  fp->rate_max = tmp___0;
//#line  12654
  if ((int )fp->endpoint & 128) {
//#line  12656
    stream = 1;
  } else {
//#line  12659
    stream = 0;
  }
  {
//#line  12662
  err = add_audio_endpoint(chip, stream, fp);
  }
//#line  12664
  if (err < 0) {
    {
//#line  12666
    kfree((void const   *)fp);
    }
//#line  12668
    return (err);
  }
  {
//#line  12671
  usb_set_interface(chip->dev, fp->iface, 0);
  }
//#line  12673
  return (0);
}
}
static struct audioformat  const  ua101_format  = 
//#line  12677
     {{(struct list_head *)0, (struct list_head *)0}, 10, 0U, 1U, 0U, 0, (unsigned char)1,
    (unsigned char)1, (unsigned char)0, (unsigned char)0, (unsigned char)0, 0U, (unsigned int )(1 << 30),
    0U, 0U, 0U, (unsigned int *)0};
//#line  12683 "usb-audio.merged.sym.c"
static int create_ua101_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                              struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct usb_host_interface *alts ;
  struct usb_interface_descriptor *altsd ;
  struct audioformat *fp ;
  int stream ;
  int err ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  record_function("create_ua101_quirk");
//#line  12696
  if (iface->num_altsetting != 2U) {
//#line  12698
    return (-6);
  }
//#line  12701
  alts = iface->altsetting + 1;
//#line  12703
  altsd = & alts->desc;
//#line  12705
  if (alts->extralen != 18) {
//#line  12707
    return (-6);
  } else
//#line  12710
  if ((int )*(alts->extra + 1) != ((1 << 5) | 4)) {
//#line  12712
    return (-6);
  } else
//#line  12715
  if ((int )altsd->bNumEndpoints != 1) {
//#line  12717
    return (-6);
  }
  {
//#line  12720
  tmp = kmemdup((void const   *)(& ua101_format), sizeof(*fp), 208U);
//#line  12722
  fp = (struct audioformat *)tmp;
  }
//#line  12724
  if (! fp) {
//#line  12726
    return (-12);
  }
//#line  12729
  fp->channels = (unsigned int )*(alts->extra + 11);
//#line  12731
  fp->iface = (int )altsd->bInterfaceNumber;
//#line  12733
  fp->endpoint = (alts->endpoint + 0)->desc.bEndpointAddress;
//#line  12735
  fp->ep_attr = (alts->endpoint + 0)->desc.bmAttributes;
//#line  12737
  fp->maxpacksize = (unsigned int )(alts->endpoint + 0)->desc.wMaxPacketSize;
//#line  12739
  tmp___0 = ((unsigned int )*(alts->extra + 15) | ((unsigned int )*((alts->extra + 15) + 1) << 8)) | ((unsigned int )*((alts->extra + 15) + 2) << 16);
//#line  12741
  fp->rate_min = tmp___0;
//#line  12743
  fp->rate_max = tmp___0;
//#line  12745
  if ((int )fp->endpoint & 128) {
//#line  12747
    stream = 1;
  } else {
//#line  12750
    stream = 0;
  }
  {
//#line  12753
  err = add_audio_endpoint(chip, stream, fp);
  }
//#line  12755
  if (err < 0) {
    {
//#line  12757
    kfree((void const   *)fp);
    }
//#line  12759
    return (err);
  }
  {
//#line  12762
  usb_set_interface(chip->dev, fp->iface, 0);
  }
//#line  12764
  return (0);
}
}
//#line  12768
static int snd_usb_create_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                struct snd_usb_audio_quirk  const  *quirk ) ;
//#line  12771 "usb-audio.merged.sym.c"
static int create_composite_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  int probed_ifnum ;
  int err ;
  int tmp ;

  {
  record_function("create_composite_quirk");
//#line  12780
  probed_ifnum = (int )(iface->altsetting)->desc.bInterfaceNumber;
//#line  12782
  quirk = (struct snd_usb_audio_quirk  const  *)quirk->data;
  {
  {
//#line  12784
  while (1) {


    if (! ((int const   )quirk->ifnum >= 0)) {
//#line  12784
      goto while_break;
    }
    {
//#line  12786
    iface = usb_ifnum_to_if((struct usb_device  const  *)chip->dev, (unsigned int )quirk->ifnum);
    }
//#line  12788
    if (! iface) {
//#line  12790
      goto __Cont;
    }
//#line  12793
    if ((int const   )quirk->ifnum != (int const   )probed_ifnum) {
      {
//#line  12795
      tmp = usb_interface_claimed(iface);
      }
//#line  12797
      if (tmp) {
//#line  12799
        goto __Cont;
      }
    }
    {
//#line  12803
    err = snd_usb_create_quirk(chip, iface, quirk);
    }
//#line  12805
    if (err < 0) {
//#line  12807
      return (err);
    }
//#line  12810
    if ((int const   )quirk->ifnum != (int const   )probed_ifnum) {
      {
//#line  12812
      usb_driver_claim_interface(& usb_audio_driver, iface, (void *)-1L);
      }
    }
    __Cont: 
//#line  12816
    quirk ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  12819
  return (0);
}
}
//#line  12823 "usb-audio.merged.sym.c"
static int ignore_interface_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                  struct snd_usb_audio_quirk  const  *quirk ) 
{ 


  {
  record_function("ignore_interface_quirk");
//#line  12830
  return (0);
}
}
//#line  12834 "usb-audio.merged.sym.c"
static int snd_usb_extigy_boot_quirk(struct usb_device *dev , struct usb_interface *intf ) 
{ 
  struct usb_host_config *config ;
  int err ;
  unsigned int tmp ;

  {
  record_function("snd_usb_extigy_boot_quirk");
//#line  12842
  config = dev->actconfig;
//#line  12844
  if ((int )config->desc.wTotalLength == 794) {
//#line  12846
    goto _L;
  } else
//#line  12849
  if ((int )config->desc.wTotalLength == 483) {
    _L: 
    {
//#line  12852
    printk(str_1034644995);
//#line  12854
    tmp = __create_pipe(dev, 0U);
//#line  12856
    err = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )16, (__u8 )67,
                          (__u16 )1, (__u16 )10, (void *)0, (__u16 )0, 1000);
    }
//#line  12859
    if (err < 0) {
      {
//#line  12861
      printk(str_747151802, err);
      }
    }
    {
//#line  12864
    err = usb_get_descriptor(dev, (unsigned char)1, (unsigned char)0, (void *)(& dev->descriptor),
                             (int )sizeof(dev->descriptor));
//#line  12867
    config = dev->actconfig;
    }
//#line  12869
    if (err < 0) {
      {
//#line  12871
      printk(str_159293978, err);
      }
    }
    {
//#line  12874
    err = usb_reset_configuration(dev);
    }
//#line  12876
    if (err < 0) {
      {
//#line  12878
      printk(str_679801322, err);
      }
    }
    {
//#line  12881
    printk(str_600119615, (int )config->desc.wTotalLength);
    }
//#line  12883
    return (-19);
  }
//#line  12886
  return (0);
}
}
//#line  12890 "usb-audio.merged.sym.c"
static int snd_usb_audigy2nx_boot_quirk(struct usb_device *dev ) 
{ 
  u8 buf ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  record_function("snd_usb_audigy2nx_boot_quirk");
  {
//#line  12898
  buf = (u8 )1;
//#line  12900
  tmp = __create_pipe(dev, 0U);
//#line  12902
  snd_usb_ctl_msg(dev, ((unsigned int )(2 << 30) | tmp) | 128U, (__u8 )42, (__u8 )((128 | (2 << 5)) | 3),
                  (__u16 )0, (__u16 )0, (void *)(& buf), (__u16 )1, 1000);
  }
//#line  12905
  if ((int )buf == 0) {
    {
//#line  12907
    tmp___0 = __create_pipe(dev, 0U);
//#line  12909
    snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp___0, (__u8 )41, (__u8 )((2 << 5) | 3),
                    (__u16 )1, (__u16 )2000, (void *)0, (__u16 )0, 1000);
    }
//#line  12912
    return (-19);
  }
//#line  12915
  return (0);
}
}
//#line  12919 "usb-audio.merged.sym.c"
static int snd_usb_cm106_write_int_reg(struct usb_device *dev , int reg , u16 value ) 
{ 
  u8 buf[4] ;
  unsigned int tmp ;
  int tmp___0 ;

  {
  record_function("snd_usb_cm106_write_int_reg");
  {
//#line  12927
  buf[0] = (u8 )32;
//#line  12929
  buf[1] = (u8 )((int )value & 255);
//#line  12931
  buf[2] = (u8 )(((int )value >> 8) & 255);
//#line  12933
  buf[3] = (u8 )reg;
//#line  12935
  tmp = __create_pipe(dev, 0U);
//#line  12937
  tmp___0 = snd_usb_ctl_msg(dev, (unsigned int )(2 << 30) | tmp, (__u8 )9, (__u8 )((1 << 5) | 2),
                            (__u16 )0, (__u16 )0, (void *)(& buf), (__u16 )4, 1000);
  }
//#line  12940
  return (tmp___0);
}
}
//#line  12944 "usb-audio.merged.sym.c"
static int snd_usb_cm106_boot_quirk(struct usb_device *dev ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_cm106_boot_quirk");
  {
//#line  12950
  tmp = snd_usb_cm106_write_int_reg(dev, 2, (u16 )32772);
  }
//#line  12952
  return (tmp);
}
}
//#line  12956 "usb-audio.merged.sym.c"
static int audiophile_skip_setting_quirk(struct snd_usb_audio *chip , int iface ,
                                         int altno ) 
{ 


  {
  record_function("audiophile_skip_setting_quirk");
  {
//#line  12963
  usb_set_interface(chip->dev, iface, 0);
  }
//#line  12965
  if (device_setup[chip->index] & 1) {
//#line  12967
    if (device_setup[chip->index] & 2) {
//#line  12969
      if (altno != 6) {
//#line  12971
        return (1);
      }
    }
//#line  12975
    if (device_setup[chip->index] & 4) {
//#line  12977
      if (altno != 1) {
//#line  12979
        return (1);
      }
    }
//#line  12983
    if ((device_setup[chip->index] & 31) == 25) {
//#line  12985
      if (altno != 2) {
//#line  12987
        return (1);
      }
    }
//#line  12991
    if ((device_setup[chip->index] & 31) == 9) {
//#line  12993
      if (altno != 3) {
//#line  12995
        return (1);
      }
    }
//#line  12999
    if ((device_setup[chip->index] & 31) == 17) {
//#line  13001
      if (altno != 4) {
//#line  13003
        return (1);
      }
    }
//#line  13007
    if ((device_setup[chip->index] & 31) == 1) {
//#line  13009
      if (altno != 5) {
//#line  13011
        return (1);
      }
    }
  }
//#line  13016
  return (0);
}
}
//#line  13020 "usb-audio.merged.sym.c"
static int snd_usb_create_quirk(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  int tmp ;

  {
  record_function("snd_usb_create_quirk");
//#line  13027
  if ((int const   )quirk->type < 16) {
    {
//#line  13029
    tmp = (*(quirk_funcs[quirk->type]))(chip, iface, quirk);
    }
//#line  13031
    return (tmp);
  } else {
    {
//#line  13034
    printk(str_608431467, (int const   )quirk->type);
    }
//#line  13036
    return (-6);
  }
}
}
//#line  13041 "usb-audio.merged.sym.c"
static void proc_audio_usbbus_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_usb_audio *chip ;

  {
  record_function("proc_audio_usbbus_read");
//#line  13047
  chip = (struct snd_usb_audio *)entry->private_data;
//#line  13049
  if (! chip->shutdown) {
    {
//#line  13051
    snd_iprintf(buffer, (char *)str_698187463, ((chip->dev)->bus)->busnum, (chip->dev)->devnum);
    }
  }
//#line  13054
  return;
}
}
//#line  13058 "usb-audio.merged.sym.c"
static void proc_audio_usbid_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct snd_usb_audio *chip ;

  {
  record_function("proc_audio_usbid_read");
//#line  13064
  chip = (struct snd_usb_audio *)entry->private_data;
//#line  13066
  if (! chip->shutdown) {
    {
//#line  13068
    snd_iprintf(buffer, (char *)str_412731004, chip->usb_id >> 16, (int )((u16 )chip->usb_id));
    }
  }
//#line  13071
  return;
}
}
//#line  13075 "usb-audio.merged.sym.c"
static void snd_usb_audio_create_proc(struct snd_usb_audio *chip ) 
{ 
  struct snd_info_entry *entry ;
  int tmp ;
  int tmp___0 ;

  {
  record_function("snd_usb_audio_create_proc");
  {
//#line  13083
  entry = (struct snd_info_entry *)((void *)0);
//#line  13085
  tmp = snd_card_proc_new(chip->card, (char const   *)str_305400396, & entry);
  }
//#line  13088
  if (! tmp) {
    {
//#line  13090
    snd_info_set_text_ops(entry, (void *)chip, & proc_audio_usbbus_read);
    }
  }
  {
//#line  13093
  tmp___0 = snd_card_proc_new(chip->card, (char const   *)str_16073815, & entry);
  }
//#line  13096
  if (! tmp___0) {
    {
//#line  13098
    snd_info_set_text_ops(entry, (void *)chip, & proc_audio_usbid_read);
    }
  }
//#line  13101
  return;
}
}
//#line  13105 "usb-audio.merged.sym.c"
static int snd_usb_audio_free(struct snd_usb_audio *chip ) 
{ 


  {
  record_function("snd_usb_audio_free");
  {
//#line  13111
  kfree((void const   *)chip);
  }
//#line  13113
  return (0);
}
}
//#line  13117 "usb-audio.merged.sym.c"
static int snd_usb_audio_dev_free(struct snd_device *device ) 
{ 
  struct snd_usb_audio *chip ;
  int tmp ;

  {
  record_function("snd_usb_audio_dev_free");
  {
//#line  13124
  chip = (struct snd_usb_audio *)device->device_data;
//#line  13126
  tmp = snd_usb_audio_free(chip);
  }
//#line  13128
  return (tmp);
}
}
//#line  13132
static int snd_usb_audio_create(struct usb_device *dev , int idx , struct snd_usb_audio_quirk  const  *quirk ,
                                struct snd_usb_audio **rchip ) ;
//#line  13135 "usb-audio.merged.sym.c"
static struct snd_device_ops ops  =    {& snd_usb_audio_dev_free, (int (*)(struct snd_device *dev ))0, (int (*)(struct snd_device *dev ))0};
//#line  13137 "usb-audio.merged.sym.c"
static int snd_usb_audio_create(struct usb_device *dev , int idx , struct snd_usb_audio_quirk  const  *quirk ,
                                struct snd_usb_audio **rchip ) 
{ 
  struct snd_card *card ;
  struct snd_usb_audio *chip ;
  int err ;
  int len ;
  char component[14] ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
  record_function("snd_usb_audio_create");
//#line  13154
  *rchip = (struct snd_usb_audio *)((void *)0);
//#line  13156
  if ((unsigned int )dev->speed != 1U) {
//#line  13158
    if ((unsigned int )dev->speed != 2U) {
//#line  13160
      if ((unsigned int )dev->speed != 3U) {
        {
//#line  13162
        printk(str_388213389, (unsigned int )dev->speed);
        }
//#line  13164
        return (-6);
      }
    }
  }
  {
//#line  13169
  card = snd_card_new(index[idx], (char const   *)id[idx], & __this_module, 0);
  }
//#line  13172
  if ((unsigned long )card == (unsigned long )((void *)0)) {
    {
//#line  13174
    printk(str_596491274, idx);
    }
//#line  13176
    return (-12);
  }
  {
//#line  13179
  tmp = kzalloc(sizeof(*chip), 208U);
//#line  13181
  chip = (struct snd_usb_audio *)tmp;
  }
//#line  13183
  if (! chip) {
    {
//#line  13185
    snd_card_free(card);
    }
//#line  13187
    return (-12);
  }
  {
//#line  13190
  chip->index = idx;
//#line  13192
  chip->dev = dev;
//#line  13194
  chip->card = card;
//#line  13196
  chip->usb_id = (u32 )(((int )dev->descriptor.idVendor << 16) | (int )dev->descriptor.idProduct);
//#line  13198
  INIT_LIST_HEAD(& chip->pcm_list);
//#line  13200
  INIT_LIST_HEAD(& chip->midi_list);
//#line  13202
  INIT_LIST_HEAD(& chip->mixer_list);
//#line  13204
  err = snd_device_new(card, 8192, (void *)chip, & ops);
  }
//#line  13206
  if (err < 0) {
    {
//#line  13208
    snd_usb_audio_free(chip);
//#line  13210
    snd_card_free(card);
    }
//#line  13212
    return (err);
  }
  {
//#line  13215
  strcpy(card->driver, str_601554213);
//#line  13217
  sprintf(component, str_209941598, chip->usb_id >> 16, (int )((u16 )chip->usb_id));
//#line  13219
  snd_component_add(card, (char const   *)(component));
  }
//#line  13221
  if (quirk) {
//#line  13223
    if (quirk->product_name) {
      {
//#line  13225
      strlcpy(card->shortname, (char const   *)quirk->product_name, sizeof(card->shortname));
      }
    } else {
//#line  13228
      goto _L;
    }
  } else
  _L: 
//#line  13233
  if (! dev->descriptor.iProduct) {
    {
//#line  13235
    sprintf(card->shortname, str_856339116, chip->usb_id >> 16, (int )((u16 )chip->usb_id));
    }
  } else {
    {
//#line  13238
    tmp___0 = usb_string(dev, (int )dev->descriptor.iProduct, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )(card->shortname),
                         sizeof(card->shortname));
    }
//#line  13241
    if (tmp___0 <= 0) {
      {
//#line  13243
      sprintf(card->shortname, str_856339116, chip->usb_id >> 16, (int )((u16 )chip->usb_id));
      }
    }
  }
//#line  13247
  if (quirk) {
//#line  13249
    if (quirk->vendor_name) {
      {
//#line  13251
      tmp___1 = strlcpy(card->longname, (char const   *)quirk->vendor_name, sizeof(card->longname));
//#line  13253
      len = (int )tmp___1;
      }
    } else {
//#line  13256
      goto _L___0;
    }
  } else
  _L___0: 
//#line  13261
  if (dev->descriptor.iManufacturer) {
    {
//#line  13263
    len = usb_string(dev, (int )dev->descriptor.iManufacturer, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )(card->longname),
                     sizeof(card->longname));
    }
  } else {
//#line  13267
    len = 0;
  }
//#line  13270
  if (len > 0) {
    {
//#line  13272
    strlcat(card->longname, str_32, sizeof(card->longname));
    }
  }
  {
//#line  13275
  strlcat(card->longname, (char const   *)(card->shortname), sizeof(card->longname));
//#line  13277
  tmp___2 = strlcat(card->longname, str_256741, sizeof(card->longname));
//#line  13279
  len = (int )tmp___2;
  }
//#line  13281
  if ((unsigned long )len < sizeof(card->longname)) {
    {
//#line  13283
    usb_make_path(dev, card->longname + len, sizeof(card->longname) - (unsigned long )len);
    }
  }
//#line  13286
  if ((unsigned int )dev->speed == 1U) {
//#line  13288
    tmp___4 = str_884756751;
  } else {
//#line  13291
    if ((unsigned int )dev->speed == 2U) {
//#line  13293
      tmp___3 = str_410776958;
    } else {
//#line  13296
      tmp___3 = str_312951437;
    }
//#line  13299
    tmp___4 = tmp___3;
  }
  {
//#line  13302
  strlcat(card->longname, tmp___4, sizeof(card->longname));
//#line  13304
  snd_usb_audio_create_proc(chip);
//#line  13306
  *rchip = chip;
  }
//#line  13308
  return (0);
}
}
//#line  13312 "usb-audio.merged.sym.c"
static void *snd_usb_audio_probe(struct usb_device *dev , struct usb_interface *intf ,
                                 struct usb_device_id  const  *usb_id ) 
{ 
  struct snd_usb_audio_quirk  const  *quirk ;
  int i ;
  int err ;
  struct snd_usb_audio *chip ;
  struct usb_host_interface *alts ;
  int ifnum ;
  u32 id___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int error ;
  int tmp___5 ;

  {
  record_function("snd_usb_audio_probe");
//#line  13333
  quirk = (struct snd_usb_audio_quirk  const  *)usb_id->driver_info;
//#line  13335
  alts = intf->altsetting + 0;
//#line  13337
  ifnum = (int )alts->desc.bInterfaceNumber;
//#line  13339
  id___0 = (u32 )(((int )dev->descriptor.idVendor << 16) | (int )dev->descriptor.idProduct);
//#line  13341
  if (quirk) {
//#line  13343
    if ((int const   )quirk->ifnum >= 0) {
//#line  13345
      if (ifnum != (int )quirk->ifnum) {
//#line  13347
        goto __err_val;
      }
    }
  }
  {
//#line  13352
  printk(str_496823950, str_974276422);
  }
//#line  13354
  if (id___0 == (u32 )((1054 << 16) | 12288)) {
    {
//#line  13356
    tmp = snd_usb_extigy_boot_quirk(dev, intf);
    }
//#line  13358
    if (tmp < 0) {
//#line  13360
      goto __err_val;
    }
  }
  {
//#line  13364
  printk(str_496823969, str_974276422);
  }
//#line  13366
  if (id___0 == (u32 )((1054 << 16) | 12320)) {
    {
//#line  13368
    tmp___0 = snd_usb_audigy2nx_boot_quirk(dev);
    }
//#line  13370
    if (tmp___0 < 0) {
//#line  13372
      goto __err_val;
    }
  }
  {
//#line  13376
  printk(str_496823988, str_974276422);
  }
//#line  13378
  if (id___0 == (u32 )((4341 << 16) | 512)) {
    {
//#line  13380
    tmp___1 = snd_usb_cm106_boot_quirk(dev);
    }
//#line  13382
    if (tmp___1 < 0) {
//#line  13384
      goto __err_val;
    }
  }
  {
//#line  13388
  printk(str_496824007, str_974276422);
//#line  13390
  chip = (struct snd_usb_audio *)((void *)0);
//#line  13392
  mutex_lock_nested(& register_mutex, 0U);
//#line  13394
  i = 0;
  }
  {
  {
//#line  13396
  while (1) {


    if (! (i < 32)) {
//#line  13396
      goto while_break;
    }
//#line  13398
    if (usb_chip[i]) {
//#line  13400
      if ((unsigned long )(usb_chip[i])->dev == (unsigned long )dev) {
//#line  13402
        chip = (struct snd_usb_audio *)usb_chip[i];
//#line  13404
        goto while_break;
      }
    }
//#line  13408
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  13411
  printk(str_496824026, str_974276422);
  }
//#line  13413
  if (! chip) {
//#line  13415
    i = 0;
    {
    {
//#line  13417
    while (1) {


      if (! (i < 32)) {
//#line  13417
        goto while_break___0;
      }
//#line  13419
      if (enable[i]) {
//#line  13421
        if (! usb_chip[i]) {
//#line  13423
          if (vid[i] == -1) {
//#line  13425
            goto _L___0;
          } else
//#line  13428
          if ((u32 )vid[i] == id___0 >> 16) {
            _L___0: 
//#line  13431
            if (pid[i] == -1) {
//#line  13433
              goto _L;
            } else
//#line  13436
            if (pid[i] == (int )((u16 )id___0)) {
              _L: 
              {
//#line  13439
              tmp___2 = snd_usb_audio_create(dev, i, quirk, & chip);
              }
//#line  13441
              if (tmp___2 < 0) {
//#line  13443
                goto __error;
              }
//#line  13446
              (chip->card)->dev = & intf->dev;
//#line  13448
              goto while_break___0;
            }
          }
        }
      }
//#line  13454
      i ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  13457
    if (! chip) {
      {
//#line  13459
      printk(str_778694563);
      }
//#line  13461
      goto __error;
    }
  }
  {
//#line  13465
  printk(str_496824045, str_974276422);
//#line  13467
  err = 1;
  }
//#line  13469
  if (quirk) {
//#line  13471
    if ((int const   )quirk->ifnum != -2) {
      {
//#line  13473
      err = snd_usb_create_quirk(chip, intf, quirk);
      }
//#line  13475
      if (err < 0) {
//#line  13477
        goto __error;
      }
    }
  }
  {
//#line  13482
  printk(str_496824064, str_974276422);
  }
//#line  13484
  if (err > 0) {
    {
//#line  13486
    tmp___3 = snd_usb_create_streams(chip, ifnum);
    }
//#line  13488
    if (tmp___3 < 0) {
//#line  13490
      goto __error;
    } else {
      {
//#line  13493
      tmp___4 = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);
      }
//#line  13495
      if (tmp___4 < 0) {
//#line  13497
        goto __error;
      }
    }
  }
  {
//#line  13502
  printk(str_496824083, str_974276422);
//#line  13504
  tmp___5 = snd_card_register(chip->card);
//#line  13506
  error = tmp___5;
  }
//#line  13508
  if (error < 0) {
    {
//#line  13510
    printk(str_358300541, str_974276422, error);
    }
//#line  13512
    goto __error;
  }
  {
//#line  13515
  printk(str_738260344, str_974276422, error);
//#line  13517
  usb_chip[chip->index] = (struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) )chip;
//#line  13519
  (chip->num_interfaces) ++;
//#line  13521
  mutex_unlock(& register_mutex);
  }
//#line  13523
  return ((void *)chip);
  __error: 
  {
//#line  13526
  printk(str_21498367, str_974276422);
  }
//#line  13528
  if (chip) {
//#line  13530
    if (! chip->num_interfaces) {
      {
//#line  13532
      snd_card_free(chip->card);
      }
    }
  }
  {
//#line  13536
  mutex_unlock(& register_mutex);
  }
  __err_val: 
//#line  13539
  return ((void *)0);
}
}
//#line  13543 "usb-audio.merged.sym.c"
static void snd_usb_audio_disconnect(struct usb_device *dev , void *ptr ) 
{ 
  struct snd_usb_audio *chip ;
  struct snd_card *card ;
  struct list_head *p ;

  {
  record_function("snd_usb_audio_disconnect");
//#line  13551
  if ((unsigned long )ptr == (unsigned long )((void *)-1L)) {
//#line  13553
    return;
  }
  {
//#line  13556
  chip = (struct snd_usb_audio *)ptr;
//#line  13558
  card = chip->card;
//#line  13560
  mutex_lock_nested(& register_mutex, 0U);
//#line  13562
  chip->shutdown = 1;
//#line  13564
  (chip->num_interfaces) --;
  }
//#line  13566
  if (chip->num_interfaces <= 0) {
    {
//#line  13568
    snd_card_disconnect(card);
//#line  13570
    p = (struct list_head *)chip->pcm_list.next;
    }
    {
    {
//#line  13572
    while (1) {


      {
//#line  13574
      __builtin_prefetch((void const   *)p->next);
      }
//#line  13576
      if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  13578
        goto while_break;
      }
      {
//#line  13581
      snd_usb_stream_disconnect(p);
//#line  13583
      p = (struct list_head *)p->next;
      }
    }

    }
    while_break: /* CIL Label */ ;
    }
//#line  13586
    p = (struct list_head *)chip->midi_list.next;
    {
    {
//#line  13588
    while (1) {


      {
//#line  13590
      __builtin_prefetch((void const   *)p->next);
      }
//#line  13592
      if (! ((unsigned long )p != (unsigned long )(& chip->midi_list))) {
//#line  13594
        goto while_break___0;
      }
      {
//#line  13597
      snd_usbmidi_disconnect(p);
//#line  13599
      p = (struct list_head *)p->next;
      }
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  13602
    p = (struct list_head *)chip->mixer_list.next;
    {
    {
//#line  13604
    while (1) {


      {
//#line  13606
      __builtin_prefetch((void const   *)p->next);
      }
//#line  13608
      if (! ((unsigned long )p != (unsigned long )(& chip->mixer_list))) {
//#line  13610
        goto while_break___1;
      }
      {
//#line  13613
      snd_usb_mixer_disconnect(p);
//#line  13615
      p = (struct list_head *)p->next;
      }
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    {
//#line  13618
    usb_chip[chip->index] = (struct snd_usb_audio * __attribute__((__noderef__, __address_space__(2))) )((void *)0);
//#line  13620
    mutex_unlock(& register_mutex);
//#line  13622
    snd_card_free_when_closed(card);
    }
  } else {
    {
//#line  13625
    mutex_unlock(& register_mutex);
    }
  }
//#line  13628
  return;
}
}
//#line  13632 "usb-audio.merged.sym.c"
struct usb_device *Nonstub_get_usb_device(struct usb_interface *intf , int marshaling ,
                                          int gen_kern , struct usb_device *after ) 
{ 
  struct usb_device *dev ;
  struct device  const  *__mptr ;

  {
  record_function("Nonstub_get_usb_device");
//#line  13640
  __mptr = (struct device  const  *)intf->dev.parent;
//#line  13642
  dev = (struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev));
//#line  13644
  if (! gen_kern) {
//#line  13646
    if (marshaling) {
//#line  13648
      if (! after) {
//#line  13650
        intf->dev.parent = (struct device *)dev;
      } else {
//#line  13653
        intf->dev.parent = (struct device *)(& after->dev);
//#line  13655
        dev = after;
      }
    } else
//#line  13659
    if (! after) {
//#line  13661
      intf->dev.parent = (struct device *)dev;
    } else {
//#line  13664
      intf->dev.parent = (struct device *)(& after->dev);
//#line  13666
      dev = after;
    }
  }
//#line  13670
  return (dev);
}
}
//#line  13674 "usb-audio.merged.sym.c"
static int usb_audio_probe(struct usb_interface * __attribute__((__extraptr__(sizeof(struct usb_device *),"Nonstub_get_usb_device"))) intf ,
                           struct usb_device_id  const  *id___0 ) 
{ 
  void *chip ;
  struct device  const  *__mptr ;

  {
  record_function("usb_audio_probe");
  {
//#line  13682
  __mptr = (struct device  const  *)intf->dev.parent;
//#line  13684
  chip = snd_usb_audio_probe((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)),
                             (struct usb_interface *)intf, id___0);
  }
//#line  13687
  if (chip) {
    {
//#line  13689
    usb_set_intfdata((struct usb_interface *)intf, chip);
    }
//#line  13691
    return (0);
  } else {
//#line  13694
    return (-5);
  }
}
}
//#line  13699 "usb-audio.merged.sym.c"
static void usb_audio_disconnect(struct usb_interface * __attribute__((__noderef__,
                                 __address_space__(2))) intf ) 
{ 
  void *tmp ;
  struct device  const  *__mptr ;

  {
  record_function("usb_audio_disconnect");
  {
//#line  13707
  tmp = usb_get_intfdata((struct usb_interface *)intf);
//#line  13709
  __mptr = (struct device  const  *)intf->dev.parent;
//#line  13711
  snd_usb_audio_disconnect((struct usb_device *)((char *)__mptr - (unsigned int )(& ((struct usb_device *)0)->dev)),
                           tmp);
  }
//#line  13714
  return;
}
}
//#line  13718 "usb-audio.merged.sym.c"
static int usb_audio_suspend(struct usb_interface *intf , pm_message_t message ) 
{ 
  struct snd_usb_audio *chip ;
  void *tmp ;
  struct list_head *p ;
  struct snd_usb_stream *as ;
  struct list_head  const  *__mptr ;
  int tmp___0 ;

  {
  record_function("usb_audio_suspend");
  {
//#line  13729
  tmp = usb_get_intfdata(intf);
//#line  13731
  chip = (struct snd_usb_audio *)tmp;
  }
//#line  13733
  if ((unsigned long )chip == (unsigned long )((void *)-1L)) {
//#line  13735
    return (0);
  }
  {
//#line  13738
  snd_power_change_state(chip->card, 768U);
//#line  13740
  tmp___0 = chip->num_suspended_intf;
//#line  13742
  (chip->num_suspended_intf) ++;
  }
//#line  13744
  if (! tmp___0) {
//#line  13746
    p = (struct list_head *)chip->pcm_list.next;
    {
    {
//#line  13748
    while (1) {


      {
//#line  13750
      __builtin_prefetch((void const   *)p->next);
      }
//#line  13752
      if (! ((unsigned long )p != (unsigned long )(& chip->pcm_list))) {
//#line  13754
        goto while_break;
      }
      {
//#line  13757
      __mptr = (struct list_head  const  *)p;
//#line  13759
      as = (struct snd_usb_stream *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_stream *)0)->list));
//#line  13761
      snd_pcm_suspend_all((struct snd_pcm *)as->pcm);
//#line  13763
      p = (struct list_head *)p->next;
      }
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
//#line  13767
  return (0);
}
}
//#line  13771 "usb-audio.merged.sym.c"
static int usb_audio_resume(struct usb_interface *intf ) 
{ 
  struct snd_usb_audio *chip ;
  void *tmp ;

  {
  record_function("usb_audio_resume");
  {
//#line  13778
  tmp = usb_get_intfdata(intf);
//#line  13780
  chip = (struct snd_usb_audio *)tmp;
  }
//#line  13782
  if ((unsigned long )chip == (unsigned long )((void *)-1L)) {
//#line  13784
    return (0);
  }
//#line  13787
  (chip->num_suspended_intf) --;
//#line  13789
  if (chip->num_suspended_intf) {
//#line  13791
    return (0);
  }
  {
//#line  13794
  snd_power_change_state(chip->card, 0U);
  }
//#line  13796
  return (0);
}
}
//#line  13828
static void snd_usb_audio_cleanup(void)  __attribute__((__section__(".exit.text"))) ;
//#line  13830
static void snd_usb_audio_cleanup(void)  __attribute__((__section__(".exit.text"))) ;
static void snd_usb_audio_cleanup(void) 
{ 


  {
  record_function("snd_usb_audio_cleanup");
  {
//#line  13836
  usb_deregister(& usb_audio_driver);
  }
//#line  13838
  return;
}
}
//#line  13854 "usb-audio.merged.sym.c"
void cleanup_module(void) 
{ 


  {
  record_function("cleanup_module");
  {
//#line  13860
  snd_usb_audio_cleanup();
  }
//#line  13862
  return;
}
}
//#line  13866
#pragma merger(0,"./usbmidi.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  13868
static void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  13870
static void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  13872
static void init_timer(struct timer_list *timer ) ;
//#line  13874
static int mod_timer(struct timer_list *timer , unsigned long expires ) ;
//#line  13876
static int del_timer_sync(struct timer_list *timer ) ;
//#line  13878
static void __tasklet_schedule(struct tasklet_struct *t ) ;
//#line  13880 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) tasklet_schedule)(struct tasklet_struct *t ) 
{ 
  int tmp ;

  {
  record_function("tasklet_schedule");
  {
//#line  13886
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& t->state));
  }
//#line  13888
  if (! tmp) {
    {
//#line  13890
    __tasklet_schedule(t);
    }
  }
//#line  13893
  return;
}
}
//#line  13897
static void tasklet_kill(struct tasklet_struct *t ) ;
//#line  13899
static void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                         unsigned long data ) ;
//#line  13902 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_num)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  record_function("usb_endpoint_num");
//#line  13908
  return ((int )((int const   )epd->bEndpointAddress & 15));
}
}
//#line  13912 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_dir_in)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  record_function("usb_endpoint_dir_in");
//#line  13918
  return (((int const   )epd->bEndpointAddress & 128) == 128);
}
}
//#line  13922 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_dir_out)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  record_function("usb_endpoint_dir_out");
//#line  13928
  return (((int const   )epd->bEndpointAddress & 128) == 0);
}
}
//#line  13932 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_xfer_bulk)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  record_function("usb_endpoint_xfer_bulk");
//#line  13938
  return (((int const   )epd->bmAttributes & 3) == 2);
}
}
//#line  13942 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) usb_endpoint_xfer_int)(struct usb_endpoint_descriptor  const  *epd ) 
{ 


  {
  record_function("usb_endpoint_xfer_int");
//#line  13948
  return (((int const   )epd->bmAttributes & 3) == 3);
}
}
//#line  13952 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) usb_fill_bulk_urb)(struct urb *urb ,
                                                                             struct usb_device *dev ,
                                                                             unsigned int pipe ,
                                                                             void *transfer_buffer ,
                                                                             int buffer_length ,
                                                                             void (*complete_fn)(struct urb * ) ,
                                                                             void *context ) 
{ 


  {
  record_function("usb_fill_bulk_urb");
//#line  13964
  urb->dev = (struct usb_device *)dev;
//#line  13966
  urb->pipe = pipe;
//#line  13968
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  13970
  urb->transfer_buffer_length = buffer_length;
//#line  13972
  urb->complete = complete_fn;
//#line  13974
  urb->context = (u8 * __attribute__((__noderef__)) )context;
//#line  13976
  return;
}
}
//#line  13980 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) usb_fill_int_urb)(struct urb *urb ,
                                                                            struct usb_device *dev ,
                                                                            unsigned int pipe ,
                                                                            void *transfer_buffer ,
                                                                            int buffer_length ,
                                                                            void (*complete_fn)(struct urb * ) ,
                                                                            void *context ,
                                                                            int interval ) 
{ 


  {
  record_function("usb_fill_int_urb");
//#line  13993
  urb->dev = (struct usb_device *)dev;
//#line  13995
  urb->pipe = pipe;
//#line  13997
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  13999
  urb->transfer_buffer_length = buffer_length;
//#line  14001
  urb->complete = complete_fn;
//#line  14003
  urb->context = (u8 * __attribute__((__noderef__)) )context;
//#line  14005
  if ((unsigned int )dev->speed == 3U) {
//#line  14007
    urb->interval = 1 << (interval - 1);
  } else {
//#line  14010
    urb->interval = interval;
  }
//#line  14013
  urb->start_frame = -1;
//#line  14015
  return;
}
}
//#line  14019
static void usb_kill_urb(struct urb *urb ) ;
//#line  14021
static int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data ,
                        int len , int *actual_length , int timeout ) ;
//#line  14024 "usb-audio.merged.sym.c"
__inline static __u16 ( __attribute__((__always_inline__)) usb_maxpacket)(struct usb_device *udev ,
                                                                          int pipe ,
                                                                          int is_out ) 
{ 
  struct usb_host_endpoint *ep ;
  unsigned int epnum ;
  int __ret_warn_on ;
  long tmp ;
  int __ret_warn_on___0 ;
  long tmp___0 ;

  {
  record_function("usb_maxpacket");
//#line  14037
  epnum = (unsigned int )((pipe >> 15) & 15);
//#line  14039
  if (is_out) {
    {
//#line  14041
    __ret_warn_on = ! (! (pipe & 128));
//#line  14043
    tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
    }
//#line  14045
    if (tmp) {
      {
//#line  14047
      warn_slowpath(str_438695472, 1722, (char const   *)((void *)0));
      }
    }
    {
//#line  14050
    __builtin_expect((long )(! (! __ret_warn_on)), 0L);
//#line  14052
    ep = udev->ep_out[epnum];
    }
  } else {
    {
//#line  14055
    __ret_warn_on___0 = ! (! (! (pipe & 128)));
//#line  14057
    tmp___0 = __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
    }
//#line  14059
    if (tmp___0) {
      {
//#line  14061
      warn_slowpath(str_438695472, 1725, (char const   *)((void *)0));
      }
    }
    {
//#line  14064
    __builtin_expect((long )(! (! __ret_warn_on___0)), 0L);
//#line  14066
    ep = udev->ep_in[epnum];
    }
  }
//#line  14069
  if (! ep) {
//#line  14071
    return ((__u16 )0);
  }
//#line  14074
  return (ep->desc.wMaxPacketSize);
}
}
//#line  14078
static int snd_rawmidi_new(struct snd_card *card , char *id , int device , int output_count ,
                           int input_count , struct snd_rawmidi **rmidi ) ;
//#line  14081
static void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi , int stream , struct snd_rawmidi_ops *ops ) ;
//#line  14083
static int snd_rawmidi_receive(struct snd_rawmidi_substream *substream , unsigned char const   *buffer ,
                               int count ) ;
//#line  14086
static int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream ) ;
//#line  14088
static int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                                     int count ) ;
//#line  14091
static int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream , int count ) ;
//#line  14093
static int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                                int count ) ;
//#line  14096
void snd_usbmidi_input_stop(struct list_head *p ) ;
//#line  14098
void snd_usbmidi_input_start(struct list_head *p ) ;
static char const   __mod_author66[44]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  14100
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'C', 
        (char const   )'l',      (char const   )'e',      (char const   )'m',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'L', 
        (char const   )'a',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'<', 
        (char const   )'c',      (char const   )'l',      (char const   )'e',      (char const   )'m', 
        (char const   )'e',      (char const   )'n',      (char const   )'s',      (char const   )'@', 
        (char const   )'l',      (char const   )'a',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'c',      (char const   )'h',      (char const   )'.', 
        (char const   )'d',      (char const   )'e',      (char const   )'>',      (char const   )'\000'};
static char const   __mod_description67[41]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  14114
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'U',      (char const   )'S',      (char const   )'B',      (char const   )' ', 
        (char const   )'A',      (char const   )'u',      (char const   )'d',      (char const   )'i', 
        (char const   )'o',      (char const   )'/',      (char const   )'M',      (char const   )'I', 
        (char const   )'D',      (char const   )'I',      (char const   )' ',      (char const   )'h', 
        (char const   )'e',      (char const   )'l',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'u',      (char const   )'l',      (char const   )'e', 
        (char const   )'\000'};
static char const   __mod_license68[21]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  14129
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'D',      (char const   )'u',      (char const   )'a',      (char const   )'l', 
        (char const   )' ',      (char const   )'B',      (char const   )'S',      (char const   )'D', 
        (char const   )'/',      (char const   )'G',      (char const   )'P',      (char const   )'L', 
        (char const   )'\000'};
//#line  14138
static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep ) ;
static uint8_t const   snd_usbmidi_cin_length[16]  = 
//#line  14140
  {      (uint8_t const   )0,      (uint8_t const   )0,      (uint8_t const   )2,      (uint8_t const   )3, 
        (uint8_t const   )3,      (uint8_t const   )1,      (uint8_t const   )2,      (uint8_t const   )3, 
        (uint8_t const   )3,      (uint8_t const   )3,      (uint8_t const   )3,      (uint8_t const   )3, 
        (uint8_t const   )2,      (uint8_t const   )2,      (uint8_t const   )3,      (uint8_t const   )1};
//#line  14147 "usb-audio.merged.sym.c"
static int snd_usbmidi_submit_urb(struct urb *urb , gfp_t flags ) 
{ 
  int err ;
  int tmp ;

  {
  record_function("snd_usbmidi_submit_urb");
  {
//#line  14154
  tmp = usb_submit_urb(urb, flags);
//#line  14156
  err = tmp;
  }
//#line  14158
  if (err < 0) {
//#line  14160
    if (err != -19) {
      {
//#line  14162
      printk(str_473127585, err);
      }
    }
  }
//#line  14166
  return (err);
}
}
//#line  14170 "usb-audio.merged.sym.c"
static int snd_usbmidi_urb_error(int status ) 
{ 


  {
  record_function("snd_usbmidi_urb_error");
  {
  if (status == -2) {
//#line  14177
    goto case_neg_2;
  }
  if (status == -104) {
//#line  14178
    goto case_neg_2;
  }
  if (status == -108) {
//#line  14179
    goto case_neg_2;
  }
  if (status == -19) {
//#line  14180
    goto case_neg_2;
  }
  if (status == -71) {
//#line  14183
    goto case_neg_71;
  }
  if (status == -62) {
//#line  14184
    goto case_neg_71;
  }
  if (status == -84) {
//#line  14185
    goto case_neg_71;
  }
//#line  14188
  goto switch_default;
  case_neg_2: /* CIL Label */ 
//#line  14182
  return (-19);
  case_neg_71: /* CIL Label */ 
//#line  14187
  return (-5);
  switch_default: /* CIL Label */ 
  {
//#line  14190
  printk(str_843424035, status);
  }
//#line  14192
  return (0);

  }
}
}
//#line  14197 "usb-audio.merged.sym.c"
static void snd_usbmidi_input_data(struct snd_usb_midi_in_endpoint *ep , int portidx ,
                                   uint8_t *data , int length ) 
{ 
  struct usbmidi_in_port *port ;
  int tmp___0 ;

  {
  record_function("snd_usbmidi_input_data");
//#line  14205
  port = & ep->ports[portidx];
//#line  14207
  if (! port->substream) {
    {
    {
//#line  14209
    while (1) {


//#line  14211
      goto while_break;
    }

    }
    while_break: /* CIL Label */ ;
    }
//#line  14214
    return;
  }
  {
//#line  14217
  tmp___0 = variable_test_bit((port->substream)->number, (unsigned long const volatile   *)(& (ep->umidi)->input_triggered));
  }
//#line  14219
  if (! tmp___0) {
//#line  14221
    return;
  }
  {
//#line  14224
  snd_rawmidi_receive(port->substream, (unsigned char const   *)data, length);
  }
//#line  14226
  return;
}
}
//#line  14230 "usb-audio.merged.sym.c"
static void snd_usbmidi_in_urb_complete(struct urb *urb ) 
{ 
  struct snd_usb_midi_in_endpoint *ep ;
  int err ;
  int tmp ;

  {
  record_function("snd_usbmidi_in_urb_complete");
//#line  14238
  ep = (struct snd_usb_midi_in_endpoint *)urb->context;
//#line  14240
  if (urb->status == 0) {
    {
//#line  14242
    (*(((ep->umidi)->usb_protocol_ops)->input))(ep, urb->transfer_buffer, urb->actual_length);
    }
  } else {
    {
//#line  14245
    tmp = snd_usbmidi_urb_error(urb->status);
//#line  14247
    err = tmp;
    }
//#line  14249
    if (err < 0) {
//#line  14251
      if (err != -19) {
        {
//#line  14253
        ep->error_resubmit = (u8 )1;
//#line  14255
        mod_timer(& (ep->umidi)->error_timer, (unsigned long )(jiffies + (unsigned long volatile   )100));
        }
      }
//#line  14258
      return;
    }
  }
  {
//#line  14262
  urb->dev = (struct usb_device *)((ep->umidi)->chip)->dev;
//#line  14264
  snd_usbmidi_submit_urb(urb, 32U);
  }
//#line  14266
  return;
}
}
//#line  14270 "usb-audio.merged.sym.c"
static void snd_usbmidi_out_urb_complete(struct urb *urb ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;
  int err ;
  int tmp ;

  {
  record_function("snd_usbmidi_out_urb_complete");
  {
//#line  14278
  ep = (struct snd_usb_midi_out_endpoint *)urb->context;
//#line  14280
  _spin_lock(& ep->buffer_lock);
//#line  14282
  ep->urb_active = 0;
//#line  14284
  _spin_unlock(& ep->buffer_lock);
  }
//#line  14286
  if (urb->status < 0) {
    {
//#line  14288
    tmp = snd_usbmidi_urb_error(urb->status);
//#line  14290
    err = tmp;
    }
//#line  14292
    if (err < 0) {
//#line  14294
      if (err != -19) {
        {
//#line  14296
        mod_timer(& (ep->umidi)->error_timer, (unsigned long )(jiffies + (unsigned long volatile   )100));
        }
      }
//#line  14299
      return;
    }
  }
  {
//#line  14303
  snd_usbmidi_do_output(ep);
  }
//#line  14305
  return;
}
}
//#line  14309 "usb-audio.merged.sym.c"
static void snd_usbmidi_do_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  struct urb *urb ;
  unsigned long flags ;
  int tmp ;

  {
  record_function("snd_usbmidi_do_output");
//#line  14317
  urb = (struct urb *)ep->urb;
  {
  {
//#line  14319
  while (1) {


    {
//#line  14321
    flags = _spin_lock_irqsave(& ep->buffer_lock);
    }
//#line  14323
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  14326
  if (ep->urb_active) {
//#line  14328
    goto _L;
  } else
//#line  14331
  if (((ep->umidi)->chip)->shutdown) {
    _L: 
    {
    {
//#line  14334
    while (1) {


      {
//#line  14336
      _spin_unlock_irqrestore(& ep->buffer_lock, flags);
      }
//#line  14338
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  14341
    return;
  }
  {
//#line  14344
  urb->transfer_buffer_length = 0;
//#line  14346
  (*(((ep->umidi)->usb_protocol_ops)->output))(ep);
  }
//#line  14348
  if (urb->transfer_buffer_length > 0) {
    {
//#line  14350
    urb->dev = (struct usb_device *)((ep->umidi)->chip)->dev;
//#line  14352
    tmp = snd_usbmidi_submit_urb(urb, 32U);
//#line  14354
    ep->urb_active = tmp >= 0;
    }
  }
  {
  {
//#line  14357
  while (1) {


    {
//#line  14359
    _spin_unlock_irqrestore(& ep->buffer_lock, flags);
    }
//#line  14361
    goto while_break___1;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  14364
  return;
}
}
//#line  14368 "usb-audio.merged.sym.c"
static void snd_usbmidi_out_tasklet(struct snd_usb_midi_out_endpoint *data ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;

  {
  record_function("snd_usbmidi_out_tasklet");
  {
//#line  14374
  ep = data;
//#line  14376
  snd_usbmidi_do_output(ep);
  }
//#line  14378
  return;
}
}
//#line  14382 "usb-audio.merged.sym.c"
static void snd_usbmidi_error_timer(struct snd_usb_midi *data ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct snd_usb_midi_in_endpoint *in ;

  {
  record_function("snd_usbmidi_error_timer");
  {
//#line  14390
  umidi = data;
//#line  14392
  _spin_lock(& umidi->disc_lock);
  }
//#line  14394
  if (umidi->disconnected) {
    {
//#line  14396
    _spin_unlock(& umidi->disc_lock);
    }
//#line  14398
    return;
  }
//#line  14401
  i = 0;
  {
  {
//#line  14403
  while (1) {


    if (! (i < 2)) {
//#line  14403
      goto while_break;
    }
//#line  14405
    in = umidi->endpoints[i].in;
//#line  14407
    if (in) {
//#line  14409
      if (in->error_resubmit) {
        {
//#line  14411
        in->error_resubmit = (u8 )0;
//#line  14413
        (in->urb)->dev = (struct usb_device *)(umidi->chip)->dev;
//#line  14415
        snd_usbmidi_submit_urb((struct urb *)in->urb, 32U);
        }
      }
    }
//#line  14419
    if (umidi->endpoints[i].out) {
      {
//#line  14421
      snd_usbmidi_do_output(umidi->endpoints[i].out);
      }
    }
//#line  14424
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  14427
  _spin_unlock(& umidi->disc_lock);
  }
//#line  14429
  return;
}
}
//#line  14433 "usb-audio.merged.sym.c"
static int send_bulk_static_data(struct snd_usb_midi_out_endpoint *ep , void const   *data ,
                                 int len ) 
{ 
  int err ;
  void *buf ;
  void *tmp ;

  {
  record_function("send_bulk_static_data");
  {
//#line  14442
  tmp = kmemdup(data, (size_t )len, 208U);
//#line  14444
  buf = tmp;
  }
//#line  14446
  if (! buf) {
//#line  14448
    return (-12);
  }
  {
//#line  14451
  err = usb_bulk_msg(((ep->umidi)->chip)->dev, (ep->urb)->pipe, buf, len, (int *)((void *)0),
                     250);
//#line  14454
  kfree((void const   *)buf);
  }
//#line  14456
  return (err);
}
}
//#line  14460 "usb-audio.merged.sym.c"
static void snd_usbmidi_standard_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                       int buffer_length ) 
{ 
  int i ;
  int cable ;
  int length ;

  {
  record_function("snd_usbmidi_standard_input");
//#line  14469
  i = 0;
  {
  {
//#line  14471
  while (1) {


    if (! (i + 3 < buffer_length)) {
//#line  14471
      goto while_break;
    }
//#line  14473
    if ((int )*(buffer + i) != 0) {
      {
//#line  14475
      cable = (int )*(buffer + i) >> 4;
//#line  14477
      length = (int )snd_usbmidi_cin_length[(int )*(buffer + i) & 15];
//#line  14479
      snd_usbmidi_input_data(ep, cable, buffer + (i + 1), length);
      }
    }
//#line  14482
    i += 4;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  14485
  return;
}
}
//#line  14489 "usb-audio.merged.sym.c"
void snd_usbmidi_midiman_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                               int buffer_length ) 
{ 
  int i ;
  int port ;
  int length ;

  {
  record_function("snd_usbmidi_midiman_input");
//#line  14498
  i = 0;
  {
  {
//#line  14500
  while (1) {


    if (! (i + 3 < buffer_length)) {
//#line  14500
      goto while_break;
    }
//#line  14502
    if ((int )*(buffer + (i + 3)) != 0) {
      {
//#line  14504
      port = (int )*(buffer + (i + 3)) >> 4;
//#line  14506
      length = (int )*(buffer + (i + 3)) & 3;
//#line  14508
      snd_usbmidi_input_data(ep, port, buffer + i, length);
      }
    }
//#line  14511
    i += 4;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  14514
  return;
}
}
//#line  14518 "usb-audio.merged.sym.c"
void snd_usbmidi_maudio_broken_running_status_input(struct snd_usb_midi_in_endpoint *ep ,
                                                    uint8_t *buffer , int buffer_length ) 
{ 
  int i ;
  int cable ;
  u8 cin ;
  struct usbmidi_in_port *port ;
  int length ;

  {
  record_function("snd_usbmidi_maudio_broken_running_status_input");
//#line  14529
  i = 0;
  {
  {
//#line  14531
  while (1) {


    if (! (i + 3 < buffer_length)) {
//#line  14531
      goto while_break;
    }
//#line  14533
    if ((int )*(buffer + i) != 0) {
//#line  14535
      cable = (int )*(buffer + i) >> 4;
//#line  14537
      cin = (u8 )((int )*(buffer + i) & 15);
//#line  14539
      port = & ep->ports[cable];
//#line  14541
      length = (int )snd_usbmidi_cin_length[cin];
//#line  14543
      if ((int )cin == 15) {
//#line  14545
        if (! ((int )*(buffer + (i + 1)) >= 248)) {
//#line  14547
          goto _L___0;
        }
      } else
      _L___0: 
//#line  14552
      if ((int )cin >= 8) {
//#line  14554
        if ((int )cin <= 14) {
//#line  14556
          port->running_status_length = (u8 )(length - 1);
        } else {
//#line  14559
          goto _L;
        }
      } else
      _L: 
//#line  14564
      if ((int )cin == 4) {
//#line  14566
        if ((int )port->running_status_length != 0) {
//#line  14568
          if ((int )*(buffer + (i + 1)) < 128) {
//#line  14570
            length = (int )port->running_status_length;
          } else {
//#line  14573
            port->running_status_length = (u8 )0;
          }
        } else {
//#line  14577
          port->running_status_length = (u8 )0;
        }
      } else {
//#line  14581
        port->running_status_length = (u8 )0;
      }
      {
//#line  14584
      snd_usbmidi_input_data(ep, cable, buffer + (i + 1), length);
      }
    }
//#line  14587
    i += 4;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  14590
  return;
}
}
//#line  14594 "usb-audio.merged.sym.c"
void snd_usbmidi_cme_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) 
{ 


  {
  record_function("snd_usbmidi_cme_input");
//#line  14601
  if (buffer_length < 2) {
    {
//#line  14603
    snd_usbmidi_standard_input(ep, buffer, buffer_length);
    }
  } else
//#line  14606
  if (((int )*(buffer + 0) & 15) != 15) {
    {
//#line  14608
    snd_usbmidi_standard_input(ep, buffer, buffer_length);
    }
  } else {
    {
//#line  14611
    snd_usbmidi_input_data(ep, (int )*(buffer + 0) >> 4, buffer + 1, buffer_length - 1);
    }
  }
//#line  14614
  return;
}
}
//#line  14618 "usb-audio.merged.sym.c"
void snd_usbmidi_output_standard_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                        uint8_t p2 , uint8_t p3 ) 
{ 
  uint8_t *buf ;

  {
  record_function("snd_usbmidi_output_standard_packet");
//#line  14625
  buf = urb->transfer_buffer + urb->transfer_buffer_length;
//#line  14627
  *(buf + 0) = p0;
//#line  14629
  *(buf + 1) = p1;
//#line  14631
  *(buf + 2) = p2;
//#line  14633
  *(buf + 3) = p3;
//#line  14635
  urb->transfer_buffer_length += 4;
//#line  14637
  return;
}
}
//#line  14641 "usb-audio.merged.sym.c"
void snd_usbmidi_output_midiman_packet(struct urb *urb , uint8_t p0 , uint8_t p1 ,
                                       uint8_t p2 , uint8_t p3 ) 
{ 
  uint8_t *buf ;

  {
  record_function("snd_usbmidi_output_midiman_packet");
//#line  14648
  buf = urb->transfer_buffer + urb->transfer_buffer_length;
//#line  14650
  *(buf + 0) = p1;
//#line  14652
  *(buf + 1) = p2;
//#line  14654
  *(buf + 2) = p3;
//#line  14656
  *(buf + 3) = (uint8_t )(((int )p0 & 240) | (int )snd_usbmidi_cin_length[(int )p0 & 15]);
//#line  14658
  urb->transfer_buffer_length += 4;
//#line  14660
  return;
}
}
//#line  14664 "usb-audio.merged.sym.c"
static void snd_usbmidi_transmit_byte(struct usbmidi_out_port *port , uint8_t b ,
                                      struct urb *urb ) 
{ 
  uint8_t p0 ;
  void (*output_packet)(struct urb * , uint8_t  , uint8_t  , uint8_t  , uint8_t  ) ;

  {
  record_function("snd_usbmidi_transmit_byte");
//#line  14672
  p0 = port->cable;
//#line  14674
  output_packet = (((port->ep)->umidi)->usb_protocol_ops)->output_packet;
//#line  14676
  if ((int )b >= 248) {
    {
//#line  14678
    (*output_packet)(urb, (uint8_t )((int )p0 | 15), b, (uint8_t )0, (uint8_t )0);
    }
  } else
//#line  14681
  if ((int )b >= 240) {
    {
    if ((int )b == 240) {
//#line  14684
      goto case_240;
    }
    if ((int )b == 241) {
//#line  14691
      goto case_241;
    }
    if ((int )b == 243) {
//#line  14692
      goto case_241;
    }
    if ((int )b == 242) {
//#line  14699
      goto case_242;
    }
    if ((int )b == 244) {
//#line  14706
      goto case_244;
    }
    if ((int )b == 245) {
//#line  14707
      goto case_244;
    }
    if ((int )b == 246) {
//#line  14712
      goto case_246;
    }
    if ((int )b == 247) {
//#line  14719
      goto case_247;
    }
//#line  14683
    goto switch_break;
    case_240: /* CIL Label */ 
//#line  14686
    port->data[0] = b;
//#line  14688
    port->state = (uint8_t )5;
//#line  14690
    goto switch_break;
    case_241: /* CIL Label */ 
//#line  14694
    port->data[0] = b;
//#line  14696
    port->state = (uint8_t )1;
//#line  14698
    goto switch_break;
    case_242: /* CIL Label */ 
//#line  14701
    port->data[0] = b;
//#line  14703
    port->state = (uint8_t )2;
//#line  14705
    goto switch_break;
    case_244: /* CIL Label */ 
//#line  14709
    port->state = (uint8_t )0;
//#line  14711
    goto switch_break;
    case_246: /* CIL Label */ 
    {
//#line  14714
    (*output_packet)(urb, (uint8_t )((int )p0 | 5), (uint8_t )246, (uint8_t )0, (uint8_t )0);
//#line  14716
    port->state = (uint8_t )0;
    }
//#line  14718
    goto switch_break;
    case_247: /* CIL Label */ 
    {
    if ((int )port->state == 4) {
//#line  14722
      goto case_4;
    }
    if ((int )port->state == 5) {
//#line  14727
      goto case_5;
    }
    if ((int )port->state == 6) {
//#line  14733
      goto case_6;
    }
//#line  14721
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
//#line  14724
    (*output_packet)(urb, (uint8_t )((int )p0 | 5), (uint8_t )247, (uint8_t )0, (uint8_t )0);
    }
//#line  14726
    goto switch_break___0;
    case_5: /* CIL Label */ 
    {
//#line  14729
    (*output_packet)(urb, (uint8_t )((int )p0 | 6), port->data[0], (uint8_t )247,
                     (uint8_t )0);
    }
//#line  14732
    goto switch_break___0;
    case_6: /* CIL Label */ 
    {
//#line  14735
    (*output_packet)(urb, (uint8_t )((int )p0 | 7), port->data[0], port->data[1],
                     (uint8_t )247);
    }
//#line  14738
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
//#line  14741
    port->state = (uint8_t )0;
//#line  14743
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
//#line  14747
  if ((int )b >= 128) {
//#line  14749
    port->data[0] = b;
//#line  14751
    if ((int )b >= 192) {
//#line  14753
      if ((int )b <= 223) {
//#line  14755
        port->state = (uint8_t )1;
      } else {
//#line  14758
        port->state = (uint8_t )2;
      }
    } else {
//#line  14762
      port->state = (uint8_t )2;
    }
  } else {
    {
    if ((int )port->state == 1) {
//#line  14767
      goto case_1;
    }
    if ((int )port->state == 2) {
//#line  14782
      goto case_2;
    }
    if ((int )port->state == 3) {
//#line  14789
      goto case_3;
    }
    if ((int )port->state == 4) {
//#line  14806
      goto case_4___0;
    }
    if ((int )port->state == 5) {
//#line  14813
      goto case_5___0;
    }
    if ((int )port->state == 6) {
//#line  14820
      goto case_6___0;
    }
//#line  14766
    goto switch_break___1;
    case_1: /* CIL Label */ 
//#line  14769
    if ((int )port->data[0] < 240) {
//#line  14771
      p0 = (uint8_t )((int )p0 | ((int )port->data[0] >> 4));
    } else {
//#line  14774
      p0 = (uint8_t )((int )p0 | 2);
//#line  14776
      port->state = (uint8_t )0;
    }
    {
//#line  14779
    (*output_packet)(urb, p0, port->data[0], b, (uint8_t )0);
    }
//#line  14781
    goto switch_break___1;
    case_2: /* CIL Label */ 
//#line  14784
    port->data[1] = b;
//#line  14786
    port->state = (uint8_t )3;
//#line  14788
    goto switch_break___1;
    case_3: /* CIL Label */ 
//#line  14791
    if ((int )port->data[0] < 240) {
//#line  14793
      p0 = (uint8_t )((int )p0 | ((int )port->data[0] >> 4));
//#line  14795
      port->state = (uint8_t )2;
    } else {
//#line  14798
      p0 = (uint8_t )((int )p0 | 3);
//#line  14800
      port->state = (uint8_t )0;
    }
    {
//#line  14803
    (*output_packet)(urb, p0, port->data[0], port->data[1], b);
    }
//#line  14805
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
//#line  14808
    port->data[0] = b;
//#line  14810
    port->state = (uint8_t )5;
//#line  14812
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
//#line  14815
    port->data[1] = b;
//#line  14817
    port->state = (uint8_t )6;
//#line  14819
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
    {
//#line  14822
    (*output_packet)(urb, (uint8_t )((int )p0 | 4), port->data[0], port->data[1],
                     b);
//#line  14825
    port->state = (uint8_t )4;
    }
//#line  14827
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
//#line  14831
  return;
}
}
//#line  14835 "usb-audio.merged.sym.c"
void snd_usbmidi_standard_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  struct urb *urb ;
  int p ;
  struct usbmidi_out_port *port ;
  uint8_t b ;
  int tmp ;

  {
  record_function("snd_usbmidi_standard_output");
//#line  14845
  urb = (struct urb *)ep->urb;
//#line  14847
  p = 0;
  {
  {
//#line  14849
  while (1) {


    if (! (p < 16)) {
//#line  14849
      goto while_break;
    }
//#line  14851
    port = & ep->ports[p];
//#line  14853
    if (! port->active) {
//#line  14855
      goto __Cont;
    }
    {
    {
//#line  14858
    while (1) {


      if (! (urb->transfer_buffer_length + 3 < ep->max_transfer)) {
//#line  14858
        goto while_break___0;
      }
      {
//#line  14860
      tmp = snd_rawmidi_transmit((struct snd_rawmidi_substream *)port->substream,
                                 & b, 1);
      }
//#line  14863
      if (tmp != 1) {
//#line  14865
        port->active = 0;
//#line  14867
        goto while_break___0;
      }
      {
//#line  14870
      snd_usbmidi_transmit_byte(port, b, urb);
      }
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: 
//#line  14874
    p ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  14877
  return;
}
}
//#line  14881 "usb-audio.merged.sym.c"
void snd_usbmidi_novation_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                                int buffer_length ) 
{ 


  {
  record_function("snd_usbmidi_novation_input");
//#line  14888
  if (buffer_length < 2) {
//#line  14890
    return;
  } else
//#line  14893
  if (! *(buffer + 0)) {
//#line  14895
    return;
  } else
//#line  14898
  if (buffer_length < (int )*(buffer + 0) + 1) {
//#line  14900
    return;
  }
  {
//#line  14903
  snd_usbmidi_input_data(ep, 0, buffer + 2, (int )*(buffer + 0) - 1);
  }
//#line  14905
  return;
}
}
//#line  14909 "usb-audio.merged.sym.c"
void snd_usbmidi_novation_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  uint8_t *transfer_buffer ;
  int count ;

  {
  record_function("snd_usbmidi_novation_output");
//#line  14916
  if (! ep->ports[0].active) {
//#line  14918
    return;
  }
  {
//#line  14921
  transfer_buffer = (ep->urb)->transfer_buffer;
//#line  14923
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               transfer_buffer + 2, ep->max_transfer - 2);
  }
//#line  14926
  if (count < 1) {
//#line  14928
    ep->ports[0].active = 0;
//#line  14930
    return;
  }
//#line  14933
  *(transfer_buffer + 0) = (uint8_t )0;
//#line  14935
  *(transfer_buffer + 1) = (uint8_t )count;
//#line  14937
  (ep->urb)->transfer_buffer_length = 2 + count;
//#line  14939
  return;
}
}
//#line  14943 "usb-audio.merged.sym.c"
void snd_usbmidi_raw_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                           int buffer_length ) 
{ 


  {
  record_function("snd_usbmidi_raw_input");
  {
//#line  14950
  snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
  }
//#line  14952
  return;
}
}
//#line  14956 "usb-audio.merged.sym.c"
void snd_usbmidi_raw_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int count ;

  {
  record_function("snd_usbmidi_raw_output");
//#line  14962
  if (! ep->ports[0].active) {
//#line  14964
    return;
  }
  {
//#line  14967
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               (ep->urb)->transfer_buffer, ep->max_transfer);
  }
//#line  14970
  if (count < 1) {
//#line  14972
    ep->ports[0].active = 0;
//#line  14974
    return;
  }
//#line  14977
  (ep->urb)->transfer_buffer_length = count;
//#line  14979
  return;
}
}
//#line  14983 "usb-audio.merged.sym.c"
void snd_usbmidi_us122l_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) 
{ 


  {
  record_function("snd_usbmidi_us122l_input");
//#line  14990
  if (buffer_length != 9) {
//#line  14992
    return;
  }
//#line  14995
  buffer_length = 8;
  {
  {
//#line  14997
  while (1) {


//#line  14999
    if (buffer_length) {
//#line  15001
      if (! ((int )*(buffer + (buffer_length - 1)) == 253)) {
//#line  15003
        goto while_break;
      }
    } else {
//#line  15007
      goto while_break;
    }
//#line  15010
    buffer_length --;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15013
  if (buffer_length) {
    {
//#line  15015
    snd_usbmidi_input_data(ep, 0, buffer, buffer_length);
    }
  }
//#line  15018
  return;
}
}
//#line  15022 "usb-audio.merged.sym.c"
void snd_usbmidi_us122l_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int count ;

  {
  record_function("snd_usbmidi_us122l_output");
//#line  15028
  if (! ep->ports[0].active) {
//#line  15030
    return;
  }
//#line  15033
  if ((unsigned int )((ep->urb)->dev)->speed == 3U) {
//#line  15035
    count = 1;
  } else {
//#line  15038
    count = 2;
  }
  {
//#line  15041
  count = snd_rawmidi_transmit((struct snd_rawmidi_substream *)ep->ports[0].substream,
                               (ep->urb)->transfer_buffer, count);
  }
//#line  15044
  if (count < 1) {
//#line  15046
    ep->ports[0].active = 0;
//#line  15048
    return;
  }
  {
//#line  15051
  memset((void *)((ep->urb)->transfer_buffer + count), 253, (size_t )(9 - count));
//#line  15053
  (ep->urb)->transfer_buffer_length = count;
  }
//#line  15055
  return;
}
}
static u8 const   init_data[9]  = 
//#line  15059
  {      (u8 const   )240,      (u8 const   )0,      (u8 const   )32,      (u8 const   )49, 
        (u8 const   )100,      (u8 const   )11,      (u8 const   )0,      (u8 const   )0, 
        (u8 const   )247};
//#line  15065 "usb-audio.merged.sym.c"
void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
  record_function("snd_usbmidi_emagic_init_out");
  {
//#line  15071
  send_bulk_static_data(ep, (void const   *)(init_data), (int )sizeof(init_data));
//#line  15073
  send_bulk_static_data(ep, (void const   *)(init_data), (int )sizeof(init_data));
  }
//#line  15075
  return;
}
}
static u8 const   finish_data[10]  = 
//#line  15079
  {      (u8 const   )240,      (u8 const   )0,      (u8 const   )32,      (u8 const   )49, 
        (u8 const   )100,      (u8 const   )16,      (u8 const   )0,      (u8 const   )127, 
        (u8 const   )64,      (u8 const   )247};
//#line  15085 "usb-audio.merged.sym.c"
void snd_usbmidi_emagic_finish_out(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
  record_function("snd_usbmidi_emagic_finish_out");
  {
//#line  15091
  send_bulk_static_data(ep, (void const   *)(finish_data), (int )sizeof(finish_data));
  }
//#line  15093
  return;
}
}
//#line  15097 "usb-audio.merged.sym.c"
void snd_usbmidi_emagic_input(struct snd_usb_midi_in_endpoint *ep , uint8_t *buffer ,
                              int buffer_length ) 
{ 
  int i ;

  {
  record_function("snd_usbmidi_emagic_input");
//#line  15104
  i = 0;
  {
  {
//#line  15106
  while (1) {


    if (! (i < buffer_length)) {
//#line  15106
      goto while_break;
    }
//#line  15108
    if ((int )*(buffer + i) == 255) {
//#line  15110
      buffer_length = i;
//#line  15112
      goto while_break;
    }
//#line  15115
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15118
  if (ep->seen_f5) {
//#line  15120
    goto switch_port;
  }
  {
  {
//#line  15123
  while (1) {


    if (! (buffer_length > 0)) {
//#line  15123
      goto while_break___0;
    }
//#line  15125
    i = 0;
    {
    {
//#line  15127
    while (1) {


      if (! (i < buffer_length)) {
//#line  15127
        goto while_break___1;
      }
//#line  15129
      if ((int )*(buffer + i) == 245) {
//#line  15131
        goto while_break___1;
      }
//#line  15134
      i ++;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    {
//#line  15137
    snd_usbmidi_input_data(ep, ep->current_port, buffer, i);
//#line  15139
    buffer += i;
//#line  15141
    buffer_length -= i;
    }
//#line  15143
    if (buffer_length <= 0) {
//#line  15145
      goto while_break___0;
    }
//#line  15148
    ep->seen_f5 = (u8 )1;
//#line  15150
    buffer ++;
//#line  15152
    buffer_length --;
    switch_port: 
//#line  15155
    if (buffer_length <= 0) {
//#line  15157
      goto while_break___0;
    }
//#line  15160
    if ((int )*(buffer + 0) < 128) {
//#line  15162
      ep->current_port = ((int )*(buffer + 0) - 1) & 15;
//#line  15164
      buffer ++;
//#line  15166
      buffer_length --;
    }
//#line  15169
    ep->seen_f5 = (u8 )0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  15172
  return;
}
}
//#line  15176 "usb-audio.merged.sym.c"
void snd_usbmidi_emagic_output(struct snd_usb_midi_out_endpoint *ep ) 
{ 
  int port0 ;
  uint8_t *buf ;
  int buf_free ;
  int length ;
  int i ;
  int portnum ;
  struct usbmidi_out_port *port ;
  int tmp ;

  {
  record_function("snd_usbmidi_emagic_output");
//#line  15189
  port0 = ep->current_port;
//#line  15191
  buf = (ep->urb)->transfer_buffer;
//#line  15193
  buf_free = ep->max_transfer;
//#line  15195
  i = 0;
  {
  {
//#line  15197
  while (1) {


    if (! (i < 16)) {
//#line  15197
      goto while_break;
    }
//#line  15199
    portnum = (port0 + i) & 15;
//#line  15201
    port = & ep->ports[portnum];
//#line  15203
    if (! port->active) {
//#line  15205
      goto __Cont;
    }
    {
//#line  15208
    tmp = snd_rawmidi_transmit_peek((struct snd_rawmidi_substream *)port->substream,
                                    buf, 1);
    }
//#line  15211
    if (tmp != 1) {
//#line  15213
      port->active = 0;
//#line  15215
      goto __Cont;
    }
//#line  15218
    if (portnum != ep->current_port) {
//#line  15220
      if (buf_free < 2) {
//#line  15222
        goto while_break;
      }
//#line  15225
      ep->current_port = portnum;
//#line  15227
      *(buf + 0) = (uint8_t )245;
//#line  15229
      *(buf + 1) = (uint8_t )((portnum + 1) & 15);
//#line  15231
      buf += 2;
//#line  15233
      buf_free -= 2;
    }
//#line  15236
    if (buf_free < 1) {
//#line  15238
      goto while_break;
    }
    {
//#line  15241
    length = snd_rawmidi_transmit((struct snd_rawmidi_substream *)port->substream,
                                  buf, buf_free);
    }
//#line  15244
    if (length > 0) {
//#line  15246
      buf += length;
//#line  15248
      buf_free -= length;
//#line  15250
      if (buf_free < 1) {
//#line  15252
        goto while_break;
      }
    }
    __Cont: 
//#line  15257
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15260
  if (buf_free < ep->max_transfer) {
//#line  15262
    if (buf_free > 0) {
//#line  15264
      *buf = (uint8_t )255;
//#line  15266
      buf_free --;
    }
  }
//#line  15270
  (ep->urb)->transfer_buffer_length = ep->max_transfer - buf_free;
//#line  15272
  return;
}
}
//#line  15276 "usb-audio.merged.sym.c"
static int snd_usbmidi_output_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct snd_usb_midi *umidi ;
  struct usbmidi_out_port *port ;
  int i ;
  int j ;

  {
  record_function("snd_usbmidi_output_open");
//#line  15285
  umidi = (struct snd_usb_midi *)(substream->rmidi)->private_data;
//#line  15287
  port = (struct usbmidi_out_port *)((void *)0);
//#line  15289
  i = 0;
  {
  {
//#line  15291
  while (1) {


    if (! (i < 2)) {
//#line  15291
      goto while_break;
    }
//#line  15293
    if (umidi->endpoints[i].out) {
//#line  15295
      j = 0;
      {
      {
//#line  15297
      while (1) {


        if (! (j < 16)) {
//#line  15297
          goto while_break___0;
        }
//#line  15299
        if ((unsigned long )(umidi->endpoints[i].out)->ports[j].substream == (unsigned long )substream) {
//#line  15301
          port = & (umidi->endpoints[i].out)->ports[j];
//#line  15303
          goto while_break___0;
        }
//#line  15306
        j ++;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
    }
//#line  15310
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15313
  if (! port) {
    {
    {
//#line  15315
    while (1) {


//#line  15317
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
//#line  15320
    return (-6);
  }
//#line  15323
  (substream->runtime)->private_data = (void *)port;
//#line  15325
  port->state = (uint8_t )0;
//#line  15327
  return (0);
}
}
//#line  15331 "usb-audio.merged.sym.c"
static int snd_usbmidi_output_close(struct snd_rawmidi_substream *substream ) 
{ 


  {
  record_function("snd_usbmidi_output_close");
//#line  15337
  return (0);
}
}
//#line  15341 "usb-audio.merged.sym.c"
static void snd_usbmidi_output_trigger(struct snd_rawmidi_substream *substream , int up___0 ) 
{ 
  struct usbmidi_out_port *port ;
  int tmp ;

  {
  record_function("snd_usbmidi_output_trigger");
//#line  15348
  port = (struct usbmidi_out_port *)(substream->runtime)->private_data;
//#line  15350
  port->active = up___0;
//#line  15352
  if (up___0) {
//#line  15354
    if ((((port->ep)->umidi)->chip)->shutdown) {
      {
      {
//#line  15356
      while (1) {


        {
//#line  15358
        tmp = snd_rawmidi_transmit_empty(substream);
        }
//#line  15360
        if (tmp) {
//#line  15362
          goto while_break;
        }
        {
//#line  15365
        snd_rawmidi_transmit_ack(substream, 1);
        }
      }

      }
      while_break: /* CIL Label */ ;
      }
//#line  15368
      return;
    }
    {
//#line  15371
    tasklet_schedule(& (port->ep)->tasklet);
    }
  }
//#line  15374
  return;
}
}
//#line  15378 "usb-audio.merged.sym.c"
static int snd_usbmidi_input_open(struct snd_rawmidi_substream *substream ) 
{ 


  {
  record_function("snd_usbmidi_input_open");
//#line  15384
  return (0);
}
}
//#line  15388 "usb-audio.merged.sym.c"
static int snd_usbmidi_input_close(struct snd_rawmidi_substream *substream ) 
{ 


  {
  record_function("snd_usbmidi_input_close");
//#line  15394
  return (0);
}
}
//#line  15398 "usb-audio.merged.sym.c"
static void snd_usbmidi_input_trigger(struct snd_rawmidi_substream *substream , int up___0 ) 
{ 
  struct snd_usb_midi *umidi ;

  {
  record_function("snd_usbmidi_input_trigger");
//#line  15404
  umidi = (struct snd_usb_midi *)(substream->rmidi)->private_data;
//#line  15406
  if (up___0) {
    {
//#line  15408
    set_bit((unsigned int )substream->number, (unsigned long volatile   *)(& umidi->input_triggered));
    }
  } else {
    {
//#line  15411
    clear_bit(substream->number, (unsigned long volatile   *)(& umidi->input_triggered));
    }
  }
//#line  15414
  return;
}
}
//#line  15418 "usb-audio.merged.sym.c"
static struct snd_rawmidi_ops snd_usbmidi_output_ops  =    {& snd_usbmidi_output_open, & snd_usbmidi_output_close, & snd_usbmidi_output_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  15421 "usb-audio.merged.sym.c"
static struct snd_rawmidi_ops snd_usbmidi_input_ops  =    {& snd_usbmidi_input_open, & snd_usbmidi_input_close, & snd_usbmidi_input_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  15424 "usb-audio.merged.sym.c"
static void snd_usbmidi_in_endpoint_delete(struct snd_usb_midi_in_endpoint *ep ) 
{ 


  {
  record_function("snd_usbmidi_in_endpoint_delete");
//#line  15430
  if (ep->urb) {
    {
//#line  15432
    usb_buffer_free(((ep->umidi)->chip)->dev, (size_t )(ep->urb)->transfer_buffer_length,
                    (void *)(ep->urb)->transfer_buffer, (ep->urb)->transfer_dma);
//#line  15435
    usb_free_urb((struct urb *)ep->urb);
    }
  }
  {
//#line  15438
  kfree((void const   *)ep);
  }
//#line  15440
  return;
}
}
//#line  15444 "usb-audio.merged.sym.c"
static int snd_usbmidi_in_endpoint_create(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *ep_info ,
                                          struct snd_usb_midi_endpoint *rep ) 
{ 
  struct snd_usb_midi_in_endpoint *ep ;
  void *buffer ;
  unsigned int pipe ;
  int length ;
  void *tmp ;
  struct urb *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  __u16 tmp___3 ;

  {
  record_function("snd_usbmidi_in_endpoint_create");
  {
//#line  15459
  rep->in = (struct snd_usb_midi_in_endpoint *)((void *)0);
//#line  15461
  tmp = kzalloc(sizeof(*ep), 208U);
//#line  15463
  ep = (struct snd_usb_midi_in_endpoint *)tmp;
  }
//#line  15465
  if (! ep) {
//#line  15467
    return (-12);
  }
  {
//#line  15470
  ep->umidi = umidi;
//#line  15472
  tmp___0 = usb_alloc_urb(0, 208U);
//#line  15474
  ep->urb = (struct urb *)tmp___0;
  }
//#line  15476
  if (! ep->urb) {
    {
//#line  15478
    snd_usbmidi_in_endpoint_delete(ep);
    }
//#line  15480
    return (-12);
  }
//#line  15483
  if (ep_info->in_interval) {
    {
//#line  15485
    tmp___1 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->in_ep);
//#line  15487
    pipe = ((unsigned int )(1 << 30) | tmp___1) | 128U;
    }
  } else {
    {
//#line  15490
    tmp___2 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->in_ep);
//#line  15492
    pipe = ((unsigned int )(3 << 30) | tmp___2) | 128U;
    }
  }
  {
//#line  15495
  tmp___3 = usb_maxpacket((umidi->chip)->dev, (int )pipe, 0);
//#line  15497
  length = (int )tmp___3;
//#line  15499
  buffer = usb_buffer_alloc((umidi->chip)->dev, (size_t )length, 208U, & (ep->urb)->transfer_dma);
  }
//#line  15501
  if (! buffer) {
    {
//#line  15503
    snd_usbmidi_in_endpoint_delete(ep);
    }
//#line  15505
    return (-12);
  }
//#line  15508
  if (ep_info->in_interval) {
    {
//#line  15510
    usb_fill_int_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, length,
                     & snd_usbmidi_in_urb_complete, (void *)ep, (int )ep_info->in_interval);
    }
  } else {
    {
//#line  15514
    usb_fill_bulk_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, length,
                      & snd_usbmidi_in_urb_complete, (void *)ep);
    }
  }
//#line  15518
  (ep->urb)->transfer_flags = 4U;
//#line  15520
  rep->in = ep;
//#line  15522
  return (0);
}
}
//#line  15526 "usb-audio.merged.sym.c"
static unsigned int snd_usbmidi_count_bits(unsigned int x ) 
{ 
  unsigned int bits ;

  {
  record_function("snd_usbmidi_count_bits");
//#line  15532
  bits = 0U;
  {
  {
//#line  15534
  while (1) {


    if (! x) {
//#line  15534
      goto while_break;
    }
//#line  15536
    x &= x - 1U;
//#line  15538
    bits ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15541
  return (bits);
}
}
//#line  15545 "usb-audio.merged.sym.c"
static void snd_usbmidi_out_endpoint_delete(struct snd_usb_midi_out_endpoint *ep ) 
{ 


  {
  record_function("snd_usbmidi_out_endpoint_delete");
//#line  15551
  if (ep->urb) {
    {
//#line  15553
    usb_buffer_free(((ep->umidi)->chip)->dev, (size_t )ep->max_transfer, (void *)(ep->urb)->transfer_buffer,
                    (ep->urb)->transfer_dma);
//#line  15556
    usb_free_urb((struct urb *)ep->urb);
    }
  }
  {
//#line  15559
  kfree((void const   *)ep);
  }
//#line  15561
  return;
}
}
//#line  15565 "usb-audio.merged.sym.c"
static struct lock_class_key __key___4  ;
//#line  15567 "usb-audio.merged.sym.c"
static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *ep_info ,
                                           struct snd_usb_midi_endpoint *rep ) 
{ 
  struct snd_usb_midi_out_endpoint *ep ;
  int i ;
  unsigned int pipe ;
  void *buffer ;
  void *tmp ;
  struct urb *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  __u16 tmp___3 ;

  {
  record_function("snd_usbmidi_out_endpoint_create");
  {
//#line  15582
  rep->out = (struct snd_usb_midi_out_endpoint *)((void *)0);
//#line  15584
  tmp = kzalloc(sizeof(*ep), 208U);
//#line  15586
  ep = (struct snd_usb_midi_out_endpoint *)tmp;
  }
//#line  15588
  if (! ep) {
//#line  15590
    return (-12);
  }
  {
//#line  15593
  ep->umidi = (struct snd_usb_midi *)umidi;
//#line  15595
  tmp___0 = usb_alloc_urb(0, 208U);
//#line  15597
  ep->urb = (struct urb *)tmp___0;
  }
//#line  15599
  if (! ep->urb) {
    {
//#line  15601
    snd_usbmidi_out_endpoint_delete(ep);
    }
//#line  15603
    return (-12);
  }
//#line  15606
  if (ep_info->out_interval) {
    {
//#line  15608
    tmp___1 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->out_ep);
//#line  15610
    pipe = (unsigned int )(1 << 30) | tmp___1;
    }
  } else {
    {
//#line  15613
    tmp___2 = __create_pipe((umidi->chip)->dev, (unsigned int )ep_info->out_ep);
//#line  15615
    pipe = (unsigned int )(3 << 30) | tmp___2;
    }
  }
//#line  15618
  if ((umidi->chip)->usb_id == (u32 )((2706 << 16) | 4128)) {
//#line  15620
    ep->max_transfer = 4;
  } else {
    {
//#line  15623
    tmp___3 = usb_maxpacket((umidi->chip)->dev, (int )pipe, 1);
//#line  15625
    ep->max_transfer = (int )tmp___3;
    }
  }
  {
//#line  15628
  buffer = usb_buffer_alloc((umidi->chip)->dev, (size_t )ep->max_transfer, 208U, & (ep->urb)->transfer_dma);
  }
//#line  15630
  if (! buffer) {
    {
//#line  15632
    snd_usbmidi_out_endpoint_delete(ep);
    }
//#line  15634
    return (-12);
  }
//#line  15637
  if (ep_info->out_interval) {
    {
//#line  15639
    usb_fill_int_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, ep->max_transfer,
                     & snd_usbmidi_out_urb_complete, (void *)ep, (int )ep_info->out_interval);
    }
  } else {
    {
//#line  15643
    usb_fill_bulk_urb((struct urb *)ep->urb, (umidi->chip)->dev, pipe, buffer, ep->max_transfer,
                      & snd_usbmidi_out_urb_complete, (void *)ep);
    }
  }
//#line  15647
  (ep->urb)->transfer_flags = 4U;
  {
  {
//#line  15649
  while (1) {


    {
//#line  15651
    __spin_lock_init(& ep->buffer_lock, str_174936368, & __key___4);
    }
//#line  15653
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  15656
  tasklet_init(& ep->tasklet, (void (*)(unsigned long  ))(& snd_usbmidi_out_tasklet),
               (unsigned long )ep);
//#line  15659
  i = 0;
  }
  {
  {
//#line  15661
  while (1) {


    if (! (i < 16)) {
//#line  15661
      goto while_break___0;
    }
//#line  15663
    if ((int )ep_info->out_cables & (1 << i)) {
//#line  15665
      ep->ports[i].ep = ep;
//#line  15667
      ep->ports[i].cable = (uint8_t )(i << 4);
    }
//#line  15670
    i ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  15673
  if ((umidi->usb_protocol_ops)->init_out_endpoint) {
    {
//#line  15675
    (*((umidi->usb_protocol_ops)->init_out_endpoint))(ep);
    }
  }
//#line  15678
  rep->out = ep;
//#line  15680
  return (0);
}
}
//#line  15684 "usb-audio.merged.sym.c"
static void snd_usbmidi_free(struct snd_usb_midi *umidi ) 
{ 
  int i ;
  struct snd_usb_midi_endpoint *ep ;

  {
  record_function("snd_usbmidi_free");
//#line  15691
  i = 0;
  {
  {
//#line  15693
  while (1) {


    if (! (i < 2)) {
//#line  15693
      goto while_break;
    }
//#line  15695
    ep = & umidi->endpoints[i];
//#line  15697
    if (ep->out) {
      {
//#line  15699
      snd_usbmidi_out_endpoint_delete(ep->out);
      }
    }
//#line  15702
    if (ep->in) {
      {
//#line  15704
      snd_usbmidi_in_endpoint_delete(ep->in);
      }
    }
//#line  15707
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  15710
  kfree((void const   *)umidi);
  }
//#line  15712
  return;
}
}
//#line  15716 "usb-audio.merged.sym.c"
static void snd_usbmidi_disconnect(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const  *__mptr ;
  struct snd_usb_midi_endpoint *ep ;

  {
  record_function("snd_usbmidi_disconnect");
  {
//#line  15725
  __mptr = (struct list_head  const  *)p;
//#line  15727
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  15729
  _spin_lock_irq(& umidi->disc_lock);
//#line  15731
  umidi->disconnected = (unsigned char)1;
//#line  15733
  _spin_unlock_irq(& umidi->disc_lock);
//#line  15735
  i = 0;
  }
  {
  {
//#line  15737
  while (1) {


    if (! (i < 2)) {
//#line  15737
      goto while_break;
    }
//#line  15739
    ep = & umidi->endpoints[i];
//#line  15741
    if (ep->out) {
      {
//#line  15743
      tasklet_kill(& (ep->out)->tasklet);
      }
    }
//#line  15746
    if (ep->out) {
//#line  15748
      if ((ep->out)->urb) {
        {
//#line  15750
        usb_kill_urb((struct urb *)(ep->out)->urb);
        }
//#line  15752
        if ((umidi->usb_protocol_ops)->finish_out_endpoint) {
          {
//#line  15754
          (*((umidi->usb_protocol_ops)->finish_out_endpoint))(ep->out);
          }
        }
      }
    }
//#line  15759
    if (ep->in) {
      {
//#line  15761
      usb_kill_urb((struct urb *)(ep->in)->urb);
      }
    }
//#line  15764
    if (ep->out) {
      {
//#line  15766
      snd_usbmidi_out_endpoint_delete(ep->out);
//#line  15768
      ep->out = (struct snd_usb_midi_out_endpoint *)((void *)0);
      }
    }
//#line  15771
    if (ep->in) {
      {
//#line  15773
      snd_usbmidi_in_endpoint_delete(ep->in);
//#line  15775
      ep->in = (struct snd_usb_midi_in_endpoint *)((void *)0);
      }
    }
//#line  15778
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  15781
  del_timer_sync(& umidi->error_timer);
  }
//#line  15783
  return;
}
}
//#line  15787 "usb-audio.merged.sym.c"
static void snd_usbmidi_rawmidi_free(struct snd_rawmidi *rmidi ) 
{ 
  struct snd_usb_midi *umidi ;

  {
  record_function("snd_usbmidi_rawmidi_free");
  {
//#line  15793
  umidi = (struct snd_usb_midi *)rmidi->private_data;
//#line  15795
  snd_usbmidi_free(umidi);
  }
//#line  15797
  return;
}
}
//#line  15801 "usb-audio.merged.sym.c"
static struct snd_rawmidi_substream *snd_usbmidi_find_substream(struct snd_usb_midi *umidi ,
                                                                int stream , int number ) 
{ 
  struct list_head *list ;
  struct snd_rawmidi_substream *substream ;
  struct list_head  const __attribute__((__noderef__)) *__mptr ;

  {
  record_function("snd_usbmidi_find_substream");
//#line  15810
  list = (struct list_head *)(umidi->rmidi)->streams[stream].substreams.next;
  {
  {
//#line  15812
  while (1) {


    {
//#line  15814
    __builtin_prefetch((void const   *)list->next);
    }
//#line  15816
    if (! ((unsigned long )list != (unsigned long )(& (umidi->rmidi)->streams[stream].substreams))) {
//#line  15818
      goto while_break;
    }
//#line  15821
    __mptr = (struct list_head  const __attribute__((__noderef__)) *)list;
//#line  15823
    substream = (struct snd_rawmidi_substream *)((char *)__mptr - (unsigned int )(& ((struct snd_rawmidi_substream *)0)->list));
//#line  15825
    if (substream->number == number) {
//#line  15827
      return (substream);
    }
//#line  15830
    list = (struct list_head *)list->next;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15833
  return ((struct snd_rawmidi_substream *)((void *)0));
}
}
static struct port_info snd_usbmidi_port_info[57]  = 
//#line  15837
  {      {(u32 )(1410 << 16), (short)2, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 3),
      (short)0, (short)128, (char const   *)str_612180258, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)1, (short)128, (char const   *)str_612180259, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)2, (short)128, (char const   *)str_612180260, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)3, (short)128, (char const   *)str_612180261, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 3),
      (short)4, (short)0, (char const   *)str_601293204, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 3),
      (short)5, (short)0, (char const   *)str_601293205, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 4),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 4),
      (short)1, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 7),
      (short)0, (short)64, (char const   *)str_612180258, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 7),
      (short)1, (short)64, (char const   *)str_612180259, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 7),
      (short)2, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 11),
      (short)0, (short)64, (char const   *)str_612180258, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 11),
      (short)1, (short)64, (char const   *)str_612180259, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 11),
      (short)2, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 12),
      (short)0, (short)64, (char const   *)str_612180258, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 12),
      (short)1, (short)64, (char const   *)str_612180259, (unsigned int )((((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 12),
      (short)2, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 20),
      (short)8, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 22),
      (short)0, (short)128, (char const   *)str_612180258, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 22),
      (short)1, (short)128, (char const   *)str_612180259, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 22),
      (short)2, (short)0, (char const   *)str_601293204, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 22),
      (short)3, (short)0, (char const   *)str_601293205, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 35),
      (short)5, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 39),
      (short)0, (short)64, (char const   *)str_612180258, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 39),
      (short)1, (short)64, (char const   *)str_612180259, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 39),
      (short)2, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 41),
      (short)0, (short)128, (char const   *)str_612180258, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 41),
      (short)1, (short)128, (char const   *)str_612180259, (unsigned int )(((((((1 << 1) | (1 << 2)) | (1 << 6)) | (1 << 3)) | (1 << 4)) | (1 << 16)) | (1 << 18))}, 
        {(u32 )((1410 << 16) | 41),
      (short)2, (short)0, (char const   *)str_601293204, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 41),
      (short)3, (short)0, (char const   *)str_601293205, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 43),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 43),
      (short)1, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 47),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 47),
      (short)1, (short)0, (char const   *)str_93429168, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 47),
      (short)2, (short)0, (char const   *)str_956492597, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51),
      (short)1, (short)0, (char const   *)str_295955, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 51),
      (short)2, (short)0, (char const   *)str_295956, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 59),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 59),
      (short)1, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 68),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 68),
      (short)1, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1410 << 16) | 72),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 72),
      (short)1, (short)0, (char const   *)str_295955, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 72),
      (short)2, (short)0, (char const   *)str_295956, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77),
      (short)0, (short)0, (char const   *)str_956433291, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77),
      (short)1, (short)0, (char const   *)str_295955, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 77),
      (short)2, (short)0, (char const   *)str_295956, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((1410 << 16) | 154),
      (short)3, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1891 << 16) | 4145),
      (short)8, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((1891 << 16) | 4147),
      (short)8, (short)0, (char const   *)str_316584895, (unsigned int )((1 << 1) | (1 << 16))}, 
        {(u32 )((2045 << 16) | 1),
      (short)0, (short)0, (char const   *)str_601293220, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2045 << 16) | 1),
      (short)1, (short)0, (char const   *)str_601293221, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 1),
      (short)8, (short)0, (char const   *)str_125301167, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 2),
      (short)8, (short)0, (char const   *)str_125301167, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}, 
        {(u32 )((2154 << 16) | 3),
      (short)4, (short)0, (char const   *)str_125301167, (unsigned int )(((1 << 1) | (1 << 16)) | (1 << 19))}};
//#line  15970 "usb-audio.merged.sym.c"
static struct port_info *find_port_info(struct snd_usb_midi *umidi , int number ) 
{ 
  int i ;

  {
  record_function("find_port_info");
//#line  15976
  i = 0;
  {
  {
//#line  15978
  while (1) {


    if (! ((unsigned long )i < sizeof(snd_usbmidi_port_info) / sizeof(snd_usbmidi_port_info[0]) + (sizeof(char [1]) - 1UL))) {
//#line  15978
      goto while_break;
    }
//#line  15980
    if (snd_usbmidi_port_info[i].id == (umidi->chip)->usb_id) {
//#line  15982
      if ((int )snd_usbmidi_port_info[i].port == number) {
//#line  15984
        return (& snd_usbmidi_port_info[i]);
      }
    }
//#line  15988
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  15991
  return ((struct port_info *)((void *)0));
}
}
//#line  15995 "usb-audio.merged.sym.c"
static void snd_usbmidi_get_port_info(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *seq_port_info ) 
{ 
  struct snd_usb_midi *umidi ;
  struct port_info *port_info ;

  {
  record_function("snd_usbmidi_get_port_info");
  {
//#line  16002
  umidi = (struct snd_usb_midi *)rmidi->private_data;
//#line  16004
  port_info = find_port_info(umidi, number);
  }
//#line  16006
  if (port_info) {
//#line  16008
    seq_port_info->type = port_info->seq_flags;
//#line  16010
    seq_port_info->midi_voices = (int )port_info->voices;
  }
//#line  16013
  return;
}
}
//#line  16017 "usb-audio.merged.sym.c"
static void snd_usbmidi_init_substream(struct snd_usb_midi *umidi , int stream , int number ,
                                       struct snd_rawmidi_substream **rsubstream ) 
{ 
  struct port_info *port_info ;
  char const   *name_format ;
  struct snd_rawmidi_substream *substream ;
  struct snd_rawmidi_substream *tmp ;

  {
  record_function("snd_usbmidi_init_substream");
  {
//#line  16027
  tmp = snd_usbmidi_find_substream(umidi, stream, number);
//#line  16029
  substream = tmp;
  }
//#line  16031
  if (! substream) {
    {
    {
//#line  16033
    while (1) {


//#line  16035
      goto while_break;
    }

    }
    while_break: /* CIL Label */ ;
    }
//#line  16038
    return;
  }
  {
//#line  16041
  port_info = find_port_info(umidi, number);
  }
//#line  16043
  if (port_info) {
//#line  16045
    name_format = port_info->name;
  } else {
//#line  16048
    name_format = (char const   *)str_687152508;
  }
  {
//#line  16051
  sprintf(substream->name, (char const   *)name_format, ((umidi->chip)->card)->shortname,
          number + 1);
//#line  16054
  *rsubstream = substream;
  }
//#line  16056
  return;
}
}
//#line  16060 "usb-audio.merged.sym.c"
static int snd_usbmidi_create_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  int i ;
  int j ;
  int err ;
  int out_ports ;
  int in_ports ;

  {
  record_function("snd_usbmidi_create_endpoints");
//#line  16070
  out_ports = 0;
//#line  16072
  in_ports = 0;
//#line  16074
  i = 0;
  {
  {
//#line  16076
  while (1) {


    if (! (i < 2)) {
//#line  16076
      goto while_break;
    }
//#line  16078
    if ((endpoints + i)->out_cables) {
      {
//#line  16080
      err = snd_usbmidi_out_endpoint_create(umidi, endpoints + i, & umidi->endpoints[i]);
      }
//#line  16082
      if (err < 0) {
//#line  16084
        return (err);
      }
    }
//#line  16088
    if ((endpoints + i)->in_cables) {
      {
//#line  16090
      err = snd_usbmidi_in_endpoint_create(umidi, endpoints + i, & umidi->endpoints[i]);
      }
//#line  16092
      if (err < 0) {
//#line  16094
        return (err);
      }
    }
//#line  16098
    j = 0;
    {
    {
//#line  16100
    while (1) {


      if (! (j < 16)) {
//#line  16100
        goto while_break___0;
      }
//#line  16102
      if ((int )(endpoints + i)->out_cables & (1 << j)) {
        {
//#line  16104
        snd_usbmidi_init_substream(umidi, 0, out_ports, (struct snd_rawmidi_substream **)(& (umidi->endpoints[i].out)->ports[j].substream));
//#line  16106
        out_ports ++;
        }
      }
//#line  16109
      if ((int )(endpoints + i)->in_cables & (1 << j)) {
        {
//#line  16111
        snd_usbmidi_init_substream(umidi, 1, in_ports, & (umidi->endpoints[i].in)->ports[j].substream);
//#line  16113
        in_ports ++;
        }
      }
//#line  16116
      j ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  16119
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  16122
  printk(str_544751132, out_ports, in_ports);
  }
//#line  16124
  return (0);
}
}
//#line  16128 "usb-audio.merged.sym.c"
static int snd_usbmidi_get_ms_info(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_ms_header_descriptor *ms_header ;
  struct usb_host_endpoint *hostep ;
  struct usb_endpoint_descriptor *ep ;
  struct usb_ms_endpoint_descriptor *ms_ep ;
  int i ;
  int epidx ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  record_function("snd_usbmidi_get_ms_info");
//#line  16149
  intf = umidi->iface;
//#line  16151
  if (! intf) {
//#line  16153
    return (-6);
  }
//#line  16156
  hostif = intf->altsetting + 0;
//#line  16158
  intfd = & hostif->desc;
//#line  16160
  ms_header = (struct usb_ms_header_descriptor *)hostif->extra;
//#line  16162
  if (hostif->extralen >= 7) {
//#line  16164
    if ((int )ms_header->bLength >= 7) {
//#line  16166
      if ((int )ms_header->bDescriptorType == ((1 << 5) | 4)) {
//#line  16168
        if ((int )ms_header->bDescriptorSubtype == 1) {
          {
//#line  16170
          printk(str_752941123, (int )ms_header->bcdMSC[1], (int )ms_header->bcdMSC[0]);
          }
        } else {
          {
//#line  16174
          printk(str_791573890);
          }
        }
      } else {
        {
//#line  16178
        printk(str_791573890);
        }
      }
    } else {
      {
//#line  16182
      printk(str_791573890);
      }
    }
  } else {
    {
//#line  16186
    printk(str_791573890);
    }
  }
//#line  16189
  epidx = 0;
//#line  16191
  i = 0;
  {
  {
//#line  16193
  while (1) {


    if (! (i < (int )intfd->bNumEndpoints)) {
//#line  16193
      goto while_break;
    }
    {
//#line  16195
    hostep = (struct usb_host_endpoint *)(hostif->endpoint + i);
//#line  16197
    ep = & hostep->desc;
//#line  16199
    tmp = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)ep);
    }
//#line  16201
    if (! tmp) {
      {
//#line  16203
      tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
      }
//#line  16205
      if (! tmp___0) {
//#line  16207
        goto __Cont;
      }
    }
//#line  16211
    ms_ep = (struct usb_ms_endpoint_descriptor *)hostep->extra;
//#line  16213
    if (hostep->extralen < 4) {
//#line  16215
      goto __Cont;
    } else
//#line  16218
    if ((int )ms_ep->bLength < 4) {
//#line  16220
      goto __Cont;
    } else
//#line  16223
    if ((int )ms_ep->bDescriptorType != ((1 << 5) | 5)) {
//#line  16225
      goto __Cont;
    } else
//#line  16228
    if ((int )ms_ep->bDescriptorSubtype != 1) {
//#line  16230
      goto __Cont;
    }
    {
//#line  16233
    tmp___5 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)ep);
    }
//#line  16235
    if (tmp___5) {
//#line  16237
      if ((endpoints + epidx)->out_ep) {
//#line  16239
        epidx ++;
//#line  16241
        if (epidx >= 2) {
          {
//#line  16243
          printk(str_754636363);
          }
//#line  16245
          goto while_break;
        }
      }
      {
//#line  16249
      tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  16251
      (endpoints + epidx)->out_ep = (int8_t )tmp___1;
//#line  16253
      tmp___2 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
      }
//#line  16255
      if (tmp___2) {
//#line  16257
        (endpoints + epidx)->out_interval = ep->bInterval;
      } else
//#line  16260
      if ((unsigned int )((umidi->chip)->dev)->speed == 1U) {
//#line  16262
        (endpoints + epidx)->out_interval = (uint8_t )1;
      }
      {
//#line  16265
      (endpoints + epidx)->out_cables = (uint16_t )((1 << (int )ms_ep->bNumEmbMIDIJack) - 1);
//#line  16267
      printk(str_994182456, (int )ep->bEndpointAddress, (int )ms_ep->bNumEmbMIDIJack);
      }
    } else {
//#line  16270
      if ((endpoints + epidx)->in_ep) {
//#line  16272
        epidx ++;
//#line  16274
        if (epidx >= 2) {
          {
//#line  16276
          printk(str_754636363);
          }
//#line  16278
          goto while_break;
        }
      }
      {
//#line  16282
      tmp___3 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  16284
      (endpoints + epidx)->in_ep = (int8_t )tmp___3;
//#line  16286
      tmp___4 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
      }
//#line  16288
      if (tmp___4) {
//#line  16290
        (endpoints + epidx)->in_interval = ep->bInterval;
      } else
//#line  16293
      if ((unsigned int )((umidi->chip)->dev)->speed == 1U) {
//#line  16295
        (endpoints + epidx)->in_interval = (uint8_t )1;
      }
      {
//#line  16298
      (endpoints + epidx)->in_cables = (uint16_t )((1 << (int )ms_ep->bNumEmbMIDIJack) - 1);
//#line  16300
      printk(str_994182456, (int )ep->bEndpointAddress, (int )ms_ep->bNumEmbMIDIJack);
      }
    }
    __Cont: 
//#line  16304
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16307
  return (0);
}
}
//#line  16311 "usb-audio.merged.sym.c"
static void snd_usbmidi_switch_roland_altsetting(struct snd_usb_midi *umidi ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;

  {
  record_function("snd_usbmidi_switch_roland_altsetting");
//#line  16319
  intf = umidi->iface;
//#line  16321
  if (! intf) {
//#line  16323
    return;
  } else
//#line  16326
  if (intf->num_altsetting != 2U) {
//#line  16328
    return;
  }
//#line  16331
  hostif = intf->altsetting + 1;
//#line  16333
  intfd = & hostif->desc;
//#line  16335
  if ((int )intfd->bNumEndpoints != 2) {
//#line  16337
    return;
  } else
//#line  16340
  if (((int )(hostif->endpoint + 0)->desc.bmAttributes & 3) != 2) {
//#line  16342
    return;
  } else
//#line  16345
  if (((int )(hostif->endpoint + 1)->desc.bmAttributes & 3) != 3) {
//#line  16347
    return;
  }
  {
//#line  16350
  printk(str_974050335, (int )intfd->bAlternateSetting);
//#line  16352
  usb_set_interface((umidi->chip)->dev, (int )intfd->bInterfaceNumber, (int )intfd->bAlternateSetting);
  }
//#line  16354
  return;
}
}
//#line  16358 "usb-audio.merged.sym.c"
static int snd_usbmidi_detect_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ,
                                        int max_endpoints ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_endpoint_descriptor *epd ;
  int i ;
  int out_eps ;
  int in_eps ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  record_function("snd_usbmidi_detect_endpoints");
//#line  16380
  out_eps = 0;
//#line  16382
  in_eps = 0;
//#line  16384
  if ((umidi->chip)->usb_id >> 16 == 1410U) {
    {
//#line  16386
    snd_usbmidi_switch_roland_altsetting(umidi);
    }
  }
//#line  16389
  if ((endpoint + 0)->out_ep) {
//#line  16391
    return (0);
  } else
//#line  16394
  if ((endpoint + 0)->in_ep) {
//#line  16396
    return (0);
  }
//#line  16399
  intf = umidi->iface;
//#line  16401
  if (! intf) {
//#line  16403
    return (-2);
  } else
//#line  16406
  if (intf->num_altsetting < 1U) {
//#line  16408
    return (-2);
  }
//#line  16411
  hostif = intf->cur_altsetting;
//#line  16413
  intfd = & hostif->desc;
//#line  16415
  i = 0;
  {
  {
//#line  16417
  while (1) {


    if (! (i < (int )intfd->bNumEndpoints)) {
//#line  16417
      goto while_break;
    }
    {
//#line  16419
    epd = & (hostif->endpoint + i)->desc;
//#line  16421
    tmp = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
    }
//#line  16423
    if (! tmp) {
      {
//#line  16425
      tmp___0 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
      }
//#line  16427
      if (! tmp___0) {
//#line  16429
        goto __Cont;
      }
    }
//#line  16433
    if (out_eps < max_endpoints) {
      {
//#line  16435
      tmp___3 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
      }
//#line  16437
      if (tmp___3) {
        {
//#line  16439
        tmp___1 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)epd);
//#line  16441
        (endpoint + out_eps)->out_ep = (int8_t )tmp___1;
//#line  16443
        tmp___2 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
        }
//#line  16445
        if (tmp___2) {
//#line  16447
          (endpoint + out_eps)->out_interval = epd->bInterval;
        }
//#line  16450
        out_eps ++;
      }
    }
//#line  16454
    if (in_eps < max_endpoints) {
      {
//#line  16456
      tmp___6 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)epd);
      }
//#line  16458
      if (tmp___6) {
        {
//#line  16460
        tmp___4 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)epd);
//#line  16462
        (endpoint + in_eps)->in_ep = (int8_t )tmp___4;
//#line  16464
        tmp___5 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
        }
//#line  16466
        if (tmp___5) {
//#line  16468
          (endpoint + in_eps)->in_interval = epd->bInterval;
        }
//#line  16471
        in_eps ++;
      }
    }
    __Cont: 
//#line  16476
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16479
  if (out_eps) {
//#line  16481
    tmp___7 = 0;
  } else
//#line  16484
  if (in_eps) {
//#line  16486
    tmp___7 = 0;
  } else {
//#line  16489
    tmp___7 = -2;
  }
//#line  16492
  return (tmp___7);
}
}
//#line  16496 "usb-audio.merged.sym.c"
static int snd_usbmidi_detect_per_port_endpoints(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoints ) 
{ 
  int err ;
  int i ;

  {
  record_function("snd_usbmidi_detect_per_port_endpoints");
  {
//#line  16503
  err = snd_usbmidi_detect_endpoints(umidi, endpoints, 2);
//#line  16505
  i = 0;
  }
  {
  {
//#line  16507
  while (1) {


    if (! (i < 2)) {
//#line  16507
      goto while_break;
    }
//#line  16509
    if ((endpoints + i)->out_ep) {
//#line  16511
      (endpoints + i)->out_cables = (uint16_t )1;
    }
//#line  16514
    if ((endpoints + i)->in_ep) {
//#line  16516
      (endpoints + i)->in_cables = (uint16_t )1;
    }
//#line  16519
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16522
  return (err);
}
}
//#line  16526 "usb-audio.merged.sym.c"
static int snd_usbmidi_detect_yamaha(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ) 
{ 
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  uint8_t *cs_desc ;
  int tmp ;

  {
  record_function("snd_usbmidi_detect_yamaha");
//#line  16536
  intf = umidi->iface;
//#line  16538
  if (! intf) {
//#line  16540
    return (-2);
  }
//#line  16543
  hostif = intf->altsetting;
//#line  16545
  intfd = & hostif->desc;
//#line  16547
  if ((int )intfd->bNumEndpoints < 1) {
//#line  16549
    return (-2);
  }
//#line  16552
  cs_desc = (uint8_t *)hostif->extra;
  {
  {
//#line  16554
  while (1) {


//#line  16556
    if ((unsigned long )cs_desc < (unsigned long )(hostif->extra + hostif->extralen)) {
//#line  16558
      if (! ((int )*(cs_desc + 0) >= 2)) {
//#line  16560
        goto while_break;
      }
    } else {
//#line  16564
      goto while_break;
    }
//#line  16567
    if ((int )*(cs_desc + 1) == ((1 << 5) | 4)) {
//#line  16569
      if ((int )*(cs_desc + 2) == 2) {
//#line  16571
        endpoint->in_cables = (uint16_t )(((int )endpoint->in_cables << 1) | 1);
      } else
//#line  16574
      if ((int )*(cs_desc + 2) == 3) {
//#line  16576
        endpoint->out_cables = (uint16_t )(((int )endpoint->out_cables << 1) | 1);
      }
    }
//#line  16580
    cs_desc += (int )*(cs_desc + 0);
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16583
  if (! endpoint->in_cables) {
//#line  16585
    if (! endpoint->out_cables) {
//#line  16587
      return (-2);
    }
  }
  {
//#line  16591
  tmp = snd_usbmidi_detect_endpoints(umidi, endpoint, 1);
  }
//#line  16593
  return (tmp);
}
}
//#line  16597 "usb-audio.merged.sym.c"
static int snd_usbmidi_create_endpoints_midiman(struct snd_usb_midi *umidi , struct snd_usb_midi_endpoint_info *endpoint ) 
{ 
  struct snd_usb_midi_endpoint_info ep_info ;
  struct usb_interface *intf ;
  struct usb_host_interface *hostif ;
  struct usb_interface_descriptor *intfd ;
  struct usb_endpoint_descriptor *epd ;
  int cable ;
  int err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  record_function("snd_usbmidi_create_endpoints_midiman");
//#line  16616
  intf = umidi->iface;
//#line  16618
  if (! intf) {
//#line  16620
    return (-2);
  }
//#line  16623
  hostif = intf->altsetting;
//#line  16625
  intfd = & hostif->desc;
//#line  16627
  if ((int )endpoint->out_cables > 1) {
//#line  16629
    tmp = 5;
  } else {
//#line  16632
    tmp = 3;
  }
//#line  16635
  if ((int )intfd->bNumEndpoints < tmp) {
    {
//#line  16637
    printk(str_872419140);
    }
//#line  16639
    return (-2);
  }
  {
//#line  16642
  epd = & (hostif->endpoint + 0)->desc;
//#line  16644
  tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)epd);
  }
//#line  16646
  if (tmp___0) {
    {
//#line  16648
    tmp___1 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)epd);
    }
//#line  16650
    if (! tmp___1) {
      {
//#line  16652
      printk(str_349765498);
      }
//#line  16654
      return (-6);
    }
  } else {
    {
//#line  16658
    printk(str_349765498);
    }
//#line  16660
    return (-6);
  }
  {
//#line  16663
  epd = & (hostif->endpoint + 2)->desc;
//#line  16665
  tmp___2 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
  }
//#line  16667
  if (tmp___2) {
    {
//#line  16669
    tmp___3 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
    }
//#line  16671
    if (! tmp___3) {
      {
//#line  16673
      printk(str_1060371900);
      }
//#line  16675
      return (-6);
    }
  } else {
    {
//#line  16679
    printk(str_1060371900);
    }
//#line  16681
    return (-6);
  }
//#line  16684
  if ((int )endpoint->out_cables > 1) {
    {
//#line  16686
    epd = & (hostif->endpoint + 4)->desc;
//#line  16688
    tmp___4 = usb_endpoint_dir_out((struct usb_endpoint_descriptor  const  *)epd);
    }
//#line  16690
    if (tmp___4) {
      {
//#line  16692
      tmp___5 = usb_endpoint_xfer_bulk((struct usb_endpoint_descriptor  const  *)epd);
      }
//#line  16694
      if (! tmp___5) {
        {
//#line  16696
        printk(str_145470558);
        }
//#line  16698
        return (-6);
      }
    } else {
      {
//#line  16702
      printk(str_145470558);
      }
//#line  16704
      return (-6);
    }
  }
  {
//#line  16708
  ep_info.out_ep = (int8_t )((int )(hostif->endpoint + 2)->desc.bEndpointAddress & 15);
//#line  16710
  ep_info.out_interval = (uint8_t )0;
//#line  16712
  ep_info.out_cables = (uint16_t )((int )endpoint->out_cables & 21845);
//#line  16714
  err = snd_usbmidi_out_endpoint_create(umidi, & ep_info, & umidi->endpoints[0]);
  }
//#line  16716
  if (err < 0) {
//#line  16718
    return (err);
  }
  {
//#line  16721
  ep_info.in_ep = (int8_t )((int )(hostif->endpoint + 0)->desc.bEndpointAddress & 15);
//#line  16723
  ep_info.in_interval = (hostif->endpoint + 0)->desc.bInterval;
//#line  16725
  ep_info.in_cables = endpoint->in_cables;
//#line  16727
  err = snd_usbmidi_in_endpoint_create(umidi, & ep_info, & umidi->endpoints[0]);
  }
//#line  16729
  if (err < 0) {
//#line  16731
    return (err);
  }
//#line  16734
  if ((int )endpoint->out_cables > 1) {
    {
//#line  16736
    ep_info.out_ep = (int8_t )((int )(hostif->endpoint + 4)->desc.bEndpointAddress & 15);
//#line  16738
    ep_info.out_cables = (uint16_t )((int )endpoint->out_cables & 43690);
//#line  16740
    err = snd_usbmidi_out_endpoint_create(umidi, & ep_info, & umidi->endpoints[1]);
    }
//#line  16742
    if (err < 0) {
//#line  16744
      return (err);
    }
  }
//#line  16748
  cable = 0;
  {
  {
//#line  16750
  while (1) {


    if (! (cable < 16)) {
//#line  16750
      goto while_break;
    }
//#line  16752
    if ((int )endpoint->out_cables & (1 << cable)) {
      {
//#line  16754
      snd_usbmidi_init_substream(umidi, 0, cable, (struct snd_rawmidi_substream **)(& (umidi->endpoints[cable & 1].out)->ports[cable].substream));
      }
    }
//#line  16757
    if ((int )endpoint->in_cables & (1 << cable)) {
      {
//#line  16759
      snd_usbmidi_init_substream(umidi, 1, cable, & (umidi->endpoints[0].in)->ports[cable].substream);
      }
    }
//#line  16762
    cable ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16765
  return (0);
}
}
//#line  16769 "usb-audio.merged.sym.c"
static struct snd_rawmidi_global_ops snd_usbmidi_ops  =    {(int (*)(struct snd_rawmidi *rmidi ))0, (int (*)(struct snd_rawmidi *rmidi ))0,
    & snd_usbmidi_get_port_info};
//#line  16772 "usb-audio.merged.sym.c"
static int snd_usbmidi_create_rawmidi(struct snd_usb_midi *umidi , int out_ports ,
                                      int in_ports ) 
{ 
  struct snd_rawmidi *rmidi ;
  int err ;
  int tmp ;

  {
  record_function("snd_usbmidi_create_rawmidi");
  {
//#line  16781
  rmidi = (struct snd_rawmidi *)((void *)0);
//#line  16783
  tmp = (umidi->chip)->next_midi_device;
//#line  16785
  ((umidi->chip)->next_midi_device) ++;
//#line  16787
  err = snd_rawmidi_new((umidi->chip)->card, (char *)str_595159629, tmp, out_ports,
                        in_ports, & rmidi);
  }
//#line  16790
  if (err < 0) {
//#line  16792
    return (err);
  }
  {
//#line  16795
  strcpy(rmidi->name, (char const   *)(((umidi->chip)->card)->shortname));
//#line  16797
  rmidi->info_flags = 7U;
//#line  16799
  rmidi->ops = & snd_usbmidi_ops;
//#line  16801
  rmidi->private_data = (void * __attribute__((__noderef__)) )umidi;
//#line  16803
  rmidi->private_free = & snd_usbmidi_rawmidi_free;
//#line  16805
  snd_rawmidi_set_ops(rmidi, 0, & snd_usbmidi_output_ops);
//#line  16807
  snd_rawmidi_set_ops(rmidi, 1, & snd_usbmidi_input_ops);
//#line  16809
  umidi->rmidi = (struct snd_rawmidi *)rmidi;
  }
//#line  16811
  return (0);
}
}
//#line  16815 "usb-audio.merged.sym.c"
void snd_usbmidi_input_stop(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const  *__mptr ;
  struct snd_usb_midi_endpoint *ep ;

  {
  record_function("snd_usbmidi_input_stop");
//#line  16824
  __mptr = (struct list_head  const  *)p;
//#line  16826
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  16828
  i = 0;
  {
  {
//#line  16830
  while (1) {


    if (! (i < 2)) {
//#line  16830
      goto while_break;
    }
//#line  16832
    ep = & umidi->endpoints[i];
//#line  16834
    if (ep->in) {
      {
//#line  16836
      usb_kill_urb((struct urb *)(ep->in)->urb);
      }
    }
//#line  16839
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16842
  return;
}
}
//#line  16846 "usb-audio.merged.sym.c"
static void snd_usbmidi_input_start_ep(struct snd_usb_midi_in_endpoint *ep ) 
{ 
  struct urb *urb ;

  {
  record_function("snd_usbmidi_input_start_ep");
//#line  16852
  if (ep) {
    {
//#line  16854
    urb = usb_alloc_urb(0, 208U);
//#line  16856
    ep->urb = (struct urb *)urb;
//#line  16858
    urb->dev = (struct usb_device *)((ep->umidi)->chip)->dev;
//#line  16860
    snd_usbmidi_submit_urb(urb, 208U);
    }
  }
//#line  16863
  return;
}
}
//#line  16867 "usb-audio.merged.sym.c"
void snd_usbmidi_input_start(struct list_head *p ) 
{ 
  struct snd_usb_midi *umidi ;
  int i ;
  struct list_head  const  *__mptr ;

  {
  record_function("snd_usbmidi_input_start");
//#line  16875
  __mptr = (struct list_head  const  *)p;
//#line  16877
  umidi = (struct snd_usb_midi *)((char *)__mptr - (unsigned int )(& ((struct snd_usb_midi *)0)->list));
//#line  16879
  i = 0;
  {
  {
//#line  16881
  while (1) {


    if (! (i < 2)) {
//#line  16881
      goto while_break;
    }
    {
//#line  16883
    snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
//#line  16885
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  16888
  return;
}
}
//#line  16892 "usb-audio.merged.sym.c"
static struct lock_class_key __key___6  ;
//#line  16894 "usb-audio.merged.sym.c"
static int snd_usb_create_midi_interface(struct snd_usb_audio *chip , struct usb_interface *iface ,
                                         struct snd_usb_audio_quirk  const  *quirk ) 
{ 
  struct snd_usb_midi *umidi ;
  struct snd_usb_midi_endpoint_info endpoints[2] ;
  int out_ports ;
  int in_ports ;
  int i ;
  int err ;
  void *tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;
  size_t __len___0 ;
  void *__ret___0 ;
  size_t __len___1 ;
  void *__ret___1 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  record_function("snd_usb_create_midi_interface");
  {
//#line  16916
  tmp = kzalloc(sizeof(*umidi), 208U);
//#line  16918
  umidi = (struct snd_usb_midi *)tmp;
  }
//#line  16920
  if (! umidi) {
//#line  16922
    return (-12);
  }
  {
//#line  16925
  umidi->chip = chip;
//#line  16927
  umidi->iface = iface;
//#line  16929
  umidi->quirk = quirk;
//#line  16931
  umidi->usb_protocol_ops = & snd_usbmidi_standard_ops;
//#line  16933
  init_timer(& umidi->error_timer);
  }
  {
  {
//#line  16935
  while (1) {


    {
//#line  16937
    __spin_lock_init(& umidi->disc_lock, str_427276364, & __key___6);
    }
//#line  16939
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  16942
  umidi->error_timer.function = (void (*)(unsigned long  ))(& snd_usbmidi_error_timer);
//#line  16944
  umidi->error_timer.data = (void *)((unsigned long )umidi);
//#line  16946
  memset((void *)(endpoints), 0, sizeof(endpoints));
  }
//#line  16948
  if (quirk) {
//#line  16950
    tmp___0 = (int )((int const   )quirk->type);
  } else {
//#line  16953
    tmp___0 = (int )((int const   )2);
  }
  {
  if (tmp___0 == 2) {
//#line  16957
    goto case_2;
  }
  if (tmp___0 == 10) {
//#line  16967
    goto case_10;
  }
  if (tmp___0 == 3) {
//#line  16970
    goto case_3;
  }
  if (tmp___0 == 4) {
//#line  16986
    goto case_4;
  }
  if (tmp___0 == 5) {
//#line  16991
    goto case_5;
  }
  if (tmp___0 == 6) {
//#line  17009
    goto case_6;
  }
  if (tmp___0 == 7) {
//#line  17016
    goto case_7;
  }
  if (tmp___0 == 8) {
//#line  17023
    goto case_8;
  }
  if (tmp___0 == 9) {
//#line  17041
    goto case_9;
  }
//#line  17048
  goto switch_default;
  case_2: /* CIL Label */ 
  {
//#line  16959
  err = snd_usbmidi_get_ms_info(umidi, endpoints);
  }
//#line  16961
  if (chip->usb_id == (u32 )((1891 << 16) | 336)) {
//#line  16963
    umidi->usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops;
  }
//#line  16966
  goto switch_break;
  case_10: /* CIL Label */ 
//#line  16969
  umidi->usb_protocol_ops = & snd_usbmidi_122l_ops;
  case_3: /* CIL Label */ 
//#line  16972
  __len = sizeof(struct snd_usb_midi_endpoint_info );
//#line  16974
  if (__len >= 64UL) {
    {
//#line  16976
    __ret = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len);
    }
  } else {
    {
//#line  16979
    __ret = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                             __len);
    }
  }
  {
//#line  16983
  err = snd_usbmidi_detect_endpoints(umidi, & endpoints[0], 1);
  }
//#line  16985
  goto switch_break;
  case_4: /* CIL Label */ 
  {
//#line  16988
  err = snd_usbmidi_detect_yamaha(umidi, & endpoints[0]);
  }
//#line  16990
  goto switch_break;
  case_5: /* CIL Label */ 
//#line  16993
  umidi->usb_protocol_ops = & snd_usbmidi_midiman_ops;
//#line  16995
  __len___0 = sizeof(struct snd_usb_midi_endpoint_info );
//#line  16997
  if (__len___0 >= 64UL) {
    {
//#line  16999
    __ret___0 = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len___0);
    }
  } else {
    {
//#line  17002
    __ret___0 = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                                 __len___0);
    }
  }
//#line  17006
  err = 0;
//#line  17008
  goto switch_break;
  case_6: /* CIL Label */ 
  {
//#line  17011
  umidi->usb_protocol_ops = & snd_usbmidi_novation_ops;
//#line  17013
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
  }
//#line  17015
  goto switch_break;
  case_7: /* CIL Label */ 
  {
//#line  17018
  umidi->usb_protocol_ops = & snd_usbmidi_raw_ops;
//#line  17020
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
  }
//#line  17022
  goto switch_break;
  case_8: /* CIL Label */ 
//#line  17025
  umidi->usb_protocol_ops = & snd_usbmidi_emagic_ops;
//#line  17027
  __len___1 = sizeof(struct snd_usb_midi_endpoint_info );
//#line  17029
  if (__len___1 >= 64UL) {
    {
//#line  17031
    __ret___1 = __memcpy((void *)(& endpoints[0]), (void const   *)quirk->data, __len___1);
    }
  } else {
    {
//#line  17034
    __ret___1 = __builtin_memcpy((void *)(& endpoints[0]), (void const   *)quirk->data,
                                 __len___1);
    }
  }
  {
//#line  17038
  err = snd_usbmidi_detect_endpoints(umidi, & endpoints[0], 1);
  }
//#line  17040
  goto switch_break;
  case_9: /* CIL Label */ 
  {
//#line  17043
  umidi->usb_protocol_ops = & snd_usbmidi_cme_ops;
//#line  17045
  err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
  }
//#line  17047
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
//#line  17050
  while (1) {


//#line  17052
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  17055
  err = -6;
//#line  17057
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  17060
  if (err < 0) {
    {
//#line  17062
    kfree((void const   *)umidi);
    }
//#line  17064
    return (err);
  }
//#line  17067
  out_ports = 0;
//#line  17069
  in_ports = 0;
//#line  17071
  i = 0;
  {
  {
//#line  17073
  while (1) {


    if (! (i < 2)) {
//#line  17073
      goto while_break___1;
    }
    {
//#line  17075
    tmp___1 = snd_usbmidi_count_bits((unsigned int )endpoints[i].out_cables);
//#line  17077
    out_ports = (int )((unsigned int )out_ports + tmp___1);
//#line  17079
    tmp___2 = snd_usbmidi_count_bits((unsigned int )endpoints[i].in_cables);
//#line  17081
    in_ports = (int )((unsigned int )in_ports + tmp___2);
//#line  17083
    i ++;
    }
  }

  }
  while_break___1: /* CIL Label */ ;
  }
  {
//#line  17086
  err = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports);
  }
//#line  17088
  if (err < 0) {
    {
//#line  17090
    kfree((void const   *)umidi);
    }
//#line  17092
    return (err);
  }
//#line  17095
  if (quirk) {
//#line  17097
    if ((int const   )quirk->type == 5) {
      {
//#line  17099
      err = snd_usbmidi_create_endpoints_midiman(umidi, & endpoints[0]);
      }
    } else {
      {
//#line  17102
      err = snd_usbmidi_create_endpoints(umidi, endpoints);
      }
    }
  } else {
    {
//#line  17106
    err = snd_usbmidi_create_endpoints(umidi, endpoints);
    }
  }
//#line  17109
  if (err < 0) {
    {
//#line  17111
    snd_usbmidi_free(umidi);
    }
//#line  17113
    return (err);
  }
  {
//#line  17116
  list_add((struct list_head *)(& umidi->list), & (umidi->chip)->midi_list);
//#line  17118
  i = 0;
  }
  {
  {
//#line  17120
  while (1) {


    if (! (i < 2)) {
//#line  17120
      goto while_break___2;
    }
    {
//#line  17122
    snd_usbmidi_input_start_ep(umidi->endpoints[i].in);
//#line  17124
    i ++;
    }
  }

  }
  while_break___2: /* CIL Label */ ;
  }
//#line  17127
  return (0);
}
}
static char const   __kstrtab_snd_usb_create_midi_interface[30]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  17131
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'_', 
        (char const   )'c',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'_',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )'f',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'\000'};
//#line  17143 "usb-audio.merged.sym.c"
static struct kernel_symbol  const  __ksymtab_snd_usb_create_midi_interface  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usb_create_midi_interface), __kstrtab_snd_usb_create_midi_interface};
static char const   __kstrtab_snd_usbmidi_input_stop[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  17146
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )'_',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'p',      (char const   )'\000'};
//#line  17156 "usb-audio.merged.sym.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_input_stop  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_input_stop), __kstrtab_snd_usbmidi_input_stop};
static char const   __kstrtab_snd_usbmidi_input_start[24]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  17159
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'i',      (char const   )'n',      (char const   )'p',      (char const   )'u', 
        (char const   )'t',      (char const   )'_',      (char const   )'s',      (char const   )'t', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )'\000'};
//#line  17169 "usb-audio.merged.sym.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_input_start  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_input_start), __kstrtab_snd_usbmidi_input_start};
static char const   __kstrtab_snd_usbmidi_disconnect[23]  __attribute__((__section__("__ksymtab_strings"),
__aligned__(1)))  = 
//#line  17172
  {      (char const   )'s',      (char const   )'n',      (char const   )'d',      (char const   )'_', 
        (char const   )'u',      (char const   )'s',      (char const   )'b',      (char const   )'m', 
        (char const   )'i',      (char const   )'d',      (char const   )'i',      (char const   )'_', 
        (char const   )'d',      (char const   )'i',      (char const   )'s',      (char const   )'c', 
        (char const   )'o',      (char const   )'n',      (char const   )'n',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'\000'};
//#line  17182 "usb-audio.merged.sym.c"
static struct kernel_symbol  const  __ksymtab_snd_usbmidi_disconnect  __attribute__((__used__,
__unused__, __section__("__ksymtab")))  =    {(unsigned long )(& snd_usbmidi_disconnect), __kstrtab_snd_usbmidi_disconnect};
//#line  17185
#pragma merger(0,"./usbmixer.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  17187
static int _cond_resched(void) ;
//#line  17189
static void __might_sleep(char *file , int line ) ;
//#line  17191 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) might_fault)(void) 
{ 


  {
  record_function("might_fault");
  {
  {
//#line  17197
  while (1) {


    {
//#line  17199
    __might_sleep((char *)str_501945809, 155);
//#line  17201
    _cond_resched();
    }
//#line  17203
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17206
  return;
}
}
//#line  17210
static  __attribute__((__noreturn__)) void __bad_pda_field(void) ;
//#line  17212
struct x8664_pda _proxy_pda ;
//#line  17214 "usb-audio.merged.sym.c"
__inline static struct task_struct *( __attribute__((__always_inline__)) get_current)(void) 
{ 
  struct task_struct *ret__ ;

  {
  record_function("get_current");
  {
  if ((int )sizeof(_proxy_pda.pcurrent) == 2) {
//#line  17221
    goto case_2;
  }
  if ((int )sizeof(_proxy_pda.pcurrent) == 4) {
//#line  17228
    goto case_4;
  }
  if ((int )sizeof(_proxy_pda.pcurrent) == 8) {
//#line  17235
    goto case_8;
  }
//#line  17242
  goto switch_default;
  case_2: /* CIL Label */ 
//#line  17223
  __asm__  ("mov"
            "w %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  17227
  goto switch_break;
  case_4: /* CIL Label */ 
//#line  17230
  __asm__  ("mov"
            "l %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  17234
  goto switch_break;
  case_8: /* CIL Label */ 
//#line  17237
  __asm__  ("mov"
            "q %%gs:%c1,%0": "=r" (ret__): "i" ((unsigned int )(& ((struct x8664_pda *)0)->pcurrent)),
            "m" (_proxy_pda.pcurrent));
//#line  17241
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  17244
  __bad_pda_field();
  }
  switch_break: /* CIL Label */ ;
  }
//#line  17247
  return (ret__);
}
}
//#line  17251 "usb-audio.merged.sym.c"
__inline static unsigned long ( __attribute__((__always_inline__)) __xchg)(unsigned long x ,
                                                                           void volatile   *ptr ,
                                                                           int size ) 
{ 


  {
  record_function("__xchg");
  {
  if (size == 1) {
//#line  17260
    goto case_1;
  }
  if (size == 2) {
//#line  17266
    goto case_2;
  }
  if (size == 4) {
//#line  17272
    goto case_4;
  }
  if (size == 8) {
//#line  17278
    goto case_8;
  }
//#line  17259
  goto switch_break;
  case_1: /* CIL Label */ 
//#line  17262
  __asm__  volatile   ("xchgb %b0,%1": "=q" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  17265
  goto switch_break;
  case_2: /* CIL Label */ 
//#line  17268
  __asm__  volatile   ("xchgw %w0,%1": "=r" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  17271
  goto switch_break;
  case_4: /* CIL Label */ 
//#line  17274
  __asm__  volatile   ("xchgl %k0,%1": "=r" (x): "m" (*((long volatile   *)ptr)),
                       "0" (x): "memory");
//#line  17277
  goto switch_break;
  case_8: /* CIL Label */ 
//#line  17280
  __asm__  volatile   ("xchgq %0,%1": "=r" (x): "m" (*((long volatile   *)ptr)), "0" (x): "memory");
//#line  17282
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  17285
  return (x);
}
}
//#line  17289
unsigned long strlen(char const   *s ) ;
//#line  17291
int strcmp(char const   *cs , char const   *ct ) ;
//#line  17293 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) test_ti_thread_flag)(struct thread_info *ti ,
                                                                              int flag ) 
{ 
  int tmp___0 ;

  {
  record_function("test_ti_thread_flag");
  {
//#line  17300
  tmp___0 = variable_test_bit(flag, (unsigned long const volatile   *)((unsigned long *)(& ti->flags)));
  }
//#line  17302
  return (tmp___0);
}
}
//#line  17306
static void init_waitqueue_head(wait_queue_head_t *q ) ;
//#line  17308
static void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
//#line  17310
static void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
//#line  17312
int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
//#line  17315
static void schedule(void) ;
//#line  17317 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) test_tsk_thread_flag)(struct task_struct *tsk ,
                                                                               int flag ) 
{ 
  int tmp ;

  {
  record_function("test_tsk_thread_flag");
  {
//#line  17324
  tmp = test_ti_thread_flag((struct thread_info *)tsk->stack, flag);
  }
//#line  17326
  return (tmp);
}
}
//#line  17330 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) signal_pending)(struct task_struct *p ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  record_function("signal_pending");
  {
//#line  17338
  tmp = test_tsk_thread_flag(p, 2);
  }
//#line  17340
  if (tmp) {
//#line  17342
    tmp___0 = 1;
  } else {
//#line  17345
    tmp___0 = 0;
  }
  {
//#line  17348
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
  }
//#line  17350
  return ((int )tmp___1);
}
}
//#line  17354 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) usb_fill_control_urb)(struct urb *urb ,
                                                                                struct usb_device *dev ,
                                                                                unsigned int pipe ,
                                                                                unsigned char *setup_packet ,
                                                                                void *transfer_buffer ,
                                                                                int buffer_length ,
                                                                                void (*complete_fn)(struct urb * ) ,
                                                                                void *context ) 
{ 


  {
  record_function("usb_fill_control_urb");
//#line  17367
  urb->dev = (struct usb_device *)dev;
//#line  17369
  urb->pipe = pipe;
//#line  17371
  urb->setup_packet = setup_packet;
//#line  17373
  urb->transfer_buffer = (u8 *)transfer_buffer;
//#line  17375
  urb->transfer_buffer_length = buffer_length;
//#line  17377
  urb->complete = complete_fn;
//#line  17379
  urb->context = (u8 * __attribute__((__noderef__)) )context;
//#line  17381
  return;
}
}
//#line  17385
static void snd_ctl_notify(struct snd_card *card , unsigned int mask , struct snd_ctl_elem_id *id ) ;
//#line  17387
static struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew ,
                                         void *private_data ) ;
//#line  17390
static int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) ;
//#line  17392
static struct snd_kcontrol *snd_ctl_find_id(struct snd_card *card , struct snd_ctl_elem_id *id ) ;
//#line  17394
int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
//#line  17396
unsigned long copy_to_user(void *to , void const   *from , unsigned int len ) ;
//#line  17400 "usb-audio.merged.sym.c"
__inline static void ( __attribute__((__always_inline__)) poll_wait)(struct file *filp ,
                                                                     wait_queue_head_t *wait_address ,
                                                                     poll_table *p ) 
{ 


  {
  record_function("poll_wait");
//#line  17408
  if (p) {
//#line  17410
    if (wait_address) {
      {
//#line  17412
      (*(p->qproc))(filp, wait_address, p);
      }
    }
  }
//#line  17416
  return;
}
}
//#line  17420
static int snd_hwdep_new(struct snd_card *card , char *id , int device , struct snd_hwdep **rhwdep ) ;
//#line  17423 "usb-audio.merged.sym.c"
static struct rc_config  const  rc_configs[3]  = {      {(u32 )((1054 << 16) | 12288), (u8 )0, (u8 )1, (u8 )2, (u8 )1, (u8 )18, (u32 )19}, 
        {(u32 )((1054 << 16) | 12320),
      (u8 )2, (u8 )1, (u8 )6, (u8 )6, (u8 )18, (u32 )19}, 
        {(u32 )((1054 << 16) | 12352), (u8 )2, (u8 )2, (u8 )6, (u8 )6, (u8 )2, (u32 )28305}};
static struct usbmix_name_map extigy_map[20]  = 
//#line  17428
  {      {2, str_968180269, 0}, 
        {5, (char const   *)((void *)0), 0}, 
        {6, str_236948253, 0}, 
        {8, str_65189559, 0}, 
        {10, str_508178660, 0}, 
        {11, str_699349911, 0}, 
        {12, str_186466258, 0}, 
        {17, (char const   *)((void *)0), 1}, 
        {17, str_941834121, 2}, 
        {18, str_336410471, 3}, 
        {18, str_158039148, 5}, 
        {18, str_1060912469, 0}, 
        {21, (char const   *)((void *)0), 0}, 
        {22, str_238177709, 0}, 
        {23, str_62046100, 0}, 
        {25, str_852258126, 0}, 
        {26, str_852258126, 0}, 
        {27, (char const   *)((void *)0), 0}, 
        {29, (char const   *)((void *)0), 0}, 
        {0, (char const   *)0, 0}};
//#line  17451 "usb-audio.merged.sym.c"
static struct usbmix_name_map mp3plus_map[7]  = {      {8, str_699349911, 0}, 
        {9, str_1060912469, 0}, 
        {10, str_809021430, 7}, 
        {11, str_948881558, 0}, 
        {12, str_3623250, 0}, 
        {14, str_65189559, 0}, 
        {0, (char const   *)0, 0}};
static struct usbmix_name_map audigy2nx_map[17]  = 
//#line  17459
  {      {6, str_3623250, 0}, 
        {8, str_65189559, 0}, 
        {11, str_960884417, 0}, 
        {12, str_948881558, 0}, 
        {13, str_267488495, 0}, 
        {14, str_312378469, 0}, 
        {17, (char const   *)((void *)0), 0}, 
        {18, str_1060912469, 0}, 
        {21, (char const   *)((void *)0), 0}, 
        {22, str_238177709, 0}, 
        {23, (char const   *)((void *)0), 0}, 
        {27, (char const   *)((void *)0), 0}, 
        {28, str_735532888, 0}, 
        {29, str_526151313, 0}, 
        {30, str_781461537, 0}, 
        {31, str_765604581, 0}, 
        {0, (char const   *)0, 0}};
//#line  17479 "usb-audio.merged.sym.c"
static char const   *__constr_expr_0___0[3]  = {      str_561380,      str_236948253,      str_840389807};
//#line  17481 "usb-audio.merged.sym.c"
static char const   *__constr_expr_1___0[3]  = {      str_9946673,      str_30230,      str_236948253};
//#line  17483 "usb-audio.merged.sym.c"
static char const   *__constr_expr_2___0[2]  = {      str_9946673,      str_609203};
//#line  17485 "usb-audio.merged.sym.c"
static struct usbmix_selector_map audigy2nx_selectors[4]  = {      {14, 3, __constr_expr_0___0}, 
        {29, 3, __constr_expr_1___0}, 
        {31, 2, __constr_expr_2___0}, 
        {0, 0, (char const   **)0}};
//#line  17490 "usb-audio.merged.sym.c"
static struct usbmix_name_map live24ext_map[2]  = {      {5, str_11480405, 0}, 
        {0, (char const   *)0, 0}};
//#line  17493 "usb-audio.merged.sym.c"
static struct usbmix_name_map linex_map[2]  = {      {3, str_204133454, 0}, 
        {0, (char const   *)0, 0}};
//#line  17496 "usb-audio.merged.sym.c"
static struct usbmix_name_map maya44_map[5]  = {      {2, str_65189559, 0}, 
        {4, str_65189559, 0}, 
        {7, str_1060912469, 0}, 
        {10, str_948881558, 0}, 
        {0, (char const   *)0, 0}};
//#line  17502 "usb-audio.merged.sym.c"
static struct usbmix_name_map justlink_map[6]  = {      {3, (char const   *)((void *)0), 0}, 
        {7, str_1060912469, 0}, 
        {8, (char const   *)((void *)0), 0}, 
        {9, (char const   *)((void *)0), 0}, 
        {12, (char const   *)((void *)0), 0}, 
        {0, (char const   *)0, 0}};
static struct usbmix_name_map aureon_51_2_map[8]  = 
//#line  17509
  {      {8, str_312378469, 0}, 
        {9, str_1060912469, 0}, 
        {10, str_11480405, 0}, 
        {11, str_948881558, 0}, 
        {12, str_403701822, 0}, 
        {13, str_508178660, 0}, 
        {14, str_65189559, 0}, 
        {0, (char const   *)0, 0}};
static struct usbmix_ctl_map usbmix_ctl_maps[11]  = 
//#line  17520
  {      {(u32 )((1054 << 16) | 12288), (struct usbmix_name_map  const  *)(extigy_map),
      (struct usbmix_selector_map  const  *)0, 1}, 
        {(u32 )((1054 << 16) | 12304), (struct usbmix_name_map  const  *)(mp3plus_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((1054 << 16) | 12320), (struct usbmix_name_map  const  *)(audigy2nx_map),
      (struct usbmix_selector_map  const  *)(audigy2nx_selectors), 0}, 
        {(u32 )((1054 << 16) | 12352), (struct usbmix_name_map  const  *)(live24ext_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((1784 << 16) | 45056), (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      1}, 
        {(u32 )((1784 << 16) | 53250), (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      1}, 
        {(u32 )((2235 << 16) | 9986), (struct usbmix_name_map  const  *)(linex_map),
      (struct usbmix_selector_map  const  *)0, 1}, 
        {(u32 )((2706 << 16) | 145), (struct usbmix_name_map  const  *)(maya44_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((3141 << 16) | 4440), (struct usbmix_name_map  const  *)(justlink_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )((3277 << 16) | 40), (struct usbmix_name_map  const  *)(aureon_51_2_map),
      (struct usbmix_selector_map  const  *)0, 0}, 
        {(u32 )0, (struct usbmix_name_map  const  *)0, (struct usbmix_selector_map  const  *)0,
      0}};
//#line  17545 "usb-audio.merged.sym.c"
int Nonstub_return_buflen(int buflen ) 
{ 


  {
  record_function("Nonstub_return_buflen");
//#line  17551
  return (buflen);
}
}
//#line  17555 "usb-audio.merged.sym.c"
static int check_mapped_name(struct mixer_build *state , int unitid , int control ,
                             char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                             int buflen ) 
{ 
  struct usbmix_name_map  const  *p ;
  size_t tmp ;

  {
  record_function("check_mapped_name");
//#line  17564
  if (! state->map) {
//#line  17566
    return (0);
  }
//#line  17569
  p = state->map;
  {
  {
//#line  17571
  while (1) {


    if (! p->id) {
//#line  17571
      goto while_break;
    }
//#line  17573
    if (p->id == (int const   )unitid) {
//#line  17575
      if (p->name) {
//#line  17577
        if (! control) {
          {
//#line  17579
          buflen --;
//#line  17581
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
          }
//#line  17583
          return ((int )tmp);
        } else
//#line  17586
        if (! p->control) {
          {
//#line  17588
          buflen --;
//#line  17590
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
          }
//#line  17592
          return ((int )tmp);
        } else
//#line  17595
        if (control == (int )p->control) {
          {
//#line  17597
          buflen --;
//#line  17599
          tmp = strlcpy((char *)buf, (char const   *)p->name, (size_t )buflen);
          }
//#line  17601
          return ((int )tmp);
        }
      }
    }
//#line  17606
    p ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17609
  return (0);
}
}
//#line  17613 "usb-audio.merged.sym.c"
static int check_ignored_ctl(struct mixer_build *state , int unitid , int control ) 
{ 
  struct usbmix_name_map  const  *p ;

  {
  record_function("check_ignored_ctl");
//#line  17619
  if (! state->map) {
//#line  17621
    return (0);
  }
//#line  17624
  p = state->map;
  {
  {
//#line  17626
  while (1) {


    if (! p->id) {
//#line  17626
      goto while_break;
    }
//#line  17628
    if (p->id == (int const   )unitid) {
//#line  17630
      if (! p->name) {
//#line  17632
        if (! control) {
//#line  17634
          return (1);
        } else
//#line  17637
        if (! p->control) {
//#line  17639
          return (1);
        } else
//#line  17642
        if (control == (int )p->control) {
//#line  17644
          return (1);
        }
      }
    }
//#line  17649
    p ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17652
  return (0);
}
}
//#line  17656 "usb-audio.merged.sym.c"
static int check_mapped_selector_name(struct mixer_build *state , int unitid , int index___0 ,
                                      char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                                      int buflen ) 
{ 
  struct usbmix_selector_map  const  *p ;
  size_t tmp ;

  {
  record_function("check_mapped_selector_name");
//#line  17665
  if (! state->selector_map) {
//#line  17667
    return (0);
  }
//#line  17670
  p = state->selector_map;
  {
  {
//#line  17672
  while (1) {


    if (! p->id) {
//#line  17672
      goto while_break;
    }
//#line  17674
    if (p->id == (int const   )unitid) {
//#line  17676
      if (index___0 < (int )p->count) {
        {
//#line  17678
        tmp = strlcpy((char *)buf, *(p->names + index___0), (size_t )buflen);
        }
//#line  17680
        return ((int )tmp);
      }
    }
//#line  17684
    p ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17687
  return (0);
}
}
//#line  17691 "usb-audio.merged.sym.c"
static void *find_audio_control_unit(struct mixer_build *state , unsigned char unit ) 
{ 
  unsigned char *p ;
  void *tmp ;

  {
  record_function("find_audio_control_unit");
//#line  17698
  p = (unsigned char *)((void *)0);
  {
  {
//#line  17700
  while (1) {


    {
//#line  17702
    tmp = snd_usb_find_desc((void *)state->buffer, (int )state->buflen, (void *)p,
                            (u8 )((1 << 5) | 4));
//#line  17705
    p = (unsigned char *)tmp;
    }
//#line  17707
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
//#line  17709
      goto while_break;
    }
//#line  17712
    if ((int )*(p + 0) >= 4) {
//#line  17714
      if ((int )*(p + 2) >= 2) {
//#line  17716
        if ((int )*(p + 2) <= 8) {
//#line  17718
          if ((int )*(p + 3) == (int )unit) {
//#line  17720
            return ((void *)p);
          }
        }
      }
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17727
  return ((void *)0);
}
}
//#line  17731 "usb-audio.merged.sym.c"
static int snd_usb_copy_string_desc(struct mixer_build *state , int index___0 , char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) buf ,
                                    int maxlen ) 
{ 
  int len ;
  int tmp ;

  {
  record_function("snd_usb_copy_string_desc");
  {
//#line  17739
  tmp = usb_string((state->chip)->dev, index___0, (char * __attribute__((__exp__(Nonstub_get_size("size")))) )buf,
                   (size_t )(maxlen - 1));
//#line  17742
  len = tmp;
//#line  17744
  *(buf + len) = (char)0;
  }
//#line  17746
  return (len);
}
}
//#line  17750 "usb-audio.merged.sym.c"
static int convert_signed_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
  record_function("convert_signed_value");
  {
  if (cval->val_type == 0) {
//#line  17757
    goto case_0;
  }
  if (cval->val_type == 1) {
//#line  17760
    goto case_1;
  }
  if (cval->val_type == 3) {
//#line  17763
    goto case_3;
  }
  if (cval->val_type == 2) {
//#line  17768
    goto case_2;
  }
  if (cval->val_type == 5) {
//#line  17778
    goto case_5;
  }
  if (cval->val_type == 4) {
//#line  17783
    goto case_4;
  }
//#line  17756
  goto switch_break;
  case_0: /* CIL Label */ 
//#line  17759
  return (! (! val));
  case_1: /* CIL Label */ 
//#line  17762
  return (! val);
  case_3: /* CIL Label */ 
//#line  17765
  val &= 255;
//#line  17767
  goto switch_break;
  case_2: /* CIL Label */ 
//#line  17770
  val &= 255;
//#line  17772
  if (val >= 128) {
//#line  17774
    val -= 256;
  }
//#line  17777
  goto switch_break;
  case_5: /* CIL Label */ 
//#line  17780
  val &= 65535;
//#line  17782
  goto switch_break;
  case_4: /* CIL Label */ 
//#line  17785
  val &= 65535;
//#line  17787
  if (val >= 32768) {
//#line  17789
    val -= 65536;
  }
//#line  17792
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  17795
  return (val);
}
}
//#line  17799 "usb-audio.merged.sym.c"
static int convert_bytes_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
  record_function("convert_bytes_value");
  {
  if (cval->val_type == 0) {
//#line  17806
    goto case_0;
  }
  if (cval->val_type == 1) {
//#line  17809
    goto case_1;
  }
  if (cval->val_type == 2) {
//#line  17812
    goto case_2;
  }
  if (cval->val_type == 3) {
//#line  17813
    goto case_2;
  }
  if (cval->val_type == 4) {
//#line  17816
    goto case_4;
  }
  if (cval->val_type == 5) {
//#line  17817
    goto case_4;
  }
//#line  17805
  goto switch_break;
  case_0: /* CIL Label */ 
//#line  17808
  return (! (! val));
  case_1: /* CIL Label */ 
//#line  17811
  return (! val);
  case_2: /* CIL Label */ 
//#line  17815
  return (val & 255);
  case_4: /* CIL Label */ 
//#line  17819
  return (val & 65535);
  switch_break: /* CIL Label */ ;
  }
//#line  17822
  return (0);
}
}
//#line  17826 "usb-audio.merged.sym.c"
static int get_relative_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
  record_function("get_relative_value");
//#line  17832
  if (! cval->res) {
//#line  17834
    cval->res = 1;
  }
//#line  17837
  if (val < cval->min) {
//#line  17839
    return (0);
  } else
//#line  17842
  if (val >= cval->max) {
//#line  17844
    return ((((cval->max - cval->min) + cval->res) - 1) / cval->res);
  } else {
//#line  17847
    return ((val - cval->min) / cval->res);
  }
}
}
//#line  17852 "usb-audio.merged.sym.c"
static int get_abs_value(struct usb_mixer_elem_info *cval , int val ) 
{ 


  {
  record_function("get_abs_value");
//#line  17858
  if (val < 0) {
//#line  17860
    return (cval->min);
  }
//#line  17863
  if (! cval->res) {
//#line  17865
    cval->res = 1;
  }
//#line  17868
  val *= cval->res;
//#line  17870
  val += cval->min;
//#line  17872
  if (val > cval->max) {
//#line  17874
    return (cval->max);
  }
//#line  17877
  return (val);
}
}
//#line  17881 "usb-audio.merged.sym.c"
static int get_ctl_value(struct usb_mixer_elem_info *cval , int request , int validx ,
                         int *value_ret ) 
{ 
  unsigned char buf[2] ;
  int val_len ;
  int tmp ;
  int timeout ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  record_function("get_ctl_value");
//#line  17895
  if (cval->val_type >= 4) {
//#line  17897
    tmp = 2;
  } else {
//#line  17900
    tmp = 1;
  }
//#line  17903
  val_len = tmp;
//#line  17905
  timeout = 10;
  {
  {
//#line  17907
  while (1) {


//#line  17909
    tmp___3 = timeout;
//#line  17911
    timeout --;
//#line  17913
    if (! (tmp___3 > 0)) {
//#line  17915
      goto while_break;
    }
    {
//#line  17918
    tmp___1 = __create_pipe(((cval->mixer)->chip)->dev, 0U);
//#line  17920
    tmp___2 = snd_usb_ctl_msg(((cval->mixer)->chip)->dev, ((unsigned int )(2 << 30) | tmp___1) | 128U,
                              (__u8 )request, (__u8 )((1 | (1 << 5)) | 128), (__u16 )validx,
                              (__u16 )((cval->mixer)->ctrlif | (cval->id << 8)), (void *)(buf),
                              (__u16 )val_len, 100);
    }
//#line  17925
    if (tmp___2 >= val_len) {
      {
//#line  17927
      tmp___0 = snd_usb_combine_bytes(buf, val_len);
//#line  17929
      *value_ret = convert_signed_value(cval, (int )tmp___0);
      }
//#line  17931
      return (0);
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  17935
  return (-22);
}
}
//#line  17939 "usb-audio.merged.sym.c"
static int get_cur_ctl_value(struct usb_mixer_elem_info *cval , int validx , int *value ) 
{ 
  int tmp ;

  {
  record_function("get_cur_ctl_value");
  {
//#line  17945
  tmp = get_ctl_value(cval, 129, validx, value);
  }
//#line  17947
  return (tmp);
}
}
//#line  17951 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) get_cur_mix_value)(struct usb_mixer_elem_info *cval ,
                                                                            int channel ,
                                                                            int *value ) 
{ 
  int tmp ;

  {
  record_function("get_cur_mix_value");
  {
//#line  17959
  tmp = get_ctl_value(cval, 129, (int )((cval->control << 8) | (unsigned int )channel),
                      value);
  }
//#line  17962
  return (tmp);
}
}
//#line  17966 "usb-audio.merged.sym.c"
static int set_ctl_value(struct usb_mixer_elem_info *cval , int request , int validx ,
                         int value_set ) 
{ 
  unsigned char buf[2] ;
  int val_len ;
  int tmp ;
  int timeout ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  record_function("set_ctl_value");
//#line  17979
  if (cval->val_type >= 4) {
//#line  17981
    tmp = 2;
  } else {
//#line  17984
    tmp = 1;
  }
  {
//#line  17987
  val_len = tmp;
//#line  17989
  timeout = 10;
//#line  17991
  value_set = convert_bytes_value(cval, value_set);
//#line  17993
  buf[0] = (unsigned char )(value_set & 255);
//#line  17995
  buf[1] = (unsigned char )((value_set >> 8) & 255);
  }
  {
  {
//#line  17997
  while (1) {


//#line  17999
    tmp___2 = timeout;
//#line  18001
    timeout --;
//#line  18003
    if (! (tmp___2 > 0)) {
//#line  18005
      goto while_break;
    }
    {
//#line  18008
    tmp___0 = __create_pipe(((cval->mixer)->chip)->dev, 0U);
//#line  18010
    tmp___1 = snd_usb_ctl_msg(((cval->mixer)->chip)->dev, (unsigned int )(2 << 30) | tmp___0,
                              (__u8 )request, (__u8 )(1 | (1 << 5)), (__u16 )validx,
                              (__u16 )((cval->mixer)->ctrlif | (cval->id << 8)), (void *)(buf),
                              (__u16 )val_len, 100);
    }
//#line  18015
    if (tmp___1 >= 0) {
//#line  18017
      return (0);
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  18021
  return (-22);
}
}
//#line  18025 "usb-audio.merged.sym.c"
static int set_cur_ctl_value(struct usb_mixer_elem_info *cval , int validx , int value ) 
{ 
  int tmp ;

  {
  record_function("set_cur_ctl_value");
  {
//#line  18031
  tmp = set_ctl_value(cval, 1, validx, value);
  }
//#line  18033
  return (tmp);
}
}
//#line  18037 "usb-audio.merged.sym.c"
__inline static int ( __attribute__((__always_inline__)) set_cur_mix_value)(struct usb_mixer_elem_info *cval ,
                                                                            int channel ,
                                                                            int value ) 
{ 
  int tmp ;

  {
  record_function("set_cur_mix_value");
  {
//#line  18045
  tmp = set_ctl_value(cval, 1, (int )((cval->control << 8) | (unsigned int )channel),
                      value);
  }
//#line  18048
  return (tmp);
}
}
//#line  18052 "usb-audio.merged.sym.c"
static int mixer_vol_tlv(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                         unsigned int *_tlv ) 
{ 
  struct usb_mixer_elem_info *cval ;
  unsigned int scale[4] ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  record_function("mixer_vol_tlv");
//#line  18063
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  18065
  scale[0] = 1U;
//#line  18067
  scale[1] = (unsigned int )(2UL * sizeof(unsigned int ));
//#line  18069
  scale[2] = 0U;
//#line  18071
  scale[3] = 0U;
//#line  18073
  if ((unsigned long )size < sizeof(scale)) {
//#line  18075
    return (-12);
  }
  {
//#line  18078
  tmp = convert_signed_value(cval, cval->min);
//#line  18080
  scale[2] = (unsigned int )((tmp * 100) / 256);
//#line  18082
  tmp___0 = convert_signed_value(cval, cval->res);
//#line  18084
  scale[3] = (unsigned int )((tmp___0 * 100) / 256);
//#line  18086
  tmp___2 = copy_to_user((void *)_tlv, (void const   *)(scale), (unsigned int )sizeof(scale));
  tmp___1 = tmp___2;
  }
//#line  18088
  if (tmp___1) {
//#line  18090
    return (-14);
  }
//#line  18093
  return (0);
}
}
//#line  18097
static int parse_audio_unit(struct mixer_build *state , int unitid ) ;
//#line  18099 "usb-audio.merged.sym.c"
static int check_matrix_bitmap(unsigned char *bmap___0 , int ich , int och , int num_outs ) 
{ 
  int idx ;

  {
  record_function("check_matrix_bitmap");
//#line  18105
  idx = ich * num_outs + och;
//#line  18107
  return ((int )*(bmap___0 + (idx >> 3)) & (128 >> (idx & 7)));
}
}
//#line  18111 "usb-audio.merged.sym.c"
static int add_control_to_empty(struct mixer_build *state , struct snd_kcontrol *kctl ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int err ;
  struct snd_kcontrol *tmp ;

  {
  record_function("add_control_to_empty");
//#line  18119
  cval = (struct usb_mixer_elem_info *)kctl->private_data;
  {
  {
//#line  18121
  while (1) {


    {
//#line  18123
    tmp = snd_ctl_find_id((state->chip)->card, & kctl->id);
    }
//#line  18125
    if (! tmp) {
//#line  18127
      goto while_break;
    }
//#line  18130
    (kctl->id.index) ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  18133
  err = snd_ctl_add((state->chip)->card, kctl);
  }
//#line  18135
  if (err < 0) {
    {
    {
//#line  18137
    while (1) {


//#line  18139
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  18142
    return (err);
  }
//#line  18145
  cval->elem_id = & kctl->id;
//#line  18147
  cval->next_id_elem = (struct usb_mixer_elem_info *)*((state->mixer)->id_elems + cval->id);
//#line  18149
  *((state->mixer)->id_elems + cval->id) = cval;
//#line  18151
  return (0);
}
}
static struct iterm_name_combo iterm_names[37]  = 
//#line  18155
  {      {768, (char *)str_211697793}, 
        {769, (char *)str_974774143}, 
        {770, (char *)str_442778450}, 
        {771, (char *)str_1073431585}, 
        {772, (char *)str_391949103}, 
        {773, (char *)str_785022198}, 
        {774, (char *)str_75719076}, 
        {775, (char *)str_28835}, 
        {1536, (char *)str_346970378}, 
        {1537, (char *)str_217733085}, 
        {1538, (char *)str_236948253}, 
        {1539, (char *)str_561380}, 
        {1540, (char *)str_1004535908}, 
        {1541, (char *)str_181451660}, 
        {1542, (char *)str_835963836}, 
        {1543, (char *)str_279917523}, 
        {1792, (char *)str_489702074}, 
        {1793, (char *)str_629245061}, 
        {1794, (char *)str_694732782}, 
        {1795, (char *)str_1341}, 
        {1796, (char *)str_25867}, 
        {1797, (char *)str_25888}, 
        {1798, (char *)str_1040058580}, 
        {1799, (char *)str_218563518}, 
        {1800, (char *)str_631087734}, 
        {1801, (char *)str_782488767}, 
        {1802, (char *)str_803851448}, 
        {1803, (char *)str_239825392}, 
        {1804, (char *)str_317885218}, 
        {1805, (char *)str_812255493}, 
        {1806, (char *)str_659772121}, 
        {1807, (char *)str_411382038}, 
        {1808, (char *)str_743645852}, 
        {1809, (char *)str_521161324}, 
        {1810, (char *)str_883168199}, 
        {1811, (char *)str_1055203368}, 
        {0, (char *)0}};
//#line  18195 "usb-audio.merged.sym.c"
static int get_term_name(struct mixer_build *state , struct usb_audio_term *iterm ,
                         unsigned char *name , int maxlen , int term_only ) 
{ 
  struct iterm_name_combo *names ;
  int tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
  record_function("get_term_name");
//#line  18205
  if (iterm->name) {
    {
//#line  18207
    tmp = snd_usb_copy_string_desc(state, iterm->name, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )name,
                                   maxlen);
    }
//#line  18210
    return (tmp);
  }
//#line  18213
  if (iterm->type >> 16) {
//#line  18215
    if (term_only) {
//#line  18217
      return (0);
    }
    {
    if (iterm->type >> 16 == 5) {
//#line  18221
      goto case_5;
    }
    if (iterm->type >> 16 == 7) {
//#line  18226
      goto case_7;
    }
    if (iterm->type >> 16 == 8) {
//#line  18231
      goto case_8;
    }
    if (iterm->type >> 16 == 4) {
//#line  18236
      goto case_4;
    }
//#line  18241
    goto switch_default;
    case_5: /* CIL Label */ 
    {
//#line  18223
    strcpy((char *)name, str_841139419);
    }
//#line  18225
    return (8);
    case_7: /* CIL Label */ 
    {
//#line  18228
    strcpy((char *)name, str_415308913);
    }
//#line  18230
    return (12);
    case_8: /* CIL Label */ 
    {
//#line  18233
    strcpy((char *)name, str_1042685215);
    }
//#line  18235
    return (8);
    case_4: /* CIL Label */ 
    {
//#line  18238
    strcpy((char *)name, str_10800265);
    }
//#line  18240
    return (5);
    switch_default: /* CIL Label */ 
    {
//#line  18243
    tmp___0 = sprintf((char *)name, str_1064537007, iterm->id);
    }
//#line  18245
    return (tmp___0);

    }
  }
  {
  if ((iterm->type & 65280) == 256) {
//#line  18250
    goto case_256;
  }
  if ((iterm->type & 65280) == 512) {
//#line  18255
    goto case_512;
  }
  if ((iterm->type & 65280) == 1024) {
//#line  18260
    goto case_1024;
  }
  if ((iterm->type & 65280) == 1280) {
//#line  18265
    goto case_1280;
  }
//#line  18249
  goto switch_break___0;
  case_256: /* CIL Label */ 
  {
//#line  18252
  strcpy((char *)name, str_30230);
  }
//#line  18254
  return (3);
  case_512: /* CIL Label */ 
  {
//#line  18257
  strcpy((char *)name, str_29891);
  }
//#line  18259
  return (3);
  case_1024: /* CIL Label */ 
  {
//#line  18262
  strcpy((char *)name, str_429534546);
  }
//#line  18264
  return (7);
  case_1280: /* CIL Label */ 
  {
//#line  18267
  strcpy((char *)name, str_11181278);
  }
//#line  18269
  return (5);
  switch_break___0: /* CIL Label */ ;
  }
//#line  18272
  names = iterm_names;
  {
  {
//#line  18274
  while (1) {


    if (! names->type) {
//#line  18274
      goto while_break;
    }
//#line  18276
    if (names->type == iterm->type) {
      {
//#line  18278
      strcpy((char *)name, (char const   *)names->name);
//#line  18280
      tmp___1 = strlen((char const   *)names->name);
      }
//#line  18282
      return ((int )tmp___1);
    }
//#line  18285
    names ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  18288
  return (0);
}
}
//#line  18292 "usb-audio.merged.sym.c"
static int check_input_term(struct mixer_build *state , int id___0 , struct usb_audio_term *term ) 
{ 
  unsigned char *p1 ;
  int tmp ;
  void *tmp___0 ;

  {
  record_function("check_input_term");
  {
//#line  18300
  memset((void *)term, 0, sizeof(*term));
  }
  {
  {
//#line  18302
  while (1) {


    {
//#line  18304
    tmp___0 = find_audio_control_unit(state, (unsigned char )id___0);
//#line  18306
    p1 = (unsigned char *)tmp___0;
    }
//#line  18308
    if (! ((unsigned long )p1 != (unsigned long )((void *)0))) {
//#line  18310
      goto while_break;
    }
//#line  18313
    term->id = id___0;
    {
    if ((int )*(p1 + 2) == 2) {
//#line  18316
      goto case_2;
    }
    if ((int )*(p1 + 2) == 6) {
//#line  18327
      goto case_6;
    }
    if ((int )*(p1 + 2) == 4) {
//#line  18332
      goto case_4;
    }
    if ((int )*(p1 + 2) == 5) {
//#line  18343
      goto case_5;
    }
    if ((int )*(p1 + 2) == 7) {
//#line  18359
      goto case_7;
    }
    if ((int )*(p1 + 2) == 8) {
//#line  18360
      goto case_7;
    }
//#line  18378
    goto switch_default;
    case_2: /* CIL Label */ 
//#line  18318
    term->type = (int )((unsigned int )((int )*p1 + 4) | ((unsigned int )*((p1 + 4) + 1) << 8));
//#line  18320
    term->channels = (int )*(p1 + 7);
//#line  18322
    term->chconfig = (unsigned int )((int )*p1 + 8) | ((unsigned int )*((p1 + 8) + 1) << 8);
//#line  18324
    term->name = (int )*(p1 + 11);
//#line  18326
    return (0);
    case_6: /* CIL Label */ 
//#line  18329
    id___0 = (int )*(p1 + 4);
//#line  18331
    goto switch_break;
    case_4: /* CIL Label */ 
//#line  18334
    term->type = (int )*(p1 + 2) << 16;
//#line  18336
    term->channels = (int )*(p1 + (5 + (int )*(p1 + 4)));
//#line  18338
    term->chconfig = (unsigned int )(((int )*p1 + 6) + (int )*(p1 + 4)) | ((unsigned int )*(((p1 + 6) + (int )*(p1 + 4)) + 1) << 8);
//#line  18340
    term->name = (int )*(p1 + ((int )*(p1 + 0) - 1));
//#line  18342
    return (0);
    case_5: /* CIL Label */ 
    {
//#line  18345
    tmp = check_input_term(state, (int )*(p1 + 5), term);
    }
//#line  18347
    if (tmp < 0) {
//#line  18349
      return (-19);
    }
//#line  18352
    term->type = (int )*(p1 + 2) << 16;
//#line  18354
    term->id = id___0;
//#line  18356
    term->name = (int )*(p1 + ((9 + (int )*(p1 + 0)) - 1));
//#line  18358
    return (0);
    case_7: /* CIL Label */ 
//#line  18362
    if ((int )*(p1 + 6) == 1) {
//#line  18364
      id___0 = (int )*(p1 + 7);
//#line  18366
      goto switch_break;
    }
//#line  18369
    term->type = (int )*(p1 + 2) << 16;
//#line  18371
    term->channels = (int )*(p1 + (7 + (int )*(p1 + 6)));
//#line  18373
    term->chconfig = (unsigned int )(((int )*p1 + 8) + (int )*(p1 + 6)) | ((unsigned int )*(((p1 + 8) + (int )*(p1 + 6)) + 1) << 8);
//#line  18375
    term->name = (int )*(p1 + ((12 + (int )*(p1 + 6)) + (int )*(p1 + (11 + (int )*(p1 + 6)))));
//#line  18377
    return (0);
    switch_default: /* CIL Label */ 
//#line  18380
    return (-19);
    switch_break: /* CIL Label */ ;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  18384
  return (-19);
}
}
static struct usb_feature_control_info ( __attribute__((__noderef__, __address_space__(2))) audio_feature_info)[10]  = 
//#line  18388
  {      {(char const   *)str_572685, 1U}, 
        {(char const   *)str_228195326, 4U}, 
        {(char const   *)str_336410471, 2U}, 
        {(char const   *)str_582837192, 2U}, 
        {(char const   *)str_158039148, 2U}, 
        {(char const   *)str_877389318, 2U}, 
        {(char const   *)str_324299317, 0U}, 
        {(char const   *)str_790741568, 5U}, 
        {(char const   *)str_924615310, 0U}, 
        {(char const   *)str_445429857, 0U}};
//#line  18402 "usb-audio.merged.sym.c"
static void usb_mixer_elem_free(struct snd_kcontrol *kctl ) 
{ 


  {
  record_function("usb_mixer_elem_free");
  {
//#line  18408
  kfree((void const   *)kctl->private_data);
//#line  18410
  kctl->private_data = (char *)((void *)0);
  }
//#line  18412
  return;
}
}
//#line  18416 "usb-audio.merged.sym.c"
static int get_min_max(struct usb_mixer_elem_info *cval , int default_min ) 
{ 
  int minchn ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int last_valid_res ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int last_valid_res___0 ;
  int saved ;
  int test ;
  int check ;
  int tmp___4 ;
  int tmp___5 ;

  {
  record_function("get_min_max");
//#line  18435
  cval->min = default_min;
//#line  18437
  cval->max = cval->min + 1;
//#line  18439
  cval->res = 1;
//#line  18441
  if (cval->val_type == 0) {
//#line  18443
    cval->initialized = (u8 )1;
  } else
//#line  18446
  if (cval->val_type == 1) {
//#line  18448
    cval->initialized = (u8 )1;
  } else {
//#line  18451
    minchn = 0;
//#line  18453
    if (cval->cmask) {
//#line  18455
      i = 0;
      {
      {
//#line  18457
      while (1) {


        if (! (i < 10)) {
//#line  18457
          goto while_break;
        }
//#line  18459
        if (cval->cmask & (unsigned int )(1 << i)) {
//#line  18461
          minchn = i + 1;
//#line  18463
          goto while_break;
        }
//#line  18466
        i ++;
      }

      }
      while_break: /* CIL Label */ ;
      }
    }
    {
//#line  18470
    tmp = get_ctl_value(cval, 131, (int )((cval->control << 8) | (unsigned int )minchn),
                        & cval->max);
    }
//#line  18473
    if (tmp < 0) {
//#line  18475
      goto _L;
    } else {
      {
//#line  18478
      tmp___0 = get_ctl_value(cval, 130, (int )((cval->control << 8) | (unsigned int )minchn),
                              & cval->min);
      }
//#line  18481
      if (tmp___0 < 0) {
        _L: 
        {
        {
//#line  18484
        while (1) {


//#line  18486
          goto while_break___0;
        }

        }
        while_break___0: /* CIL Label */ ;
        }
//#line  18489
        return (-22);
      }
    }
    {
//#line  18493
    tmp___3 = get_ctl_value(cval, 132, (int )((cval->control << 8) | (unsigned int )minchn),
                            & cval->res);
    }
//#line  18496
    if (tmp___3 < 0) {
//#line  18498
      cval->res = 1;
    } else {
//#line  18501
      last_valid_res = cval->res;
      {
      {
//#line  18503
      while (1) {


        if (! (cval->res > 1)) {
//#line  18503
          goto while_break___1;
        }
        {
//#line  18505
        tmp___1 = set_ctl_value(cval, 4, (int )((cval->control << 8) | (unsigned int )minchn),
                                cval->res / 2);
        }
//#line  18508
        if (tmp___1 < 0) {
//#line  18510
          goto while_break___1;
        }
//#line  18513
        cval->res /= 2;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
//#line  18516
      tmp___2 = get_ctl_value(cval, 132, (int )((cval->control << 8) | (unsigned int )minchn),
                              & cval->res);
      }
//#line  18519
      if (tmp___2 < 0) {
//#line  18521
        cval->res = last_valid_res;
      }
    }
//#line  18525
    if (cval->res == 0) {
//#line  18527
      cval->res = 1;
    }
//#line  18530
    if (cval->min + cval->res < cval->max) {
      {
//#line  18532
      last_valid_res___0 = cval->res;
//#line  18534
      get_cur_mix_value(cval, minchn, & saved);
      }
      {
      {
//#line  18536
      while (1) {


//#line  18538
        test = saved;
//#line  18540
        if (test < cval->max) {
//#line  18542
          test += cval->res;
        } else {
//#line  18545
          test -= cval->res;
        }
//#line  18548
        if (test < cval->min) {
//#line  18550
          cval->res = last_valid_res___0;
//#line  18552
          goto while_break___2;
        } else
//#line  18555
        if (test > cval->max) {
//#line  18557
          cval->res = last_valid_res___0;
//#line  18559
          goto while_break___2;
        } else {
          {
//#line  18562
          tmp___4 = set_cur_mix_value(cval, minchn, test);
          }
//#line  18564
          if (tmp___4) {
//#line  18566
            cval->res = last_valid_res___0;
//#line  18568
            goto while_break___2;
          } else {
            {
//#line  18571
            tmp___5 = get_cur_mix_value(cval, minchn, & check);
            }
//#line  18573
            if (tmp___5) {
//#line  18575
              cval->res = last_valid_res___0;
//#line  18577
              goto while_break___2;
            }
          }
        }
//#line  18582
        if (test == check) {
//#line  18584
          goto while_break___2;
        }
//#line  18587
        cval->res *= 2;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
      {
//#line  18590
      set_cur_mix_value(cval, minchn, saved);
      }
    }
//#line  18593
    cval->initialized = (u8 )1;
  }
//#line  18596
  return (0);
}
}
//#line  18600 "usb-audio.merged.sym.c"
static int mixer_ctl_feature_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct usb_mixer_elem_info *cval ;

  {
  record_function("mixer_ctl_feature_info");
//#line  18606
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  18608
  if (cval->val_type == 0) {
//#line  18610
    uinfo->type = 1;
  } else
//#line  18613
  if (cval->val_type == 1) {
//#line  18615
    uinfo->type = 1;
  } else {
//#line  18618
    uinfo->type = 2;
  }
//#line  18621
  uinfo->count = (unsigned int )cval->channels;
//#line  18623
  if (cval->val_type == 0) {
//#line  18625
    uinfo->value.integer.min = 0L;
//#line  18627
    uinfo->value.integer.max = 1L;
  } else
//#line  18630
  if (cval->val_type == 1) {
//#line  18632
    uinfo->value.integer.min = 0L;
//#line  18634
    uinfo->value.integer.max = 1L;
  } else {
//#line  18637
    if (! cval->initialized) {
      {
//#line  18639
      get_min_max(cval, 0);
      }
    }
//#line  18642
    uinfo->value.integer.min = 0L;
//#line  18644
    uinfo->value.integer.max = (long )((((cval->max - cval->min) + cval->res) - 1) / cval->res);
  }
//#line  18647
  return (0);
}
}
//#line  18651 "usb-audio.merged.sym.c"
static int mixer_ctl_feature_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int c ;
  int cnt ;
  int val ;
  int err ;

  {
  record_function("mixer_ctl_feature_get");
//#line  18661
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  18663
  if (cval->cmask) {
//#line  18665
    cnt = 0;
//#line  18667
    c = 0;
    {
    {
//#line  18669
    while (1) {


      if (! (c < 10)) {
//#line  18669
        goto while_break;
      }
//#line  18671
      if (cval->cmask & (unsigned int )(1 << c)) {
        {
//#line  18673
        err = get_cur_mix_value(cval, c + 1, & val);
        }
//#line  18675
        if (err < 0) {
//#line  18677
          if ((cval->mixer)->ignore_ctl_error) {
//#line  18679
            ucontrol->value.integer.value[0] = (long )cval->min;
//#line  18681
            return (0);
          }
          {
          {
//#line  18684
          while (1) {


//#line  18686
            goto while_break___0;
          }

          }
          while_break___0: /* CIL Label */ ;
          }
//#line  18689
          return (err);
        }
        {
//#line  18692
        val = get_relative_value(cval, val);
//#line  18694
        ucontrol->value.integer.value[cnt] = (long )val;
//#line  18696
        cnt ++;
        }
      }
//#line  18699
      c ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
//#line  18703
    err = get_cur_mix_value(cval, 0, & val);
    }
//#line  18705
    if (err < 0) {
//#line  18707
      if ((cval->mixer)->ignore_ctl_error) {
//#line  18709
        ucontrol->value.integer.value[0] = (long )cval->min;
//#line  18711
        return (0);
      }
      {
      {
//#line  18714
      while (1) {


//#line  18716
        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
//#line  18719
      return (err);
    }
    {
//#line  18722
    val = get_relative_value(cval, val);
//#line  18724
    ucontrol->value.integer.value[0] = (long )val;
    }
  }
//#line  18727
  return (0);
}
}
//#line  18731 "usb-audio.merged.sym.c"
static int mixer_ctl_feature_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int c ;
  int cnt ;
  int val ;
  int oval ;
  int err ;
  int changed ;

  {
  record_function("mixer_ctl_feature_put");
//#line  18743
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  18745
  changed = 0;
//#line  18747
  if (cval->cmask) {
//#line  18749
    cnt = 0;
//#line  18751
    c = 0;
    {
    {
//#line  18753
    while (1) {


      if (! (c < 10)) {
//#line  18753
        goto while_break;
      }
//#line  18755
      if (cval->cmask & (unsigned int )(1 << c)) {
        {
//#line  18757
        err = get_cur_mix_value(cval, c + 1, & oval);
        }
//#line  18759
        if (err < 0) {
//#line  18761
          if ((cval->mixer)->ignore_ctl_error) {
//#line  18763
            return (0);
          }
//#line  18766
          return (err);
        }
        {
//#line  18769
        val = (int )ucontrol->value.integer.value[cnt];
//#line  18771
        val = get_abs_value(cval, val);
        }
//#line  18773
        if (oval != val) {
          {
//#line  18775
          set_cur_mix_value(cval, c + 1, val);
//#line  18777
          changed = 1;
          }
        }
        {
//#line  18780
        get_cur_mix_value(cval, c + 1, & val);
//#line  18782
        cnt ++;
        }
      }
//#line  18785
      c ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
//#line  18789
    err = get_cur_mix_value(cval, 0, & oval);
    }
//#line  18791
    if (err < 0) {
//#line  18793
      if ((cval->mixer)->ignore_ctl_error) {
//#line  18795
        return (0);
      }
    }
//#line  18799
    if (err < 0) {
//#line  18801
      return (err);
    }
    {
//#line  18804
    val = (int )ucontrol->value.integer.value[0];
//#line  18806
    val = get_abs_value(cval, val);
    }
//#line  18808
    if (val != oval) {
      {
//#line  18810
      set_cur_mix_value(cval, 0, val);
//#line  18812
      changed = 1;
      }
    }
  }
//#line  18816
  return (changed);
}
}
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) usb_feature_unit_ctl  = 
//#line  18820
     {2, 0U, 0U, (unsigned char *)str_0, 0U, 0U, 0U, & mixer_ctl_feature_info, & mixer_ctl_feature_get,
    & mixer_ctl_feature_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  18825 "usb-audio.merged.sym.c"
static void build_feature_ctl(struct mixer_build *state , unsigned char *desc , unsigned int ctl_mask ,
                              int control , struct usb_audio_term *iterm , int unitid ) 
{ 
  unsigned int len ;
  int mapped_name ;
  int nameid ;
  struct snd_kcontrol *kctl ;
  struct usb_mixer_elem_info *cval ;
  int tmp ;
  void *tmp___0 ;
  int i ;
  int c ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;

  {
  record_function("build_feature_ctl");
//#line  18849
  len = 0U;
//#line  18851
  mapped_name = 0;
//#line  18853
  nameid = (int )*(desc + ((int )*(desc + 0) - 1));
//#line  18855
  control ++;
//#line  18857
  if (control == 6) {
//#line  18859
    return;
  }
  {
//#line  18862
  tmp = check_ignored_ctl(state, unitid, control);
  }
//#line  18864
  if (tmp) {
//#line  18866
    return;
  }
  {
//#line  18869
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  18871
  cval = (struct usb_mixer_elem_info *)tmp___0;
  }
//#line  18873
  if (! cval) {
    {
//#line  18875
    printk(str_680563518);
    }
//#line  18877
    return;
  }
//#line  18880
  cval->mixer = state->mixer;
//#line  18882
  cval->id = (unsigned int )unitid;
//#line  18884
  cval->control = (unsigned int )control;
//#line  18886
  cval->cmask = ctl_mask;
//#line  18888
  cval->val_type = (int )audio_feature_info[control - 1].type;
//#line  18890
  if (ctl_mask == 0U) {
//#line  18892
    cval->channels = 1;
  } else {
//#line  18895
    c = 0;
//#line  18897
    i = 0;
    {
    {
//#line  18899
    while (1) {


      if (! (i < 16)) {
//#line  18899
        goto while_break;
      }
//#line  18901
      if (ctl_mask & (unsigned int )(1 << i)) {
//#line  18903
        c ++;
      }
//#line  18906
      i ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
//#line  18909
    cval->channels = c;
  }
  {
//#line  18912
  get_min_max(cval, 0);
//#line  18914
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& usb_feature_unit_ctl),
                      (void *)cval);
  }
//#line  18917
  if (! kctl) {
    {
//#line  18919
    printk(str_680563518);
//#line  18921
    kfree((void const   *)cval);
    }
//#line  18923
    return;
  }
  {
//#line  18926
  kctl->private_free = & usb_mixer_elem_free;
//#line  18928
  tmp___1 = check_mapped_name(state, unitid, control, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  18931
  len = (unsigned int )tmp___1;
//#line  18933
  mapped_name = len != 0U;
  }
//#line  18935
  if (! len) {
//#line  18937
    if (nameid) {
      {
//#line  18939
      tmp___2 = snd_usb_copy_string_desc(state, nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                         (int )sizeof(kctl->id.name));
//#line  18942
      len = (unsigned int )tmp___2;
      }
    }
  }
  {
  if (control == 1) {
//#line  18947
    goto case_1;
  }
  if (control == 2) {
//#line  18948
    goto case_1;
  }
//#line  19009
  goto switch_default;
  case_1: /* CIL Label */ 
//#line  18950
  if (! len) {
    {
//#line  18952
    tmp___3 = get_term_name(state, iterm, kctl->id.name, (int )sizeof(kctl->id.name),
                            1);
//#line  18955
    len = (unsigned int )tmp___3;
    }
//#line  18957
    if (! len) {
      {
//#line  18959
      tmp___4 = get_term_name(state, & state->oterm, kctl->id.name, (int )sizeof(kctl->id.name),
                              1);
//#line  18962
      len = (unsigned int )tmp___4;
      }
    }
//#line  18965
    if (! len) {
      {
//#line  18967
      tmp___5 = sprintf((char *)(kctl->id.name), str_532616561, unitid);
//#line  18969
      len = (unsigned int )tmp___5;
      }
    }
  }
//#line  18973
  if (! mapped_name) {
//#line  18975
    if (! (state->oterm.type >> 16)) {
//#line  18977
      if ((state->oterm.type & 65280) == 256) {
        {
//#line  18979
        tmp___6 = strlcat((char *)(kctl->id.name), str_873074482, sizeof(kctl->id.name));
//#line  18981
        len = (unsigned int )tmp___6;
        }
      } else {
        {
//#line  18984
        tmp___7 = strlcat((char *)(kctl->id.name + len), str_772338763, sizeof(kctl->id.name));
//#line  18986
        len = (unsigned int )tmp___7;
        }
      }
    }
  }
//#line  18991
  if (control == 1) {
//#line  18993
    tmp___8 = str_653514840;
  } else {
//#line  18996
    tmp___8 = str_659921694;
  }
  {
//#line  18999
  strlcat((char *)(kctl->id.name + len), tmp___8, sizeof(kctl->id.name));
  }
//#line  19001
  if (control == 2) {
//#line  19003
    kctl->tlv.c = & mixer_vol_tlv;
//#line  19005
    kctl->vd[0].access |= (unsigned int )((1 << 4) | (1 << 28));
  }
//#line  19008
  goto switch_break;
  switch_default: /* CIL Label */ 
//#line  19011
  if (! len) {
    {
//#line  19013
    strlcpy((char *)(kctl->id.name), (char const   *)audio_feature_info[control - 1].name,
            sizeof(kctl->id.name));
    }
  }
//#line  19017
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  if ((int )(state->chip)->usb_id == ((1137 << 16) | 257)) {
//#line  19021
    goto case_exp;
  }
  if ((int )(state->chip)->usb_id == ((1137 << 16) | 260)) {
//#line  19022
    goto case_exp;
  }
  if ((int )(state->chip)->usb_id == ((1137 << 16) | 261)) {
//#line  19023
    goto case_exp;
  }
  if ((int )(state->chip)->usb_id == ((1650 << 16) | 4161)) {
//#line  19024
    goto case_exp;
  }
//#line  19020
  goto switch_break___0;
  case_exp: /* CIL Label */ 
  {
//#line  19026
  tmp___9 = strcmp((char const   *)(kctl->id.name), str_88429757);
  }
//#line  19028
  if (! tmp___9) {
//#line  19030
    if (cval->min == -15616) {
      {
//#line  19032
      printk(str_647061483);
//#line  19034
      cval->max = -256;
      }
    }
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
//#line  19039
  add_control_to_empty(state, kctl);
  }
//#line  19041
  return;
}
}
//#line  19045 "usb-audio.merged.sym.c"
static int parse_audio_feature_unit(struct mixer_build *state , int unitid , unsigned char *ftr ) 
{ 
  int channels ;
  int i ;
  int j ;
  struct usb_audio_term iterm ;
  unsigned int master_bits ;
  unsigned int first_ch_bits ;
  int err ;
  int csize ;
  int tmp ;
  unsigned int ch_bits ;
  unsigned int mask ;
  unsigned int tmp___0 ;

  {
  record_function("parse_audio_feature_unit");
//#line  19062
  if ((int )*(ftr + 0) < 7) {
    {
//#line  19064
    printk(str_758343632, unitid);
    }
//#line  19066
    return (-22);
  } else {
//#line  19069
    csize = (int )*(ftr + 5);
//#line  19071
    if (csize) {
//#line  19073
      if ((int )*(ftr + 0) < 7 + csize) {
        {
//#line  19075
        printk(str_758343632, unitid);
        }
//#line  19077
        return (-22);
      }
    } else {
      {
//#line  19081
      printk(str_758343632, unitid);
      }
//#line  19083
      return (-22);
    }
  }
  {
//#line  19087
  err = parse_audio_unit(state, (int )*(ftr + 4));
  }
//#line  19089
  if (err < 0) {
//#line  19091
    return (err);
  }
  {
//#line  19094
  tmp = check_input_term(state, (int )*(ftr + 4), & iterm);
  }
//#line  19096
  if (tmp < 0) {
//#line  19098
    return (-22);
  }
  {
//#line  19101
  channels = ((int )*(ftr + 0) - 7) / csize - 1;
//#line  19103
  master_bits = snd_usb_combine_bytes(ftr + 6, csize);
  }
//#line  19105
  if (channels > 0) {
    {
//#line  19107
    first_ch_bits = snd_usb_combine_bytes((ftr + 6) + csize, csize);
    }
  } else {
//#line  19110
    first_ch_bits = 0U;
  }
//#line  19113
  i = 0;
  {
  {
//#line  19115
  while (1) {


    if (! (i < 10)) {
//#line  19115
      goto while_break;
    }
//#line  19117
    ch_bits = 0U;
//#line  19119
    j = 0;
    {
    {
//#line  19121
    while (1) {


      if (! (j < channels)) {
//#line  19121
        goto while_break___0;
      }
      {
//#line  19123
      tmp___0 = snd_usb_combine_bytes((ftr + 6) + csize * (j + 1), csize);
//#line  19125
      mask = tmp___0;
      }
//#line  19127
      if (mask & (unsigned int )(1 << i)) {
//#line  19129
        ch_bits |= (unsigned int )(1 << j);
      }
//#line  19132
      j ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  19135
    if (ch_bits & 1U) {
      {
//#line  19137
      build_feature_ctl(state, ftr, ch_bits, i, & iterm, unitid);
      }
    }
//#line  19140
    if (master_bits & (unsigned int )(1 << i)) {
      {
//#line  19142
      build_feature_ctl(state, ftr, 0U, i, & iterm, unitid);
      }
    }
//#line  19145
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  19148
  return (0);
}
}
//#line  19152 "usb-audio.merged.sym.c"
static void build_mixer_unit_ctl(struct mixer_build *state , unsigned char *desc ,
                                 int in_pin , int in_ch , int unitid , struct usb_audio_term *iterm ) 
{ 
  struct usb_mixer_elem_info *cval ;
  unsigned int input_pins ;
  unsigned int num_outs ;
  unsigned int i ;
  unsigned int len ;
  struct snd_kcontrol *kctl ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  record_function("build_mixer_unit_ctl");
  {
//#line  19170
  input_pins = (unsigned int )*(desc + 4);
//#line  19172
  num_outs = (unsigned int )*(desc + (5U + input_pins));
//#line  19174
  tmp = check_ignored_ctl(state, unitid, 0);
  }
//#line  19176
  if (tmp) {
//#line  19178
    return;
  }
  {
//#line  19181
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  19183
  cval = (struct usb_mixer_elem_info *)tmp___0;
  }
//#line  19185
  if (! cval) {
//#line  19187
    return;
  }
//#line  19190
  cval->mixer = state->mixer;
//#line  19192
  cval->id = (unsigned int )unitid;
//#line  19194
  cval->control = (unsigned int )(in_ch + 1);
//#line  19196
  cval->val_type = 4;
//#line  19198
  i = 0U;
  {
  {
//#line  19200
  while (1) {


    if (! (i < num_outs)) {
//#line  19200
      goto while_break;
    }
    {
//#line  19202
    tmp___1 = check_matrix_bitmap((desc + 9) + input_pins, in_ch, (int )i, (int )num_outs);
    }
//#line  19204
    if (tmp___1) {
//#line  19206
      cval->cmask |= (unsigned int )(1 << i);
//#line  19208
      (cval->channels) ++;
    }
//#line  19211
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  19214
  get_min_max(cval, 0);
//#line  19216
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& usb_feature_unit_ctl),
                      (void *)cval);
  }
//#line  19219
  if (! kctl) {
    {
//#line  19221
    printk(str_680563518);
//#line  19223
    kfree((void const   *)cval);
    }
//#line  19225
    return;
  }
  {
//#line  19228
  kctl->private_free = & usb_mixer_elem_free;
//#line  19230
  tmp___2 = check_mapped_name(state, unitid, 0, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  19233
  len = (unsigned int )tmp___2;
  }
//#line  19235
  if (! len) {
    {
//#line  19237
    tmp___3 = get_term_name(state, iterm, kctl->id.name, (int )sizeof(kctl->id.name),
                            0);
//#line  19240
    len = (unsigned int )tmp___3;
    }
  }
//#line  19243
  if (! len) {
    {
//#line  19245
    tmp___4 = sprintf((char *)(kctl->id.name), str_1028937, in_ch + 1);
//#line  19247
    len = (unsigned int )tmp___4;
    }
  }
  {
//#line  19250
  strlcat((char *)(kctl->id.name + len), str_659921694, sizeof(kctl->id.name));
//#line  19252
  add_control_to_empty(state, kctl);
  }
//#line  19254
  return;
}
}
//#line  19258 "usb-audio.merged.sym.c"
static int parse_audio_mixer_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  struct usb_audio_term iterm ;
  int input_pins ;
  int num_ins ;
  int num_outs ;
  int pin ;
  int ich ;
  int err ;
  int och ;
  int ich_has_controls ;
  int tmp ;

  {
  record_function("parse_audio_mixer_unit");
//#line  19273
  if ((int )*(desc + 0) < 11) {
    {
//#line  19275
    printk(str_757471119, unitid);
    }
//#line  19277
    return (-22);
  } else {
//#line  19280
    input_pins = (int )*(desc + 4);
//#line  19282
    if (input_pins) {
//#line  19284
      num_outs = (int )*(desc + (5 + input_pins));
//#line  19286
      if (! num_outs) {
        {
//#line  19288
        printk(str_757471119, unitid);
        }
//#line  19290
        return (-22);
      }
    } else {
      {
//#line  19294
      printk(str_757471119, unitid);
      }
//#line  19296
      return (-22);
    }
  }
//#line  19300
  if ((int )*(desc + 0) <= 10 + input_pins) {
//#line  19302
    return (0);
  }
//#line  19305
  num_ins = 0;
//#line  19307
  ich = 0;
//#line  19309
  pin = 0;
  {
  {
//#line  19311
  while (1) {


    if (! (pin < input_pins)) {
//#line  19311
      goto while_break;
    }
    {
//#line  19313
    err = parse_audio_unit(state, (int )*(desc + (5 + pin)));
    }
//#line  19315
    if (err < 0) {
//#line  19317
      return (err);
    }
    {
//#line  19320
    err = check_input_term(state, (int )*(desc + (5 + pin)), & iterm);
    }
//#line  19322
    if (err < 0) {
//#line  19324
      return (err);
    }
//#line  19327
    num_ins += iterm.channels;
    {
    {
//#line  19329
    while (1) {


      if (! (ich < num_ins)) {
//#line  19329
        goto while_break___0;
      }
//#line  19331
      ich_has_controls = 0;
//#line  19333
      och = 0;
      {
      {
//#line  19335
      while (1) {


        if (! (och < num_outs)) {
//#line  19335
          goto while_break___1;
        }
        {
//#line  19337
        tmp = check_matrix_bitmap((desc + 9) + input_pins, ich, och, num_outs);
        }
//#line  19339
        if (tmp) {
//#line  19341
          ich_has_controls = 1;
//#line  19343
          goto while_break___1;
        }
//#line  19346
        och ++;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
//#line  19349
      if (ich_has_controls) {
        {
//#line  19351
        build_mixer_unit_ctl(state, desc, pin, ich, unitid, & iterm);
        }
      }
//#line  19354
      ich ++;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  19357
    pin ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  19360
  return (0);
}
}
//#line  19364 "usb-audio.merged.sym.c"
static int mixer_ctl_procunit_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int err ;
  int val ;

  {
  record_function("mixer_ctl_procunit_get");
  {
//#line  19372
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  19374
  err = get_cur_ctl_value(cval, (int )(cval->control << 8), & val);
  }
//#line  19376
  if (err < 0) {
//#line  19378
    if ((cval->mixer)->ignore_ctl_error) {
//#line  19380
      ucontrol->value.integer.value[0] = (long )cval->min;
//#line  19382
      return (0);
    }
  }
//#line  19386
  if (err < 0) {
//#line  19388
    return (err);
  }
  {
//#line  19391
  val = get_relative_value(cval, val);
//#line  19393
  ucontrol->value.integer.value[0] = (long )val;
  }
//#line  19395
  return (0);
}
}
//#line  19399 "usb-audio.merged.sym.c"
static int mixer_ctl_procunit_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int oval ;
  int err ;

  {
  record_function("mixer_ctl_procunit_put");
  {
//#line  19408
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  19410
  err = get_cur_ctl_value(cval, (int )(cval->control << 8), & oval);
  }
//#line  19412
  if (err < 0) {
//#line  19414
    if ((cval->mixer)->ignore_ctl_error) {
//#line  19416
      return (0);
    }
//#line  19419
    return (err);
  }
  {
//#line  19422
  val = (int )ucontrol->value.integer.value[0];
//#line  19424
  val = get_abs_value(cval, val);
  }
//#line  19426
  if (val != oval) {
    {
//#line  19428
    set_cur_ctl_value(cval, (int )(cval->control << 8), val);
    }
//#line  19430
    return (1);
  }
//#line  19433
  return (0);
}
}
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) mixer_procunit_ctl  = 
//#line  19437
     {2, 0U, 0U, (unsigned char *)str_0, 0U, 0U, 0U, & mixer_ctl_feature_info, & mixer_ctl_procunit_get,
    & mixer_ctl_procunit_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  19442 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) updown_proc_info)[3]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_923436265, 3, 1}, 
        {0, (char *)0, 0, 0}};
//#line  19447 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) prologic_proc_info)[3]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_923436265, 3, 1}, 
        {0, (char *)0, 0, 0}};
//#line  19452 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) threed_enh_proc_info)[3]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_225760646, 3, 0}, 
        {0, (char *)0, 0, 0}};
//#line  19457 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) reverb_proc_info)[5]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_10641780, 3, 0}, 
        {3, (char *)str_616233, 5, 0}, 
        {4, (char *)str_9595539, 3, 0}, 
        {0, (char *)0, 0, 0}};
//#line  19464 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) chorus_proc_info)[5]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_10641780, 3, 0}, 
        {3, (char *)str_599760, 5, 0}, 
        {4, (char *)str_9597327, 5, 0}, 
        {0, (char *)0, 0, 0}};
//#line  19471 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) dcr_proc_info)[7]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {2, (char *)str_11395627, 5, 0}, 
        {3, (char *)str_657372624, 4, 0}, 
        {4, (char *)str_497625127, 4, 0}, 
        {5, (char *)str_229836041, 5, 0}, 
        {6, (char *)str_96862090, 5, 0}, 
        {0, (char *)0, 0, 0}};
//#line  19480 "usb-audio.merged.sym.c"
static struct procunit_info ( __attribute__((__noderef__, __address_space__(2))) procunits)[7]  = {      {1,
      (char *)str_1059676627, (struct procunit_value_info *)(updown_proc_info)}, 
        {2, (char *)str_468492697, (struct procunit_value_info *)(prologic_proc_info)}, 
        {3,
      (char *)str_168675912, (struct procunit_value_info *)(threed_enh_proc_info)}, 
        {4,
      (char *)str_217050626, (struct procunit_value_info *)(reverb_proc_info)}, 
        {5, (char *)str_180256858, (struct procunit_value_info *)(chorus_proc_info)}, 
        {6,
      (char *)str_25903, (struct procunit_value_info *)(dcr_proc_info)}, 
        {0, (char *)0, (struct procunit_value_info *)0}};
//#line  19491
static int build_audio_procunit(struct mixer_build *state , int unitid , unsigned char *dsc ,
                                struct procunit_info *list , char *name ) ;
//#line  19494 "usb-audio.merged.sym.c"
static struct procunit_value_info ( __attribute__((__noderef__, __address_space__(2))) default_value_info)[2]  = {      {1,
      (char *)str_221788472, 0, 0}, 
        {0, (char *)0, 0, 0}};
//#line  19498 "usb-audio.merged.sym.c"
static struct procunit_info  __attribute__((__noderef__, __address_space__(2))) default_info  =    {0,
    (char *)((void *)0), (struct procunit_value_info *)(default_value_info)};
//#line  19501 "usb-audio.merged.sym.c"
static int build_audio_procunit(struct mixer_build *state , int unitid , unsigned char *dsc ,
                                struct procunit_info *list , char *name ) 
{ 
  int num_ins ;
  struct usb_mixer_elem_info *cval ;
  struct snd_kcontrol *kctl ;
  int i ;
  int err ;
  int nameid ;
  int type ;
  int len ;
  struct procunit_info *info ;
  struct procunit_value_info *valinfo ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  record_function("build_audio_procunit");
//#line  19520
  num_ins = (int )*(dsc + 6);
//#line  19522
  if ((int )*(dsc + 0) < 13) {
    {
//#line  19524
    printk(str_981956828, name, unitid);
    }
//#line  19526
    return (-22);
  } else
//#line  19529
  if ((int )*(dsc + 0) < 13 + num_ins) {
    {
//#line  19531
    printk(str_981956828, name, unitid);
    }
//#line  19533
    return (-22);
  } else
//#line  19536
  if ((int )*(dsc + 0) < num_ins + (int )*(dsc + (11 + num_ins))) {
    {
//#line  19538
    printk(str_981956828, name, unitid);
    }
//#line  19540
    return (-22);
  }
//#line  19543
  i = 0;
  {
  {
//#line  19545
  while (1) {


    if (! (i < num_ins)) {
//#line  19545
      goto while_break;
    }
    {
//#line  19547
    err = parse_audio_unit(state, (int )*(dsc + (7 + i)));
    }
//#line  19549
    if (err < 0) {
//#line  19551
      return (err);
    }
//#line  19554
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  19557
  type = (int )((unsigned int )*(dsc + 4) | ((unsigned int )*((dsc + 4) + 1) << 8));
//#line  19559
  info = list;
  {
  {
//#line  19561
  while (1) {


//#line  19563
    if (info) {
//#line  19565
      if (! info->type) {
//#line  19567
        goto while_break___0;
      }
    } else {
//#line  19571
      goto while_break___0;
    }
//#line  19574
    if (info->type == type) {
//#line  19576
      goto while_break___0;
    }
//#line  19579
    info ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  19582
  if (! info) {
//#line  19584
    info = (struct procunit_info *)(& default_info);
  } else
//#line  19587
  if (! info->type) {
//#line  19589
    info = (struct procunit_info *)(& default_info);
  }
//#line  19592
  valinfo = info->values;
  {
  {
//#line  19594
  while (1) {


    if (! valinfo->control) {
//#line  19594
      goto while_break___1;
    }
//#line  19596
    if (! ((int )*(dsc + (12 + num_ins)) & (1 << (valinfo->control - 1)))) {
//#line  19598
      goto __Cont;
    }
    {
//#line  19601
    tmp = check_ignored_ctl(state, unitid, valinfo->control);
    }
//#line  19603
    if (tmp) {
//#line  19605
      goto __Cont;
    }
    {
//#line  19608
    tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  19610
    cval = (struct usb_mixer_elem_info *)tmp___0;
    }
//#line  19612
    if (! cval) {
      {
//#line  19614
      printk(str_680563518);
      }
//#line  19616
      return (-12);
    }
//#line  19619
    cval->mixer = state->mixer;
//#line  19621
    cval->id = (unsigned int )unitid;
//#line  19623
    cval->control = (unsigned int )valinfo->control;
//#line  19625
    cval->val_type = valinfo->val_type;
//#line  19627
    cval->channels = 1;
//#line  19629
    if (type == 1) {
//#line  19631
      if (cval->control == 2U) {
//#line  19633
        cval->min = 1;
//#line  19635
        cval->max = (int )*(dsc + 15);
//#line  19637
        cval->res = 1;
//#line  19639
        cval->initialized = (u8 )1;
      } else {
        {
//#line  19642
        get_min_max(cval, valinfo->min_value);
        }
      }
    } else {
      {
//#line  19646
      get_min_max(cval, valinfo->min_value);
      }
    }
    {
//#line  19649
    kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& mixer_procunit_ctl),
                        (void *)cval);
    }
//#line  19652
    if (! kctl) {
      {
//#line  19654
      printk(str_680563518);
//#line  19656
      kfree((void const   *)cval);
      }
//#line  19658
      return (-12);
    }
    {
//#line  19661
    kctl->private_free = & usb_mixer_elem_free;
//#line  19663
    tmp___1 = check_mapped_name(state, unitid, (int )cval->control, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                (int )sizeof(kctl->id.name));
    }
//#line  19666
    if (! tmp___1) {
//#line  19668
      if (info->name) {
        {
//#line  19670
        strlcpy((char *)(kctl->id.name), (char const   *)info->name, sizeof(kctl->id.name));
        }
      } else {
//#line  19673
        nameid = (int )*(dsc + ((12 + num_ins) + (int )*(dsc + (11 + num_ins))));
//#line  19675
        len = 0;
//#line  19677
        if (nameid) {
          {
//#line  19679
          len = snd_usb_copy_string_desc(state, nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                                         (int )sizeof(kctl->id.name));
          }
        }
//#line  19683
        if (! len) {
          {
//#line  19685
          strlcpy((char *)(kctl->id.name), (char const   *)name, sizeof(kctl->id.name));
          }
        }
      }
    }
    {
//#line  19690
    strlcat((char *)(kctl->id.name), str_32, sizeof(kctl->id.name));
//#line  19692
    strlcat((char *)(kctl->id.name), (char const   *)valinfo->suffix, sizeof(kctl->id.name));
//#line  19694
    err = add_control_to_empty(state, kctl);
    }
//#line  19696
    if (err < 0) {
//#line  19698
      return (err);
    }
    __Cont: 
//#line  19702
    valinfo ++;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  19705
  return (0);
}
}
//#line  19709 "usb-audio.merged.sym.c"
static int parse_audio_processing_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  int tmp ;

  {
  record_function("parse_audio_processing_unit");
  {
//#line  19715
  tmp = build_audio_procunit(state, unitid, desc, (struct procunit_info *)(procunits),
                             (char *)str_870290969);
  }
//#line  19718
  return (tmp);
}
}
//#line  19722 "usb-audio.merged.sym.c"
static int parse_audio_extension_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  int tmp ;

  {
  record_function("parse_audio_extension_unit");
  {
//#line  19728
  tmp = build_audio_procunit(state, unitid, desc, (struct procunit_info *)((void *)0),
                             (char *)str_400614853);
  }
//#line  19731
  return (tmp);
}
}
//#line  19735 "usb-audio.merged.sym.c"
static int mixer_ctl_selector_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct usb_mixer_elem_info *cval ;
  char **itemlist ;
  int tmp ;

  {
  record_function("mixer_ctl_selector_info");
  {
//#line  19743
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  19745
  itemlist = (char **)kcontrol->private_value;
//#line  19747
  tmp = __snd_bug_on(0);
  }
//#line  19749
  if (tmp) {
//#line  19751
    return (-22);
  }
//#line  19754
  uinfo->type = 3;
//#line  19756
  uinfo->count = 1U;
//#line  19758
  uinfo->value.enumerated.items = (unsigned int )cval->max;
//#line  19760
  if ((int )uinfo->value.enumerated.item >= cval->max) {
//#line  19762
    uinfo->value.enumerated.item = (unsigned int )(cval->max - 1);
  }
  {
//#line  19765
  strcpy(uinfo->value.enumerated.name, (char const   *)*(itemlist + uinfo->value.enumerated.item));
  }
//#line  19767
  return (0);
}
}
//#line  19771 "usb-audio.merged.sym.c"
static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int err ;

  {
  record_function("mixer_ctl_selector_get");
  {
//#line  19779
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  19781
  err = get_cur_ctl_value(cval, 0, & val);
  }
//#line  19783
  if (err < 0) {
//#line  19785
    if ((cval->mixer)->ignore_ctl_error) {
//#line  19787
      ucontrol->value.enumerated.item[0] = 0U;
//#line  19789
      return (0);
    }
//#line  19792
    return (err);
  }
  {
//#line  19795
  val = get_relative_value(cval, val);
//#line  19797
  ucontrol->value.enumerated.item[0] = (unsigned int )val;
  }
//#line  19799
  return (0);
}
}
//#line  19803 "usb-audio.merged.sym.c"
static int mixer_ctl_selector_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_elem_info *cval ;
  int val ;
  int oval ;
  int err ;

  {
  record_function("mixer_ctl_selector_put");
  {
//#line  19812
  cval = (struct usb_mixer_elem_info *)kcontrol->private_data;
//#line  19814
  err = get_cur_ctl_value(cval, 0, & oval);
  }
//#line  19816
  if (err < 0) {
//#line  19818
    if ((cval->mixer)->ignore_ctl_error) {
//#line  19820
      return (0);
    }
//#line  19823
    return (err);
  }
  {
//#line  19826
  val = (int )ucontrol->value.enumerated.item[0];
//#line  19828
  val = get_abs_value(cval, val);
  }
//#line  19830
  if (val != oval) {
    {
//#line  19832
    set_cur_ctl_value(cval, 0, val);
    }
//#line  19834
    return (1);
  }
//#line  19837
  return (0);
}
}
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) mixer_selectunit_ctl  = 
//#line  19841
     {2, 0U, 0U, (unsigned char *)str_0, 0U, 0U, 0U, & mixer_ctl_selector_info, & mixer_ctl_selector_get,
    & mixer_ctl_selector_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  19846 "usb-audio.merged.sym.c"
static void usb_mixer_selector_elem_free(struct snd_kcontrol *kctl ) 
{ 
  int i ;
  int num_ins ;
  struct usb_mixer_elem_info *cval ;
  char **itemlist ;

  {
  record_function("usb_mixer_selector_elem_free");
//#line  19855
  num_ins = 0;
//#line  19857
  if (kctl->private_data) {
    {
//#line  19859
    cval = (struct usb_mixer_elem_info *)kctl->private_data;
//#line  19861
    num_ins = cval->max;
//#line  19863
    kfree((void const   *)cval);
//#line  19865
    kctl->private_data = (char *)((void *)0);
    }
  }
//#line  19868
  if (kctl->private_value) {
//#line  19870
    itemlist = (char **)kctl->private_value;
//#line  19872
    i = 0;
    {
    {
//#line  19874
    while (1) {


      if (! (i < num_ins)) {
//#line  19874
        goto while_break;
      }
      {
//#line  19876
      kfree((void const   *)*(itemlist + i));
//#line  19878
      i ++;
      }
    }

    }
    while_break: /* CIL Label */ ;
    }
    {
//#line  19881
    kfree((void const   *)itemlist);
//#line  19883
    kctl->private_value = 0UL;
    }
  }
//#line  19886
  return;
}
}
//#line  19890 "usb-audio.merged.sym.c"
static int parse_audio_selector_unit(struct mixer_build *state , int unitid , unsigned char *desc ) 
{ 
  unsigned int num_ins ;
  unsigned int i ;
  unsigned int nameid ;
  unsigned int len ;
  int err ;
  struct usb_mixer_elem_info *cval ;
  struct snd_kcontrol *kctl ;
  char **namelist ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct usb_audio_term iterm ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  record_function("parse_audio_selector_unit");
//#line  19914
  num_ins = (unsigned int )*(desc + 4);
//#line  19916
  if (! num_ins) {
    {
//#line  19918
    printk(str_761039825, unitid);
    }
//#line  19920
    return (-22);
  } else
//#line  19923
  if ((unsigned int )*(desc + 0) < 5U + num_ins) {
    {
//#line  19925
    printk(str_761039825, unitid);
    }
//#line  19927
    return (-22);
  }
//#line  19930
  i = 0U;
  {
  {
//#line  19932
  while (1) {


    if (! (i < num_ins)) {
//#line  19932
      goto while_break;
    }
    {
//#line  19934
    err = parse_audio_unit(state, (int )*(desc + (5U + i)));
    }
//#line  19936
    if (err < 0) {
//#line  19938
      return (err);
    }
//#line  19941
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  19944
  if (num_ins == 1U) {
//#line  19946
    return (0);
  }
  {
//#line  19949
  tmp = check_ignored_ctl(state, unitid, 0);
  }
//#line  19951
  if (tmp) {
//#line  19953
    return (0);
  }
  {
//#line  19956
  tmp___0 = kzalloc(sizeof(*cval), 208U);
//#line  19958
  cval = (struct usb_mixer_elem_info *)tmp___0;
  }
//#line  19960
  if (! cval) {
    {
//#line  19962
    printk(str_680563518);
    }
//#line  19964
    return (-12);
  }
  {
//#line  19967
  cval->mixer = state->mixer;
//#line  19969
  cval->id = (unsigned int )unitid;
//#line  19971
  cval->val_type = 3;
//#line  19973
  cval->channels = 1;
//#line  19975
  cval->min = 1;
//#line  19977
  cval->max = (int )num_ins;
//#line  19979
  cval->res = 1;
//#line  19981
  cval->initialized = (u8 )1;
//#line  19983
  tmp___1 = kmalloc(sizeof(char *) * (unsigned long )num_ins, 208U);
//#line  19985
  namelist = (char **)tmp___1;
  }
//#line  19987
  if (! namelist) {
    {
//#line  19989
    printk(str_967653936);
//#line  19991
    kfree((void const   *)cval);
    }
//#line  19993
    return (-12);
  }
//#line  19996
  i = 0U;
  {
  {
//#line  19998
  while (1) {


    if (! (i < num_ins)) {
//#line  19998
      goto while_break___0;
    }
    {
//#line  20000
    len = 0U;
//#line  20002
    tmp___2 = kmalloc((size_t )64, 208U);
//#line  20004
    *(namelist + i) = (char *)tmp___2;
    }
//#line  20006
    if (! *(namelist + i)) {
      {
//#line  20008
      printk(str_967653936);
      }
      {
      {
//#line  20010
      while (1) {


//#line  20012
        tmp___3 = i;
//#line  20014
        i --;
//#line  20016
        if (! tmp___3) {
//#line  20018
          goto while_break___1;
        }
        {
//#line  20021
        kfree((void const   *)*(namelist + i));
        }
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
//#line  20024
      kfree((void const   *)namelist);
//#line  20026
      kfree((void const   *)cval);
      }
//#line  20028
      return (-12);
    }
    {
//#line  20031
    tmp___4 = check_mapped_selector_name(state, unitid, (int )i, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )*(namelist + i),
                                         64);
//#line  20034
    len = (unsigned int )tmp___4;
    }
//#line  20036
    if (! len) {
      {
//#line  20038
      tmp___6 = check_input_term(state, (int )*(desc + (5U + i)), & iterm);
      }
//#line  20040
      if (tmp___6 >= 0) {
        {
//#line  20042
        tmp___5 = get_term_name(state, & iterm, (unsigned char *)*(namelist + i),
                                64, 0);
//#line  20045
        len = (unsigned int )tmp___5;
        }
      }
    }
//#line  20049
    if (! len) {
      {
//#line  20051
      sprintf(*(namelist + i), str_927843941, i);
      }
    }
//#line  20054
    i ++;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  20057
  kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& mixer_selectunit_ctl),
                      (void *)cval);
  }
//#line  20060
  if (! kctl) {
    {
//#line  20062
    printk(str_680563518);
//#line  20064
    kfree((void const   *)namelist);
//#line  20066
    kfree((void const   *)cval);
    }
//#line  20068
    return (-12);
  }
  {
//#line  20071
  kctl->private_value = (unsigned long )namelist;
//#line  20073
  kctl->private_free = & usb_mixer_selector_elem_free;
//#line  20075
  nameid = (unsigned int )*(desc + ((int )*(desc + 0) - 1));
//#line  20077
  tmp___7 = check_mapped_name(state, unitid, 0, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                              (int )sizeof(kctl->id.name));
//#line  20080
  len = (unsigned int )tmp___7;
  }
//#line  20082
  if (! len) {
//#line  20084
    if (nameid) {
      {
//#line  20086
      snd_usb_copy_string_desc(state, (int )nameid, (char * __attribute__((__exp__(Nonstub_return_buflen("buflen")))) )(kctl->id.name),
                               (int )sizeof(kctl->id.name));
      }
    } else {
      {
//#line  20090
      tmp___8 = get_term_name(state, & state->oterm, kctl->id.name, (int )sizeof(kctl->id.name),
                              0);
//#line  20093
      len = (unsigned int )tmp___8;
      }
//#line  20095
      if (! len) {
        {
//#line  20097
        strlcpy((char *)(kctl->id.name), str_32328, sizeof(kctl->id.name));
        }
      }
//#line  20100
      if ((state->oterm.type & 65280) == 256) {
        {
//#line  20102
        strlcat((char *)(kctl->id.name), str_983984005, sizeof(kctl->id.name));
        }
      } else {
        {
//#line  20105
        strlcat((char *)(kctl->id.name), str_508915848, sizeof(kctl->id.name));
        }
      }
    }
  }
  {
//#line  20110
  err = add_control_to_empty(state, kctl);
  }
//#line  20112
  if (err < 0) {
//#line  20114
    return (err);
  }
//#line  20117
  return (0);
}
}
//#line  20121 "usb-audio.merged.sym.c"
static int parse_audio_unit(struct mixer_build *state , int unitid ) 
{ 
  unsigned char *p1 ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  record_function("parse_audio_unit");
  {
//#line  20134
  tmp = test_and_set_bit(unitid, (unsigned long volatile   *)(state->unitbitmap));
  }
//#line  20136
  if (tmp) {
//#line  20138
    return (0);
  }
  {
//#line  20141
  tmp___0 = find_audio_control_unit(state, (unsigned char )unitid);
//#line  20143
  p1 = (unsigned char *)tmp___0;
  }
//#line  20145
  if (! p1) {
    {
//#line  20147
    printk(str_709717790, unitid);
    }
//#line  20149
    return (-22);
  }
  {
  if ((int )*(p1 + 2) == 2) {
//#line  20153
    goto case_2;
  }
  if ((int )*(p1 + 2) == 4) {
//#line  20156
    goto case_4;
  }
  if ((int )*(p1 + 2) == 5) {
//#line  20161
    goto case_5;
  }
  if ((int )*(p1 + 2) == 6) {
//#line  20166
    goto case_6;
  }
  if ((int )*(p1 + 2) == 7) {
//#line  20171
    goto case_7;
  }
  if ((int )*(p1 + 2) == 8) {
//#line  20176
    goto case_8;
  }
//#line  20181
  goto switch_default;
  case_2: /* CIL Label */ 
//#line  20155
  return (0);
  case_4: /* CIL Label */ 
  {
//#line  20158
  tmp___1 = parse_audio_mixer_unit(state, unitid, p1);
  }
//#line  20160
  return (tmp___1);
  case_5: /* CIL Label */ 
  {
//#line  20163
  tmp___2 = parse_audio_selector_unit(state, unitid, p1);
  }
//#line  20165
  return (tmp___2);
  case_6: /* CIL Label */ 
  {
//#line  20168
  tmp___3 = parse_audio_feature_unit(state, unitid, p1);
  }
//#line  20170
  return (tmp___3);
  case_7: /* CIL Label */ 
  {
//#line  20173
  tmp___4 = parse_audio_processing_unit(state, unitid, p1);
  }
//#line  20175
  return (tmp___4);
  case_8: /* CIL Label */ 
  {
//#line  20178
  tmp___5 = parse_audio_extension_unit(state, unitid, p1);
  }
//#line  20180
  return (tmp___5);
  switch_default: /* CIL Label */ 
  {
//#line  20183
  printk(str_133922991, unitid, (int )*(p1 + 2));
  }
//#line  20185
  return (-22);

  }
}
}
//#line  20190 "usb-audio.merged.sym.c"
static void snd_usb_mixer_free(struct usb_mixer_interface *mixer ) 
{ 


  {
  record_function("snd_usb_mixer_free");
  {
//#line  20196
  kfree((void const   *)mixer->id_elems);
  }
//#line  20198
  if (mixer->urb) {
    {
//#line  20200
    kfree((void const   *)(mixer->urb)->transfer_buffer);
//#line  20202
    usb_free_urb(mixer->urb);
    }
  }
  {
//#line  20205
  usb_free_urb(mixer->rc_urb);
//#line  20207
  kfree((void const   *)mixer->rc_setup_packet);
//#line  20209
  kfree((void const   *)mixer);
  }
//#line  20211
  return;
}
}
//#line  20215 "usb-audio.merged.sym.c"
static int snd_usb_mixer_dev_free(struct snd_device *device ) 
{ 
  struct usb_mixer_interface *mixer ;

  {
  record_function("snd_usb_mixer_dev_free");
  {
//#line  20221
  mixer = (struct usb_mixer_interface *)device->device_data;
//#line  20223
  snd_usb_mixer_free(mixer);
  }
//#line  20225
  return (0);
}
}
//#line  20229 "usb-audio.merged.sym.c"
static int snd_usb_mixer_controls(struct usb_mixer_interface *mixer ) 
{ 
  unsigned char *desc ;
  struct mixer_build state ;
  int err ;
  struct usbmix_ctl_map  const  *map ;
  struct usb_host_interface *hostif ;
  struct usb_interface *tmp ;
  void *tmp___0 ;

  {
  record_function("snd_usb_mixer_controls");
  {
//#line  20241
  tmp = usb_ifnum_to_if((struct usb_device  const  *)(mixer->chip)->dev, mixer->ctrlif);
//#line  20243
  hostif = tmp->altsetting + 0;
//#line  20245
  memset((void *)(& state), 0, sizeof(state));
//#line  20247
  state.chip = mixer->chip;
//#line  20249
  state.mixer = mixer;
//#line  20251
  state.buffer = (unsigned char * __attribute__((__expfld__(buflen))) )hostif->extra;
//#line  20253
  state.buflen = (unsigned int )hostif->extralen;
//#line  20255
  map = (struct usbmix_ctl_map  const  *)(usbmix_ctl_maps);
  }
  {
  {
//#line  20257
  while (1) {


    if (! map->id) {
//#line  20257
      goto while_break;
    }
//#line  20259
    if (map->id == (u32 const   )(state.chip)->usb_id) {
//#line  20261
      state.map = (struct usbmix_name_map  const  *)map->map;
//#line  20263
      state.selector_map = (struct usbmix_selector_map  const  *)map->selector_map;
//#line  20265
      mixer->ignore_ctl_error = (unsigned int )map->ignore_ctl_error;
//#line  20267
      goto while_break;
    }
//#line  20270
    map ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  20273
  desc = (unsigned char *)((void *)0);
  {
  {
//#line  20275
  while (1) {

    while_continue___0: /* CIL Label */ ;
    {
//#line  20277
    tmp___0 = snd_usb_find_csint_desc((void *)hostif->extra, hostif->extralen, (void *)desc,
                                      (u8 )3);
//#line  20280
    desc = (unsigned char *)tmp___0;
    }
//#line  20282
    if (! ((unsigned long )desc != (unsigned long )((void *)0))) {
//#line  20284
      goto while_break___0;
    }
//#line  20287
    if ((int )*(desc + 0) < 9) {
//#line  20289
      goto while_continue___0;
    }
    {
//#line  20292
    set_bit((unsigned int )*(desc + 3), (unsigned long volatile   *)(state.unitbitmap));
//#line  20294
    state.oterm.id = (int )*(desc + 3);
//#line  20296
    state.oterm.type = (int )((unsigned int )*(desc + 4) | ((unsigned int )*((desc + 4) + 1) << 8));
//#line  20298
    state.oterm.name = (int )*(desc + 8);
//#line  20300
    err = parse_audio_unit(& state, (int )*(desc + 7));
    }
//#line  20302
    if (err < 0) {
//#line  20304
      return (err);
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  20308
  return (0);
}
}
//#line  20312 "usb-audio.merged.sym.c"
static void snd_usb_mixer_notify_id(struct usb_mixer_interface *mixer , int unitid ) 
{ 
  struct usb_mixer_elem_info *info ;

  {
  record_function("snd_usb_mixer_notify_id");
//#line  20318
  info = *(mixer->id_elems + unitid);
  {
  {
//#line  20320
  while (1) {


    if (! info) {
//#line  20320
      goto while_break;
    }
    {
//#line  20322
    snd_ctl_notify((mixer->chip)->card, 1U, info->elem_id);
//#line  20324
    info = (struct usb_mixer_elem_info *)info->next_id_elem;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  20327
  return;
}
}
//#line  20331 "usb-audio.merged.sym.c"
static void snd_usb_mixer_memory_change(struct usb_mixer_interface *mixer , int unitid ) 
{ 


  {
  record_function("snd_usb_mixer_memory_change");
//#line  20337
  if (! mixer->rc_cfg) {
//#line  20339
    return;
  }
  {
  if (unitid == 0) {
//#line  20343
    goto case_0;
  }
  if (unitid == 4) {
//#line  20350
    goto case_4;
  }
  if (unitid == 7) {
//#line  20351
    goto case_4;
  }
  if (unitid == 19) {
//#line  20352
    goto case_4;
  }
  if (unitid == 20) {
//#line  20353
    goto case_4;
  }
  if (unitid == 3) {
//#line  20356
    goto case_3;
  }
//#line  20364
  goto switch_default;
  case_0: /* CIL Label */ 
  {
//#line  20345
  (mixer->rc_urb)->dev = (struct usb_device *)(mixer->chip)->dev;
//#line  20347
  usb_submit_urb(mixer->rc_urb, 32U);
  }
//#line  20349
  goto switch_break;
  case_4: /* CIL Label */ 
//#line  20355
  goto switch_break;
  case_3: /* CIL Label */ 
//#line  20358
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
    {
//#line  20360
    snd_usb_mixer_notify_id(mixer, (int )(mixer->rc_cfg)->mute_mixer_id);
    }
  }
//#line  20363
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
  {
//#line  20366
  while (1) {


//#line  20368
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  20371
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  20374
  return;
}
}
//#line  20378 "usb-audio.merged.sym.c"
static void snd_usb_mixer_status_complete(struct urb *urb ) 
{ 
  struct usb_mixer_interface *mixer ;
  u8 *buf ;
  int i ;

  {
  record_function("snd_usb_mixer_status_complete");
//#line  20386
  mixer = (struct usb_mixer_interface *)urb->context;
//#line  20388
  if (urb->status == 0) {
//#line  20390
    buf = urb->transfer_buffer;
//#line  20392
    i = urb->actual_length;
    {
    {
//#line  20394
    while (1) {


      if (! (i >= 2)) {
//#line  20394
        goto while_break;
      }
      {
      {
//#line  20396
      while (1) {


//#line  20398
        goto while_break___0;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
//#line  20401
      if (((int )*(buf + 0) & 15) != 0) {
//#line  20403
        goto __Cont;
      }
//#line  20406
      if (! ((int )*(buf + 0) & 64)) {
        {
//#line  20408
        snd_usb_mixer_notify_id(mixer, (int )*(buf + 1));
        }
      } else {
        {
//#line  20411
        snd_usb_mixer_memory_change(mixer, (int )*(buf + 1));
        }
      }
      __Cont: 
//#line  20415
      buf += 2;
//#line  20417
      i -= 2;
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
//#line  20421
  if (urb->status != -2) {
//#line  20423
    if (urb->status != -104) {
      {
//#line  20425
      urb->dev = (struct usb_device *)(mixer->chip)->dev;
//#line  20427
      usb_submit_urb(urb, 32U);
      }
    }
  }
//#line  20431
  return;
}
}
//#line  20435 "usb-audio.merged.sym.c"
static int snd_usb_mixer_status_create(struct usb_mixer_interface *mixer ) 
{ 
  struct usb_host_interface *hostif ;
  struct usb_endpoint_descriptor *ep ;
  void *transfer_buffer ;
  int buffer_length ;
  unsigned int epnum ;
  struct usb_interface *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
  record_function("snd_usb_mixer_status_create");
  {
//#line  20450
  tmp = usb_ifnum_to_if((struct usb_device  const  *)(mixer->chip)->dev, mixer->ctrlif);
//#line  20452
  hostif = tmp->altsetting + 0;
  }
//#line  20454
  if ((int )hostif->desc.bNumEndpoints < 1) {
//#line  20456
    return (0);
  }
  {
//#line  20459
  ep = & (hostif->endpoint + 0)->desc;
//#line  20461
  tmp___0 = usb_endpoint_dir_in((struct usb_endpoint_descriptor  const  *)ep);
  }
//#line  20463
  if (tmp___0) {
    {
//#line  20465
    tmp___1 = usb_endpoint_xfer_int((struct usb_endpoint_descriptor  const  *)ep);
    }
//#line  20467
    if (! tmp___1) {
//#line  20469
      return (0);
    }
  } else {
//#line  20473
    return (0);
  }
  {
//#line  20476
  tmp___2 = usb_endpoint_num((struct usb_endpoint_descriptor  const  *)ep);
//#line  20478
  epnum = (unsigned int )tmp___2;
//#line  20480
  buffer_length = (int )ep->wMaxPacketSize;
//#line  20482
  transfer_buffer = kmalloc((size_t )buffer_length, 208U);
  }
//#line  20484
  if (! transfer_buffer) {
//#line  20486
    return (-12);
  }
  {
//#line  20489
  mixer->urb = usb_alloc_urb(0, 208U);
  }
//#line  20491
  if (! mixer->urb) {
    {
//#line  20493
    kfree((void const   *)transfer_buffer);
    }
//#line  20495
    return (-12);
  }
  {
//#line  20498
  tmp___3 = __create_pipe((mixer->chip)->dev, epnum);
//#line  20500
  usb_fill_int_urb(mixer->urb, (mixer->chip)->dev, ((unsigned int )(1 << 30) | tmp___3) | 128U,
                   transfer_buffer, buffer_length, & snd_usb_mixer_status_complete,
                   (void *)mixer, (int )ep->bInterval);
//#line  20504
  usb_submit_urb(mixer->urb, 208U);
  }
//#line  20506
  return (0);
}
}
//#line  20510 "usb-audio.merged.sym.c"
static void snd_usb_soundblaster_remote_complete(struct urb *urb ) 
{ 
  struct usb_mixer_interface *mixer ;
  struct rc_config  const  *rc ;
  u32 code ;

  {
  record_function("snd_usb_soundblaster_remote_complete");
//#line  20518
  mixer = (struct usb_mixer_interface *)urb->context;
//#line  20520
  rc = mixer->rc_cfg;
//#line  20522
  if (urb->status < 0) {
//#line  20524
    return;
  } else
//#line  20527
  if (urb->actual_length < (int )rc->min_packet_length) {
//#line  20529
    return;
  }
//#line  20532
  code = (u32 )mixer->rc_buffer[rc->offset];
//#line  20534
  if ((int const   )rc->length == 2) {
//#line  20536
    code |= (unsigned int )((int )mixer->rc_buffer[(int const   )rc->offset + 1] << 8);
  }
//#line  20539
  if (code == (u32 )rc->mute_code) {
    {
//#line  20541
    snd_usb_mixer_notify_id(mixer, (int )rc->mute_mixer_id);
    }
  }
  {
//#line  20544
  mixer->rc_code = code;
//#line  20546
  __asm__  volatile   ("sfence": : : "memory");
//#line  20548
  __wake_up(& mixer->rc_waitq, 3U, 1, (void *)0);
  }
//#line  20550
  return;
}
}
//#line  20554 "usb-audio.merged.sym.c"
static int snd_usb_sbrc_hwdep_open(struct snd_hwdep *hw , struct file *file ) 
{ 
  struct usb_mixer_interface *mixer ;
  int tmp ;

  {
  record_function("snd_usb_sbrc_hwdep_open");
  {
//#line  20561
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  20563
  tmp = test_and_set_bit(0, (unsigned long volatile   *)(& mixer->rc_hwdep_open));
  }
//#line  20565
  if (tmp) {
//#line  20567
    return (-16);
  }
//#line  20570
  return (0);
}
}
//#line  20574 "usb-audio.merged.sym.c"
static int snd_usb_sbrc_hwdep_release(struct snd_hwdep *hw , struct file *file ) 
{ 
  struct usb_mixer_interface *mixer ;

  {
  record_function("snd_usb_sbrc_hwdep_release");
  {
//#line  20580
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  20582
  clear_bit(0, (unsigned long volatile   *)(& mixer->rc_hwdep_open));
//#line  20584
  __asm__  volatile   ("": : : "memory");
  }
//#line  20586
  return (0);
}
}
//#line  20590 "usb-audio.merged.sym.c"
static long snd_usb_sbrc_hwdep_read(struct snd_hwdep *hw , char *buf , long count ,
                                    loff_t *offset ) 
{ 
  struct usb_mixer_interface *mixer ;
  int err ;
  u32 rc_code ;
  int __ret ;
  wait_queue_t __wait ;
  struct task_struct *tmp ;
  unsigned long tmp___0 ;
  struct task_struct *tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  int __ret_pu ;
  char __pu_val ;
  int __ret_pu___0 ;
  u32 __pu_val___0 ;
  long tmp___4 ;

  {
  record_function("snd_usb_sbrc_hwdep_read");
//#line  20611
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  20613
  if (count != 1L) {
//#line  20615
    if (count != 4L) {
//#line  20617
      return (-22L);
    }
  }
  {
//#line  20621
  __ret = 0;
//#line  20623
  tmp___3 = __xchg(0UL, (void volatile   *)(& mixer->rc_code), (int )sizeof(mixer->rc_code));
//#line  20625
  rc_code = (u32 )tmp___3;
  }
//#line  20627
  if (! (rc_code != 0U)) {
    {
    {
//#line  20629
    while (1) {


      {
//#line  20631
      tmp = get_current();
//#line  20633
      __wait.flags = 0U;
//#line  20635
      __wait.private = (void *)tmp;
//#line  20637
      __wait.func = & autoremove_wake_function;
//#line  20639
      __wait.task_list.next = (struct list_head *)(& __wait.task_list);
//#line  20641
      __wait.task_list.prev = (struct list_head *)(& __wait.task_list);
      }
      {
      {
//#line  20643
      while (1) {


        {
//#line  20645
        prepare_to_wait(& mixer->rc_waitq, & __wait, 1);
//#line  20647
        tmp___0 = __xchg(0UL, (void volatile   *)(& mixer->rc_code), (int )sizeof(mixer->rc_code));
//#line  20649
        rc_code = (u32 )tmp___0;
        }
//#line  20651
        if (rc_code != 0U) {
//#line  20653
          goto while_break___0;
        }
        {
//#line  20656
        tmp___1 = get_current();
//#line  20658
        tmp___2 = signal_pending(tmp___1);
        }
//#line  20660
        if (! tmp___2) {
          {
//#line  20662
          schedule();
          }
//#line  20664
          goto __Cont;
        }
//#line  20667
        __ret = -512;
//#line  20669
        goto while_break___0;
        __Cont: ;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
      {
//#line  20673
      finish_wait(& mixer->rc_waitq, & __wait);
      }
//#line  20675
      goto while_break;
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
//#line  20679
  err = __ret;
//#line  20681
  if (err == 0) {
//#line  20683
    if (count == 1L) {
      {
//#line  20685
      might_fault();
//#line  20687
      __pu_val = (char )rc_code;
      }
      {
      if ((int )sizeof(*buf) == 1) {
//#line  20690
        goto case_1;
      }
      if ((int )sizeof(*buf) == 2) {
//#line  20696
        goto case_2;
      }
      if ((int )sizeof(*buf) == 4) {
//#line  20702
        goto case_4;
      }
      if ((int )sizeof(*buf) == 8) {
//#line  20708
        goto case_8;
      }
//#line  20714
      goto switch_default;
      case_1: /* CIL Label */ 
//#line  20692
      __asm__  volatile   ("call __put_user_"
                           "1": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  20695
      goto switch_break;
      case_2: /* CIL Label */ 
//#line  20698
      __asm__  volatile   ("call __put_user_"
                           "2": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  20701
      goto switch_break;
      case_4: /* CIL Label */ 
//#line  20704
      __asm__  volatile   ("call __put_user_"
                           "4": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  20707
      goto switch_break;
      case_8: /* CIL Label */ 
//#line  20710
      __asm__  volatile   ("call __put_user_"
                           "8": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  20713
      goto switch_break;
      switch_default: /* CIL Label */ 
//#line  20716
      __asm__  volatile   ("call __put_user_"
                           "X": "=a" (__ret_pu): "0" (__pu_val), "c" (buf): "ebx");
//#line  20719
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
//#line  20722
      err = __ret_pu;
    } else {
      {
//#line  20725
      might_fault();
//#line  20727
      __pu_val___0 = rc_code;
      }
      {
      if ((int )sizeof(*((u32 *)buf)) == 1) {
//#line  20730
        goto case_1___0;
      }
      if ((int )sizeof(*((u32 *)buf)) == 2) {
//#line  20736
        goto case_2___0;
      }
      if ((int )sizeof(*((u32 *)buf)) == 4) {
//#line  20742
        goto case_4___0;
      }
      if ((int )sizeof(*((u32 *)buf)) == 8) {
//#line  20748
        goto case_8___0;
      }
//#line  20754
      goto switch_default___0;
      case_1___0: /* CIL Label */ 
//#line  20732
      __asm__  volatile   ("call __put_user_"
                           "1": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  20735
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
//#line  20738
      __asm__  volatile   ("call __put_user_"
                           "2": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  20741
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
//#line  20744
      __asm__  volatile   ("call __put_user_"
                           "4": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  20747
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
//#line  20750
      __asm__  volatile   ("call __put_user_"
                           "8": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  20753
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
//#line  20756
      __asm__  volatile   ("call __put_user_"
                           "X": "=a" (__ret_pu___0): "0" (__pu_val___0), "c" ((u32 *)buf): "ebx");
//#line  20759
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
//#line  20762
      err = __ret_pu___0;
    }
  }
//#line  20766
  if (err < 0) {
//#line  20768
    tmp___4 = (long )err;
  } else {
//#line  20771
    tmp___4 = count;
  }
//#line  20774
  return (tmp___4);
}
}
//#line  20778 "usb-audio.merged.sym.c"
static unsigned int snd_usb_sbrc_hwdep_poll(struct snd_hwdep *hw , struct file *file ,
                                            poll_table *wait ) 
{ 
  struct usb_mixer_interface *mixer ;
  int tmp ;

  {
  record_function("snd_usb_sbrc_hwdep_poll");
  {
//#line  20786
  mixer = (struct usb_mixer_interface *)hw->private_data;
//#line  20788
  poll_wait(file, & mixer->rc_waitq, wait);
  }
//#line  20790
  if (mixer->rc_code) {
//#line  20792
    tmp = 65;
  } else {
//#line  20795
    tmp = 0;
  }
//#line  20798
  return ((unsigned int )tmp);
}
}
//#line  20802 "usb-audio.merged.sym.c"
static int snd_usb_soundblaster_remote_init(struct usb_mixer_interface *mixer ) 
{ 
  struct snd_hwdep *hwdep ;
  int err ;
  int len ;
  int i ;
  void *tmp ;
  unsigned int tmp___0 ;

  {
  record_function("snd_usb_soundblaster_remote_init");
//#line  20813
  i = 0;
  {
  {
//#line  20815
  while (1) {


    if (! ((unsigned long )i < sizeof(rc_configs) / sizeof(rc_configs[0]) + (sizeof(char [1]) - 1UL))) {
//#line  20815
      goto while_break;
    }
//#line  20817
    if (rc_configs[i].usb_id == (u32 const   )(mixer->chip)->usb_id) {
//#line  20819
      goto while_break;
    }
//#line  20822
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  20825
  if ((unsigned long )i >= sizeof(rc_configs) / sizeof(rc_configs[0]) + (sizeof(char [1]) - 1UL)) {
//#line  20827
    return (0);
  }
  {
//#line  20830
  mixer->rc_cfg = & rc_configs[i];
//#line  20832
  len = (int )(mixer->rc_cfg)->packet_length;
//#line  20834
  init_waitqueue_head(& mixer->rc_waitq);
//#line  20836
  err = snd_hwdep_new((mixer->chip)->card, (char *)str_238745560, 0, & hwdep);
  }
//#line  20839
  if (err < 0) {
//#line  20841
    return (err);
  }
  {
//#line  20844
  sprintf(hwdep->name, str_459503637, ((mixer->chip)->card)->shortname);
//#line  20846
  hwdep->iface = 15;
//#line  20848
  hwdep->private_data = (void *)mixer;
//#line  20850
  hwdep->ops.read = & snd_usb_sbrc_hwdep_read;
//#line  20852
  hwdep->ops.open = & snd_usb_sbrc_hwdep_open;
//#line  20854
  hwdep->ops.release = & snd_usb_sbrc_hwdep_release;
//#line  20856
  hwdep->ops.poll = & snd_usb_sbrc_hwdep_poll;
//#line  20858
  mixer->rc_urb = usb_alloc_urb(0, 208U);
  }
//#line  20860
  if (! mixer->rc_urb) {
//#line  20862
    return (-12);
  }
  {
//#line  20865
  tmp = kmalloc(sizeof(*(mixer->rc_setup_packet)), 208U);
//#line  20867
  mixer->rc_setup_packet = (struct usb_ctrlrequest *)tmp;
  }
//#line  20869
  if (! mixer->rc_setup_packet) {
    {
//#line  20871
    usb_free_urb(mixer->rc_urb);
//#line  20873
    mixer->rc_urb = (struct urb *)((void *)0);
    }
//#line  20875
    return (-12);
  }
  {
//#line  20878
  (mixer->rc_setup_packet)->bRequestType = (__u8 )((128 | (1 << 5)) | 1);
//#line  20880
  (mixer->rc_setup_packet)->bRequest = (__u8 )133;
//#line  20882
  (mixer->rc_setup_packet)->wValue = (__u16 )0;
//#line  20884
  (mixer->rc_setup_packet)->wIndex = (__u16 )0;
//#line  20886
  (mixer->rc_setup_packet)->wLength = (__u16 )len;
//#line  20888
  tmp___0 = __create_pipe((mixer->chip)->dev, 0U);
//#line  20890
  usb_fill_control_urb(mixer->rc_urb, (mixer->chip)->dev, ((unsigned int )(2 << 30) | tmp___0) | 128U,
                       (u8 *)mixer->rc_setup_packet, (void *)(mixer->rc_buffer), len,
                       & snd_usb_soundblaster_remote_complete, (void *)mixer);
  }
//#line  20894
  return (0);
}
}
//#line  20898 "usb-audio.merged.sym.c"
static int snd_audigy2nx_led_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_interface *mixer ;
  int index___0 ;

  {
  record_function("snd_audigy2nx_led_get");
//#line  20905
  mixer = (struct usb_mixer_interface *)kcontrol->private_data;
//#line  20907
  index___0 = (int )kcontrol->private_value;
//#line  20909
  ucontrol->value.integer.value[0] = (long )mixer->audigy2nx_leds[index___0];
//#line  20911
  return (0);
}
}
//#line  20915 "usb-audio.merged.sym.c"
static int snd_audigy2nx_led_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct usb_mixer_interface *mixer ;
  int index___0 ;
  int value ;
  int err ;
  int changed ;
  unsigned int tmp ;

  {
  record_function("snd_audigy2nx_led_put");
//#line  20926
  mixer = (struct usb_mixer_interface *)kcontrol->private_data;
//#line  20928
  index___0 = (int )kcontrol->private_value;
//#line  20930
  value = (int )ucontrol->value.integer.value[0];
//#line  20932
  if (value > 1) {
//#line  20934
    return (-22);
  }
  {
//#line  20937
  changed = value != (int )mixer->audigy2nx_leds[index___0];
//#line  20939
  tmp = __create_pipe((mixer->chip)->dev, 0U);
//#line  20941
  err = snd_usb_ctl_msg((mixer->chip)->dev, (unsigned int )(2 << 30) | tmp, (__u8 )36,
                        (__u8 )((2 << 5) | 3), (__u16 )value, (__u16 )(index___0 + 2),
                        (void *)0, (__u16 )0, 100);
  }
//#line  20945
  if (err < 0) {
//#line  20947
    return (err);
  }
//#line  20950
  mixer->audigy2nx_leds[index___0] = (u8 )value;
//#line  20952
  return (changed);
}
}
//#line  20956 "usb-audio.merged.sym.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_audigy2nx_controls)[3]  = {      {2,
      0U, 0U, (unsigned char *)str_934616211, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {2, 0U, 0U, (unsigned char *)str_298606004, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      1UL}, 
        {2, 0U, 0U, (unsigned char *)str_550941773, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_audigy2nx_led_get, & snd_audigy2nx_led_put, {(snd_kcontrol_tlv_rw_t *)0},
      2UL}};
//#line  20967 "usb-audio.merged.sym.c"
static int snd_audigy2nx_controls_create(struct usb_mixer_interface *mixer ) 
{ 
  int i ;
  int err ;
  struct snd_kcontrol *tmp ;

  {
  record_function("snd_audigy2nx_controls_create");
//#line  20975
  i = 0;
  {
  {
//#line  20977
  while (1) {


    if (! ((unsigned long )i < sizeof(snd_audigy2nx_controls) / sizeof(snd_audigy2nx_controls[0]) + (sizeof(char [1]) - 1UL))) {
//#line  20977
      goto while_break;
    }
//#line  20979
    if (i > 1) {
//#line  20981
      if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
//#line  20983
        goto while_break;
      }
    }
    {
//#line  20987
    tmp = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_audigy2nx_controls[i]),
                       (void *)mixer);
//#line  20990
    err = snd_ctl_add((mixer->chip)->card, tmp);
    }
//#line  20992
    if (err < 0) {
//#line  20994
      return (err);
    }
//#line  20997
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  21000
  mixer->audigy2nx_leds[1] = (u8 )1;
//#line  21002
  return (0);
}
}
//#line  21006
static void snd_audigy2nx_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
//#line  21008 "usb-audio.merged.sym.c"
static struct sb_jack  const  jacks_audigy2nx[5]  = {      {4, str_683293777}, 
        {7, str_1061019973}, 
        {19, str_333096528}, 
        {20, str_888942698}, 
        {-1, (char const   *)((void *)0)}};
//#line  21014 "usb-audio.merged.sym.c"
static struct sb_jack  const  jacks_live24ext[4]  = {      {4, str_1061019973}, 
        {3, str_888942698}, 
        {0, str_806837355}, 
        {-1, (char const   *)((void *)0)}};
//#line  21019 "usb-audio.merged.sym.c"
static void snd_audigy2nx_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct sb_jack  const  *jacks ;
  struct usb_mixer_interface *mixer ;
  int i ;
  int err ;
  u8 buf[3] ;
  unsigned int tmp ;

  {
  record_function("snd_audigy2nx_proc_read");
  {
//#line  21030
  mixer = (struct usb_mixer_interface *)entry->private_data;
//#line  21032
  snd_iprintf(buffer, (char *)str_1041470126, ((mixer->chip)->card)->shortname);
  }
//#line  21034
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  21036
    jacks = jacks_audigy2nx;
  } else
//#line  21039
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
//#line  21041
    jacks = jacks_live24ext;
  } else {
//#line  21044
    return;
  }
//#line  21047
  i = 0;
  {
  {
//#line  21049
  while (1) {


    if (! (jacks + i)->name) {
//#line  21049
      goto while_break;
    }
    {
//#line  21051
    snd_iprintf(buffer, (char *)str_296432, (jacks + i)->name);
//#line  21053
    tmp = __create_pipe((mixer->chip)->dev, 0U);
//#line  21055
    err = snd_usb_ctl_msg((mixer->chip)->dev, ((unsigned int )(2 << 30) | tmp) | 128U,
                          (__u8 )133, (__u8 )((128 | (1 << 5)) | 1), (__u16 )0, (__u16 )((jacks + i)->unitid << 8),
                          (void *)(buf), (__u16 )3, 100);
    }
//#line  21059
    if (err == 3) {
//#line  21061
      if ((int )buf[0] == 3) {
        {
//#line  21063
        snd_iprintf(buffer, (char *)str_708091878, (int )buf[1], (int )buf[2]);
        }
      } else
//#line  21066
      if ((int )buf[0] == 6) {
        {
//#line  21068
        snd_iprintf(buffer, (char *)str_708091878, (int )buf[1], (int )buf[2]);
        }
      } else {
        {
//#line  21071
        snd_iprintf(buffer, (char *)str_1207);
        }
      }
    } else {
      {
//#line  21075
      snd_iprintf(buffer, (char *)str_1207);
      }
    }
//#line  21078
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  21081
  return;
}
}
//#line  21085 "usb-audio.merged.sym.c"
static struct snd_device_ops  __attribute__((__noderef__, __address_space__(2))) dev_ops  =    {& snd_usb_mixer_dev_free,
    (int (*)(struct snd_device *dev ))0, (int (*)(struct snd_device *dev ))0};
//#line  21088 "usb-audio.merged.sym.c"
static int snd_usb_create_mixer(struct snd_usb_audio *chip , int ctrlif , int ignore_error ) 
{ 
  struct usb_mixer_interface *mixer ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  struct snd_info_entry *entry ;
  int tmp___1 ;

  {
  record_function("snd_usb_create_mixer");
  {
//#line  21099
  strcpy((chip->card)->mixername, str_570853617);
//#line  21101
  tmp = kzalloc(sizeof(*mixer), 208U);
//#line  21103
  mixer = (struct usb_mixer_interface *)tmp;
  }
//#line  21105
  if (! mixer) {
//#line  21107
    return (-12);
  }
  {
//#line  21110
  mixer->chip = chip;
//#line  21112
  mixer->ctrlif = (unsigned int )ctrlif;
//#line  21114
  mixer->ignore_ctl_error = (unsigned int )ignore_error;
//#line  21116
  tmp___0 = kcalloc((size_t )256, sizeof(*(mixer->id_elems)), 208U);
//#line  21118
  mixer->id_elems = (struct usb_mixer_elem_info **)tmp___0;
  }
//#line  21120
  if (! mixer->id_elems) {
    {
//#line  21122
    kfree((void const   *)mixer);
    }
//#line  21124
    return (-12);
  }
  {
//#line  21127
  err = snd_usb_mixer_controls(mixer);
  }
//#line  21129
  if (err < 0) {
//#line  21131
    goto _error;
  } else {
    {
//#line  21134
    err = snd_usb_mixer_status_create(mixer);
    }
//#line  21136
    if (err < 0) {
//#line  21138
      goto _error;
    }
  }
  {
//#line  21142
  err = snd_usb_soundblaster_remote_init(mixer);
  }
//#line  21144
  if (err < 0) {
//#line  21146
    goto _error;
  }
//#line  21149
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12320)) {
//#line  21151
    goto _L;
  } else
//#line  21154
  if ((mixer->chip)->usb_id == (u32 )((1054 << 16) | 12352)) {
    _L: 
    {
//#line  21157
    err = snd_audigy2nx_controls_create(mixer);
    }
//#line  21159
    if (err < 0) {
//#line  21161
      goto _error;
    }
    {
//#line  21164
    tmp___1 = snd_card_proc_new(chip->card, (char const   *)str_325836133, & entry);
    }
//#line  21167
    if (! tmp___1) {
      {
//#line  21169
      snd_info_set_text_ops(entry, (void *)mixer, & snd_audigy2nx_proc_read);
      }
    }
  }
  {
//#line  21173
  err = snd_device_new(chip->card, 8192, (void *)mixer, (struct snd_device_ops *)(& dev_ops));
  }
//#line  21175
  if (err < 0) {
//#line  21177
    goto _error;
  }
  {
//#line  21180
  list_add(& mixer->list, & chip->mixer_list);
  }
//#line  21182
  return (0);
  _error: 
  {
//#line  21185
  snd_usb_mixer_free(mixer);
  }
//#line  21187
  return (err);
}
}
//#line  21191 "usb-audio.merged.sym.c"
static void snd_usb_mixer_disconnect(struct list_head *p ) 
{ 
  struct usb_mixer_interface *mixer ;
  struct list_head  const  *__mptr ;

  {
  record_function("snd_usb_mixer_disconnect");
  {
//#line  21198
  __mptr = (struct list_head  const  *)p;
//#line  21200
  mixer = (struct usb_mixer_interface *)((char *)__mptr - (unsigned int )(& ((struct usb_mixer_interface *)0)->list));
//#line  21202
  usb_kill_urb(mixer->urb);
//#line  21204
  usb_kill_urb(mixer->rc_urb);
  }
//#line  21206
  return;
}
}
static void MARSH___STUB__snd_card_new(struct req_args *rqarg , int idx , char const   *id ,
                                       struct module *module , int extra_size ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen8 ;

  {
  record_function("MARSH___STUB__snd_card_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& idx), sizeof(int ));
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    strlen8 = (int )strlen((void *)id);
    strlen8 ++;
    fill_marshbuf("snd_card_new", & _buf_, & _off_, & strlen8, sizeof(int ));
    fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)id, strlen8 * sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & module);
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& extra_size), sizeof(int ));
  rqarg->function_id = 1517;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_card *DEMARSH_STUB__snd_card_new(struct req_args *rqarg , int idx ,
                                                   char const   *id , struct module *module ,
                                                   int extra_size ) 
{ 
  struct snd_card *_retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen9 ;

  {
  record_function("DEMARSH_STUB__snd_card_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& idx));
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& id), sizeof(char const   ));
  if (id != 0U) {
    fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), & strlen9);
    nooks_ot_alloc_arraymem_user((void *)(& id), strlen9, sizeof(char const   ), 0);
    fetch_marshbuf("snd_card_new", _buf_, & _off_, strlen9 * sizeof(char const   ),
                   (void *)id);
  }
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& module), sizeof(struct module ));
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& extra_size));
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& _retval_), sizeof(struct snd_card ));
  return (_retval_);
}
}
struct snd_card *snd_card_new(int idx , char const   *id , struct module *module ,
                              int extra_size ) 
{ 
  struct req_args rqarg ;
  struct snd_card *_retval_ ;

  {
  record_function("snd_card_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_new(& rqarg, idx, id, module, extra_size);
  disp_kern("snd_card_new", & rqarg);
  _retval_ = 0U;
  _retval_ = (struct snd_card *)DEMARSH_STUB__snd_card_new(& rqarg, idx, id, module,
                                                           extra_size);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB___spin_unlock_irqrestore(struct req_args *rqarg , spinlock_t *lock ,
                                                  unsigned long flags ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_unlock_irqrestore");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_unlock_irqrestore", & _buf_, & _off_, & lock);
  fill_marshbuf("_spin_unlock_irqrestore", & _buf_, & _off_, (void *)(& flags), sizeof(unsigned long ));
  rqarg->function_id = 1327;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB___spin_unlock_irqrestore(struct req_args *rqarg , spinlock_t *lock ,
                                                  unsigned long flags ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_unlock_irqrestore");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_unlock_irqrestore", _buf_, & _off_, (void **)(& lock),
                     sizeof(spinlock_t ));
  fetch_marshbuf("_spin_unlock_irqrestore", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& flags));
  return;
}
}
void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 
  struct req_args rqarg ;

  {
  record_function("_spin_unlock_irqrestore");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB___spin_unlock_irqrestore(& rqarg, lock, flags);
  disp_kern("_spin_unlock_irqrestore", & rqarg);
  DEMARSH_STUB___spin_unlock_irqrestore(& rqarg, lock, flags);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_rawmidi_set_ops(struct req_args *rqarg , struct snd_rawmidi *rmidi ,
                                              int stream , struct snd_rawmidi_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_set_ops");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_set_ops", & _buf_, & _off_, & rmidi);
  fill_marshbuf("snd_rawmidi_set_ops", & _buf_, & _off_, (void *)(& stream), sizeof(int ));
  fill_marshbuf_ptr("snd_rawmidi_set_ops", & _buf_, & _off_, & ops);
  rqarg->function_id = 1553;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_rawmidi_set_ops(struct req_args *rqarg , struct snd_rawmidi *rmidi ,
                                              int stream , struct snd_rawmidi_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_set_ops");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_set_ops", _buf_, & _off_, (void **)(& rmidi), sizeof(struct snd_rawmidi ));
  fetch_marshbuf("snd_rawmidi_set_ops", _buf_, & _off_, sizeof(int ), (void *)(& stream));
  fetch_marshbuf_ptr("snd_rawmidi_set_ops", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_rawmidi_ops ));
  return;
}
}
void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi , int stream , struct snd_rawmidi_ops *ops ) 
{ 
  struct req_args rqarg ;

  {
  record_function("snd_rawmidi_set_ops");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_rawmidi_set_ops(& rqarg, rmidi, stream, ops);
  disp_kern("snd_rawmidi_set_ops", & rqarg);
  DEMARSH_STUB__snd_rawmidi_set_ops(& rqarg, rmidi, stream, ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_buffer_free(struct req_args *rqarg , struct usb_device *dev ,
                                          size_t size , void *addr , dma_addr_t dma ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_buffer_free");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_buffer_free", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_buffer_free", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf_ptr("usb_buffer_free", & _buf_, & _off_, & addr);
  fill_marshbuf("usb_buffer_free", & _buf_, & _off_, (void *)(& dma), sizeof(unsigned long long ));
  rqarg->function_id = 2126;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__usb_buffer_free(struct req_args *rqarg , struct usb_device *dev ,
                                          size_t size , void *addr , dma_addr_t dma ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_buffer_free");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_buffer_free", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_buffer_free", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fetch_marshbuf_ptr("usb_buffer_free", _buf_, & _off_, & addr, sizeof(void ));
  fetch_marshbuf("usb_buffer_free", _buf_, & _off_, sizeof(unsigned long long ), (void *)(& dma));
  return;
}
}
void usb_buffer_free(struct usb_device *dev , size_t size , void *addr , dma_addr_t dma ) 
{ 
  struct req_args rqarg ;

  {
  record_function("usb_buffer_free");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__usb_buffer_free(& rqarg, dev, size, addr, dma);
  disp_kern("usb_buffer_free", & rqarg);
  DEMARSH_STUB__usb_buffer_free(& rqarg, dev, size, addr, dma);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_rawmidi_transmit_ack(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                                   int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_transmit_ack");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_transmit_ack", & _buf_, & _off_, & substream);
  fill_marshbuf("snd_rawmidi_transmit_ack", & _buf_, & _off_, (void *)(& count), sizeof(int ));
  rqarg->function_id = 1555;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_transmit_ack(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                                  int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_transmit_ack");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_transmit_ack", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf("snd_rawmidi_transmit_ack", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_transmit_ack", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream , int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_transmit_ack");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_transmit_ack(& rqarg, substream, count);
  disp_kern("snd_rawmidi_transmit_ack", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_transmit_ack(& rqarg, substream, count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_new_stream(struct req_args *rqarg , struct snd_pcm *pcm ,
                                             int stream , int substream_count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_new_stream");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_new_stream", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_new_stream", & _buf_, & _off_, (void *)(& stream), sizeof(int ));
  fill_marshbuf("snd_pcm_new_stream", & _buf_, & _off_, (void *)(& substream_count),
                sizeof(int ));
  rqarg->function_id = 1544;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_new_stream(struct req_args *rqarg , struct snd_pcm *pcm ,
                                            int stream , int substream_count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_new_stream");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_new_stream", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_new_stream", _buf_, & _off_, sizeof(int ), (void *)(& stream));
  fetch_marshbuf("snd_pcm_new_stream", _buf_, & _off_, sizeof(int ), (void *)(& substream_count));
  fetch_marshbuf("snd_pcm_new_stream", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_new_stream(struct snd_pcm *pcm , int stream , int substream_count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_new_stream");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_new_stream(& rqarg, pcm, stream, substream_count);
  disp_kern("snd_pcm_new_stream", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_new_stream(& rqarg, pcm, stream, substream_count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__del_timer_sync(struct req_args *rqarg , struct timer_list *timer ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__del_timer_sync");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("del_timer_sync", & _buf_, & _off_, & timer);
  rqarg->function_id = 1365;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__del_timer_sync(struct req_args *rqarg , struct timer_list *timer ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__del_timer_sync");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("del_timer_sync", _buf_, & _off_, (void **)(& timer), sizeof(struct timer_list ));
  fetch_marshbuf("del_timer_sync", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int del_timer_sync(struct timer_list *timer ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("del_timer_sync");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__del_timer_sync(& rqarg, timer);
  disp_kern("del_timer_sync", & rqarg);
  _retval_ = (int )DEMARSH_STUB__del_timer_sync(& rqarg, timer);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____phys_addr(struct req_args *rqarg , unsigned long arg1 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____phys_addr");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("__phys_addr", & _buf_, & _off_, (void *)(& arg1), sizeof(unsigned long ));
  rqarg->function_id = 1314;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static unsigned long DEMARSH_STUB____phys_addr(struct req_args *rqarg , unsigned long arg1 ) 
{ 
  unsigned long _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____phys_addr");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("__phys_addr", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg1));
  fetch_marshbuf("__phys_addr", _buf_, & _off_, sizeof(unsigned long ), (void *)(& _retval_));
  return (_retval_);
}
}
unsigned long __phys_addr(unsigned long arg0 ) 
{ 
  struct req_args rqarg ;
  unsigned long _retval_ ;

  {
  record_function("__phys_addr");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB____phys_addr(& rqarg, arg0);
  disp_kern("__phys_addr", & rqarg);
  _retval_ = (unsigned long )DEMARSH_STUB____phys_addr(& rqarg, arg0);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_rate_to_rate_bit(struct req_args *rqarg , unsigned int rate ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_rate_to_rate_bit");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("snd_pcm_rate_to_rate_bit", & _buf_, & _off_, (void *)(& rate), sizeof(unsigned int ));
  rqarg->function_id = 1546;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static unsigned int DEMARSH_STUB__snd_pcm_rate_to_rate_bit(struct req_args *rqarg ,
                                                           unsigned int rate ) 
{ 
  unsigned int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_rate_to_rate_bit");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_pcm_rate_to_rate_bit", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& rate));
  fetch_marshbuf("snd_pcm_rate_to_rate_bit", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
unsigned int snd_pcm_rate_to_rate_bit(unsigned int rate ) 
{ 
  struct req_args rqarg ;
  unsigned int _retval_ ;

  {
  record_function("snd_pcm_rate_to_rate_bit");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_rate_to_rate_bit(& rqarg, rate);
  disp_kern("snd_pcm_rate_to_rate_bit", & rqarg);
  _retval_ = (unsigned int )DEMARSH_STUB__snd_pcm_rate_to_rate_bit(& rqarg, rate);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB___spin_lock_irqsave(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_lock_irqsave");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_lock_irqsave", & _buf_, & _off_, & lock);
  rqarg->function_id = 1324;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static unsigned long DEMARSH_STUB___spin_lock_irqsave(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  unsigned long _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_lock_irqsave");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_lock_irqsave", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  fetch_marshbuf("_spin_lock_irqsave", _buf_, & _off_, sizeof(unsigned long ), (void *)(& _retval_));
  return (_retval_);
}
}
unsigned long _spin_lock_irqsave(spinlock_t *lock ) 
{ 
  struct req_args rqarg ;
  unsigned long _retval_ ;

  {
  record_function("_spin_lock_irqsave");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB___spin_lock_irqsave(& rqarg, lock);
  disp_kern("_spin_lock_irqsave", & rqarg);
  _retval_ = (unsigned long )DEMARSH_STUB___spin_lock_irqsave(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB___spin_lock_irq(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_lock_irq");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_lock_irq", & _buf_, & _off_, & lock);
  rqarg->function_id = 1323;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB___spin_lock_irq(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_lock_irq");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_lock_irq", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  return;
}
}
void _spin_lock_irq(spinlock_t *lock ) 
{ 
  struct req_args rqarg ;

  {
  record_function("_spin_lock_irq");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB___spin_lock_irq(& rqarg, lock);
  disp_kern("_spin_lock_irq", & rqarg);
  DEMARSH_STUB___spin_lock_irq(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_hwdep_new(struct req_args *rqarg , struct snd_card *card ,
                                        char *id , int device , struct snd_hwdep **rhwdep ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen8 ;

  {
  record_function("MARSH___STUB__snd_hwdep_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_hwdep_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_hwdep_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    strlen8 = (int )strlen((void *)id);
    strlen8 ++;
    fill_marshbuf("snd_hwdep_new", & _buf_, & _off_, & strlen8, sizeof(int ));
    fill_marshbuf("snd_hwdep_new", & _buf_, & _off_, (void *)id, strlen8 * sizeof(char ));
  }
  fill_marshbuf("snd_hwdep_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf_ptr("snd_hwdep_new", & _buf_, & _off_, & rhwdep);
  if (rhwdep != 0U) {
    fill_marshbuf_ptr("snd_hwdep_new", & _buf_, & _off_, rhwdep);
  }
  rqarg->function_id = 1529;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_hwdep_new(struct req_args *rqarg , struct snd_card *card ,
                                       char *id , int device , struct snd_hwdep **rhwdep ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen9 ;

  {
  record_function("DEMARSH_STUB__snd_hwdep_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_hwdep_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_hwdep_new", _buf_, & _off_, (void **)(& id), sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_hwdep_new", _buf_, & _off_, sizeof(int ), & strlen9);
    nooks_ot_alloc_arraymem_user((void *)(& id), strlen9, sizeof(char ), 0);
    fetch_marshbuf("snd_hwdep_new", _buf_, & _off_, strlen9 * sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_hwdep_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf_ptr("snd_hwdep_new", _buf_, & _off_, (void **)(& rhwdep), sizeof(struct snd_hwdep *));
  if (rhwdep != 0U) {
    fetch_marshbuf_ptr("snd_hwdep_new", _buf_, & _off_, (void **)rhwdep, sizeof(struct snd_hwdep ));
  }
  fetch_marshbuf("snd_hwdep_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_hwdep_new(struct snd_card *card , char *id , int device , struct snd_hwdep **rhwdep ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_hwdep_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_hwdep_new(& rqarg, card, id, device, rhwdep);
  disp_kern("snd_hwdep_new", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_hwdep_new(& rqarg, card, id, device, rhwdep);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_hw_constraint_list(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                     unsigned int cond , snd_pcm_hw_param_t var ,
                                                     struct snd_pcm_hw_constraint_list *l ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_hw_constraint_list");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_list", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_list", & _buf_, & _off_, (void *)(& cond),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_list", & _buf_, & _off_, (void *)(& var), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_hw_constraint_list", & _buf_, & _off_, & l);
  rqarg->function_id = 1539;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_hw_constraint_list(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                    unsigned int cond , snd_pcm_hw_param_t var ,
                                                    struct snd_pcm_hw_constraint_list *l ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_hw_constraint_list");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_list", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_list", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& cond));
  fetch_marshbuf("snd_pcm_hw_constraint_list", _buf_, & _off_, sizeof(int ), (void *)(& var));
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_list", _buf_, & _off_, (void **)(& l),
                     sizeof(struct snd_pcm_hw_constraint_list ));
  fetch_marshbuf("snd_pcm_hw_constraint_list", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime , unsigned int cond ,
                               snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_list *l ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_hw_constraint_list");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_hw_constraint_list(& rqarg, runtime, cond, var, l);
  disp_kern("snd_pcm_hw_constraint_list", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_hw_constraint_list(& rqarg, runtime, cond,
                                                            var, l);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_buffer_alloc(struct req_args *rqarg , struct usb_device *dev ,
                                           size_t size , gfp_t mem_flags , dma_addr_t *dma ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_buffer_alloc");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_buffer_alloc", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_buffer_alloc", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf("usb_buffer_alloc", & _buf_, & _off_, (void *)(& mem_flags), sizeof(unsigned int ));
  fill_marshbuf_ptr("usb_buffer_alloc", & _buf_, & _off_, & dma);
  if (dma != 0U) {
    fill_marshbuf("usb_buffer_alloc", & _buf_, & _off_, (void *)dma, sizeof(unsigned long long ));
  }
  rqarg->function_id = 2125;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void *DEMARSH_STUB__usb_buffer_alloc(struct req_args *rqarg , struct usb_device *dev ,
                                            size_t size , gfp_t mem_flags , dma_addr_t *dma ) 
{ 
  void *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_buffer_alloc");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_buffer_alloc", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_buffer_alloc", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fetch_marshbuf("usb_buffer_alloc", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mem_flags));
  fetch_marshbuf_ptr("usb_buffer_alloc", _buf_, & _off_, (void **)(& dma), sizeof(dma_addr_t ));
  if (dma != 0U) {
    fetch_marshbuf("usb_buffer_alloc", _buf_, & _off_, sizeof(unsigned long long ),
                   (void *)dma);
  }
  fetch_marshbuf_ptr("usb_buffer_alloc", _buf_, & _off_, & _retval_, sizeof(void ));
  return (_retval_);
}
}
void *usb_buffer_alloc(struct usb_device *dev , size_t size , gfp_t mem_flags , dma_addr_t *dma ) 
{ 
  struct req_args rqarg ;
  void *_retval_ ;

  {
  record_function("usb_buffer_alloc");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_buffer_alloc(& rqarg, dev, size, mem_flags, dma);
  disp_kern("usb_buffer_alloc", & rqarg);
  _retval_ = 0U;
  _retval_ = (void *)DEMARSH_STUB__usb_buffer_alloc(& rqarg, dev, size, mem_flags,
                                                    dma);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_transmit_empty(struct req_args *rqarg , struct snd_rawmidi_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_transmit_empty");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_transmit_empty", & _buf_, & _off_, & substream);
  rqarg->function_id = 1556;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_transmit_empty(struct req_args *rqarg , struct snd_rawmidi_substream *substream ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_transmit_empty");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_transmit_empty", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf("snd_rawmidi_transmit_empty", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_transmit_empty");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_transmit_empty(& rqarg, substream);
  disp_kern("snd_rawmidi_transmit_empty", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_transmit_empty(& rqarg, substream);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____wake_up(struct req_args *rqarg , wait_queue_head_t *q ,
                                    unsigned int mode , int nr , void *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____wake_up");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & q);
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& mode), sizeof(unsigned int ));
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& nr), sizeof(int ));
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & key);
  rqarg->function_id = 1319;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____wake_up(struct req_args *rqarg , wait_queue_head_t *q ,
                                    unsigned int mode , int nr , void *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____wake_up");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mode));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(int ), (void *)(& nr));
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, & key, sizeof(void ));
  return;
}
}
void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) 
{ 
  struct req_args rqarg ;

  {
  record_function("__wake_up");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____wake_up(& rqarg, q, mode, nr, key);
  disp_kern("__wake_up", & rqarg);
  DEMARSH_STUB____wake_up(& rqarg, q, mode, nr, key);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_driver_claim_interface(struct req_args *rqarg , struct usb_driver *driver ,
                                                     struct usb_interface *iface ,
                                                     void *priv ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_driver_claim_interface");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_driver_claim_interface", & _buf_, & _off_, & driver);
  fill_marshbuf_ptr("usb_driver_claim_interface", & _buf_, & _off_, & iface);
  fill_marshbuf_ptr("usb_driver_claim_interface", & _buf_, & _off_, & priv);
  rqarg->function_id = 2131;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_driver_claim_interface(struct req_args *rqarg , struct usb_driver *driver ,
                                                    struct usb_interface *iface ,
                                                    void *priv ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_driver_claim_interface");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_driver_claim_interface", _buf_, & _off_, (void **)(& driver),
                     sizeof(struct usb_driver ));
  fetch_marshbuf_ptr("usb_driver_claim_interface", _buf_, & _off_, (void **)(& iface),
                     sizeof(struct usb_interface ));
  fetch_marshbuf_ptr("usb_driver_claim_interface", _buf_, & _off_, & priv, sizeof(void ));
  fetch_marshbuf("usb_driver_claim_interface", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_driver_claim_interface(struct usb_driver *driver , struct usb_interface *iface ,
                               void *priv ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_driver_claim_interface");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_driver_claim_interface(& rqarg, driver, iface, priv);
  disp_kern("usb_driver_claim_interface", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_driver_claim_interface(& rqarg, driver, iface,
                                                            priv);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_find_id(struct req_args *rqarg , struct snd_card *card ,
                                          struct snd_ctl_elem_id *id ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_ctl_find_id");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_find_id", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_ctl_find_id", & _buf_, & _off_, & id);
  rqarg->function_id = 1525;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_kcontrol *DEMARSH_STUB__snd_ctl_find_id(struct req_args *rqarg ,
                                                          struct snd_card *card ,
                                                          struct snd_ctl_elem_id *id ) 
{ 
  struct snd_kcontrol *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_ctl_find_id");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_find_id", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_ctl_find_id", _buf_, & _off_, (void **)(& id), sizeof(struct snd_ctl_elem_id ));
  fetch_marshbuf_ptr("snd_ctl_find_id", _buf_, & _off_, (void **)(& _retval_), sizeof(struct snd_kcontrol ));
  return (_retval_);
}
}
struct snd_kcontrol *snd_ctl_find_id(struct snd_card *card , struct snd_ctl_elem_id *id ) 
{ 
  struct req_args rqarg ;
  struct snd_kcontrol *_retval_ ;

  {
  record_function("snd_ctl_find_id");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ctl_find_id(& rqarg, card, id);
  disp_kern("snd_ctl_find_id", & rqarg);
  _retval_ = 0U;
  _retval_ = (struct snd_kcontrol *)DEMARSH_STUB__snd_ctl_find_id(& rqarg, card, id);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____list_add(struct req_args *rqarg , struct list_head *new ,
                                     struct list_head *prev , struct list_head *next ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____list_add");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__list_add", & _buf_, & _off_, & new);
  fill_marshbuf_ptr("__list_add", & _buf_, & _off_, & prev);
  fill_marshbuf_ptr("__list_add", & _buf_, & _off_, & next);
  rqarg->function_id = 1296;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____list_add(struct req_args *rqarg , struct list_head *new ,
                                     struct list_head *prev , struct list_head *next ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____list_add");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__list_add", _buf_, & _off_, (void **)(& new), sizeof(struct list_head ));
  fetch_marshbuf_ptr("__list_add", _buf_, & _off_, (void **)(& prev), sizeof(struct list_head ));
  fetch_marshbuf_ptr("__list_add", _buf_, & _off_, (void **)(& next), sizeof(struct list_head ));
  return;
}
}
void __list_add(struct list_head *new , struct list_head *prev , struct list_head *next ) 
{ 
  struct req_args rqarg ;

  {
  record_function("__list_add");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____list_add(& rqarg, new, prev, next);
  disp_kern("__list_add", & rqarg);
  DEMARSH_STUB____list_add(& rqarg, new, prev, next);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB___spin_lock(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_lock");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_lock", & _buf_, & _off_, & lock);
  rqarg->function_id = 1322;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB___spin_lock(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_lock");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_lock", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  return;
}
}
void _spin_lock(spinlock_t *lock ) 
{ 
  struct req_args rqarg ;

  {
  record_function("_spin_lock");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB___spin_lock(& rqarg, lock);
  disp_kern("_spin_lock", & rqarg);
  DEMARSH_STUB___spin_lock(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_card_proc_new(struct req_args *rqarg , struct snd_card *card ,
                                            char const   *name , struct snd_info_entry **entryp ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen7 ;

  {
  record_function("MARSH___STUB__snd_card_proc_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & name);
  if (name != 0U) {
    strlen7 = (int )strlen((void *)name);
    strlen7 ++;
    fill_marshbuf("snd_card_proc_new", & _buf_, & _off_, & strlen7, sizeof(int ));
    fill_marshbuf("snd_card_proc_new", & _buf_, & _off_, (void *)name, strlen7 * sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & entryp);
  if (entryp != 0U) {
    fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, entryp);
  }
  rqarg->function_id = 1518;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_proc_new(struct req_args *rqarg , struct snd_card *card ,
                                           char const   *name , struct snd_info_entry **entryp ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen8 ;

  {
  record_function("DEMARSH_STUB__snd_card_proc_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& name), sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, sizeof(int ), & strlen8);
    nooks_ot_alloc_arraymem_user((void *)(& name), strlen8, sizeof(char const   ),
                                 0);
    fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, strlen8 * sizeof(char const   ),
                   (void *)name);
  }
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& entryp), sizeof(struct snd_info_entry *));
  if (entryp != 0U) {
    fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)entryp, sizeof(struct snd_info_entry ));
  }
  fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_proc_new(struct snd_card *card , char const   *name , struct snd_info_entry **entryp ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_card_proc_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_proc_new(& rqarg, card, name, entryp);
  disp_kern("snd_card_proc_new", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_card_proc_new(& rqarg, card, name, entryp);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_new(struct req_args *rqarg , struct snd_card *card ,
                                      char *id , int device , int playback_count ,
                                      int capture_count , struct snd_pcm **rpcm ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen10 ;

  {
  record_function("MARSH___STUB__snd_pcm_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    strlen10 = (int )strlen((void *)id);
    strlen10 ++;
    fill_marshbuf("snd_pcm_new", & _buf_, & _off_, & strlen10, sizeof(int ));
    fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)id, strlen10 * sizeof(char ));
  }
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& playback_count), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& capture_count), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & rpcm);
  if (rpcm != 0U) {
    fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, rpcm);
  }
  rqarg->function_id = 1543;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_new(struct req_args *rqarg , struct snd_card *card ,
                                     char *id , int device , int playback_count ,
                                     int capture_count , struct snd_pcm **rpcm ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen11 ;

  {
  record_function("DEMARSH_STUB__snd_pcm_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& id), sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), & strlen11);
    nooks_ot_alloc_arraymem_user((void *)(& id), strlen11, sizeof(char ), 0);
    fetch_marshbuf("snd_pcm_new", _buf_, & _off_, strlen11 * sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& playback_count));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& capture_count));
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& rpcm), sizeof(struct snd_pcm *));
  if (rpcm != 0U) {
    fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)rpcm, sizeof(struct snd_pcm ));
  }
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_new(struct snd_card *card , char *id , int device , int playback_count ,
                int capture_count , struct snd_pcm **rpcm ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_new(& rqarg, card, id, device, playback_count, capture_count,
                            rpcm);
  disp_kern("snd_pcm_new", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_new(& rqarg, card, id, device, playback_count,
                                             capture_count, rpcm);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__schedule(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__schedule");
  _off_ = 0U;
  _buf_ = 0U;
  rqarg->function_id = 1499;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__schedule(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__schedule");
  _off_ = 0U;
  _buf_ = rqarg->data;
  return;
}
}
void schedule(void) 
{ 
  struct req_args rqarg ;

  {
  record_function("schedule");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__schedule(& rqarg);
  disp_kern("schedule", & rqarg);
  DEMARSH_STUB__schedule(& rqarg);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_string(struct req_args *rqarg , struct usb_device *dev ,
                                     int index , char * __attribute__((__exp__(Nonstub_get_size("size")))) buf ,
                                     size_t size ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_string");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_string", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_string", & _buf_, & _off_, (void *)(& index), sizeof(int ));
  fill_marshbuf_ptr("usb_string", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    fill_marshbuf("usb_string", & _buf_, & _off_, (void *)buf, sizeof(char ));
  }
  fill_marshbuf("usb_string", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  rqarg->function_id = 2157;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_string(struct req_args *rqarg , struct usb_device *dev ,
                                    int index , char * __attribute__((__exp__(Nonstub_get_size("size")))) buf ,
                                    size_t size ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_string");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_string", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_string", _buf_, & _off_, sizeof(int ), (void *)(& index));
  fetch_marshbuf_ptr("usb_string", _buf_, & _off_, (void **)(& buf), sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("usb_string", _buf_, & _off_, sizeof(char ), (void *)buf);
  }
  fetch_marshbuf("usb_string", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fetch_marshbuf("usb_string", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_string(struct usb_device *dev , int index , char * __attribute__((__exp__(Nonstub_get_size("size")))) buf ,
               size_t size ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_string");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_string(& rqarg, dev, index, buf, size);
  disp_kern("usb_string", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_string(& rqarg, dev, index, buf, size);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__tasklet_kill(struct req_args *rqarg , struct tasklet_struct *t ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__tasklet_kill");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("tasklet_kill", & _buf_, & _off_, & t);
  rqarg->function_id = 2104;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__tasklet_kill(struct req_args *rqarg , struct tasklet_struct *t ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__tasklet_kill");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("tasklet_kill", _buf_, & _off_, (void **)(& t), sizeof(struct tasklet_struct ));
  return;
}
}
void tasklet_kill(struct tasklet_struct *t ) 
{ 
  struct req_args rqarg ;

  {
  record_function("tasklet_kill");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__tasklet_kill(& rqarg, t);
  disp_kern("tasklet_kill", & rqarg);
  DEMARSH_STUB__tasklet_kill(& rqarg, t);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_kill_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_kill_urb");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_kill_urb", & _buf_, & _off_, & urb);
  rqarg->function_id = 2147;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__usb_kill_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_kill_urb");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_kill_urb", _buf_, & _off_, (void **)(& urb), sizeof(struct urb ));
  return;
}
}
void usb_kill_urb(struct urb *urb ) 
{ 
  struct req_args rqarg ;

  {
  record_function("usb_kill_urb");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__usb_kill_urb(& rqarg, urb);
  disp_kern("usb_kill_urb", & rqarg);
  DEMARSH_STUB__usb_kill_urb(& rqarg, urb);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_deregister(struct req_args *rqarg , struct usb_driver *arg1 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_deregister");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_deregister", & _buf_, & _off_, & arg1);
  rqarg->function_id = 2130;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__usb_deregister(struct req_args *rqarg , struct usb_driver *arg1 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_deregister");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_deregister", _buf_, & _off_, (void **)(& arg1), sizeof(struct usb_driver ));
  return;
}
}
void usb_deregister(struct usb_driver *arg0 ) 
{ 
  struct req_args rqarg ;

  {
  record_function("usb_deregister");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__usb_deregister(& rqarg, arg0);
  disp_kern("usb_deregister", & rqarg);
  DEMARSH_STUB__usb_deregister(& rqarg, arg0);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_suspend_all(struct req_args *rqarg , struct snd_pcm *pcm ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_suspend_all");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_suspend_all", & _buf_, & _off_, & pcm);
  rqarg->function_id = 1549;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_suspend_all(struct req_args *rqarg , struct snd_pcm *pcm ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_suspend_all");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_suspend_all", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_suspend_all", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_suspend_all(struct snd_pcm *pcm ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_suspend_all");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_suspend_all(& rqarg, pcm);
  disp_kern("snd_pcm_suspend_all", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_suspend_all(& rqarg, pcm);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_format_physical_width(struct req_args *rqarg , snd_pcm_format_t format ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_format_physical_width");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("snd_pcm_format_physical_width", & _buf_, & _off_, (void *)(& format),
                sizeof(int ));
  rqarg->function_id = 1536;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_format_physical_width(struct req_args *rqarg , snd_pcm_format_t format ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_format_physical_width");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_pcm_format_physical_width", _buf_, & _off_, sizeof(int ), (void *)(& format));
  fetch_marshbuf("snd_pcm_format_physical_width", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_format_physical_width(snd_pcm_format_t format ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_format_physical_width");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_format_physical_width(& rqarg, format);
  disp_kern("snd_pcm_format_physical_width", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_format_physical_width(& rqarg, format);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__msecs_to_jiffies(struct req_args *rqarg , unsigned int m ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__msecs_to_jiffies");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("msecs_to_jiffies", & _buf_, & _off_, (void *)(& m), sizeof(unsigned int ));
  rqarg->function_id = 1445;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static unsigned long DEMARSH_STUB__msecs_to_jiffies(struct req_args *rqarg , unsigned int m ) 
{ 
  unsigned long _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__msecs_to_jiffies");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("msecs_to_jiffies", _buf_, & _off_, sizeof(unsigned int ), (void *)(& m));
  fetch_marshbuf("msecs_to_jiffies", _buf_, & _off_, sizeof(unsigned long ), (void *)(& _retval_));
  return (_retval_);
}
}
unsigned long msecs_to_jiffies(unsigned int m ) 
{ 
  struct req_args rqarg ;
  unsigned long _retval_ ;

  {
  record_function("msecs_to_jiffies");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__msecs_to_jiffies(& rqarg, m);
  disp_kern("msecs_to_jiffies", & rqarg);
  _retval_ = (unsigned long )DEMARSH_STUB__msecs_to_jiffies(& rqarg, m);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__mutex_lock_nested(struct req_args *rqarg , struct mutex *lock ,
                                            unsigned int subclass ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__mutex_lock_nested");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mutex_lock_nested", & _buf_, & _off_, & lock);
  fill_marshbuf("mutex_lock_nested", & _buf_, & _off_, (void *)(& subclass), sizeof(unsigned int ));
  rqarg->function_id = 1446;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__mutex_lock_nested(struct req_args *rqarg , struct mutex *lock ,
                                            unsigned int subclass ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__mutex_lock_nested");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mutex_lock_nested", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ));
  fetch_marshbuf("mutex_lock_nested", _buf_, & _off_, sizeof(unsigned int ), (void *)(& subclass));
  return;
}
}
void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) 
{ 
  struct req_args rqarg ;

  {
  record_function("mutex_lock_nested");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__mutex_lock_nested(& rqarg, lock, subclass);
  disp_kern("mutex_lock_nested", & rqarg);
  DEMARSH_STUB__mutex_lock_nested(& rqarg, lock, subclass);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB___spin_unlock_irq(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_unlock_irq");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_unlock_irq", & _buf_, & _off_, & lock);
  rqarg->function_id = 1326;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB___spin_unlock_irq(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_unlock_irq");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_unlock_irq", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  return;
}
}
void _spin_unlock_irq(spinlock_t *lock ) 
{ 
  struct req_args rqarg ;

  {
  record_function("_spin_unlock_irq");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB___spin_unlock_irq(& rqarg, lock);
  disp_kern("_spin_unlock_irq", & rqarg);
  DEMARSH_STUB___spin_unlock_irq(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__mod_timer(struct req_args *rqarg , struct timer_list *timer ,
                                    unsigned long expires ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__mod_timer");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mod_timer", & _buf_, & _off_, & timer);
  fill_marshbuf("mod_timer", & _buf_, & _off_, (void *)(& expires), sizeof(unsigned long ));
  rqarg->function_id = 1443;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__mod_timer(struct req_args *rqarg , struct timer_list *timer ,
                                   unsigned long expires ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__mod_timer");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mod_timer", _buf_, & _off_, (void **)(& timer), sizeof(struct timer_list ));
  fetch_marshbuf("mod_timer", _buf_, & _off_, sizeof(unsigned long ), (void *)(& expires));
  fetch_marshbuf("mod_timer", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("mod_timer");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__mod_timer(& rqarg, timer, expires);
  disp_kern("mod_timer", & rqarg);
  _retval_ = (int )DEMARSH_STUB__mod_timer(& rqarg, timer, expires);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_new1(struct req_args *rqarg , struct snd_kcontrol_new  const  *kcontrolnew ,
                                       void *private_data ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_ctl_new1");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & kcontrolnew);
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & private_data);
  rqarg->function_id = 1526;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_kcontrol *DEMARSH_STUB__snd_ctl_new1(struct req_args *rqarg , struct snd_kcontrol_new  const  *kcontrolnew ,
                                                       void *private_data ) 
{ 
  struct snd_kcontrol *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_ctl_new1");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, (void **)(& kcontrolnew), sizeof(struct snd_kcontrol_new  const  ));
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, & private_data, sizeof(void ));
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, (void **)(& _retval_), sizeof(struct snd_kcontrol ));
  return (_retval_);
}
}
struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew , void *private_data ) 
{ 
  struct req_args rqarg ;
  struct snd_kcontrol *_retval_ ;

  {
  record_function("snd_ctl_new1");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ctl_new1(& rqarg, kcontrolnew, private_data);
  disp_kern("snd_ctl_new1", & rqarg);
  _retval_ = 0U;
  _retval_ = (struct snd_kcontrol *)DEMARSH_STUB__snd_ctl_new1(& rqarg, kcontrolnew,
                                                               private_data);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__prepare_to_wait(struct req_args *rqarg , wait_queue_head_t *q ,
                                          wait_queue_t *wait , int state ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__prepare_to_wait");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("prepare_to_wait", & _buf_, & _off_, & q);
  fill_marshbuf_ptr("prepare_to_wait", & _buf_, & _off_, & wait);
  fill_marshbuf("prepare_to_wait", & _buf_, & _off_, (void *)(& state), sizeof(int ));
  rqarg->function_id = 1479;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__prepare_to_wait(struct req_args *rqarg , wait_queue_head_t *q ,
                                          wait_queue_t *wait , int state ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__prepare_to_wait");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("prepare_to_wait", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ));
  fetch_marshbuf_ptr("prepare_to_wait", _buf_, & _off_, (void **)(& wait), sizeof(wait_queue_t ));
  fetch_marshbuf("prepare_to_wait", _buf_, & _off_, sizeof(int ), (void *)(& state));
  return;
}
}
void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) 
{ 
  struct req_args rqarg ;

  {
  record_function("prepare_to_wait");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__prepare_to_wait(& rqarg, q, wait, state);
  disp_kern("prepare_to_wait", & rqarg);
  DEMARSH_STUB__prepare_to_wait(& rqarg, q, wait, state);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_rawmidi_receive(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                              unsigned char const   *buffer , int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_receive");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_receive", & _buf_, & _off_, & substream);
  fill_marshbuf_ptr("snd_rawmidi_receive", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("snd_rawmidi_receive", & _buf_, & _off_, (void *)buffer, sizeof(unsigned char const   ));
  }
  fill_marshbuf("snd_rawmidi_receive", & _buf_, & _off_, (void *)(& count), sizeof(int ));
  rqarg->function_id = 1552;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_receive(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                             unsigned char const   *buffer , int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_receive");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_receive", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf_ptr("snd_rawmidi_receive", _buf_, & _off_, (void **)(& buffer), sizeof(unsigned char const   ));
  if (buffer != 0U) {
    fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(unsigned char const   ),
                   (void *)buffer);
  }
  fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_receive(struct snd_rawmidi_substream *substream , unsigned char const   *buffer ,
                        int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_receive");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_receive(& rqarg, substream, buffer, count);
  disp_kern("snd_rawmidi_receive", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_receive(& rqarg, substream, buffer, count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB___spin_unlock(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___spin_unlock");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("_spin_unlock", & _buf_, & _off_, & lock);
  rqarg->function_id = 1325;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB___spin_unlock(struct req_args *rqarg , spinlock_t *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___spin_unlock");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("_spin_unlock", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  return;
}
}
void _spin_unlock(spinlock_t *lock ) 
{ 
  struct req_args rqarg ;

  {
  record_function("_spin_unlock");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB___spin_unlock(& rqarg, lock);
  disp_kern("_spin_unlock", & rqarg);
  DEMARSH_STUB___spin_unlock(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_rawmidi_new(struct req_args *rqarg , struct snd_card *card ,
                                          char *id , int device , int output_count ,
                                          int input_count , struct snd_rawmidi **rmidi ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen10 ;

  {
  record_function("MARSH___STUB__snd_rawmidi_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    strlen10 = (int )strlen((void *)id);
    strlen10 ++;
    fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, & strlen10, sizeof(int ));
    fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)id, strlen10 * sizeof(char ));
  }
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& output_count), sizeof(int ));
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& input_count), sizeof(int ));
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & rmidi);
  if (rmidi != 0U) {
    fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, rmidi);
  }
  rqarg->function_id = 1551;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_new(struct req_args *rqarg , struct snd_card *card ,
                                         char *id , int device , int output_count ,
                                         int input_count , struct snd_rawmidi **rmidi ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen11 ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& id), sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), & strlen11);
    nooks_ot_alloc_arraymem_user((void *)(& id), strlen11, sizeof(char ), 0);
    fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, strlen11 * sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& output_count));
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& input_count));
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& rmidi), sizeof(struct snd_rawmidi *));
  if (rmidi != 0U) {
    fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)rmidi, sizeof(struct snd_rawmidi ));
  }
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_new(struct snd_card *card , char *id , int device , int output_count ,
                    int input_count , struct snd_rawmidi **rmidi ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_new(& rqarg, card, id, device, output_count, input_count,
                                rmidi);
  disp_kern("snd_rawmidi_new", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_new(& rqarg, card, id, device, output_count,
                                                 input_count, rmidi);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_submit_urb(struct req_args *rqarg , struct urb *urb ,
                                         gfp_t mem_flags ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_submit_urb");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_submit_urb", & _buf_, & _off_, & urb);
  fill_marshbuf("usb_submit_urb", & _buf_, & _off_, (void *)(& mem_flags), sizeof(unsigned int ));
  rqarg->function_id = 2158;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_submit_urb(struct req_args *rqarg , struct urb *urb ,
                                        gfp_t mem_flags ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_submit_urb");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_submit_urb", _buf_, & _off_, (void **)(& urb), sizeof(struct urb ));
  fetch_marshbuf("usb_submit_urb", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mem_flags));
  fetch_marshbuf("usb_submit_urb", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_submit_urb(struct urb *urb , gfp_t mem_flags ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_submit_urb");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_submit_urb(& rqarg, urb, mem_flags);
  disp_kern("usb_submit_urb", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_submit_urb(& rqarg, urb, mem_flags);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_register_driver(struct req_args *rqarg , struct usb_driver *arg1 ,
                                              struct module *arg2 , char const   *arg3 ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen7 ;

  {
  record_function("MARSH___STUB__usb_register_driver");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_register_driver", & _buf_, & _off_, & arg1);
  fill_marshbuf_ptr("usb_register_driver", & _buf_, & _off_, & arg2);
  fill_marshbuf_ptr("usb_register_driver", & _buf_, & _off_, & arg3);
  if (arg3 != 0U) {
    strlen7 = (int )strlen((void *)arg3);
    strlen7 ++;
    fill_marshbuf("usb_register_driver", & _buf_, & _off_, & strlen7, sizeof(int ));
    fill_marshbuf("usb_register_driver", & _buf_, & _off_, (void *)arg3, strlen7 * sizeof(char const   ));
  }
  rqarg->function_id = 2153;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_register_driver(struct req_args *rqarg , struct usb_driver *arg1 ,
                                             struct module *arg2 , char const   *arg3 ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen8 ;

  {
  record_function("DEMARSH_STUB__usb_register_driver");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_register_driver", _buf_, & _off_, (void **)(& arg1), sizeof(struct usb_driver ));
  fetch_marshbuf_ptr("usb_register_driver", _buf_, & _off_, (void **)(& arg2), sizeof(struct module ));
  fetch_marshbuf_ptr("usb_register_driver", _buf_, & _off_, (void **)(& arg3), sizeof(char const   ));
  if (arg3 != 0U) {
    fetch_marshbuf("usb_register_driver", _buf_, & _off_, sizeof(int ), & strlen8);
    nooks_ot_alloc_arraymem_user((void *)(& arg3), strlen8, sizeof(char const   ),
                                 0);
    fetch_marshbuf("usb_register_driver", _buf_, & _off_, strlen8 * sizeof(char const   ),
                   (void *)arg3);
  }
  fetch_marshbuf("usb_register_driver", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_register_driver(struct usb_driver *arg0 , struct module *arg1 , char const   *arg2 ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_register_driver");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_register_driver(& rqarg, arg0, arg1, arg2);
  disp_kern("usb_register_driver", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_register_driver(& rqarg, arg0, arg1, arg2);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__mutex_unlock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__mutex_unlock");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mutex_unlock", & _buf_, & _off_, & lock);
  rqarg->function_id = 1447;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__mutex_unlock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__mutex_unlock");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mutex_unlock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ));
  return;
}
}
void mutex_unlock(struct mutex *lock ) 
{ 
  struct req_args rqarg ;

  {
  record_function("mutex_unlock");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__mutex_unlock(& rqarg, lock);
  disp_kern("mutex_unlock", & rqarg);
  DEMARSH_STUB__mutex_unlock(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_set_interface(struct req_args *rqarg , struct usb_device *dev ,
                                            int ifnum , int alternate ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_set_interface");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_set_interface", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_set_interface", & _buf_, & _off_, (void *)(& ifnum), sizeof(int ));
  fill_marshbuf("usb_set_interface", & _buf_, & _off_, (void *)(& alternate), sizeof(int ));
  rqarg->function_id = 2155;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_set_interface(struct req_args *rqarg , struct usb_device *dev ,
                                           int ifnum , int alternate ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_set_interface");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_set_interface", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_set_interface", _buf_, & _off_, sizeof(int ), (void *)(& ifnum));
  fetch_marshbuf("usb_set_interface", _buf_, & _off_, sizeof(int ), (void *)(& alternate));
  fetch_marshbuf("usb_set_interface", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_set_interface(struct usb_device *dev , int ifnum , int alternate ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_set_interface");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_set_interface(& rqarg, dev, ifnum, alternate);
  disp_kern("usb_set_interface", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_set_interface(& rqarg, dev, ifnum, alternate);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____tasklet_schedule(struct req_args *rqarg , struct tasklet_struct *t ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____tasklet_schedule");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__tasklet_schedule", & _buf_, & _off_, & t);
  rqarg->function_id = 1317;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____tasklet_schedule(struct req_args *rqarg , struct tasklet_struct *t ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____tasklet_schedule");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__tasklet_schedule", _buf_, & _off_, (void **)(& t), sizeof(struct tasklet_struct ));
  return;
}
}
void __tasklet_schedule(struct tasklet_struct *t ) 
{ 
  struct req_args rqarg ;

  {
  record_function("__tasklet_schedule");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____tasklet_schedule(& rqarg, t);
  disp_kern("__tasklet_schedule", & rqarg);
  DEMARSH_STUB____tasklet_schedule(& rqarg, t);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_hw_rule_add_MJR2(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_hw_rule_add_MJR2");
  _off_ = 0U;
  _buf_ = 0U;
  rqarg->function_id = 1541;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_hw_rule_add_MJR2(struct req_args *rqarg ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_hw_rule_add_MJR2");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_pcm_hw_rule_add_MJR2", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_hw_rule_add_MJR2(void) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_hw_rule_add_MJR2");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_hw_rule_add_MJR2(& rqarg);
  disp_kern("snd_pcm_hw_rule_add_MJR2", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_hw_rule_add_MJR2(& rqarg);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__tasklet_init(struct req_args *rqarg , struct tasklet_struct *t ,
                                       void (*func)(unsigned long  ) , unsigned long data ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__tasklet_init");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("tasklet_init", & _buf_, & _off_, & t);
  fill_marshbuf_ptr("tasklet_init", & _buf_, & _off_, & func);
  fill_marshbuf("tasklet_init", & _buf_, & _off_, (void *)(& data), sizeof(unsigned long ));
  rqarg->function_id = 2103;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__tasklet_init(struct req_args *rqarg , struct tasklet_struct *t ,
                                       void (*func)(unsigned long  ) , unsigned long data ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__tasklet_init");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("tasklet_init", _buf_, & _off_, (void **)(& t), sizeof(struct tasklet_struct ));
  fetch_marshbuf_ptr("tasklet_init", _buf_, & _off_, (void **)(& func), sizeof(void (unsigned long  )));
  fetch_marshbuf("tasklet_init", _buf_, & _off_, sizeof(unsigned long ), (void *)(& data));
  return;
}
}
void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) , unsigned long data ) 
{ 
  struct req_args rqarg ;

  {
  record_function("tasklet_init");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__tasklet_init(& rqarg, t, func, data);
  disp_kern("tasklet_init", & rqarg);
  DEMARSH_STUB__tasklet_init(& rqarg, t, func, data);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB___cond_resched(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB___cond_resched");
  _off_ = 0U;
  _buf_ = 0U;
  rqarg->function_id = 1321;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB___cond_resched(struct req_args *rqarg ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB___cond_resched");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("_cond_resched", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int _cond_resched(void) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("_cond_resched");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB___cond_resched(& rqarg);
  disp_kern("_cond_resched", & rqarg);
  _retval_ = (int )DEMARSH_STUB___cond_resched(& rqarg);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__init_timer(struct req_args *rqarg , struct timer_list *timer ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__init_timer");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("init_timer", & _buf_, & _off_, & timer);
  rqarg->function_id = 1407;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__init_timer(struct req_args *rqarg , struct timer_list *timer ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__init_timer");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("init_timer", _buf_, & _off_, (void **)(& timer), sizeof(struct timer_list ));
  return;
}
}
void init_timer(struct timer_list *timer ) 
{ 
  struct req_args rqarg ;

  {
  record_function("init_timer");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__init_timer(& rqarg, timer);
  disp_kern("init_timer", & rqarg);
  DEMARSH_STUB__init_timer(& rqarg, timer);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__schedule_timeout_uninterruptible(struct req_args *rqarg ,
                                                           long timeout ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__schedule_timeout_uninterruptible");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("schedule_timeout_uninterruptible", & _buf_, & _off_, (void *)(& timeout),
                sizeof(long ));
  rqarg->function_id = 1500;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static long DEMARSH_STUB__schedule_timeout_uninterruptible(struct req_args *rqarg ,
                                                           long timeout ) 
{ 
  long _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__schedule_timeout_uninterruptible");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("schedule_timeout_uninterruptible", _buf_, & _off_, sizeof(long ),
                 (void *)(& timeout));
  fetch_marshbuf("schedule_timeout_uninterruptible", _buf_, & _off_, sizeof(long ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
long schedule_timeout_uninterruptible(long timeout ) 
{ 
  struct req_args rqarg ;
  long _retval_ ;

  {
  record_function("schedule_timeout_uninterruptible");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__schedule_timeout_uninterruptible(& rqarg, timeout);
  disp_kern("schedule_timeout_uninterruptible", & rqarg);
  _retval_ = (long )DEMARSH_STUB__schedule_timeout_uninterruptible(& rqarg, timeout);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_add(struct req_args *rqarg , struct snd_card *card ,
                                      struct snd_kcontrol *kcontrol ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_ctl_add");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & kcontrol);
  rqarg->function_id = 1523;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_ctl_add(struct req_args *rqarg , struct snd_card *card ,
                                     struct snd_kcontrol *kcontrol ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_ctl_add");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& kcontrol), sizeof(struct snd_kcontrol ));
  fetch_marshbuf("snd_ctl_add", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_ctl_add");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ctl_add(& rqarg, card, kcontrol);
  disp_kern("snd_ctl_add", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_ctl_add(& rqarg, card, kcontrol);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_alloc_urb(struct req_args *rqarg , int iso_packets ,
                                        gfp_t mem_flags ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_alloc_urb");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("usb_alloc_urb", & _buf_, & _off_, (void *)(& iso_packets), sizeof(int ));
  fill_marshbuf("usb_alloc_urb", & _buf_, & _off_, (void *)(& mem_flags), sizeof(unsigned int ));
  rqarg->function_id = 2118;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct urb *DEMARSH_STUB__usb_alloc_urb(struct req_args *rqarg , int iso_packets ,
                                               gfp_t mem_flags ) 
{ 
  struct urb *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_alloc_urb");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("usb_alloc_urb", _buf_, & _off_, sizeof(int ), (void *)(& iso_packets));
  fetch_marshbuf("usb_alloc_urb", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mem_flags));
  fetch_marshbuf_ptr("usb_alloc_urb", _buf_, & _off_, (void **)(& _retval_), sizeof(struct urb ));
  return (_retval_);
}
}
struct urb *usb_alloc_urb(int iso_packets , gfp_t mem_flags ) 
{ 
  struct req_args rqarg ;
  struct urb *_retval_ ;

  {
  record_function("usb_alloc_urb");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_alloc_urb(& rqarg, iso_packets, mem_flags);
  disp_kern("usb_alloc_urb", & rqarg);
  _retval_ = 0U;
  _retval_ = (struct urb *)DEMARSH_STUB__usb_alloc_urb(& rqarg, iso_packets, mem_flags);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_transmit_peek(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                                    unsigned char *buffer , int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_transmit_peek");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_transmit_peek", & _buf_, & _off_, & substream);
  fill_marshbuf_ptr("snd_rawmidi_transmit_peek", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("snd_rawmidi_transmit_peek", & _buf_, & _off_, (void *)buffer, sizeof(unsigned char ));
  }
  fill_marshbuf("snd_rawmidi_transmit_peek", & _buf_, & _off_, (void *)(& count),
                sizeof(int ));
  rqarg->function_id = 1557;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_transmit_peek(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                                   unsigned char *buffer , int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_transmit_peek");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_transmit_peek", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf_ptr("snd_rawmidi_transmit_peek", _buf_, & _off_, (void **)(& buffer),
                     sizeof(unsigned char ));
  if (buffer != 0U) {
    fetch_marshbuf("snd_rawmidi_transmit_peek", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)buffer);
  }
  fetch_marshbuf("snd_rawmidi_transmit_peek", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_transmit_peek", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                              int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_transmit_peek");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_transmit_peek(& rqarg, substream, buffer, count);
  disp_kern("snd_rawmidi_transmit_peek", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_transmit_peek(& rqarg, substream, buffer,
                                                           count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__init_waitqueue_head(struct req_args *rqarg , wait_queue_head_t *q ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__init_waitqueue_head");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("init_waitqueue_head", & _buf_, & _off_, & q);
  rqarg->function_id = 1410;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__init_waitqueue_head(struct req_args *rqarg , wait_queue_head_t *q ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__init_waitqueue_head");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("init_waitqueue_head", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ));
  return;
}
}
void init_waitqueue_head(wait_queue_head_t *q ) 
{ 
  struct req_args rqarg ;

  {
  record_function("init_waitqueue_head");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__init_waitqueue_head(& rqarg, q);
  disp_kern("init_waitqueue_head", & rqarg);
  DEMARSH_STUB__init_waitqueue_head(& rqarg, q);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_ifnum_to_if(struct req_args *rqarg , struct usb_device  const  *dev ,
                                          unsigned int ifnum ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_ifnum_to_if");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_ifnum_to_if", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_ifnum_to_if", & _buf_, & _off_, (void *)(& ifnum), sizeof(unsigned int ));
  rqarg->function_id = 2145;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct usb_interface *DEMARSH_STUB__usb_ifnum_to_if(struct req_args *rqarg ,
                                                           struct usb_device  const  *dev ,
                                                           unsigned int ifnum ) 
{ 
  struct usb_interface *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_ifnum_to_if");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_ifnum_to_if", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device  const  ));
  fetch_marshbuf("usb_ifnum_to_if", _buf_, & _off_, sizeof(unsigned int ), (void *)(& ifnum));
  fetch_marshbuf_ptr("usb_ifnum_to_if", _buf_, & _off_, (void **)(& _retval_), sizeof(struct usb_interface ));
  return (_retval_);
}
}
struct usb_interface *usb_ifnum_to_if(struct usb_device  const  *dev , unsigned int ifnum ) 
{ 
  struct req_args rqarg ;
  struct usb_interface *_retval_ ;

  {
  record_function("usb_ifnum_to_if");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_ifnum_to_if(& rqarg, dev, ifnum);
  disp_kern("usb_ifnum_to_if", & rqarg);
  _retval_ = 0U;
  _retval_ = (struct usb_interface *)DEMARSH_STUB__usb_ifnum_to_if(& rqarg, dev, ifnum);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_hw_constraint_minmax(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                       snd_pcm_hw_param_t var , unsigned int min ,
                                                       unsigned int max ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_hw_constraint_minmax");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& var),
                sizeof(int ));
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& min),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& max),
                sizeof(unsigned int ));
  rqarg->function_id = 1540;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_hw_constraint_minmax(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                      snd_pcm_hw_param_t var , unsigned int min ,
                                                      unsigned int max ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_hw_constraint_minmax");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_minmax", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(int ), (void *)(& var));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& min));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& max));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime , snd_pcm_hw_param_t var ,
                                 unsigned int min , unsigned int max ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_hw_constraint_minmax");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_hw_constraint_minmax(& rqarg, runtime, var, min, max);
  disp_kern("snd_pcm_hw_constraint_minmax", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_hw_constraint_minmax(& rqarg, runtime, var,
                                                              min, max);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____might_sleep(struct req_args *rqarg , char *file , int line ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____might_sleep");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__might_sleep", & _buf_, & _off_, & file);
  if (file != 0U) {
    fill_marshbuf("__might_sleep", & _buf_, & _off_, (void *)file, sizeof(char ));
  }
  fill_marshbuf("__might_sleep", & _buf_, & _off_, (void *)(& line), sizeof(int ));
  rqarg->function_id = 1298;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____might_sleep(struct req_args *rqarg , char *file , int line ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____might_sleep");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__might_sleep", _buf_, & _off_, (void **)(& file), sizeof(char ));
  if (file != 0U) {
    fetch_marshbuf("__might_sleep", _buf_, & _off_, sizeof(char ), (void *)file);
  }
  fetch_marshbuf("__might_sleep", _buf_, & _off_, sizeof(int ), (void *)(& line));
  return;
}
}
void __might_sleep(char *file , int line ) 
{ 
  struct req_args rqarg ;

  {
  record_function("__might_sleep");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____might_sleep(& rqarg, file, line);
  disp_kern("__might_sleep", & rqarg);
  DEMARSH_STUB____might_sleep(& rqarg, file, line);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_card_free(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_card_free");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_free", & _buf_, & _off_, & card);
  rqarg->function_id = 1515;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_free(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_card_free");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_free", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_free", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_free(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_card_free");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_free(& rqarg, card);
  disp_kern("snd_card_free", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_card_free(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_unlink_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_unlink_urb");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_unlink_urb", & _buf_, & _off_, & urb);
  rqarg->function_id = 2159;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_unlink_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_unlink_urb");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_unlink_urb", _buf_, & _off_, (void **)(& urb), sizeof(struct urb ));
  fetch_marshbuf("usb_unlink_urb", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_unlink_urb(struct urb *urb ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_unlink_urb");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_unlink_urb(& rqarg, urb);
  disp_kern("usb_unlink_urb", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_unlink_urb(& rqarg, urb);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__list_del(struct req_args *rqarg , struct list_head *entry ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__list_del");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("list_del", & _buf_, & _off_, & entry);
  rqarg->function_id = 1424;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__list_del(struct req_args *rqarg , struct list_head *entry ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__list_del");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("list_del", _buf_, & _off_, (void **)(& entry), sizeof(struct list_head ));
  return;
}
}
void list_del(struct list_head *entry ) 
{ 
  struct req_args rqarg ;

  {
  record_function("list_del");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__list_del(& rqarg, entry);
  disp_kern("list_del", & rqarg);
  DEMARSH_STUB__list_del(& rqarg, entry);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_period_elapsed(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_period_elapsed");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_period_elapsed", & _buf_, & _off_, & substream);
  rqarg->function_id = 1545;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_pcm_period_elapsed(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_period_elapsed");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_period_elapsed", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ));
  return;
}
}
void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) 
{ 
  struct req_args rqarg ;

  {
  record_function("snd_pcm_period_elapsed");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_pcm_period_elapsed(& rqarg, substream);
  disp_kern("snd_pcm_period_elapsed", & rqarg);
  DEMARSH_STUB__snd_pcm_period_elapsed(& rqarg, substream);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB____spin_lock_init(struct req_args *rqarg , spinlock_t *lock ,
                                           char const   *name , struct lock_class_key *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____spin_lock_init");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__spin_lock_init", & _buf_, & _off_, & lock);
  fill_marshbuf_ptr("__spin_lock_init", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__spin_lock_init", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("__spin_lock_init", & _buf_, & _off_, & key);
  rqarg->function_id = 1316;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____spin_lock_init(struct req_args *rqarg , spinlock_t *lock ,
                                           char const   *name , struct lock_class_key *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____spin_lock_init");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__spin_lock_init", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ));
  fetch_marshbuf_ptr("__spin_lock_init", _buf_, & _off_, (void **)(& name), sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__spin_lock_init", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  fetch_marshbuf_ptr("__spin_lock_init", _buf_, & _off_, (void **)(& key), sizeof(struct lock_class_key ));
  return;
}
}
void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) 
{ 
  struct req_args rqarg ;

  {
  record_function("__spin_lock_init");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____spin_lock_init(& rqarg, lock, name, key);
  disp_kern("__spin_lock_init", & rqarg);
  DEMARSH_STUB____spin_lock_init(& rqarg, lock, name, key);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_reset_configuration(struct req_args *rqarg , struct usb_device *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_reset_configuration");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_reset_configuration", & _buf_, & _off_, & dev);
  rqarg->function_id = 2154;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_reset_configuration(struct req_args *rqarg , struct usb_device *dev ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_reset_configuration");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_reset_configuration", _buf_, & _off_, (void **)(& dev),
                     sizeof(struct usb_device ));
  fetch_marshbuf("usb_reset_configuration", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_reset_configuration(struct usb_device *dev ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_reset_configuration");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_reset_configuration(& rqarg, dev);
  disp_kern("usb_reset_configuration", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_reset_configuration(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_notify(struct req_args *rqarg , struct snd_card *card ,
                                         unsigned int mask , struct snd_ctl_elem_id *id ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_ctl_notify");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_notify", & _buf_, & _off_, & card);
  fill_marshbuf("snd_ctl_notify", & _buf_, & _off_, (void *)(& mask), sizeof(unsigned int ));
  fill_marshbuf_ptr("snd_ctl_notify", & _buf_, & _off_, & id);
  rqarg->function_id = 1527;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_ctl_notify(struct req_args *rqarg , struct snd_card *card ,
                                         unsigned int mask , struct snd_ctl_elem_id *id ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_ctl_notify");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_notify", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf("snd_ctl_notify", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mask));
  fetch_marshbuf_ptr("snd_ctl_notify", _buf_, & _off_, (void **)(& id), sizeof(struct snd_ctl_elem_id ));
  return;
}
}
void snd_ctl_notify(struct snd_card *card , unsigned int mask , struct snd_ctl_elem_id *id ) 
{ 
  struct req_args rqarg ;

  {
  record_function("snd_ctl_notify");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_ctl_notify(& rqarg, card, mask, id);
  disp_kern("snd_ctl_notify", & rqarg);
  DEMARSH_STUB__snd_ctl_notify(& rqarg, card, mask, id);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_stop(struct req_args *rqarg , struct snd_pcm_substream *substream ,
                                       int status ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_stop");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_stop", & _buf_, & _off_, & substream);
  fill_marshbuf("snd_pcm_stop", & _buf_, & _off_, (void *)(& status), sizeof(int ));
  rqarg->function_id = 1548;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_stop(struct req_args *rqarg , struct snd_pcm_substream *substream ,
                                      int status ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_stop");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_stop", _buf_, & _off_, (void **)(& substream), sizeof(struct snd_pcm_substream ));
  fetch_marshbuf("snd_pcm_stop", _buf_, & _off_, sizeof(int ), (void *)(& status));
  fetch_marshbuf("snd_pcm_stop", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_stop(struct snd_pcm_substream *substream , int status ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_pcm_stop");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_stop(& rqarg, substream, status);
  disp_kern("snd_pcm_stop", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_pcm_stop(& rqarg, substream, status);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_set_ops(struct req_args *rqarg , struct snd_pcm *pcm ,
                                          int direction , struct snd_pcm_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_pcm_set_ops");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_set_ops", & _buf_, & _off_, (void *)(& direction), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & ops);
  rqarg->function_id = 1547;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_pcm_set_ops(struct req_args *rqarg , struct snd_pcm *pcm ,
                                          int direction , struct snd_pcm_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_pcm_set_ops");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_set_ops", _buf_, & _off_, sizeof(int ), (void *)(& direction));
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_pcm_ops ));
  return;
}
}
void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) 
{ 
  struct req_args rqarg ;

  {
  record_function("snd_pcm_set_ops");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_pcm_set_ops(& rqarg, pcm, direction, ops);
  disp_kern("snd_pcm_set_ops", & rqarg);
  DEMARSH_STUB__snd_pcm_set_ops(& rqarg, pcm, direction, ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_card_disconnect(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_card_disconnect");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_disconnect", & _buf_, & _off_, & card);
  rqarg->function_id = 1514;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_disconnect(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_card_disconnect");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_disconnect", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_disconnect", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_disconnect(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_card_disconnect");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_disconnect(& rqarg, card);
  disp_kern("snd_card_disconnect", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_card_disconnect(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__finish_wait(struct req_args *rqarg , wait_queue_head_t *q ,
                                      wait_queue_t *wait ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__finish_wait");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("finish_wait", & _buf_, & _off_, & q);
  fill_marshbuf_ptr("finish_wait", & _buf_, & _off_, & wait);
  rqarg->function_id = 1377;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__finish_wait(struct req_args *rqarg , wait_queue_head_t *q ,
                                      wait_queue_t *wait ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__finish_wait");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("finish_wait", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ));
  fetch_marshbuf_ptr("finish_wait", _buf_, & _off_, (void **)(& wait), sizeof(wait_queue_t ));
  return;
}
}
void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) 
{ 
  struct req_args rqarg ;

  {
  record_function("finish_wait");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__finish_wait(& rqarg, q, wait);
  disp_kern("finish_wait", & rqarg);
  DEMARSH_STUB__finish_wait(& rqarg, q, wait);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_get_descriptor(struct req_args *rqarg , struct usb_device *dev ,
                                             unsigned char desctype , unsigned char descindex ,
                                             void *buf , int size ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_get_descriptor");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_get_descriptor", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_get_descriptor", & _buf_, & _off_, (void *)(& desctype), sizeof(unsigned char ));
  fill_marshbuf("usb_get_descriptor", & _buf_, & _off_, (void *)(& descindex), sizeof(unsigned char ));
  fill_marshbuf_ptr("usb_get_descriptor", & _buf_, & _off_, & buf);
  fill_marshbuf("usb_get_descriptor", & _buf_, & _off_, (void *)(& size), sizeof(int ));
  rqarg->function_id = 2143;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_get_descriptor(struct req_args *rqarg , struct usb_device *dev ,
                                            unsigned char desctype , unsigned char descindex ,
                                            void *buf , int size ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_get_descriptor");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_get_descriptor", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_get_descriptor", _buf_, & _off_, sizeof(unsigned char ), (void *)(& desctype));
  fetch_marshbuf("usb_get_descriptor", _buf_, & _off_, sizeof(unsigned char ), (void *)(& descindex));
  fetch_marshbuf_ptr("usb_get_descriptor", _buf_, & _off_, & buf, sizeof(void ));
  fetch_marshbuf("usb_get_descriptor", _buf_, & _off_, sizeof(int ), (void *)(& size));
  fetch_marshbuf("usb_get_descriptor", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_get_descriptor(struct usb_device *dev , unsigned char desctype , unsigned char descindex ,
                       void *buf , int size ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_get_descriptor");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_get_descriptor(& rqarg, dev, desctype, descindex, buf, size);
  disp_kern("usb_get_descriptor", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_get_descriptor(& rqarg, dev, desctype, descindex,
                                                    buf, size);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_component_add(struct req_args *rqarg , struct snd_card *card ,
                                            char const   *component ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int strlen6 ;

  {
  record_function("MARSH___STUB__snd_component_add");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_component_add", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_component_add", & _buf_, & _off_, & component);
  if (component != 0U) {
    strlen6 = (int )strlen((void *)component);
    strlen6 ++;
    fill_marshbuf("snd_component_add", & _buf_, & _off_, & strlen6, sizeof(int ));
    fill_marshbuf("snd_component_add", & _buf_, & _off_, (void *)component, strlen6 * sizeof(char const   ));
  }
  rqarg->function_id = 1522;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_component_add(struct req_args *rqarg , struct snd_card *card ,
                                           char const   *component ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int strlen7 ;

  {
  record_function("DEMARSH_STUB__snd_component_add");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_component_add", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_component_add", _buf_, & _off_, (void **)(& component),
                     sizeof(char const   ));
  if (component != 0U) {
    fetch_marshbuf("snd_component_add", _buf_, & _off_, sizeof(int ), & strlen7);
    nooks_ot_alloc_arraymem_user((void *)(& component), strlen7, sizeof(char const   ),
                                 0);
    fetch_marshbuf("snd_component_add", _buf_, & _off_, strlen7 * sizeof(char const   ),
                   (void *)component);
  }
  fetch_marshbuf("snd_component_add", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_component_add(struct snd_card *card , char const   *component ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_component_add");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_component_add(& rqarg, card, component);
  disp_kern("snd_component_add", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_component_add(& rqarg, card, component);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_free_when_closed(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_card_free_when_closed");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_free_when_closed", & _buf_, & _off_, & card);
  rqarg->function_id = 1516;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_free_when_closed(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_card_free_when_closed");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_free_when_closed", _buf_, & _off_, (void **)(& card),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_free_when_closed", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_free_when_closed(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_card_free_when_closed");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_free_when_closed(& rqarg, card);
  disp_kern("snd_card_free_when_closed", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_card_free_when_closed(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_bulk_msg(struct req_args *rqarg , struct usb_device *usb_dev ,
                                       unsigned int pipe , void *data , int len ,
                                       int *actual_length , int timeout ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_bulk_msg");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_bulk_msg", & _buf_, & _off_, & usb_dev);
  fill_marshbuf("usb_bulk_msg", & _buf_, & _off_, (void *)(& pipe), sizeof(unsigned int ));
  fill_marshbuf_ptr("usb_bulk_msg", & _buf_, & _off_, & data);
  fill_marshbuf("usb_bulk_msg", & _buf_, & _off_, (void *)(& len), sizeof(int ));
  fill_marshbuf_ptr("usb_bulk_msg", & _buf_, & _off_, & actual_length);
  if (actual_length != 0U) {
    fill_marshbuf("usb_bulk_msg", & _buf_, & _off_, (void *)actual_length, sizeof(int ));
  }
  fill_marshbuf("usb_bulk_msg", & _buf_, & _off_, (void *)(& timeout), sizeof(int ));
  rqarg->function_id = 2127;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_bulk_msg(struct req_args *rqarg , struct usb_device *usb_dev ,
                                      unsigned int pipe , void *data , int len , int *actual_length ,
                                      int timeout ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_bulk_msg");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_bulk_msg", _buf_, & _off_, (void **)(& usb_dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_bulk_msg", _buf_, & _off_, sizeof(unsigned int ), (void *)(& pipe));
  fetch_marshbuf_ptr("usb_bulk_msg", _buf_, & _off_, & data, sizeof(void ));
  fetch_marshbuf("usb_bulk_msg", _buf_, & _off_, sizeof(int ), (void *)(& len));
  fetch_marshbuf_ptr("usb_bulk_msg", _buf_, & _off_, (void **)(& actual_length), sizeof(int ));
  if (actual_length != 0U) {
    fetch_marshbuf("usb_bulk_msg", _buf_, & _off_, sizeof(int ), (void *)actual_length);
  }
  fetch_marshbuf("usb_bulk_msg", _buf_, & _off_, sizeof(int ), (void *)(& timeout));
  fetch_marshbuf("usb_bulk_msg", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_bulk_msg(struct usb_device *usb_dev , unsigned int pipe , void *data , int len ,
                 int *actual_length , int timeout ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_bulk_msg");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_bulk_msg(& rqarg, usb_dev, pipe, data, len, actual_length, timeout);
  disp_kern("usb_bulk_msg", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_bulk_msg(& rqarg, usb_dev, pipe, data, len, actual_length,
                                              timeout);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____bad_pda_field(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____bad_pda_field");
  _off_ = 0U;
  _buf_ = 0U;
  rqarg->function_id = 1005;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____bad_pda_field(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____bad_pda_field");
  _off_ = 0U;
  _buf_ = rqarg->data;
  return;
}
}
void __bad_pda_field(void) 
{ 
  struct req_args rqarg ;

  {
  record_function("__bad_pda_field");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____bad_pda_field(& rqarg);
  disp_kern("__bad_pda_field", & rqarg);
  DEMARSH_STUB____bad_pda_field(& rqarg);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_device_new(struct req_args *rqarg , struct snd_card *card ,
                                         snd_device_type_t type , void *device_data ,
                                         struct snd_device_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_device_new");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & card);
  fill_marshbuf("snd_device_new", & _buf_, & _off_, (void *)(& type), sizeof(int ));
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & device_data);
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & ops);
  rqarg->function_id = 1528;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_device_new(struct req_args *rqarg , struct snd_card *card ,
                                        snd_device_type_t type , void *device_data ,
                                        struct snd_device_ops *ops ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_device_new");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf("snd_device_new", _buf_, & _off_, sizeof(int ), (void *)(& type));
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, & device_data, sizeof(void ));
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_device_ops ));
  fetch_marshbuf("snd_device_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                   struct snd_device_ops *ops ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_device_new");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_device_new(& rqarg, card, type, device_data, ops);
  disp_kern("snd_device_new", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_device_new(& rqarg, card, type, device_data,
                                                ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__usb_free_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_free_urb");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_free_urb", & _buf_, & _off_, & urb);
  rqarg->function_id = 2142;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__usb_free_urb(struct req_args *rqarg , struct urb *urb ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_free_urb");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_free_urb", _buf_, & _off_, (void **)(& urb), sizeof(struct urb ));
  return;
}
}
void usb_free_urb(struct urb *urb ) 
{ 
  struct req_args rqarg ;

  {
  record_function("usb_free_urb");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__usb_free_urb(& rqarg, urb);
  disp_kern("usb_free_urb", & rqarg);
  DEMARSH_STUB__usb_free_urb(& rqarg, urb);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__usb_control_msg(struct req_args *rqarg , struct usb_device *dev ,
                                          unsigned int pipe , __u8 request , __u8 requesttype ,
                                          __u16 value , __u16 index , void *data ,
                                          __u16 size , int timeout ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__usb_control_msg");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("usb_control_msg", & _buf_, & _off_, & dev);
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& pipe), sizeof(unsigned int ));
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& request), sizeof(unsigned char ));
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& requesttype), sizeof(unsigned char ));
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& value), sizeof(unsigned short ));
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& index), sizeof(unsigned short ));
  fill_marshbuf_ptr("usb_control_msg", & _buf_, & _off_, & data);
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& size), sizeof(unsigned short ));
  fill_marshbuf("usb_control_msg", & _buf_, & _off_, (void *)(& timeout), sizeof(int ));
  rqarg->function_id = 2129;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__usb_control_msg(struct req_args *rqarg , struct usb_device *dev ,
                                         unsigned int pipe , __u8 request , __u8 requesttype ,
                                         __u16 value , __u16 index , void *data ,
                                         __u16 size , int timeout ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__usb_control_msg");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("usb_control_msg", _buf_, & _off_, (void **)(& dev), sizeof(struct usb_device ));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned int ), (void *)(& pipe));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned char ), (void *)(& request));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned char ), (void *)(& requesttype));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned short ), (void *)(& value));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned short ), (void *)(& index));
  fetch_marshbuf_ptr("usb_control_msg", _buf_, & _off_, & data, sizeof(void ));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(unsigned short ), (void *)(& size));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(int ), (void *)(& timeout));
  fetch_marshbuf("usb_control_msg", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int usb_control_msg(struct usb_device *dev , unsigned int pipe , __u8 request , __u8 requesttype ,
                    __u16 value , __u16 index , void *data , __u16 size , int timeout ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("usb_control_msg");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__usb_control_msg(& rqarg, dev, pipe, request, requesttype, value, index,
                                data, size, timeout);
  disp_kern("usb_control_msg", & rqarg);
  _retval_ = (int )DEMARSH_STUB__usb_control_msg(& rqarg, dev, pipe, request, requesttype,
                                                 value, index, data, size, timeout);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_transmit(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                               unsigned char *buffer , int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_rawmidi_transmit");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_transmit", & _buf_, & _off_, & substream);
  fill_marshbuf_ptr("snd_rawmidi_transmit", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("snd_rawmidi_transmit", & _buf_, & _off_, (void *)buffer, sizeof(unsigned char ));
  }
  fill_marshbuf("snd_rawmidi_transmit", & _buf_, & _off_, (void *)(& count), sizeof(int ));
  rqarg->function_id = 1554;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_transmit(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                              unsigned char *buffer , int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_rawmidi_transmit");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_transmit", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf_ptr("snd_rawmidi_transmit", _buf_, & _off_, (void **)(& buffer),
                     sizeof(unsigned char ));
  if (buffer != 0U) {
    fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)buffer);
  }
  fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                         int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_rawmidi_transmit");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_transmit(& rqarg, substream, buffer, count);
  disp_kern("snd_rawmidi_transmit", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_transmit(& rqarg, substream, buffer,
                                                      count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____memcpy(struct req_args *rqarg , void *to , void const   *from ,
                                   size_t len ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB____memcpy");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__memcpy", & _buf_, & _off_, & to);
  fill_marshbuf_ptr("__memcpy", & _buf_, & _off_, & from);
  fill_marshbuf("__memcpy", & _buf_, & _off_, (void *)(& len), sizeof(unsigned long ));
  rqarg->function_id = 1297;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void *DEMARSH_STUB____memcpy(struct req_args *rqarg , void *to , void const   *from ,
                                    size_t len ) 
{ 
  void *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB____memcpy");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__memcpy", _buf_, & _off_, & to, sizeof(void ));
  fetch_marshbuf_ptr("__memcpy", _buf_, & _off_, (void **)(& from), sizeof(void const   ));
  fetch_marshbuf("__memcpy", _buf_, & _off_, sizeof(unsigned long ), (void *)(& len));
  fetch_marshbuf_ptr("__memcpy", _buf_, & _off_, & _retval_, sizeof(void ));
  return (_retval_);
}
}
void *__memcpy(void *to , void const   *from , size_t len ) 
{ 
  struct req_args rqarg ;
  void *_retval_ ;

  {
  record_function("__memcpy");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB____memcpy(& rqarg, to, from, len);
  disp_kern("__memcpy", & rqarg);
  _retval_ = 0U;
  _retval_ = (void *)DEMARSH_STUB____memcpy(& rqarg, to, from, len);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_register(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  record_function("MARSH___STUB__snd_card_register");
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_register", & _buf_, & _off_, & card);
  rqarg->function_id = 1519;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_register(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  record_function("DEMARSH_STUB__snd_card_register");
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_register", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_register", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_register(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;

  {
  record_function("snd_card_register");
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_register(& rqarg, card);
  disp_kern("snd_card_register", & rqarg);
  _retval_ = (int )DEMARSH_STUB__snd_card_register(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
extern int disp_user(char *function_name , struct req_args *rqargs ) 
{ 
  struct marshret_struct retval ;

  {
  record_function("disp_user");
  retval.buf = 0U;
  return (1);
}
}
void register_functions(void) 
{ 


  {
  record_function("register_functions");
  nooks_ot_register_userfn(param_set_int, 1457);
  nooks_ot_register_userfn(param_get_int, 1454);
  nooks_ot_register_userfn(param_set_charp, 1456);
  nooks_ot_register_userfn(param_get_charp, 1453);
  nooks_ot_register_userfn(param_set_bool, 1455);
  nooks_ot_register_userfn(param_get_bool, 1452);
  nooks_ot_register_userfn(param_array_set, 1451);
  nooks_ot_register_userfn(param_array_get, 1450);
  nooks_ot_register_userfn(snd_pcm_lib_ioctl, 1542);
  nooks_ot_register_userfn(autoremove_wake_function, 1338);
  nooks_ot_register_userfn(snd_ctl_boolean_mono_info, 1524);
}
}
int param_set_int(char const   *val , struct kernel_param *kp ) 
{ 


  {
  record_function("param_set_int");
  return (0U);
}
}
int param_get_int(char *buffer , struct kernel_param *kp ) 
{ 


  {
  record_function("param_get_int");
  return (0U);
}
}
int param_set_charp(char const   *val , struct kernel_param *kp ) 
{ 


  {
  record_function("param_set_charp");
  return (0U);
}
}
int param_get_charp(char *buffer , struct kernel_param *kp ) 
{ 


  {
  record_function("param_get_charp");
  return (0U);
}
}
int param_set_bool(char const   *val , struct kernel_param *kp ) 
{ 


  {
  record_function("param_set_bool");
  return (0U);
}
}
int param_get_bool(char *buffer , struct kernel_param *kp ) 
{ 


  {
  record_function("param_get_bool");
  return (0U);
}
}
int param_array_set(char const   *val , struct kernel_param *kp ) 
{ 


  {
  record_function("param_array_set");
  return (0U);
}
}
int param_array_get(char *buffer , struct kernel_param *kp ) 
{ 


  {
  record_function("param_array_get");
  return (0U);
}
}
int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) 
{ 


  {
  record_function("snd_pcm_lib_ioctl");
  return (0U);
}
}
int autoremove_wake_function(wait_queue_t *wait , unsigned int mode , int sync , void *key ) 
{ 


  {
  record_function("autoremove_wake_function");
  return (0U);
}
}
int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
  record_function("snd_ctl_boolean_mono_info");
  return (0U);
}
}
void register_globals(void) 
{ 


  {
  record_function("register_globals");
  nooks_ot_register_userfn(str_812255493, 2022);
  nooks_ot_register_userfn(str_296432, 1830);
  nooks_ot_register_userfn(& __constr_expr_89, 1274);
  nooks_ot_register_userfn(& __constr_expr_65, 1248);
  nooks_ot_register_userfn(str_721858797, 1992);
  nooks_ot_register_userfn(str_9461004, 2071);
  nooks_ot_register_userfn(str_1005803972, 1689);
  nooks_ot_register_userfn(& __constr_expr_220, 1147);
  nooks_ot_register_userfn(str_496824007, 1897);
  nooks_ot_register_userfn(str_974774143, 2086);
  nooks_ot_register_userfn(str_468492697, 1886);
  nooks_ot_register_userfn(& snd_usbmidi_output_ops, 1662);
  nooks_ot_register_userfn(& __constr_expr_148, 1065);
  nooks_ot_register_userfn(& __constr_expr_157, 1075);
  nooks_ot_register_userfn(__constr_expr_173, 1093);
  nooks_ot_register_userfn(str_154546433, 1748);
  nooks_ot_register_userfn(str_106136500, 1708);
  nooks_ot_register_userfn(str_449190836, 1880);
  nooks_ot_register_userfn(str_941834121, 2067);
  nooks_ot_register_userfn(str_0, 1687);
  nooks_ot_register_userfn(& __constr_expr_258, 1188);
  nooks_ot_register_userfn(& __constr_expr_53, 1235);
  nooks_ot_register_userfn(str_233798669, 1813);
  nooks_ot_register_userfn(str_611716, 1946);
  nooks_ot_register_userfn(& __constr_expr_5, 1231);
  nooks_ot_register_userfn(& __constr_expr_185, 1106);
  nooks_ot_register_userfn(str_953588697, 2074);
  nooks_ot_register_userfn(str_956492597, 2076);
  nooks_ot_register_userfn(str_803851448, 2018);
  nooks_ot_register_userfn(str_888942698, 2051);
  nooks_ot_register_userfn(& __constr_expr_94, 1280);
  nooks_ot_register_userfn(& __constr_expr_199, 1121);
  nooks_ot_register_userfn(str_690022538, 1984);
  nooks_ot_register_userfn(str_9378607, 2064);
  nooks_ot_register_userfn(str_854501259, 2033);
  nooks_ot_register_userfn(str_974276422, 2085);
  nooks_ot_register_userfn(str_204133454, 1781);
  nooks_ot_register_userfn(str_229836041, 1812);
  nooks_ot_register_userfn(enable, 1370);
  nooks_ot_register_userfn(& __constr_expr_41, 1222);
  nooks_ot_register_userfn(& __constr_expr_229, 1156);
  nooks_ot_register_userfn(& __constr_expr_17, 1089);
  nooks_ot_register_userfn(& __constr_expr_149, 1066);
  nooks_ot_register_userfn(str_154546418, 1745);
  nooks_ot_register_userfn(str_10915755, 1719);
  nooks_ot_register_userfn(& __constr_expr_264, 1195);
  nooks_ot_register_userfn(str_698010430, 1986);
  nooks_ot_register_userfn(str_508178660, 1905);
  nooks_ot_register_userfn(& __constr_expr_29, 1207);
  nooks_ot_register_userfn(str_790741568, 2013);
  nooks_ot_register_userfn(& __constr_expr_108, 1021);
  nooks_ot_register_userfn(& __param_arr_device_setup, 1299);
  nooks_ot_register_userfn(str_32155715, 1845);
  nooks_ot_register_userfn(str_611717, 1947);
  nooks_ot_register_userfn(str_597637, 1931);
  nooks_ot_register_userfn(str_601293205, 1937);
  nooks_ot_register_userfn(& __constr_expr_70, 1254);
  nooks_ot_register_userfn(& __constr_expr_163, 1082);
  nooks_ot_register_userfn(str_218563518, 1797);
  nooks_ot_register_userfn(str_683293777, 1981);
  nooks_ot_register_userfn(& async_unlink, 1330);
  nooks_ot_register_userfn(& __constr_expr_82, 1267);
  nooks_ot_register_userfn(& __constr_expr_172, 1092);
  nooks_ot_register_userfn(& __constr_expr_136, 1052);
  nooks_ot_register_userfn(str_85230465, 2028);
  nooks_ot_register_userfn(str_854498725, 2029);
  nooks_ot_register_userfn(str_410776958, 1867);
  nooks_ot_register_userfn(str_30230, 1834);
  nooks_ot_register_userfn(& __constr_expr_96, 1282);
  nooks_ot_register_userfn(& __constr_expr_120, 1035);
  nooks_ot_register_userfn(str_11395627, 1726);
  nooks_ot_register_userfn(& __constr_expr_236, 1164);
  nooks_ot_register_userfn(& __constr_expr_140, 1057);
  nooks_ot_register_userfn(str_31094, 1838);
  nooks_ot_register_userfn(str_9770741, 2088);
  nooks_ot_register_userfn(id, 1399);
  nooks_ot_register_userfn(& __constr_expr_58, 1240);
  nooks_ot_register_userfn(& __constr_expr_269, 1200);
  nooks_ot_register_userfn(str_496506222, 1893);
  nooks_ot_register_userfn(str_968180269, 2082);
  nooks_ot_register_userfn(str_582837192, 1925);
  nooks_ot_register_userfn(__constr_expr_215, 1141);
  nooks_ot_register_userfn(str_473778296, 1888);
  nooks_ot_register_userfn(str_611719, 1948);
  nooks_ot_register_userfn(str_974799125, 2087);
  nooks_ot_register_userfn(str_612180260, 1951);
  nooks_ot_register_userfn(str_25867, 1821);
  nooks_ot_register_userfn(str_934616211, 2061);
  nooks_ot_register_userfn(& __constr_expr_127, 1042);
  nooks_ot_register_userfn(& __constr_expr_155, 1073);
  nooks_ot_register_userfn(str_461892223, 1885);
  nooks_ot_register_userfn(& __constr_expr_46, 1227);
  nooks_ot_register_userfn(str_87930470, 2045);
  nooks_ot_register_userfn(& __constr_expr_10, 1012);
  nooks_ot_register_userfn(str_32, 1844);
  nooks_ot_register_userfn(str_561380, 1918);
  nooks_ot_register_userfn(str_9595539, 2077);
  nooks_ot_register_userfn(usb_chip, 2128);
  nooks_ot_register_userfn(__constr_expr_221, 1148);
  nooks_ot_register_userfn(& __constr_expr_256, 1186);
  nooks_ot_register_userfn(str_10753440, 1715);
  nooks_ot_register_userfn(str_657602785, 1971);
  nooks_ot_register_userfn(str_677216733, 1977);
  nooks_ot_register_userfn(str_595159629, 1928);
  nooks_ot_register_userfn(str_11181278, 1721);
  nooks_ot_register_userfn(reverb_proc_info, 1498);
  nooks_ot_register_userfn(& __constr_expr_34, 1214);
  nooks_ot_register_userfn(& __param_arr_enable, 1300);
  nooks_ot_register_userfn(& __constr_expr_22, 1146);
  nooks_ot_register_userfn(& __constr_expr_196, 1118);
  nooks_ot_register_userfn(& mixer_selectunit_ctl, 1441);
  nooks_ot_register_userfn(str_764993234, 2006);
  nooks_ot_register_userfn(str_218283728, 1796);
  nooks_ot_register_userfn(str_21158850, 1787);
  nooks_ot_register_userfn(str_316584895, 1842);
  nooks_ot_register_userfn(& __constr_expr_75, 1259);
  nooks_ot_register_userfn(str_629245061, 1958);
  nooks_ot_register_userfn(str_133922991, 1740);
  nooks_ot_register_userfn(audigy2nx_map, 1331);
  nooks_ot_register_userfn(& __constr_expr_144, 1061);
  nooks_ot_register_userfn(& __constr_expr_87, 1272);
  nooks_ot_register_userfn(__constr_expr_0___0, 1010);
  nooks_ot_register_userfn(str_154546784, 1753);
  nooks_ot_register_userfn(str_327960850, 1849);
  nooks_ot_register_userfn(str_601554213, 1940);
  nooks_ot_register_userfn(str_526151313, 1911);
  nooks_ot_register_userfn(& __constr_expr_227, 1154);
  nooks_ot_register_userfn(str_225760646, 1809);
  nooks_ot_register_userfn(& __constr_expr_63, 1246);
  nooks_ot_register_userfn(str_30931, 1837);
  nooks_ot_register_userfn(str_64240467, 1963);
  nooks_ot_register_userfn(str_857529930, 2037);
  nooks_ot_register_userfn(str_349765498, 1854);
  nooks_ot_register_userfn(str_1064537007, 1711);
  nooks_ot_register_userfn(& ua1000_format, 2110);
  nooks_ot_register_userfn(& default_info, 1363);
  nooks_ot_register_userfn(& __constr_expr_133, 1049);
  nooks_ot_register_userfn(str_515799417, 1907);
  nooks_ot_register_userfn(str_178901836, 1765);
  nooks_ot_register_userfn(str_1015625071, 1691);
  nooks_ot_register_userfn(& __constr_expr_104, 1017);
  nooks_ot_register_userfn(str_473127585, 1887);
  nooks_ot_register_userfn(str_835963836, 2023);
  nooks_ot_register_userfn(str_983984005, 2093);
  nooks_ot_register_userfn(& __constr_expr_3, 1209);
  nooks_ot_register_userfn(& __constr_expr_137, 1053);
  nooks_ot_register_userfn(__constr_expr_164, 1083);
  nooks_ot_register_userfn(& __constr_expr_51, 1233);
  nooks_ot_register_userfn(finish_data, 1376);
  nooks_ot_register_userfn(str_154546778, 1750);
  nooks_ot_register_userfn(str_219268125, 1802);
  nooks_ot_register_userfn(__constr_expr_109, 1022);
  nooks_ot_register_userfn(& __constr_expr_234, 1162);
  nooks_ot_register_userfn(str_16073815, 1757);
  nooks_ot_register_userfn(str_267488495, 1825);
  nooks_ot_register_userfn(& __constr_expr_182, 1103);
  nooks_ot_register_userfn(str_757471119, 2002);
  nooks_ot_register_userfn(usb_audio_ids, 2121);
  nooks_ot_register_userfn(& uaxx_ep, 2115);
  nooks_ot_register_userfn(& __constr_expr_211, 1137);
  nooks_ot_register_userfn(& __constr_expr_116, 1030);
  nooks_ot_register_userfn(__constr_expr_95, 1281);
  nooks_ot_register_userfn(& __constr_expr_39, 1219);
  nooks_ot_register_userfn(str_181728381, 1771);
  nooks_ot_register_userfn(str_11300298, 1723);
  nooks_ot_register_userfn(& __constr_expr_15, 1067);
  nooks_ot_register_userfn(str_589782702, 1927);
  nooks_ot_register_userfn(str_994182456, 2096);
  nooks_ot_register_userfn(str_415308913, 1870);
  nooks_ot_register_userfn(& __constr_expr_153, 1071);
  nooks_ot_register_userfn(__constr_expr_121, 1036);
  nooks_ot_register_userfn(procunits, 1484);
  nooks_ot_register_userfn(& __constr_expr_27, 1201);
  nooks_ot_register_userfn(str_75292164, 1997);
  nooks_ot_register_userfn(str_893500057, 2053);
  nooks_ot_register_userfn(& __constr_expr_262, 1193);
  nooks_ot_register_userfn(str_185760420, 1773);
  nooks_ot_register_userfn(str_21498367, 1790);
  nooks_ot_register_userfn(str_217733085, 1795);
  nooks_ot_register_userfn(str_761039825, 2004);
  nooks_ot_register_userfn(& register_mutex, 1488);
  nooks_ot_register_userfn(& ua101_format, 2111);
  nooks_ot_register_userfn(& __this_module, 1318);
  nooks_ot_register_userfn(& __constr_expr_80, 1265);
  nooks_ot_register_userfn(& __constr_expr_92, 1278);
  nooks_ot_register_userfn(& __constr_expr_68, 1251);
  nooks_ot_register_userfn(str_405545198, 1865);
  nooks_ot_register_userfn(str_10902533, 1717);
  nooks_ot_register_userfn(& snd_usbmidi_emagic_ops, 1628);
  nooks_ot_register_userfn(str_698187463, 1987);
  nooks_ot_register_userfn(str_948881558, 2073);
  nooks_ot_register_userfn(str_647061483, 1965);
  nooks_ot_register_userfn(& __constr_expr_250, 1180);
  nooks_ot_register_userfn(& __key___5, 1289);
  nooks_ot_register_userfn(prologic_proc_info, 1485);
  nooks_ot_register_userfn(str_201558877, 1778);
  nooks_ot_register_userfn(& __constr_expr_171, 1091);
  nooks_ot_register_userfn(__constr_expr_246, 1175);
  nooks_ot_register_userfn(str_947601669, 2072);
  nooks_ot_register_userfn(str_967653936, 2081);
  nooks_ot_register_userfn(str_752941123, 1998);
  nooks_ot_register_userfn(str_883168199, 2047);
  nooks_ot_register_userfn(& __constr_expr_252, 1182);
  nooks_ot_register_userfn(& __constr_expr_56, 1238);
  nooks_ot_register_userfn(str_868332612, 2039);
  nooks_ot_register_userfn(str_635602341, 1960);
  nooks_ot_register_userfn(str_164490267, 1758);
  nooks_ot_register_userfn(str_496824083, 1901);
  nooks_ot_register_userfn(str_75719076, 2001);
  nooks_ot_register_userfn(str_981956828, 2091);
  nooks_ot_register_userfn(& ua700_ep, 2112);
  nooks_ot_register_userfn(& __constr_expr_225, 1152);
  nooks_ot_register_userfn(& __constr_expr_267, 1198);
  nooks_ot_register_userfn(str_182916092, 1772);
  nooks_ot_register_userfn(str_179391037, 1767);
  nooks_ot_register_userfn(str_679801322, 1979);
  nooks_ot_register_userfn(str_62046100, 1957);
  nooks_ot_register_userfn(str_653514840, 1969);
  nooks_ot_register_userfn(__constr_expr_197, 1119);
  nooks_ot_register_userfn(& __constr_expr_8, 1264);
  nooks_ot_register_userfn(& __constr_expr_205, 1130);
  nooks_ot_register_userfn(& snd_usbmidi_standard_ops, 1671);
  nooks_ot_register_userfn(& __constr_expr_131, 1047);
  nooks_ot_register_userfn(& __constr_expr_44, 1225);
  nooks_ot_register_userfn(& snd_usb_capture_ops, 1572);
  nooks_ot_register_userfn(str_11694111, 1733);
  nooks_ot_register_userfn(str_220833115, 1807);
  nooks_ot_register_userfn(str_1069376918, 1713);
  nooks_ot_register_userfn(__kstrtab_snd_usbmidi_input_start, 1294);
  nooks_ot_register_userfn(str_125301167, 1736);
  nooks_ot_register_userfn(str_411382038, 1868);
  nooks_ot_register_userfn(str_1207, 1735);
  nooks_ot_register_userfn(& __constr_expr_162, 1081);
  nooks_ot_register_userfn(& __param_arr_vid, 1304);
  nooks_ot_register_userfn(& __constr_expr_20, 1124);
  nooks_ot_register_userfn(& __constr_expr_105, 1018);
  nooks_ot_register_userfn(& __constr_expr_32, 1212);
  nooks_ot_register_userfn(str_248349902, 1818);
  nooks_ot_register_userfn(str_178770687, 1764);
  nooks_ot_register_userfn(str_35173879, 1855);
  nooks_ot_register_userfn(str_778694563, 2009);
  nooks_ot_register_userfn(str_1073431585, 1714);
  nooks_ot_register_userfn(str_217050626, 1794);
  nooks_ot_register_userfn(& __constr_expr_73, 1257);
  nooks_ot_register_userfn(__constr_expr_2___0, 1208);
  nooks_ot_register_userfn(& __constr_expr_188, 1109);
  nooks_ot_register_userfn(& __constr_expr_232, 1160);
  nooks_ot_register_userfn(str_461885725, 1884);
  nooks_ot_register_userfn(str_216271012, 1793);
  nooks_ot_register_userfn(& ignore_ctl_error, 1400);
  nooks_ot_register_userfn(aureon_51_2_map, 1337);
  nooks_ot_register_userfn(str_1034644995, 1694);
  nooks_ot_register_userfn(str_158039148, 1754);
  nooks_ot_register_userfn(& __constr_expr_85, 1270);
  nooks_ot_register_userfn(str_532616561, 1913);
  nooks_ot_register_userfn(& __constr_expr_117, 1031);
  nooks_ot_register_userfn(iterm_names, 1412);
  nooks_ot_register_userfn(__kstrtab_snd_usb_create_midi_interface, 1292);
  nooks_ot_register_userfn(__constr_expr_138, 1054);
  nooks_ot_register_userfn(str_202091287, 1779);
  nooks_ot_register_userfn(__constr_expr_204, 1129);
  nooks_ot_register_userfn(str_214582020, 1789);
  nooks_ot_register_userfn(& __constr_expr_272, 1204);
  nooks_ot_register_userfn(str_351748476, 1856);
  nooks_ot_register_userfn(str_295956, 1829);
  nooks_ot_register_userfn(str_317885218, 1843);
  nooks_ot_register_userfn(str_1041470126, 1698);
  nooks_ot_register_userfn(& __constr_expr_61, 1244);
  nooks_ot_register_userfn(jacks_live24ext, 1414);
  nooks_ot_register_userfn(__constr_expr_154, 1072);
  nooks_ot_register_userfn(& dev_ops, 1367);
  nooks_ot_register_userfn(& __constr_expr_178, 1098);
  nooks_ot_register_userfn(str_756280652, 2000);
  nooks_ot_register_userfn(str_490515, 1891);
  nooks_ot_register_userfn(str_892675406, 2052);
  nooks_ot_register_userfn(str_496823988, 1896);
  nooks_ot_register_userfn(__constr_expr_212, 1138);
  nooks_ot_register_userfn(str_211697793, 1788);
  nooks_ot_register_userfn(str_1059676627, 1704);
  nooks_ot_register_userfn(& __constr_expr_219, 1145);
  nooks_ot_register_userfn(__param_str_index, 1310);
  nooks_ot_register_userfn(& mixer_procunit_ctl, 1440);
  nooks_ot_register_userfn(& __constr_expr_168, 1087);
  nooks_ot_register_userfn(& __constr_expr_243, 1172);
  nooks_ot_register_userfn(str_154546422, 1747);
  nooks_ot_register_userfn(str_220831141, 1804);
  nooks_ot_register_userfn(live24ext_map, 1425);
  nooks_ot_register_userfn(str_977636194, 2089);
  nooks_ot_register_userfn(& __constr_expr_49, 1230);
  nooks_ot_register_userfn(str_186466258, 1774);
  nooks_ot_register_userfn(str_445429857, 1878);
  nooks_ot_register_userfn(str_158454992, 1755);
  nooks_ot_register_userfn(str_207147453, 1782);
  nooks_ot_register_userfn(str_496460573, 1892);
  nooks_ot_register_userfn(str_93429168, 2060);
  nooks_ot_register_userfn(& __constr_expr_1, 1011);
  nooks_ot_register_userfn(str_782488767, 2011);
  nooks_ot_register_userfn(str_333096528, 1850);
  nooks_ot_register_userfn(& __constr_expr_13, 1045);
  nooks_ot_register_userfn(__param_str_id, 1308);
  nooks_ot_register_userfn(& __constr_expr_37, 1217);
  nooks_ot_register_userfn(& __constr_expr_194, 1116);
  nooks_ot_register_userfn(& __constr_expr_146, 1063);
  nooks_ot_register_userfn(str_934776571, 2062);
  nooks_ot_register_userfn(str_165494466, 1760);
  nooks_ot_register_userfn(str_854499811, 2032);
  nooks_ot_register_userfn(str_496823950, 1894);
  nooks_ot_register_userfn(str_11480405, 1727);
  nooks_ot_register_userfn(str_497625127, 1902);
  nooks_ot_register_userfn(__constr_expr_177, 1097);
  nooks_ot_register_userfn(& __constr_expr_25, 1179);
  nooks_ot_register_userfn(& __constr_expr_203, 1128);
  nooks_ot_register_userfn(& __constr_expr_223, 1150);
  nooks_ot_register_userfn(str_10530917, 1700);
  nooks_ot_register_userfn(str_944839672, 2069);
  nooks_ot_register_userfn(& __constr_expr_78, 1262);
  nooks_ot_register_userfn(& __constr_expr_160, 1079);
  nooks_ot_register_userfn(str_706759643, 1989);
  nooks_ot_register_userfn(str_65189559, 1966);
  nooks_ot_register_userfn(str_324299317, 1847);
  nooks_ot_register_userfn(& __constr_expr_97, 1283);
  nooks_ot_register_userfn(& __constr_expr_90, 1276);
  nooks_ot_register_userfn(& __constr_expr_259, 1189);
  nooks_ot_register_userfn(& __constr_expr_66, 1249);
  nooks_ot_register_userfn(str_615991579, 1955);
  nooks_ot_register_userfn(str_31596, 1841);
  nooks_ot_register_userfn(str_599646, 1933);
  nooks_ot_register_userfn(str_601293204, 1936);
  nooks_ot_register_userfn(str_1040058580, 1696);
  nooks_ot_register_userfn(str_550941773, 1915);
  nooks_ot_register_userfn(& __constr_expr_186, 1107);
  nooks_ot_register_userfn(str_556279697, 1916);
  nooks_ot_register_userfn(str_854499087, 2030);
  nooks_ot_register_userfn(str_884756751, 2049);
  nooks_ot_register_userfn(str_9946673, 2097);
  nooks_ot_register_userfn(& snd_usb_playback_ops, 1604);
  nooks_ot_register_userfn(str_9597327, 2078);
  nooks_ot_register_userfn(& __constr_expr_248, 1177);
  nooks_ot_register_userfn(& __constr_expr_101, 1014);
  nooks_ot_register_userfn(& __constr_expr_202, 1127);
  nooks_ot_register_userfn(& __constr_expr_134, 1050);
  nooks_ot_register_userfn(& __constr_expr_54, 1236);
  nooks_ot_register_userfn(& __constr_expr_123, 1038);
  nooks_ot_register_userfn(& __constr_expr_230, 1158);
  nooks_ot_register_userfn(str_207539138, 1783);
  nooks_ot_register_userfn(str_9839312, 2092);
  nooks_ot_register_userfn(& nrpacks, 1448);
  nooks_ot_register_userfn(str_960860569, 2079);
  nooks_ot_register_userfn(str_501945809, 1903);
  nooks_ot_register_userfn(__constr_expr_106, 1019);
  nooks_ot_register_userfn(str_228195326, 1811);
  nooks_ot_register_userfn(& __constr_expr_152, 1070);
  nooks_ot_register_userfn(& __constr_expr_6, 1242);
  nooks_ot_register_userfn(& __constr_expr_176, 1096);
  nooks_ot_register_userfn(str_764792676, 2005);
  nooks_ot_register_userfn(str_180244545, 1768);
  nooks_ot_register_userfn(str_298493551, 1831);
  nooks_ot_register_userfn(& __constr_expr_209, 1134);
  nooks_ot_register_userfn(str_612180259, 1950);
  nooks_ot_register_userfn(str_1341, 1741);
  nooks_ot_register_userfn(& __constr_expr_113, 1027);
  nooks_ot_register_userfn(& __key___4, 1288);
  nooks_ot_register_userfn(str_459503637, 1881);
  nooks_ot_register_userfn(__param_str_device_setup, 1306);
  nooks_ot_register_userfn(& __constr_expr_42, 1223);
  nooks_ot_register_userfn(& __constr_expr_166, 1085);
  nooks_ot_register_userfn(& __constr_expr_265, 1196);
  nooks_ot_register_userfn(str_461880310, 1883);
  nooks_ot_register_userfn(& __constr_expr_18, 1100);
  nooks_ot_register_userfn(__constr_expr_118, 1032);
  nooks_ot_register_userfn(str_686943043, 1982);
  nooks_ot_register_userfn(__param_str_async_unlink, 1305);
  nooks_ot_register_userfn(audio_urb_ops, 1334);
  nooks_ot_register_userfn(str_856339116, 2036);
  nooks_ot_register_userfn(str_765604581, 2007);
  nooks_ot_register_userfn(& __constr_expr_240, 1169);
  nooks_ot_register_userfn(& __constr_expr_241, 1170);
  nooks_ot_register_userfn(str_616233, 1956);
  nooks_ot_register_userfn(& snd_usbmidi_input_ops, 1642);
  nooks_ot_register_userfn(& __constr_expr_30, 1210);
  nooks_ot_register_userfn(audio_feature_info, 1333);
  nooks_ot_register_userfn(quirk_funcs, 1486);
  nooks_ot_register_userfn(maya44_map, 1429);
  nooks_ot_register_userfn(& __constr_expr_175, 1095);
  nooks_ot_register_userfn(& __constr_expr_143, 1060);
  nooks_ot_register_userfn(str_129785196, 1738);
  nooks_ot_register_userfn(str_30235, 1835);
  nooks_ot_register_userfn(str_528878465, 1912);
  nooks_ot_register_userfn(str_145470558, 1743);
  nooks_ot_register_userfn(str_429534546, 1872);
  nooks_ot_register_userfn(& __constr_expr_71, 1255);
  nooks_ot_register_userfn(& __constr_expr_83, 1268);
  nooks_ot_register_userfn(& __constr_expr_192, 1114);
  nooks_ot_register_userfn(& __constr_expr_125, 1040);
  nooks_ot_register_userfn(str_986049528, 2095);
  nooks_ot_register_userfn(str_607981, 1942);
  nooks_ot_register_userfn(str_984249857, 2094);
  nooks_ot_register_userfn(str_174936368, 1762);
  nooks_ot_register_userfn(str_489702074, 1890);
  nooks_ot_register_userfn(str_709717790, 1991);
  nooks_ot_register_userfn(& __param_arr_pid, 1303);
  nooks_ot_register_userfn(str_154546782, 1752);
  nooks_ot_register_userfn(& snd_usbmidi_novation_ops, 1652);
  nooks_ot_register_userfn(& __constr_expr_158, 1076);
  nooks_ot_register_userfn(str_215226995, 1791);
  nooks_ot_register_userfn(& __constr_expr_270, 1202);
  nooks_ot_register_userfn(str_596491274, 1930);
  nooks_ot_register_userfn(& __constr_expr_59, 1241);
  nooks_ot_register_userfn(str_735532888, 1993);
  nooks_ot_register_userfn(__constr_expr_145, 1062);
  nooks_ot_register_userfn(str_923436265, 2057);
  nooks_ot_register_userfn(& __constr_expr_257, 1187);
  nooks_ot_register_userfn(str_11554596, 1730);
  nooks_ot_register_userfn(str_219268750, 1803);
  nooks_ot_register_userfn(rc_configs, 1487);
  nooks_ot_register_userfn(str_882451506, 2046);
  nooks_ot_register_userfn(str_872419140, 2041);
  nooks_ot_register_userfn(str_10800265, 1716);
  nooks_ot_register_userfn(chorus_proc_info, 1349);
  nooks_ot_register_userfn(vid, 2162);
  nooks_ot_register_userfn(snd_usbmidi_cin_length, 1613);
  nooks_ot_register_userfn(& __constr_expr_184, 1105);
  nooks_ot_register_userfn(str_1041397175, 1697);
  nooks_ot_register_userfn(& __constr_expr_47, 1228);
  nooks_ot_register_userfn(str_178903280, 1766);
  nooks_ot_register_userfn(str_981105601, 2090);
  nooks_ot_register_userfn(str_438695472, 1875);
  nooks_ot_register_userfn(& __constr_expr_200, 1125);
  nooks_ot_register_userfn(str_181451660, 1770);
  nooks_ot_register_userfn(str_32328, 1846);
  nooks_ot_register_userfn(& __constr_expr_11, 1023);
  nooks_ot_register_userfn(& snd_usbmidi_cme_ops, 1615);
  nooks_ot_register_userfn(& snd_usbmidi_122l_ops, 1612);
  nooks_ot_register_userfn(str_154546776, 1749);
  nooks_ot_register_userfn(str_220831597, 1805);
  nooks_ot_register_userfn(str_305400396, 1836);
  nooks_ot_register_userfn(& __constr_expr_102, 1015);
  nooks_ot_register_userfn(str_960884417, 2080);
  nooks_ot_register_userfn(& __constr_expr_150, 1068);
  nooks_ot_register_userfn(str_1028937, 1692);
  nooks_ot_register_userfn(& __constr_expr_228, 1155);
  nooks_ot_register_userfn(& __constr_expr_35, 1215);
  nooks_ot_register_userfn(& __constr_expr_23, 1157);
  nooks_ot_register_userfn(str_615768, 1953);
  nooks_ot_register_userfn(& __constr_expr_207, 1132);
  nooks_ot_register_userfn(str_11540363, 1728);
  nooks_ot_register_userfn(str_1039773507, 1695);
  nooks_ot_register_userfn(str_754636363, 1999);
  nooks_ot_register_userfn(str_841139419, 2025);
  nooks_ot_register_userfn(__param_str_enable, 1307);
  nooks_ot_register_userfn(& __constr_expr_76, 1260);
  nooks_ot_register_userfn(& __constr_expr_114, 1028);
  nooks_ot_register_userfn(snd_usbmidi_port_info, 1665);
  nooks_ot_register_userfn(str_894397911, 2054);
  nooks_ot_register_userfn(str_6623682, 1974);
  nooks_ot_register_userfn(__constr_expr_135, 1051);
  nooks_ot_register_userfn(str_863125700, 2038);
  nooks_ot_register_userfn(str_738260344, 1994);
  nooks_ot_register_userfn(& __constr_expr_88, 1273);
  nooks_ot_register_userfn(str_346970378, 1853);
  nooks_ot_register_userfn(str_400614853, 1862);
  nooks_ot_register_userfn(& __constr_expr_238, 1166);
  nooks_ot_register_userfn(& __constr_expr_64, 1247);
  nooks_ot_register_userfn(& __constr_expr_141, 1058);
  nooks_ot_register_userfn(& __constr_expr_237, 1165);
  nooks_ot_register_userfn(str_405545197, 1864);
  nooks_ot_register_userfn(str_504327, 1904);
  nooks_ot_register_userfn(str_608431467, 1944);
  nooks_ot_register_userfn(str_809021430, 2021);
  nooks_ot_register_userfn(str_88429757, 2048);
  nooks_ot_register_userfn(& __constr_expr_190, 1112);
  nooks_ot_register_userfn(str_201558876, 1777);
  nooks_ot_register_userfn(str_10592645, 1703);
  nooks_ot_register_userfn(& __constr_expr_216, 1142);
  nooks_ot_register_userfn(str_1054178865, 1701);
  nooks_ot_register_userfn(str_544751132, 1914);
  nooks_ot_register_userfn(str_521161324, 1909);
  nooks_ot_register_userfn(str_325836133, 1848);
  nooks_ot_register_userfn(& __constr_expr_52, 1234);
  nooks_ot_register_userfn(& __constr_expr_4, 1220);
  nooks_ot_register_userfn(& ops, 1449);
  nooks_ot_register_userfn(str_639341561, 1962);
  nooks_ot_register_userfn(str_14089218, 1742);
  nooks_ot_register_userfn(& __constr_expr_156, 1074);
  nooks_ot_register_userfn(& __constr_expr_169, 1088);
  nooks_ot_register_userfn(str_208320737, 1784);
  nooks_ot_register_userfn(str_496824064, 1900);
  nooks_ot_register_userfn(__constr_expr_124, 1039);
  nooks_ot_register_userfn(str_785022198, 2012);
  nooks_ot_register_userfn(str_25903, 1823);
  nooks_ot_register_userfn(& __constr_expr_183, 1104);
  nooks_ot_register_userfn(& __constr_expr_255, 1185);
  nooks_ot_register_userfn(str_209484720, 1785);
  nooks_ot_register_userfn(str_11540368, 1729);
  nooks_ot_register_userfn(str_159293978, 1756);
  nooks_ot_register_userfn(& __constr_expr_40, 1221);
  nooks_ot_register_userfn(str_238177709, 1815);
  nooks_ot_register_userfn(str_772338763, 2008);
  nooks_ot_register_userfn(& __constr_expr_16, 1078);
  nooks_ot_register_userfn(& snd_usbmidi_maudio_broken_running_status_ops, 1648);
  nooks_ot_register_userfn(str_10637825, 1709);
  nooks_ot_register_userfn(str_64261101, 1964);
  nooks_ot_register_userfn(index, 1402);
  nooks_ot_register_userfn(& __constr_expr_28, 1206);
  nooks_ot_register_userfn(& __constr_expr_263, 1194);
  nooks_ot_register_userfn(str_444495457, 1877);
  nooks_ot_register_userfn(str_601293221, 1939);
  nooks_ot_register_userfn(str_659772121, 1972);
  nooks_ot_register_userfn(str_708091878, 1990);
  nooks_ot_register_userfn(init_data, 1403);
  nooks_ot_register_userfn(str_80732848, 2020);
  nooks_ot_register_userfn(str_9415899, 2066);
  nooks_ot_register_userfn(str_11174419, 1720);
  nooks_ot_register_userfn(& __constr_expr_69, 1252);
  nooks_ot_register_userfn(& __constr_expr_81, 1266);
  nooks_ot_register_userfn(str_496824026, 1898);
  nooks_ot_register_userfn(str_442778450, 1876);
  nooks_ot_register_userfn(& __constr_expr_93, 1279);
  nooks_ot_register_userfn(str_168675912, 1761);
  nooks_ot_register_userfn(& __constr_expr_226, 1153);
  nooks_ot_register_userfn(str_461878866, 1882);
  nooks_ot_register_userfn(str_10915739, 1718);
  nooks_ot_register_userfn(str_797487953, 2015);
  nooks_ot_register_userfn(str_336410471, 1852);
  nooks_ot_register_userfn(str_680563518, 1980);
  nooks_ot_register_userfn(__constr_expr_254, 1184);
  nooks_ot_register_userfn(usbmix_ctl_maps, 2160);
  nooks_ot_register_userfn(snd_audigy2nx_controls, 1509);
  nooks_ot_register_userfn(str_11699988, 1734);
  nooks_ot_register_userfn(& __constr_expr_57, 1239);
  nooks_ot_register_userfn(& __constr_expr_268, 1199);
  nooks_ot_register_userfn(str_215619040, 1792);
  nooks_ot_register_userfn(str_569364926, 1920);
  nooks_ot_register_userfn(& __constr_expr_132, 1048);
  nooks_ot_register_userfn(str_295955, 1828);
  nooks_ot_register_userfn(str_239825392, 1817);
  nooks_ot_register_userfn(__constr_expr_208, 1133);
  nooks_ot_register_userfn(str_806837355, 2019);
  nooks_ot_register_userfn(__param_str_ignore_ctl_error, 1309);
  nooks_ot_register_userfn(__constr_expr_103, 1016);
  nooks_ot_register_userfn(str_1014490587, 1690);
  nooks_ot_register_userfn(str_9378605, 2063);
  nooks_ot_register_userfn(str_854499089, 2031);
  nooks_ot_register_userfn(threed_enh_proc_info, 2109);
  nooks_ot_register_userfn(str_496823969, 1895);
  nooks_ot_register_userfn(str_403701822, 1863);
  nooks_ot_register_userfn(device_setup, 1369);
  nooks_ot_register_userfn(__param_str_nrpacks, 1311);
  nooks_ot_register_userfn(str_96862090, 2083);
  nooks_ot_register_userfn(& __constr_expr_110, 1024);
  nooks_ot_register_userfn(& __constr_expr_9, 1275);
  nooks_ot_register_userfn(& __constr_expr_235, 1163);
  nooks_ot_register_userfn(& __constr_expr_147, 1064);
  nooks_ot_register_userfn(str_154546420, 1746);
  nooks_ot_register_userfn(& __constr_expr_45, 1226);
  nooks_ot_register_userfn(str_219267764, 1801);
  nooks_ot_register_userfn(str_667951693, 1976);
  nooks_ot_register_userfn(& __constr_expr_98, 1284);
  nooks_ot_register_userfn(str_699349911, 1988);
  nooks_ot_register_userfn(str_924615310, 2058);
  nooks_ot_register_userfn(__constr_expr_115, 1029);
  nooks_ot_register_userfn(& __constr_expr_217, 1143);
  nooks_ot_register_userfn(__constr_expr_191, 1113);
  nooks_ot_register_userfn(& uaxx_quirk, 2116);
  nooks_ot_register_userfn(str_1068557351, 1712);
  nooks_ot_register_userfn(str_855751047, 2034);
  nooks_ot_register_userfn(& __constr_expr_21, 1135);
  nooks_ot_register_userfn(str_799096034, 2016);
  nooks_ot_register_userfn(str_956433291, 2075);
  nooks_ot_register_userfn(& __constr_expr_33, 1213);
  nooks_ot_register_userfn(& __constr_expr_122, 1037);
  nooks_ot_register_userfn(str_631087734, 1959);
  nooks_ot_register_userfn(str_1061019973, 1707);
  nooks_ot_register_userfn(& __constr_expr_74, 1258);
  nooks_ot_register_userfn(str_803117500, 2017);
  nooks_ot_register_userfn(& snd_usbmidi_raw_ops, 1667);
  nooks_ot_register_userfn(__kstrtab_snd_usbmidi_input_stop, 1295);
  nooks_ot_register_userfn(str_165493744, 1759);
  nooks_ot_register_userfn(__constr_expr_1___0, 1122);
  nooks_ot_register_userfn(str_63622457, 1961);
  nooks_ot_register_userfn(str_312951437, 1840);
  nooks_ot_register_userfn(str_609203, 1945);
  nooks_ot_register_userfn(& __constr_expr_253, 1183);
  nooks_ot_register_userfn(str_657372624, 1970);
  nooks_ot_register_userfn(& snd_usbmidi_midiman_ops, 1650);
  nooks_ot_register_userfn(default_value_info, 1364);
  nooks_ot_register_userfn(& __constr_expr_86, 1271);
  nooks_ot_register_userfn(__constr_expr_181, 1102);
  nooks_ot_register_userfn(& usb_audio_driver, 2120);
  nooks_ot_register_userfn(__param_str_vid, 1313);
  nooks_ot_register_userfn(str_608393064, 1943);
  nooks_ot_register_userfn(str_11272957, 1722);
  nooks_ot_register_userfn(str_376161077, 1859);
  nooks_ot_register_userfn(__constr_expr_249, 1178);
  nooks_ot_register_userfn(str_236948253, 1814);
  nooks_ot_register_userfn(str_877389318, 2043);
  nooks_ot_register_userfn(& __constr_expr_247, 1176);
  nooks_ot_register_userfn(& __constr_expr_62, 1245);
  nooks_ot_register_userfn(__constr_expr_170, 1090);
  nooks_ot_register_userfn(str_597914956, 1932);
  nooks_ot_register_userfn(str_855751104, 2035);
  nooks_ot_register_userfn(str_941262301, 2065);
  nooks_ot_register_userfn(str_612180261, 1952);
  nooks_ot_register_userfn(str_25888, 1822);
  nooks_ot_register_userfn(str_298606004, 1832);
  nooks_ot_register_userfn(& __constr_expr_273, 1205);
  nooks_ot_register_userfn(mp3plus_map, 1444);
  nooks_ot_register_userfn(& __constr_expr_2, 1123);
  nooks_ot_register_userfn(str_652131613, 1967);
  nooks_ot_register_userfn(str_522043394, 1910);
  nooks_ot_register_userfn(str_256741, 1820);
  nooks_ot_register_userfn(str_840389807, 2024);
  nooks_ot_register_userfn(str_599760, 1934);
  nooks_ot_register_userfn(& __constr_expr_50, 1232);
  nooks_ot_register_userfn(& __constr_expr_224, 1151);
  nooks_ot_register_userfn(& __constr_expr_198, 1120);
  nooks_ot_register_userfn(& __key___6, 1290);
  nooks_ot_register_userfn(& ua700_quirk, 2113);
  nooks_ot_register_userfn(& __constr_expr_206, 1131);
  nooks_ot_register_userfn(str_11588601, 1732);
  nooks_ot_register_userfn(str_482873, 1889);
  nooks_ot_register_userfn(& snd_usbmidi_ops, 1654);
  nooks_ot_register_userfn(str_15231084, 1744);
  nooks_ot_register_userfn(str_427276364, 1871);
  nooks_ot_register_userfn(str_572685, 1922);
  nooks_ot_register_userfn(& __constr_expr_99, 1285);
  nooks_ot_register_userfn(& __constr_expr_130, 1046);
  nooks_ot_register_userfn(& __constr_expr_14, 1056);
  nooks_ot_register_userfn(& __constr_expr_38, 1218);
  nooks_ot_register_userfn(str_43365079, 1873);
  nooks_ot_register_userfn(& __constr_expr_161, 1080);
  nooks_ot_register_userfn(str_219266584, 1798);
  nooks_ot_register_userfn(updown_proc_info, 2117);
  nooks_ot_register_userfn(str_87817340, 2044);
  nooks_ot_register_userfn(str_612180258, 1949);
  nooks_ot_register_userfn(str_694732782, 1985);
  nooks_ot_register_userfn(& __constr_expr_180, 1101);
  nooks_ot_register_userfn(str_238745560, 1816);
  nooks_ot_register_userfn(audio_urb_ops_high_speed, 1335);
  nooks_ot_register_userfn(& __constr_expr_26, 1190);
  nooks_ot_register_userfn(& __constr_expr_126, 1041);
  nooks_ot_register_userfn(str_1030557429, 1693);
  nooks_ot_register_userfn(& __constr_expr_261, 1192);
  nooks_ot_register_userfn(str_944848775, 2070);
  nooks_ot_register_userfn(str_209941598, 1786);
  nooks_ot_register_userfn(str_781461537, 2010);
  nooks_ot_register_userfn(& __constr_expr_189, 1110);
  nooks_ot_register_userfn(str_10641780, 1710);
  nooks_ot_register_userfn(& __constr_expr_111, 1025);
  nooks_ot_register_userfn(& __constr_expr_79, 1263);
  nooks_ot_register_userfn(& __constr_expr_233, 1161);
  nooks_ot_register_userfn(& __constr_expr_91, 1277);
  nooks_ot_register_userfn(& __constr_expr_67, 1250);
  nooks_ot_register_userfn(str_129785158, 1737);
  nooks_ot_register_userfn(str_226407066, 1810);
  nooks_ot_register_userfn(str_51703753, 1908);
  nooks_ot_register_userfn(& __constr_expr_139, 1055);
  nooks_ot_register_userfn(str_1060371900, 1705);
  nooks_ot_register_userfn(str_29891, 1833);
  nooks_ot_register_userfn(__constr_expr_129, 1044);
  nooks_ot_register_userfn(__kstrtab_snd_usbmidi_disconnect, 1293);
  nooks_ot_register_userfn(str_585972373, 1926);
  nooks_ot_register_userfn(str_26232, 1824);
  nooks_ot_register_userfn(str_902805966, 2055);
  nooks_ot_register_userfn(& __constr_expr_251, 1181);
  nooks_ot_register_userfn(str_843424035, 2026);
  nooks_ot_register_userfn(str_279917523, 1826);
  nooks_ot_register_userfn(& __constr_expr_179, 1099);
  nooks_ot_register_userfn(str_508915848, 1906);
  nooks_ot_register_userfn(& __constr_expr_213, 1139);
  nooks_ot_register_userfn(& __constr_expr_55, 1237);
  nooks_ot_register_userfn(str_154546780, 1751);
  nooks_ot_register_userfn(__constr_expr_218, 1144);
  nooks_ot_register_userfn(str_199274370, 1775);
  nooks_ot_register_userfn(str_388213389, 1860);
  nooks_ot_register_userfn(str_312378469, 1839);
  nooks_ot_register_userfn(str_221788472, 1808);
  nooks_ot_register_userfn(& __constr_expr_244, 1173);
  nooks_ot_register_userfn(& __constr_expr_167, 1086);
  nooks_ot_register_userfn(& __constr_expr_245, 1174);
  nooks_ot_register_userfn(jacks_audigy2nx, 1413);
  nooks_ot_register_userfn(& usb_feature_unit_ctl, 2138);
  nooks_ot_register_userfn(str_11554634, 1731);
  nooks_ot_register_userfn(& __constr_expr_7, 1253);
  nooks_ot_register_userfn(str_11300412, 1724);
  nooks_ot_register_userfn(str_595175755, 1929);
  nooks_ot_register_userfn(str_974050335, 2084);
  nooks_ot_register_userfn(str_1042685215, 1699);
  nooks_ot_register_userfn(& __constr_expr_266, 1197);
  nooks_ot_register_userfn(extigy_map, 1371);
  nooks_ot_register_userfn(& __constr_expr_43, 1224);
  nooks_ot_register_userfn(str_885550103, 2050);
  nooks_ot_register_userfn(str_577592, 1924);
  nooks_ot_register_userfn(str_677794626, 1978);
  nooks_ot_register_userfn(& __constr_expr_195, 1117);
  nooks_ot_register_userfn(str_652565892, 1968);
  nooks_ot_register_userfn(str_1004535908, 1688);
  nooks_ot_register_userfn(str_927843941, 2059);
  nooks_ot_register_userfn(& __constr_expr_19, 1111);
  nooks_ot_register_userfn(& __constr_expr_31, 1211);
  nooks_ot_register_userfn(audigy2nx_selectors, 1332);
  nooks_ot_register_userfn(str_405545199, 1866);
  nooks_ot_register_userfn(str_219267023, 1800);
  nooks_ot_register_userfn(str_412731004, 1869);
  nooks_ot_register_userfn(& __constr_expr_128, 1043);
  nooks_ot_register_userfn(& __constr_expr_222, 1149);
  nooks_ot_register_userfn(str_3623250, 1858);
  nooks_ot_register_userfn(str_758343632, 2003);
  nooks_ot_register_userfn(& __constr_expr_72, 1256);
  nooks_ot_register_userfn(& __constr_expr_159, 1077);
  nooks_ot_register_userfn(& __constr_expr_84, 1269);
  nooks_ot_register_userfn(str_615920, 1954);
  nooks_ot_register_userfn(str_220831975, 1806);
  nooks_ot_register_userfn(str_564233269, 1919);
  nooks_ot_register_userfn(str_791573890, 2014);
  nooks_ot_register_userfn(str_1055203368, 1702);
  nooks_ot_register_userfn(linex_map, 1421);
  nooks_ot_register_userfn(dcr_proc_info, 1361);
  nooks_ot_register_userfn(& __constr_expr_260, 1191);
  nooks_ot_register_userfn(str_447048969, 1879);
  nooks_ot_register_userfn(str_178763828, 1763);
  nooks_ot_register_userfn(str_558343, 1917);
  nooks_ot_register_userfn(str_358300541, 1857);
  nooks_ot_register_userfn(& __constr_expr_187, 1108);
  nooks_ot_register_userfn(str_28835, 1827);
  nooks_ot_register_userfn(& __constr_expr_60, 1243);
  nooks_ot_register_userfn(& __constr_expr_271, 1203);
  nooks_ot_register_userfn(str_870290969, 2040);
  nooks_ot_register_userfn(& __param_arr_index, 1302);
  nooks_ot_register_userfn(__constr_expr_100, 1013);
  nooks_ot_register_userfn(justlink_map, 1415);
  nooks_ot_register_userfn(str_254016772, 1819);
  nooks_ot_register_userfn(& __constr_expr_201, 1126);
  nooks_ot_register_userfn(str_219266585, 1799);
  nooks_ot_register_userfn(& __param_arr_id, 1301);
  nooks_ot_register_userfn(str_600119615, 1935);
  nooks_ot_register_userfn(str_852258126, 2027);
  nooks_ot_register_userfn(str_659921694, 1973);
  nooks_ot_register_userfn(& __constr_expr_231, 1159);
  nooks_ot_register_userfn(& __constr_expr_107, 1020);
  nooks_ot_register_userfn(__param_str_pid, 1312);
  nooks_ot_register_userfn(& __constr_expr_151, 1069);
  nooks_ot_register_userfn(& __constr_expr_48, 1229);
  nooks_ot_register_userfn(str_201558875, 1776);
  nooks_ot_register_userfn(str_11300431, 1725);
  nooks_ot_register_userfn(str_576734707, 1923);
  nooks_ot_register_userfn(str_687152508, 1983);
  nooks_ot_register_userfn(str_743645852, 1995);
  nooks_ot_register_userfn(str_570853617, 1921);
  nooks_ot_register_userfn(& __constr_expr_210, 1136);
  nooks_ot_register_userfn(& ua_format, 2114);
  nooks_ot_register_userfn(__constr_expr_112, 1026);
  nooks_ot_register_userfn(str_433838956, 1874);
  nooks_ot_register_userfn(& __constr_expr_12, 1034);
  nooks_ot_register_userfn(str_6629097, 1975);
  nooks_ot_register_userfn(str_9440451, 2068);
  nooks_ot_register_userfn(& __constr_expr_214, 1140);
  nooks_ot_register_userfn(str_496824045, 1899);
  nooks_ot_register_userfn(str_391949103, 1861);
  nooks_ot_register_userfn(str_180256858, 1769);
  nooks_ot_register_userfn(& __constr_expr_119, 1033);
  nooks_ot_register_userfn(& __constr_expr_165, 1084);
  nooks_ot_register_userfn(& __constr_expr_36, 1216);
  nooks_ot_register_userfn(& __constr_expr_242, 1171);
  nooks_ot_register_userfn(__constr_expr_239, 1167);
  nooks_ot_register_userfn(str_129785201, 1739);
  nooks_ot_register_userfn(str_335406018, 1851);
  nooks_ot_register_userfn(str_747151802, 1996);
  nooks_ot_register_userfn(& __constr_expr_24, 1168);
  nooks_ot_register_userfn(str_1060912469, 1706);
  nooks_ot_register_userfn(str_873074482, 2042);
  nooks_ot_register_userfn(& __constr_expr_142, 1059);
  nooks_ot_register_userfn(& __constr_expr_174, 1094);
  nooks_ot_register_userfn(& __constr_expr_0, 1009);
  nooks_ot_register_userfn(& __constr_expr_77, 1261);
  nooks_ot_register_userfn(pid, 1470);
  nooks_ot_register_userfn(& __constr_expr_193, 1115);
  nooks_ot_register_userfn(str_202098146, 1780);
  nooks_ot_register_userfn(str_607388, 1941);
  nooks_ot_register_userfn(str_908632785, 2056);
  nooks_ot_register_userfn(str_601293220, 1938);
}
}
