/* Generated by CIL v. 1.4.0 */
/* print_CIL_Input is true */

#include "../../common/master_top.h" // Matt E1
char function_id_map[1407][128]  = 
  {      "0", 
        "1", 
        "2", 
        "3", 
        "4", 
        "5", 
        "6", 
        "7", 
        "8", 
        "9", 
        "10", 
        "11", 
        "12", 
        "13", 
        "14", 
        "15", 
        "16", 
        "17", 
        "18", 
        "19", 
        "20", 
        "21", 
        "22", 
        "23", 
        "24", 
        "25", 
        "26", 
        "27", 
        "28", 
        "29", 
        "30", 
        "31", 
        "32", 
        "33", 
        "34", 
        "35", 
        "36", 
        "37", 
        "38", 
        "39", 
        "40", 
        "41", 
        "42", 
        "43", 
        "44", 
        "45", 
        "46", 
        "47", 
        "48", 
        "49", 
        "50", 
        "51", 
        "52", 
        "53", 
        "54", 
        "55", 
        "56", 
        "57", 
        "58", 
        "59", 
        "60", 
        "61", 
        "62", 
        "63", 
        "64", 
        "65", 
        "66", 
        "67", 
        "68", 
        "69", 
        "70", 
        "71", 
        "72", 
        "73", 
        "74", 
        "75", 
        "76", 
        "77", 
        "78", 
        "79", 
        "80", 
        "81", 
        "82", 
        "83", 
        "84", 
        "85", 
        "86", 
        "87", 
        "88", 
        "89", 
        "90", 
        "91", 
        "92", 
        "93", 
        "94", 
        "95", 
        "96", 
        "97", 
        "98", 
        "99", 
        "100", 
        "101", 
        "102", 
        "103", 
        "104", 
        "105", 
        "106", 
        "107", 
        "108", 
        "109", 
        "110", 
        "111", 
        "112", 
        "113", 
        "114", 
        "115", 
        "116", 
        "117", 
        "118", 
        "119", 
        "120", 
        "121", 
        "122", 
        "123", 
        "124", 
        "125", 
        "126", 
        "127", 
        "128", 
        "129", 
        "130", 
        "131", 
        "132", 
        "133", 
        "134", 
        "135", 
        "136", 
        "137", 
        "138", 
        "139", 
        "140", 
        "141", 
        "142", 
        "143", 
        "144", 
        "145", 
        "146", 
        "147", 
        "148", 
        "149", 
        "150", 
        "151", 
        "152", 
        "153", 
        "154", 
        "155", 
        "156", 
        "157", 
        "158", 
        "159", 
        "160", 
        "161", 
        "162", 
        "163", 
        "164", 
        "165", 
        "166", 
        "167", 
        "168", 
        "169", 
        "170", 
        "171", 
        "172", 
        "173", 
        "174", 
        "175", 
        "176", 
        "177", 
        "178", 
        "179", 
        "180", 
        "181", 
        "182", 
        "183", 
        "184", 
        "185", 
        "186", 
        "187", 
        "188", 
        "189", 
        "190", 
        "191", 
        "192", 
        "193", 
        "194", 
        "195", 
        "196", 
        "197", 
        "198", 
        "199", 
        "200", 
        "201", 
        "202", 
        "203", 
        "204", 
        "205", 
        "206", 
        "207", 
        "208", 
        "209", 
        "210", 
        "211", 
        "212", 
        "213", 
        "214", 
        "215", 
        "216", 
        "217", 
        "218", 
        "219", 
        "220", 
        "221", 
        "222", 
        "223", 
        "224", 
        "225", 
        "226", 
        "227", 
        "228", 
        "229", 
        "230", 
        "231", 
        "232", 
        "233", 
        "234", 
        "235", 
        "236", 
        "237", 
        "238", 
        "239", 
        "240", 
        "241", 
        "242", 
        "243", 
        "244", 
        "245", 
        "246", 
        "247", 
        "248", 
        "249", 
        "250", 
        "251", 
        "252", 
        "253", 
        "254", 
        "255", 
        "256", 
        "257", 
        "258", 
        "259", 
        "260", 
        "261", 
        "262", 
        "263", 
        "264", 
        "265", 
        "266", 
        "267", 
        "268", 
        "269", 
        "270", 
        "271", 
        "272", 
        "273", 
        "274", 
        "275", 
        "276", 
        "277", 
        "278", 
        "279", 
        "280", 
        "281", 
        "282", 
        "283", 
        "284", 
        "285", 
        "286", 
        "287", 
        "288", 
        "289", 
        "290", 
        "291", 
        "292", 
        "293", 
        "294", 
        "295", 
        "296", 
        "297", 
        "298", 
        "299", 
        "300", 
        "301", 
        "302", 
        "303", 
        "304", 
        "305", 
        "306", 
        "307", 
        "308", 
        "309", 
        "310", 
        "311", 
        "312", 
        "313", 
        "314", 
        "315", 
        "316", 
        "317", 
        "318", 
        "319", 
        "320", 
        "321", 
        "322", 
        "323", 
        "324", 
        "325", 
        "326", 
        "327", 
        "328", 
        "329", 
        "330", 
        "331", 
        "332", 
        "333", 
        "334", 
        "335", 
        "336", 
        "337", 
        "338", 
        "339", 
        "340", 
        "341", 
        "342", 
        "343", 
        "344", 
        "345", 
        "346", 
        "347", 
        "348", 
        "349", 
        "350", 
        "351", 
        "352", 
        "353", 
        "354", 
        "355", 
        "356", 
        "357", 
        "358", 
        "359", 
        "360", 
        "361", 
        "362", 
        "363", 
        "364", 
        "365", 
        "366", 
        "367", 
        "368", 
        "369", 
        "370", 
        "371", 
        "372", 
        "373", 
        "374", 
        "375", 
        "376", 
        "377", 
        "378", 
        "379", 
        "380", 
        "381", 
        "382", 
        "383", 
        "384", 
        "385", 
        "386", 
        "387", 
        "388", 
        "389", 
        "390", 
        "391", 
        "392", 
        "393", 
        "394", 
        "395", 
        "396", 
        "397", 
        "398", 
        "399", 
        "400", 
        "401", 
        "402", 
        "403", 
        "404", 
        "405", 
        "406", 
        "407", 
        "408", 
        "409", 
        "410", 
        "411", 
        "412", 
        "413", 
        "414", 
        "415", 
        "416", 
        "417", 
        "418", 
        "419", 
        "420", 
        "421", 
        "422", 
        "423", 
        "424", 
        "425", 
        "426", 
        "427", 
        "428", 
        "429", 
        "430", 
        "431", 
        "432", 
        "433", 
        "434", 
        "435", 
        "436", 
        "437", 
        "438", 
        "439", 
        "440", 
        "441", 
        "442", 
        "443", 
        "444", 
        "445", 
        "446", 
        "447", 
        "448", 
        "449", 
        "450", 
        "451", 
        "452", 
        "453", 
        "454", 
        "455", 
        "456", 
        "457", 
        "458", 
        "459", 
        "460", 
        "461", 
        "462", 
        "463", 
        "464", 
        "465", 
        "466", 
        "467", 
        "468", 
        "469", 
        "470", 
        "471", 
        "472", 
        "473", 
        "474", 
        "475", 
        "476", 
        "477", 
        "478", 
        "479", 
        "480", 
        "481", 
        "482", 
        "483", 
        "484", 
        "485", 
        "486", 
        "487", 
        "488", 
        "489", 
        "490", 
        "491", 
        "492", 
        "493", 
        "494", 
        "495", 
        "496", 
        "497", 
        "498", 
        "499", 
        "500", 
        "501", 
        "502", 
        "503", 
        "504", 
        "505", 
        "506", 
        "507", 
        "508", 
        "509", 
        "510", 
        "511", 
        "512", 
        "513", 
        "514", 
        "515", 
        "516", 
        "517", 
        "518", 
        "519", 
        "520", 
        "521", 
        "522", 
        "523", 
        "524", 
        "525", 
        "526", 
        "527", 
        "528", 
        "529", 
        "530", 
        "531", 
        "532", 
        "533", 
        "534", 
        "535", 
        "536", 
        "537", 
        "538", 
        "539", 
        "540", 
        "541", 
        "542", 
        "543", 
        "544", 
        "545", 
        "546", 
        "547", 
        "548", 
        "549", 
        "550", 
        "551", 
        "552", 
        "553", 
        "554", 
        "555", 
        "556", 
        "557", 
        "558", 
        "559", 
        "560", 
        "561", 
        "562", 
        "563", 
        "564", 
        "565", 
        "566", 
        "567", 
        "568", 
        "569", 
        "570", 
        "571", 
        "572", 
        "573", 
        "574", 
        "575", 
        "576", 
        "577", 
        "578", 
        "579", 
        "580", 
        "581", 
        "582", 
        "583", 
        "584", 
        "585", 
        "586", 
        "587", 
        "588", 
        "589", 
        "590", 
        "591", 
        "592", 
        "593", 
        "594", 
        "595", 
        "596", 
        "597", 
        "598", 
        "599", 
        "600", 
        "601", 
        "602", 
        "603", 
        "604", 
        "605", 
        "606", 
        "607", 
        "608", 
        "609", 
        "610", 
        "611", 
        "612", 
        "613", 
        "614", 
        "615", 
        "616", 
        "617", 
        "618", 
        "619", 
        "620", 
        "621", 
        "622", 
        "623", 
        "624", 
        "625", 
        "626", 
        "627", 
        "628", 
        "629", 
        "630", 
        "631", 
        "632", 
        "633", 
        "634", 
        "635", 
        "636", 
        "637", 
        "638", 
        "639", 
        "640", 
        "641", 
        "642", 
        "643", 
        "644", 
        "645", 
        "646", 
        "647", 
        "648", 
        "649", 
        "650", 
        "651", 
        "652", 
        "653", 
        "654", 
        "655", 
        "656", 
        "657", 
        "658", 
        "659", 
        "660", 
        "661", 
        "662", 
        "663", 
        "664", 
        "665", 
        "666", 
        "667", 
        "668", 
        "669", 
        "670", 
        "671", 
        "672", 
        "673", 
        "674", 
        "675", 
        "676", 
        "677", 
        "678", 
        "679", 
        "680", 
        "681", 
        "682", 
        "683", 
        "684", 
        "685", 
        "686", 
        "687", 
        "688", 
        "689", 
        "690", 
        "691", 
        "692", 
        "693", 
        "694", 
        "695", 
        "696", 
        "697", 
        "698", 
        "699", 
        "700", 
        "701", 
        "702", 
        "703", 
        "704", 
        "705", 
        "706", 
        "707", 
        "708", 
        "709", 
        "710", 
        "711", 
        "712", 
        "713", 
        "714", 
        "715", 
        "716", 
        "717", 
        "718", 
        "719", 
        "720", 
        "721", 
        "722", 
        "723", 
        "724", 
        "725", 
        "726", 
        "727", 
        "728", 
        "729", 
        "730", 
        "731", 
        "732", 
        "733", 
        "734", 
        "735", 
        "736", 
        "737", 
        "738", 
        "739", 
        "740", 
        "741", 
        "742", 
        "743", 
        "744", 
        "745", 
        "746", 
        "747", 
        "748", 
        "749", 
        "750", 
        "751", 
        "752", 
        "753", 
        "754", 
        "755", 
        "756", 
        "757", 
        "758", 
        "759", 
        "760", 
        "761", 
        "762", 
        "763", 
        "764", 
        "765", 
        "766", 
        "767", 
        "768", 
        "769", 
        "770", 
        "771", 
        "772", 
        "773", 
        "774", 
        "775", 
        "776", 
        "777", 
        "778", 
        "779", 
        "780", 
        "781", 
        "782", 
        "783", 
        "784", 
        "785", 
        "786", 
        "787", 
        "788", 
        "789", 
        "790", 
        "791", 
        "792", 
        "793", 
        "794", 
        "795", 
        "796", 
        "797", 
        "798", 
        "799", 
        "800", 
        "801", 
        "802", 
        "803", 
        "804", 
        "805", 
        "806", 
        "807", 
        "808", 
        "809", 
        "810", 
        "811", 
        "812", 
        "813", 
        "814", 
        "815", 
        "816", 
        "817", 
        "818", 
        "819", 
        "820", 
        "821", 
        "822", 
        "823", 
        "824", 
        "825", 
        "826", 
        "827", 
        "828", 
        "829", 
        "830", 
        "831", 
        "832", 
        "833", 
        "834", 
        "835", 
        "836", 
        "837", 
        "838", 
        "839", 
        "840", 
        "841", 
        "842", 
        "843", 
        "844", 
        "845", 
        "846", 
        "847", 
        "848", 
        "849", 
        "850", 
        "851", 
        "852", 
        "853", 
        "854", 
        "855", 
        "856", 
        "857", 
        "858", 
        "859", 
        "860", 
        "861", 
        "862", 
        "863", 
        "864", 
        "865", 
        "866", 
        "867", 
        "868", 
        "869", 
        "870", 
        "871", 
        "872", 
        "873", 
        "874", 
        "875", 
        "876", 
        "877", 
        "878", 
        "879", 
        "880", 
        "881", 
        "882", 
        "883", 
        "884", 
        "885", 
        "886", 
        "887", 
        "888", 
        "889", 
        "890", 
        "891", 
        "892", 
        "893", 
        "894", 
        "895", 
        "896", 
        "897", 
        "898", 
        "899", 
        "900", 
        "901", 
        "902", 
        "903", 
        "904", 
        "905", 
        "906", 
        "907", 
        "908", 
        "909", 
        "910", 
        "911", 
        "912", 
        "913", 
        "914", 
        "915", 
        "916", 
        "917", 
        "918", 
        "919", 
        "920", 
        "921", 
        "922", 
        "923", 
        "924", 
        "925", 
        "926", 
        "927", 
        "928", 
        "929", 
        "930", 
        "931", 
        "932", 
        "933", 
        "934", 
        "935", 
        "936", 
        "937", 
        "938", 
        "939", 
        "940", 
        "941", 
        "942", 
        "943", 
        "944", 
        "945", 
        "946", 
        "947", 
        "948", 
        "949", 
        "950", 
        "951", 
        "952", 
        "953", 
        "954", 
        "955", 
        "956", 
        "957", 
        "958", 
        "959", 
        "960", 
        "961", 
        "962", 
        "963", 
        "964", 
        "965", 
        "966", 
        "967", 
        "968", 
        "969", 
        "970", 
        "971", 
        "972", 
        "973", 
        "974", 
        "975", 
        "976", 
        "977", 
        "978", 
        "979", 
        "980", 
        "981", 
        "982", 
        "983", 
        "984", 
        "985", 
        "986", 
        "987", 
        "988", 
        "989", 
        "990", 
        "991", 
        "992", 
        "993", 
        "994", 
        "995", 
        "996", 
        "997", 
        "998", 
        "999", 
        "MICRODRIVERS__DUMMY", 
        "MICRODRIVERS__MODIF___mutex_init", 
        "MICRODRIVERS__MODIF___pci_register_driver", 
        "MICRODRIVERS__MODIF___release_region", 
        "MICRODRIVERS__MODIF___request_region", 
        "MICRODRIVERS__MODIF___spin_lock_init", 
        "MICRODRIVERS__MODIF___wake_up", 
        "MICRODRIVERS__MODIF__spin_lock", 
        "MICRODRIVERS__MODIF__spin_lock_bh", 
        "MICRODRIVERS__MODIF__spin_lock_irq", 
        "MICRODRIVERS__MODIF__spin_lock_irqsave", 
        "MICRODRIVERS__MODIF__spin_unlock", 
        "MICRODRIVERS__MODIF__spin_unlock_bh", 
        "MICRODRIVERS__MODIF__spin_unlock_irq", 
        "MICRODRIVERS__MODIF__spin_unlock_irqrestore", 
        "MICRODRIVERS__MODIF_create_proc_entry", 
        "MICRODRIVERS__MODIF_device_create_file", 
        "MICRODRIVERS__MODIF_free_irq", 
        "MICRODRIVERS__MODIF_hrtimer_get_res", 
        "MICRODRIVERS__MODIF_kmem_cache_zalloc", 
        "MICRODRIVERS__MODIF_logAlloc", 
        "MICRODRIVERS__MODIF_logRead", 
        "MICRODRIVERS__MODIF_logStackFrame", 
        "MICRODRIVERS__MODIF_logWrite", 
        "MICRODRIVERS__MODIF_mutex_lock", 
        "MICRODRIVERS__MODIF_mutex_unlock", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_byte", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_word", 
        "MICRODRIVERS__MODIF_pci_disable_device", 
        "MICRODRIVERS__MODIF_pci_enable_device", 
        "MICRODRIVERS__MODIF_pci_release_regions", 
        "MICRODRIVERS__MODIF_pci_request_regions", 
        "MICRODRIVERS__MODIF_pci_restore_state", 
        "MICRODRIVERS__MODIF_pci_save_state", 
        "MICRODRIVERS__MODIF_pci_set_master", 
        "MICRODRIVERS__MODIF_pci_set_power_state", 
        "MICRODRIVERS__MODIF_pci_unregister_driver", 
        "MICRODRIVERS__MODIF_proc_symlink", 
        "MICRODRIVERS__MODIF_request_irq", 
        "__const_udelay", 
        "__gameport_register_port", 
        "__key___0", 
        "__kmalloc", 
        "__mutex_init", 
        "__param_arr_enable", 
        "__param_arr_fm_port", 
        "__param_arr_id", 
        "__param_arr_index", 
        "__param_arr_joystick_port", 
        "__param_arr_mpu_port", 
        "__param_arr_soft_ac3", 
        "__param_str_enable", 
        "__param_str_fm_port", 
        "__param_str_id", 
        "__param_str_index", 
        "__param_str_joystick_port", 
        "__param_str_mpu_port", 
        "__param_str_soft_ac3", 
        "__pci_register_driver", 
        "__raw_spin_unlock", 
        "__request_region", 
        "__snd_bug_on", 
        "__this_module", 
        "__ticket_spin_unlock", 
        "__wake_up", 
        "_snd_cmipci_uswitch_get", 
        "_snd_cmipci_uswitch_put", 
        "_spin_lock", 
        "_spin_lock_irq", 
        "alsa_card_cmipci_exit", 
        "alsa_card_cmipci_init", 
        "cleanup_module", 
        "close_device_check", 
        "cm_saved_mixer", 
        "cmipci_sb_reg_decode", 
        "cmipci_switch_arg_exchange_dac", 
        "cmipci_switch_arg_fourch", 
        "cmipci_switch_arg_modem", 
        "cmipci_switch_arg_spdi_monitor", 
        "cmipci_switch_arg_spdi_phase", 
        "cmipci_switch_arg_spdi_phase2", 
        "cmipci_switch_arg_spdi_valid", 
        "cmipci_switch_arg_spdif_copyright", 
        "cmipci_switch_arg_spdif_dac_out", 
        "cmipci_switch_arg_spdif_enable", 
        "cmipci_switch_arg_spdif_in_sel1", 
        "cmipci_switch_arg_spdif_in_sel2", 
        "cmipci_switch_arg_spdif_loop", 
        "cmipci_switch_arg_spdo2dac", 
        "cmipci_switch_arg_spdo_5v", 
        "dev_get_drvdata", 
        "dev_name", 
        "dev_set_drvdata", 
        "driver", 
        "enable", 
        "fm_port", 
        "free_irq", 
        "gameport_allocate_port", 
        "gameport_register_port", 
        "gameport_set_name", 
        "gameport_set_phys", 
        "gameport_unregister_port", 
        "get_line_in_mode", 
        "heapifyfree", 
        "heapifymalloc", 
        "hw_channels", 
        "hw_constraints_channels_4", 
        "hw_constraints_channels_6", 
        "hw_constraints_channels_8", 
        "hw_constraints_rates", 
        "hw_param_interval", 
        "id", 
        "inb", 
        "index", 
        "init_module", 
        "inl", 
        "intel_82437vx", 
        "inw", 
        "ioport_resource", 
        "joystick_port", 
        "kfree", 
        "kmalloc", 
        "kzalloc", 
        "logAlloc", 
        "logFree", 
        "logRead", 
        "logStackFrame", 
        "logStackVar", 
        "logWrite", 
        "memset", 
        "mpu_port", 
        "msleep", 
        "mutex_lock", 
        "mutex_unlock", 
        "native_irq_enable", 
        "open_device_check", 
        "ops", 
        "outb", 
        "outl", 
        "outw", 
        "param_array_get", 
        "param_array_set", 
        "param_get_bool", 
        "param_get_charp", 
        "param_get_int", 
        "param_get_long", 
        "param_set_bool", 
        "param_set_charp", 
        "param_set_int", 
        "param_set_long", 
        "pci_choose_state", 
        "pci_dev_present", 
        "pci_disable_device", 
        "pci_enable_device", 
        "pci_get_drvdata", 
        "pci_name", 
        "pci_release_regions", 
        "pci_request_regions", 
        "pci_restore_state", 
        "pci_save_state", 
        "pci_set_drvdata", 
        "pci_set_master", 
        "pci_set_power_state", 
        "pci_unregister_driver", 
        "ports", 
        "printk", 
        "query_chip", 
        "rate_constraints", 
        "rates", 
        "raw_local_irq_enable", 
        "release_and_free_resource", 
        "request_irq", 
        "restore_mixer_state", 
        "save_mixer_state", 
        "saved_mixers", 
        "saved_regs", 
        "set_dac_channels", 
        "setup_ac3", 
        "setup_spdif_playback", 
        "snd_card_disconnect", 
        "snd_card_free", 
        "snd_card_new", 
        "snd_card_proc_new", 
        "snd_card_register", 
        "snd_cmipci_8738_mixer_switches", 
        "snd_cmipci_capture_close", 
        "snd_cmipci_capture_open", 
        "snd_cmipci_capture_ops", 
        "snd_cmipci_capture_pointer", 
        "snd_cmipci_capture_prepare", 
        "snd_cmipci_capture_spdif_close", 
        "snd_cmipci_capture_spdif_hw_free", 
        "snd_cmipci_capture_spdif_open", 
        "snd_cmipci_capture_spdif_ops", 
        "snd_cmipci_capture_spdif_prepare", 
        "snd_cmipci_capture_trigger", 
        "snd_cmipci_ch_reset", 
        "snd_cmipci_clear_bit", 
        "snd_cmipci_clear_bit_b", 
        "snd_cmipci_create", 
        "snd_cmipci_create_fm", 
        "snd_cmipci_create_gameport", 
        "snd_cmipci_dev_free", 
        "snd_cmipci_extra_mixer_switches", 
        "snd_cmipci_free", 
        "snd_cmipci_free_gameport", 
        "snd_cmipci_get_input_sw", 
        "snd_cmipci_get_native_mixer", 
        "snd_cmipci_get_native_mixer_sensitive", 
        "snd_cmipci_get_volume", 
        "snd_cmipci_hw_free", 
        "snd_cmipci_hw_params", 
        "snd_cmipci_ids", 
        "snd_cmipci_info_input_sw", 
        "snd_cmipci_info_native_mixer", 
        "snd_cmipci_info_volume", 
        "snd_cmipci_interrupt", 
        "snd_cmipci_line_in_mode_get", 
        "snd_cmipci_line_in_mode_info", 
        "snd_cmipci_line_in_mode_put", 
        "snd_cmipci_mic_in_mode_get", 
        "snd_cmipci_mic_in_mode_info", 
        "snd_cmipci_mic_in_mode_put", 
        "snd_cmipci_mixer_new", 
        "snd_cmipci_mixer_read", 
        "snd_cmipci_mixer_switches", 
        "snd_cmipci_mixer_write", 
        "snd_cmipci_mixers", 
        "snd_cmipci_modem_switch", 
        "snd_cmipci_nomulti_switch", 
        "snd_cmipci_old_mixer_switches", 
        "snd_cmipci_pcm2_new", 
        "snd_cmipci_pcm_new", 
        "snd_cmipci_pcm_pointer", 
        "snd_cmipci_pcm_prepare", 
        "snd_cmipci_pcm_spdif_new", 
        "snd_cmipci_pcm_trigger", 
        "snd_cmipci_playback2_close", 
        "snd_cmipci_playback2_hw_free", 
        "snd_cmipci_playback2_hw_params", 
        "snd_cmipci_playback2_open", 
        "snd_cmipci_playback2_ops", 
        "snd_cmipci_playback_close", 
        "snd_cmipci_playback_hw_free", 
        "snd_cmipci_playback_open", 
        "snd_cmipci_playback_ops", 
        "snd_cmipci_playback_pointer", 
        "snd_cmipci_playback_prepare", 
        "snd_cmipci_playback_spdif_close", 
        "snd_cmipci_playback_spdif_open", 
        "snd_cmipci_playback_spdif_ops", 
        "snd_cmipci_playback_spdif_prepare", 
        "snd_cmipci_playback_trigger", 
        "snd_cmipci_probe", 
        "snd_cmipci_proc_init", 
        "snd_cmipci_proc_read", 
        "snd_cmipci_put_input_sw", 
        "snd_cmipci_put_native_mixer", 
        "snd_cmipci_put_native_mixer_sensitive", 
        "snd_cmipci_put_volume", 
        "snd_cmipci_rate_freq", 
        "snd_cmipci_read", 
        "snd_cmipci_read_b", 
        "snd_cmipci_read_w", 
        "snd_cmipci_remove", 
        "snd_cmipci_resume", 
        "snd_cmipci_set_bit", 
        "snd_cmipci_set_bit_b", 
        "snd_cmipci_silence_hack", 
        "snd_cmipci_spdif_default", 
        "snd_cmipci_spdif_default_get", 
        "snd_cmipci_spdif_default_info", 
        "snd_cmipci_spdif_default_put", 
        "snd_cmipci_spdif_mask", 
        "snd_cmipci_spdif_mask_get", 
        "snd_cmipci_spdif_mask_info", 
        "snd_cmipci_spdif_stream", 
        "snd_cmipci_spdif_stream_get", 
        "snd_cmipci_spdif_stream_info", 
        "snd_cmipci_spdif_stream_put", 
        "snd_cmipci_spdout_enable_get", 
        "snd_cmipci_spdout_enable_put", 
        "snd_cmipci_suspend", 
        "snd_cmipci_uswitch_get", 
        "snd_cmipci_uswitch_put", 
        "snd_cmipci_write", 
        "snd_cmipci_write_b", 
        "snd_cmipci_write_w", 
        "snd_ctl_add", 
        "snd_ctl_boolean_mono_info", 
        "snd_ctl_find_id", 
        "snd_ctl_new1", 
        "snd_ctl_notify", 
        "snd_device_new", 
        "snd_info_set_text_ops", 
        "snd_iprintf", 
        "snd_mpu401_uart_interrupt", 
        "snd_mpu401_uart_new", 
        "snd_opl3_create", 
        "snd_opl3_hwdep_new", 
        "snd_pcm_format_width", 
        "snd_pcm_hw_constraint_list", 
        "snd_pcm_hw_constraint_minmax", 
        "snd_pcm_hw_constraint_msbits", 
        "snd_pcm_lib_free_pages", 
        "snd_pcm_lib_ioctl", 
        "snd_pcm_lib_malloc_pages", 
        "snd_pcm_lib_preallocate_pages_for_all", 
        "snd_pcm_new", 
        "snd_pcm_period_elapsed", 
        "snd_pcm_set_ops", 
        "snd_pcm_suspend_all", 
        "snd_power_change_state", 
        "soft_ac3", 
        "sprintf", 
        "stackguard_get_ra", 
        "stackguard_pop", 
        "stackguard_push", 
        "stackguard_set_ra", 
        "stackguard_stack", 
        "str_10", 
        "str_1012473204", 
        "str_1033184297", 
        "str_1050924700", 
        "str_1053863758", 
        "str_1061823061", 
        "str_10834194", 
        "str_122695140", 
        "str_122865562", 
        "str_124421908", 
        "str_129101994", 
        "str_131425151", 
        "str_131426595", 
        "str_13950841", 
        "str_147350971", 
        "str_15552", 
        "str_163141482", 
        "str_171248176", 
        "str_176464283", 
        "str_181451256", 
        "str_184869755", 
        "str_205040111", 
        "str_235265470", 
        "str_235676013", 
        "str_240831266", 
        "str_247204062", 
        "str_260101403", 
        "str_287061104", 
        "str_293594775", 
        "str_29932487", 
        "str_338056805", 
        "str_367676234", 
        "str_375887647", 
        "str_377684264", 
        "str_385748318", 
        "str_420826266", 
        "str_425593287", 
        "str_43107761", 
        "str_436717668", 
        "str_442862329", 
        "str_4442453", 
        "str_449269183", 
        "str_450144620", 
        "str_453010511", 
        "str_459204435", 
        "str_465611289", 
        "str_482017502", 
        "str_487403672", 
        "str_488424356", 
        "str_49675815", 
        "str_532174899", 
        "str_533589931", 
        "str_537495551", 
        "str_541433933", 
        "str_573849695", 
        "str_5821155", 
        "str_582694837", 
        "str_61353136", 
        "str_623789268", 
        "str_625602805", 
        "str_629297690", 
        "str_6417578", 
        "str_645250580", 
        "str_682558423", 
        "str_683063999", 
        "str_689470853", 
        "str_695176261", 
        "str_701583115", 
        "str_745591601", 
        "str_751998455", 
        "str_782745852", 
        "str_799428759", 
        "str_82022903", 
        "str_824495312", 
        "str_851283624", 
        "str_851541551", 
        "str_857948405", 
        "str_88429757", 
        "str_908489522", 
        "str_916388850", 
        "str_970171951", 
        "strcmp", 
        "strcpy", 
        "strlcpy", 
        "strlen", 
        "texts", 
        "texts___0"};
int function_id_map_len  =    1407;
char str_82022903[20]  =    "PCM Playback Switch";
char str_436717668[21]  =    "IEC958 Output Switch";
char str_49675815[18]  =    "IEC958 Mix Analog";
char str_5821155[12]  =    "IEC958 Loop";
char str_375887647[24]  =    "IEC958 Playback Default";
char str_287061104[25]  =    "IEC958 Playback Con Mask";
char str_1012473204[27]  =    "IEC958 Playback PCM Stream";
char str_573849695[20]  =    "C-Media PCI DAC/ADC";
char str_916388850[20]  =    "C-Media PCI 2nd DAC";
char str_43107761[19]  =    "C-Media PCI IEC958";
char str_625602805[23]  =    "Master Playback Volume";
char str_338056805[20]  =    "3D Control - Switch";
char str_88429757[20]  =    "PCM Playback Volume";
char str_171248176[19]  =    "PCM Capture Switch";
char str_449269183[22]  =    "Synth Playback Volume";
char str_442862329[22]  =    "Synth Playback Switch";
char str_453010511[20]  =    "Synth Capture Route";
char str_488424356[19]  =    "CD Playback Volume";
char str_482017502[19]  =    "CD Playback Switch";
char str_450144620[17]  =    "CD Capture Route";
char str_701583115[21]  =    "Line Playback Volume";
char str_695176261[21]  =    "Line Playback Switch";
char str_147350971[19]  =    "Line Capture Route";
char str_129101994[20]  =    "Mic Playback Volume";
char str_122695140[20]  =    "Mic Playback Switch";
char str_851541551[19]  =    "Mic Capture Switch";
char str_465611289[27]  =    "PC Speaker Playback Volume";
char str_751998455[20]  =    "Aux Playback Volume";
char str_745591601[20]  =    "Aux Playback Switch";
char str_1053863758[19]  =    "Aux Capture Switch";
char str_682558423[26]  =    "Mic Boost Playback Switch";
char str_857948405[19]  =    "Mic Capture Volume";
char str_689470853[22]  =    "Phone Playback Volume";
char str_683063999[22]  =    "Phone Playback Switch";
char str_459204435[27]  =    "PC Speaker Playback Switch";
char str_824495312[25]  =    "Mic Boost Capture Switch";
char str_629297690[8]  =    "Line-In";
char str_1033184297[12]  =    "Rear Output";
char str_420826266[12]  =    "Bass Output";
char str_205040111[7]  =    "Mic-In";
char str_487403672[18]  =    "Center/LFE Output";
char str_163141482[18]  =    "Four Channel Mode";
char str_1061823061[13]  =    "Line-In Mode";
char str_541433933[13]  =    "Exchange DAC";
char str_851283624[16]  =    "IEC958 In Valid";
char str_623789268[17]  =    "IEC958 Copyright";
char str_181451256[10]  =    "IEC958 5V";
char str_908489522[18]  =    "IEC958 In Monitor";
char str_532174899[24]  =    "IEC958 In Phase Inverse";
char str_61353136[17]  =    "IEC958 In Select";
char str_124421908[12]  =    "Mic-In Mode";
char str_10834194[6]  =    "Modem";
char str_970171951[11]  =    "CMedia PCI";
char str_15552[4]  =    "%s\n";
char str_29932487[7]  =    "\n%02x:";
char str_4442453[6]  =    " %02x";
char str_10[2]  =    "\n";
char str_260101403[7]  =    "cmipci";
char str_645250580[16]  =    "CMIPCI gameport";
char str_385748318[42]  =    "<4>cmipci: cannot reserve joystick ports\n";
char str_425593287[48]  =    "<3>cmipci: cannot allocate memory for gameport\n";
char str_582694837[17]  =    "C-Media Gameport";
char str_367676234[16]  =    "pci%s/gameport0";
char str_247204062[47]  =    "<3>cmipci: no OPL device at %#lx, skipping...\n";
char str_537495551[37]  =    "<3>cmipci: cannot create OPL3 hwdep\n";
char str_799428759[16]  =    "&cm->open_mutex";
char str_235265470[26]  =    "<3>unable to grab IRQ %d\n";
char str_6417578[6]  =    "-MC%d";
char str_122865562[7]  =    "-SWIEC";
char str_1050924700[14]  =    "C-Media CMI%d";
char str_184869755[12]  =    " (model %d)";
char str_533589931[21]  =    "%s%s at %#lx, irq %i";
char str_13950841[39]  =    "<3>cannot enable MPU-401 port at %#lx\n";
char str_782745852[39]  =    "<3>cmipci: no UART401 device at 0x%lx\n";
char str_293594775[11]  =    "%s probe!\n";
char str_240831266[17]  =    "snd_cmipci_probe";
char str_131426595[8]  =    "CMI8738";
char str_131425151[8]  =    "CMI8338";
char str_176464283[7]  =    "CMIPCI";
char str_235676013[55]  =    "<3>cmipci: pci_enable_device failed, disabling device\n";
char str_377684264[12]  =    "C-Media PCI";
//#line  17 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
//#line  20 "include/asm-generic/int-ll64.h"
typedef short __s16;
//#line  21 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
//#line  23 "include/asm-generic/int-ll64.h"
typedef int __s32;
//#line  24 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
//#line  27 "include/asm-generic/int-ll64.h"
typedef long long __s64;
//#line  28 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
//#line  40 "include/asm-generic/int-ll64.h"
typedef signed char s8;
//#line  41 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
//#line  44 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
//#line  47 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
//#line  49 "include/asm-generic/int-ll64.h"
typedef long long s64;
//#line  50 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
//#line  12 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_nlink_t;
//#line  13 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_off_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
//#line  16 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
//#line  17 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
//#line  18 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
//#line  19 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
//#line  23 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
//#line  24 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
//#line  25 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
//#line  32 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
//#line  41 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
//#line  42 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/types.h"
typedef unsigned short umode_t;
//#line  28 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/types.h"
typedef u64 dma_addr_t;
//#line  16 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
//#line  19 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
//#line  21 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
//#line  22 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
//#line  23 "include/linux/types.h"
typedef __kernel_off_t off_t;
//#line  24 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
//#line  28 "include/linux/types.h"
typedef __kernel_timer_t timer_t;
//#line  29 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
//#line  35 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
//#line  36 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
//#line  57 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
//#line  66 "include/linux/types.h"
typedef __kernel_size_t size_t;
//#line  71 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
//#line  81 "include/linux/types.h"
typedef __kernel_time_t time_t;
//#line  86 "include/linux/types.h"
typedef __kernel_clock_t clock_t;
//#line  113 "include/linux/types.h"
typedef __u32 u_int32_t;
//#line  114 "include/linux/types.h"
typedef __s32 int32_t;
//#line  120 "include/linux/types.h"
typedef __u32 uint32_t;
//#line  145 "include/linux/types.h"
typedef unsigned long sector_t;
//#line  146 "include/linux/types.h"
typedef unsigned long blkcnt_t;
//#line  186 "include/linux/types.h"
typedef unsigned int gfp_t;
//#line  187 "include/linux/types.h"
typedef unsigned int fmode_t;
//#line  190 "include/linux/types.h"
typedef u64 phys_addr_t;
//#line  195 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
//#line  197 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
//#line  202 "include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long volatile   counter ;
};
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
//#line  12 "include/linux/thread_info.h"
struct timespec;
struct timespec;
//#line  59 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/alternative.h"
struct module;
struct module;
//#line  80 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/page_64.h"
typedef unsigned long pgdval_t;
//#line  81 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/page_64.h"
typedef unsigned long pgprotval_t;
//#line  83
struct page;
//#line  56 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/page.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_15 pgd_t;
//#line  57 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/page.h"
struct __anonstruct_pgprot_t_16 {
   pgprotval_t pgprot ;
};
typedef struct __anonstruct_pgprot_t_16 pgprot_t;
//#line  69
struct page;
//#line  20 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/thread_info.h"
struct task_struct;
struct task_struct;
//#line  7 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct task_struct;
//#line  8
struct mm_struct;
struct mm_struct;
//#line  98 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
//#line  135
struct task_struct;
//#line  141 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField6 ;
};
//#line  10 "include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
//#line  114 "include/linux/kernel.h"
struct completion;
struct completion;
//#line  115
struct pt_regs;
//#line  208
struct pid;
struct pid;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/current.h"
struct task_struct;
//#line  20 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/system.h"
struct task_struct;
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_23 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_24 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField8 ;
   struct __anonstruct____missing_field_name_24 __annonCompField9 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_22 __annonCompField10 ;
} __attribute__((__packed__)) ;
//#line  33 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/ds.h"
struct task_struct;
//#line  34
struct ds_context;
struct ds_context;
//#line  36
struct bts_tracer;
struct bts_tracer;
//#line  11 "include/linux/personality.h"
struct pt_regs;
//#line  144 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((255UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct cpumask cpumask_t;
//#line  252 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct thread_struct;
//#line  289 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_33 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_34 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_32 {
   struct __anonstruct____missing_field_name_33 __annonCompField11 ;
   struct __anonstruct____missing_field_name_34 __annonCompField12 ;
};
union __anonunion____missing_field_name_35 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_32 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_35 __annonCompField14 ;
} __attribute__((__aligned__(16))) ;
//#line  340 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
//#line  360 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
//#line  366 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
} __attribute__((__packed__, __aligned__(64))) ;
//#line  372 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
//#line  386
struct kmem_cache;
//#line  391 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   struct ds_context *ds_ctx ;
   unsigned int bts_ovfl_signal ;
};
//#line  23 "include/asm-generic/atomic.h"
typedef atomic64_t atomic_long_t;
//#line  19 "include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
//#line  540
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
//#line  544 "include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_37 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
//#line  12 "include/linux/lockdep.h"
struct task_struct;
//#line  363 "include/linux/lockdep.h"
struct lock_class_key {

};
//#line  20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_38 {
   raw_spinlock_t raw_lock ;
};
typedef struct __anonstruct_spinlock_t_38 spinlock_t;
//#line  36 "include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_39 {
   raw_rwlock_t raw_lock ;
};
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
//#line  8 "include/linux/vmalloc.h"
struct vm_area_struct;
struct vm_area_struct;
//#line  68 "include/asm-generic/iomap.h"
struct pci_dev;
struct pci_dev;
//#line  19 "include/linux/irqreturn.h"
typedef int irqreturn_t;
//#line  18 "include/linux/capability.h"
struct task_struct;
//#line  99 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
//#line  553
struct dentry;
struct dentry;
//#line  14 "include/linux/time.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
//#line  100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
//#line  92 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_42 {
   unsigned long bits[(((unsigned long )(1 << 6) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct_nodemask_t_42 nodemask_t;
//#line  14 "include/linux/prio_tree.h"
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
//#line  20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
//#line  28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
//#line  17 "include/linux/rwsem.h"
struct rw_semaphore;
struct rw_semaphore;
//#line  31 "include/linux/rwsem-spinlock.h"
struct rw_semaphore {
   __s32 activity ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
//#line  28 "include/linux/wait.h"
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
//#line  32 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
//#line  50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
//#line  54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
//#line  56
struct task_struct;
//#line  25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
//#line  48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_43 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_43 mm_context_t;
//#line  22 "include/linux/mm_types.h"
struct address_space;
struct address_space;
//#line  27 "include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
//#line  39 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_45 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion____missing_field_name_44 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_45 __annonCompField15 ;
};
struct __anonstruct____missing_field_name_47 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_48 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_44 __annonCompField16 ;
   union __anonunion____missing_field_name_46 __annonCompField18 ;
   union __anonunion____missing_field_name_48 __annonCompField19 ;
   struct list_head lru ;
};
//#line  104
struct file;
//#line  122 "include/linux/mm_types.h"
struct __anonstruct_vm_set_50 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_49 {
   struct __anonstruct_vm_set_50 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_49 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void * __attribute__((__noderef__, __address_space__(2))) vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
//#line  179 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
//#line  184 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
//#line  190 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
//#line  7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
//#line  37 "include/linux/pm.h"
struct device;
struct device;
//#line  39 "include/linux/pm.h"
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
//#line  170 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
//#line  308
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
//#line  318 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
//#line  21 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
//#line  60 "include/linux/pageblock-flags.h"
struct page;
//#line  8 "include/linux/memory_hotplug.h"
struct page;
//#line  749 "include/linux/mmzone.h"
struct file;
//#line  252 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/topology.h"
struct pci_bus;
struct pci_bus;
//#line  940 "include/linux/mmzone.h"
struct page;
//#line  8 "include/linux/gfp.h"
struct vm_area_struct;
//#line  46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
//#line  59 "include/linux/ktime.h"
typedef union ktime ktime_t;
//#line  9 "include/linux/timer.h"
struct tvec_base;
struct tvec_base;
//#line  11 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
};
//#line  181
struct hrtimer;
struct hrtimer;
//#line  182
enum hrtimer_restart;
//#line  16 "include/linux/workqueue.h"
struct work_struct;
struct work_struct;
//#line  25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head  __attribute__((__noderef__, __address_space__(2))) entry ;
   void (*func)(struct work_struct *work ) ;
};
//#line  39 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
//#line  20 "include/linux/sysfs.h"
struct kobject;
struct kobject;
//#line  21
struct module;
//#line  28 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
//#line  34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
//#line  63
struct vm_area_struct;
//#line  65 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
//#line  77 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
//#line  82
struct sysfs_dirent;
struct sysfs_dirent;
//#line  59 "include/linux/kobject.h"
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
//#line  104 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
//#line  110 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
//#line  117 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
//#line  151 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
//#line  35 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
//#line  46 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
//#line  63 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
//#line  70 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[255] ;
};
//#line  50 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
//#line  83 "include/linux/sem.h"
struct task_struct;
//#line  117
struct sem_undo_list;
//#line  130 "include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
//#line  136 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
//#line  10 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/signal.h"
struct siginfo;
struct siginfo;
//#line  30 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_104 {
   unsigned long sig[1] ;
};
typedef struct __anonstruct_sigset_t_104 sigset_t;
//#line  17 "include/asm-generic/signal.h"
typedef void __signalfn_t(int  );
//#line  18 "include/asm-generic/signal.h"
typedef __signalfn_t __attribute__((__noderef__, __address_space__(1)))  *__sighandler_t;
//#line  20 "include/asm-generic/signal.h"
typedef void __restorefn_t(void);
//#line  21 "include/asm-generic/signal.h"
typedef __restorefn_t __attribute__((__noderef__, __address_space__(1)))  *__sigrestore_t;
//#line  167 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
//#line  174 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
//#line  7 "include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void __attribute__((__noderef__, __address_space__(1)))  *sival_ptr ;
};
typedef union sigval sigval_t;
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_106 {
   pid_t _pid ;
   uid_t _uid ;
};
struct __anonstruct__timer_107 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_108 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_109 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
struct __anonstruct__sigfault_110 {
   void __attribute__((__noderef__, __address_space__(1)))  *_addr ;
};
struct __anonstruct__sigpoll_111 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_105 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_106 _kill ;
   struct __anonstruct__timer_107 _timer ;
   struct __anonstruct__rt_108 _rt ;
   struct __anonstruct__sigchld_109 _sigchld ;
   struct __anonstruct__sigfault_110 _sigfault ;
   struct __anonstruct__sigpoll_111 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_105 _sifields ;
};
typedef struct siginfo siginfo_t;
//#line  274
struct siginfo;
//#line  14 "include/linux/signal.h"
struct user_struct;
//#line  24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
//#line  242
struct pt_regs;
//#line  4 "include/linux/path.h"
struct dentry;
//#line  5
struct vfsmount;
struct vfsmount;
//#line  7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
//#line  6 "include/linux/fs_struct.h"
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct path root ;
   struct path pwd ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
//#line  50 "include/linux/pid.h"
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
//#line  57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
//#line  69 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
//#line  100
struct pid_namespace;
//#line  97 "include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
//#line  24 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_114 {

};
typedef struct __anonstruct_seccomp_t_114 seccomp_t;
//#line  80 "include/linux/plist.h"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
};
//#line  38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
struct rt_mutex_waiter;
//#line  6 "include/linux/resource.h"
struct task_struct;
//#line  43 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
//#line  26 "include/linux/hrtimer.h"
struct hrtimer_clock_base;
struct hrtimer_clock_base;
//#line  27
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
//#line  40
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
//#line  100 "include/linux/hrtimer.h"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
};
//#line  139 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
};
//#line  168 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
};
//#line  11 "include/linux/task_io_accounting.h"
struct task_io_accounting {

};
//#line  32 "include/linux/sysctl.h"
struct file;
//#line  33
struct completion;
//#line  947
struct nsproxy;
struct nsproxy;
//#line  28 "include/linux/key.h"
typedef int32_t key_serial_t;
//#line  31 "include/linux/key.h"
typedef uint32_t key_perm_t;
//#line  33
struct key;
struct key;
//#line  73
struct seq_file;
struct seq_file;
//#line  74
struct user_struct;
//#line  75
struct signal_struct;
struct signal_struct;
//#line  76
struct cred;
struct cred;
//#line  78
struct key_type;
struct key_type;
//#line  80
struct keyring_list;
struct keyring_list;
//#line  123
struct key_user;
union __anonunion_type_data_169 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
union __anonunion_payload_170 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_169 type_data ;
   union __anonunion_payload_170 payload ;
};
//#line  19 "include/linux/cred.h"
struct user_struct;
//#line  20
struct cred;
//#line  21
struct inode;
struct inode;
//#line  29 "include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
//#line  81 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
//#line  114 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
//#line  96 "include/linux/sched.h"
struct futex_pi_state;
struct futex_pi_state;
//#line  97
struct robust_list_head;
struct robust_list_head;
//#line  98
struct bio;
struct bio;
//#line  99
struct bts_tracer;
//#line  140
struct seq_file;
//#line  242
struct task_struct;
//#line  336
struct nsproxy;
//#line  337
struct user_namespace;
struct user_namespace;
//#line  58 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
//#line  16 "include/linux/uio.h"
struct iovec {
   void __attribute__((__noderef__, __address_space__(1)))  *iov_base ;
   __kernel_size_t iov_len ;
};
//#line  15 "include/linux/aio.h"
struct kioctx;
struct kioctx;
//#line  87 "include/linux/aio.h"
union __anonunion_ki_obj_172 {
   void __attribute__((__noderef__, __address_space__(1)))  *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_172 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char __attribute__((__noderef__, __address_space__(1)))  *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
//#line  167 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
//#line  180 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
//#line  215
struct mm_struct;
//#line  426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
//#line  433 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
//#line  452 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
//#line  479 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
//#line  492 "include/linux/sched.h"
union __anonunion____missing_field_name_173 {
   pid_t pgrp  __attribute__((__deprecated__)) ;
   pid_t __pgrp ;
};
union __anonunion____missing_field_name_174 {
   pid_t session  __attribute__((__deprecated__)) ;
   pid_t __session ;
};
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   union __anonunion____missing_field_name_173 __annonCompField20 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_174 __annonCompField21 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
//#line  641 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
//#line  686
struct backing_dev_info;
struct backing_dev_info;
//#line  687
struct reclaim_state;
struct reclaim_state;
//#line  690 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
};
//#line  706 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
//#line  751
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
//#line  827 "include/linux/sched.h"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
//#line  850
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
//#line  868 "include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned long span[] ;
};
//#line  960
struct io_context;
struct io_context;
//#line  969
struct audit_context;
struct audit_context;
//#line  970
struct mempolicy;
//#line  971
struct pipe_inode_info;
struct pipe_inode_info;
//#line  974
struct rq;
struct rq;
//#line  975
struct sched_domain;
//#line  977 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
};
//#line  1027 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
//#line  1041 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
};
//#line  1098 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
//#line  1114
struct linux_binfmt;
struct files_struct;
struct compat_robust_list_head;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct bts_tracer *bts ;
   void *bts_buffer ;
   size_t bts_size ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int __attribute__((__noderef__, __address_space__(1)))  *set_child_tid ;
   int __attribute__((__noderef__, __address_space__(1)))  *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   struct robust_list_head  __attribute__((__noderef__, __address_space__(1))) *robust_list ;
   struct compat_robust_list_head  __attribute__((__noderef__, __address_space__(1))) *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mempolicy *mempolicy ;
   short il_next ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   struct prop_local_single dirties ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
//#line  1486
struct pid_namespace;
//#line  77 "include/linux/irq.h"
struct proc_dir_entry;
struct proc_dir_entry;
//#line  16 "include/linux/profile.h"
struct proc_dir_entry;
//#line  17
struct pt_regs;
//#line  65
struct task_struct;
//#line  66
struct mm_struct;
//#line  88
struct pt_regs;
//#line  120 "include/linux/hardirq.h"
struct task_struct;
//#line  80 "include/linux/interrupt.h"
struct device;
//#line  318 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
//#line  12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
//#line  17 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
//#line  18 "include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
//#line  165
struct device;
//#line  19 "include/linux/klist.h"
struct klist_node;
struct klist_node;
//#line  20 "include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
//#line  39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
//#line  62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
//#line  40 "include/linux/kmod.h"
struct key;
//#line  41
struct file;
//#line  98
struct file;
//#line  279 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/elf.h"
struct task_struct;
//#line  10 "include/linux/elf.h"
struct file;
//#line  27 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
//#line  28 "include/linux/elf.h"
typedef __u16 Elf64_Half;
//#line  32 "include/linux/elf.h"
typedef __u32 Elf64_Word;
//#line  33 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
//#line  181 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
//#line  32 "include/linux/moduleparam.h"
struct kernel_param;
struct kernel_param;
//#line  39
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_182 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_182 __annonCompField22 ;
};
//#line  52 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
//#line  58 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
//#line  207
struct module;
//#line  18 "include/linux/marker.h"
struct module;
//#line  20 "include/linux/tracepoint.h"
struct module;
//#line  21
struct tracepoint;
struct tracepoint;
//#line  23 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
//#line  5 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/module.h"
struct mod_arch_specific {

};
//#line  34 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
//#line  46
struct module;
//#line  48 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
//#line  58
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
//#line  71
struct exception_table_entry;
struct exception_table_entry;
//#line  222
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
//#line  229
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
//#line  594
struct device_driver;
struct device_driver;
//#line  596
struct module;
//#line  16 "include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
//#line  4 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/device.h"
struct dma_mapping_ops;
struct dev_archdata {
   void *acpi_handle ;
   struct dma_mapping_ops *dma_ops ;
   void *iommu ;
};
//#line  30 "include/linux/device.h"
struct device;
//#line  31
struct device_driver;
//#line  32
struct driver_private;
struct driver_private;
//#line  33
struct class;
struct class;
//#line  34
struct class_private;
struct class_private;
//#line  35
struct bus_type;
struct bus_type;
//#line  36
struct bus_type_private;
struct bus_type_private;
//#line  38 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
//#line  51
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
//#line  122 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
//#line  155 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
//#line  187
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
//#line  207
struct device_type;
//#line  240 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
//#line  287 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
//#line  300 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
//#line  360 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
//#line  369
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   unsigned int uevent_suppress : 1 ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   char * __attribute__((__noderef__, __address_space__(2))) driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
//#line  25 "include/linux/io.h"
struct device;
//#line  60 "include/linux/pci.h"
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
//#line  110 "include/linux/pci.h"
typedef int pci_power_t;
//#line  128 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
//#line  130
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
//#line  154 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
//#line  169 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
//#line  182
struct pci_vpd;
struct pci_vpd;
//#line  187
struct pci_driver;
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int state_saved : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
//#line  311
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
//#line  366 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
//#line  385 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
//#line  397 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
//#line  417 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
//#line  437
struct module;
//#line  438 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
//#line  6 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
struct task_struct;
//#line  40 "include/linux/debug_locks.h"
struct task_struct;
//#line  17 "include/linux/mm.h"
struct mempolicy;
//#line  18
struct anon_vma;
//#line  19
struct file_ra_state;
struct file_ra_state;
//#line  20
struct user_struct;
//#line  21
struct writeback_control;
struct writeback_control;
//#line  382 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/pgtable.h"
struct file;
//#line  400
struct seq_file;
//#line  73 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/pgtable_64.h"
struct mm_struct;
//#line  542 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
//#line  165 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void __attribute__((__noderef__, __address_space__(1)))  *virtual_address ;
   struct page *page ;
};
//#line  182 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
//#line  224
struct inode;
//#line  181 "include/linux/page-flags.h"
struct page;
//#line  6 "include/linux/swiotlb.h"
struct device;
//#line  8
struct scatterlist;
//#line  19 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/dma-mapping.h"
struct dma_mapping_ops {
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_single)(struct device *hwdev , phys_addr_t ptr , size_t size ,
                            int direction ) ;
   void (*unmap_single)(struct device *dev , dma_addr_t addr , size_t size , int direction ) ;
   void (*sync_single_for_cpu)(struct device *hwdev , dma_addr_t dma_handle , size_t size ,
                               int direction ) ;
   void (*sync_single_for_device)(struct device *hwdev , dma_addr_t dma_handle , size_t size ,
                                  int direction ) ;
   void (*sync_single_range_for_cpu)(struct device *hwdev , dma_addr_t dma_handle ,
                                     unsigned long offset , size_t size , int direction ) ;
   void (*sync_single_range_for_device)(struct device *hwdev , dma_addr_t dma_handle ,
                                        unsigned long offset , size_t size , int direction ) ;
   void (*sync_sg_for_cpu)(struct device *hwdev , struct scatterlist *sg , int nelems ,
                           int direction ) ;
   void (*sync_sg_for_device)(struct device *hwdev , struct scatterlist *sg , int nelems ,
                              int direction ) ;
   int (*map_sg)(struct device *hwdev , struct scatterlist *sg , int nents , int direction ) ;
   void (*unmap_sg)(struct device *hwdev , struct scatterlist *sg , int nents , int direction ) ;
   int (*dma_supported)(struct device *hwdev , u64 mask ) ;
   int is_phys ;
};
struct gameport_driver;
struct gameport {
   void *port_data ;
   char name[32] ;
   char phys[32] ;
   int io ;
   int speed ;
   int fuzz ;
   void (*trigger)(struct gameport * ) ;
   unsigned char (*read)(struct gameport * ) ;
   int (*cooked_read)(struct gameport * , int * , int * ) ;
   int (*calibrate)(struct gameport * , int * , int * ) ;
   int (*open)(struct gameport * , int  ) ;
   void (*close)(struct gameport * ) ;
   struct timer_list poll_timer ;
   unsigned int poll_interval ;
   spinlock_t timer_lock ;
   unsigned int poll_cnt ;
   void (*poll_handler)(struct gameport * ) ;
   struct gameport *parent ;
   struct gameport *child ;
   struct gameport_driver *drv ;
   struct mutex drv_mutex ;
   struct device dev ;
   unsigned int registered ;
   struct list_head node ;
};
//#line  54 "include/linux/gameport.h"
struct gameport_driver {
   void *private ;
   char *description ;
   int (*connect)(struct gameport * , struct gameport_driver *drv ) ;
   int (*reconnect)(struct gameport * ) ;
   void (*disconnect)(struct gameport * ) ;
   struct device_driver driver ;
   unsigned int ignore ;
};
//#line  44 "include/sound/core.h"
struct pci_dev;
//#line  51 "include/sound/core.h"
typedef int snd_device_type_t;
//#line  67 "include/sound/core.h"
typedef int snd_device_state_t;
//#line  77
struct snd_device;
struct snd_device;
//#line  79 "include/sound/core.h"
struct snd_device_ops {
   int (* __attribute__((__noderef__, __address_space__(2))) dev_free)(struct snd_device *dev ) ;
   int (* __attribute__((__noderef__, __address_space__(2))) dev_register)(struct snd_device *dev ) ;
   int (* __attribute__((__noderef__, __address_space__(2))) dev_disconnect)(struct snd_device *dev ) ;
};
//#line  85
struct snd_card;
struct snd_device {
   struct list_head list ;
   struct snd_card *card ;
   snd_device_state_t state ;
   snd_device_type_t type ;
   void *device_data ;
   struct snd_device_ops * __attribute__((__noderef__, __address_space__(2))) ops ;
};
//#line  98
struct file_operations;
struct snd_monitor_file {
   struct file *file ;
   struct snd_monitor_file *next ;
   struct file_operations  const  *disconnected_f_op ;
   struct list_head shutdown_list ;
};
//#line  107
struct snd_info_entry;
struct snd_shutdown_f_ops;
struct snd_mixer_oss;
struct snd_card {
   int number ;
   char id[16] ;
   char driver[16] ;
   char shortname[32] ;
   char longname[80] ;
   char mixername[80] ;
   char components[128] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card *card ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct snd_monitor_file *files ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   struct device *dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
//#line  337
struct resource;
//#line  11 "include/linux/dcache.h"
struct nameidata;
struct nameidata;
//#line  12
struct path;
//#line  13
struct vfsmount;
//#line  33 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
//#line  89 "include/linux/dcache.h"
union __anonunion_d_u_186 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_186 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[32] ;
};
//#line  134 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
//#line  61 "include/linux/radix-tree.h"
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
//#line  14 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
//#line  316 "include/linux/fs.h"
struct export_operations;
struct export_operations;
//#line  318
struct iovec;
//#line  319
struct nameidata;
//#line  320
struct kiocb;
//#line  321
struct pipe_inode_info;
//#line  322
struct poll_table_struct;
struct poll_table_struct;
//#line  323
struct kstatfs;
struct kstatfs;
//#line  324
struct vm_area_struct;
//#line  325
struct vfsmount;
//#line  326
struct cred;
//#line  378 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
//#line  106 "include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
//#line  127 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
//#line  50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
//#line  137 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
//#line  143 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
//#line  17 "include/linux/dqblk_qtree.h"
struct dquot;
struct dquot;
//#line  182 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
//#line  183 "include/linux/quota.h"
typedef long long qsize_t;
//#line  197 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
//#line  211
struct quota_format_type;
struct quota_format_type;
//#line  213 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
//#line  226
struct super_block;
//#line  263 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
//#line  285 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
//#line  296 "include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
//#line  314 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
//#line  328 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
//#line  372 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
//#line  441 "include/linux/fs.h"
struct page;
//#line  442
struct address_space;
//#line  443
struct writeback_control;
//#line  486 "include/linux/fs.h"
union __anonunion_arg_192 {
   char __attribute__((__noderef__, __address_space__(1)))  *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_191 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_192 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_191 read_descriptor_t;
//#line  499 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
//#line  548
struct backing_dev_info;
//#line  549 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  573
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
//#line  649
struct inode_operations;
struct file_lock;
struct cdev;
union __anonunion____missing_field_name_193 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_193 __annonCompField23 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
//#line  804 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
//#line  815 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
//#line  838 "include/linux/fs.h"
union __anonunion_f_u_194 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_194 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void * __attribute__((__noderef__, __address_space__(2))) private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
//#line  957 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
//#line  959 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
//#line  964 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
//#line  8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
struct nlm_lockowner;
//#line  13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
//#line  19
struct nfs4_lock_state;
struct nfs4_lock_state;
//#line  20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
//#line  986 "include/linux/fs.h"
struct fasync_struct;
struct __anonstruct_afs_196 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_195 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_196 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_195 fl_u ;
};
//#line  1097 "include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
//#line  1132
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
//#line  1258 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
//#line  1310 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char __attribute__((__noderef__, __address_space__(1)))  * ,
                   size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const __attribute__((__noderef__, __address_space__(1)))  * ,
                    size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
//#line  1339 "include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char __attribute__((__noderef__, __address_space__(1)))  * ,
                   int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
//#line  1368
struct seq_file;
//#line  1382 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
//#line  1565 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
//#line  1949
struct bio;
//#line  95 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
//#line  26 "include/linux/poll.h"
struct poll_table_struct;
//#line  33 "include/linux/poll.h"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
//#line  28 "include/sound/info.h"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
//#line  40
struct snd_info_entry;
//#line  42 "include/sound/info.h"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
   void (*write)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
};
//#line  49 "include/sound/info.h"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry *entry , unsigned short mode , void **file_private_data ) ;
   int (*release)(struct snd_info_entry *entry , unsigned short mode , void *file_private_data ) ;
   long (*read)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                char __attribute__((__noderef__, __address_space__(1)))  *buf , unsigned long count ,
                unsigned long pos ) ;
   long (*write)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                 char const __attribute__((__noderef__, __address_space__(1)))  *buf ,
                 unsigned long count , unsigned long pos ) ;
   long long (*llseek)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                       long long offset , int orig ) ;
   unsigned int (*poll)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                        poll_table *wait ) ;
   int (*ioctl)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                unsigned int cmd , unsigned long arg ) ;
   int (*mmap)(struct snd_info_entry *entry , void *file_private_data , struct inode *inode ,
               struct file *file , struct vm_area_struct *vma ) ;
};
//#line  73 "include/sound/info.h"
union __anonunion_c_200 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
struct ensoniq;
struct snd_info_entry {
   char const   *name ;
   mode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_200 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   struct ensoniq *private_data ;
   void (*private_free)(struct snd_info_entry *entry ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
//#line  63 "include/sound/asound.h"
struct snd_aes_iec958 {
   unsigned char status[24] ;
   unsigned char subcode[147] ;
   unsigned char pad ;
   unsigned char dig_subframe[4] ;
};
//#line  112 "include/sound/asound.h"
struct snd_hwdep_dsp_status {
   unsigned int version ;
   unsigned char id[32] ;
   unsigned int num_dsps ;
   unsigned int dsp_loaded ;
   unsigned int chip_ready ;
   unsigned char reserved[16] ;
};
//#line  121 "include/sound/asound.h"
struct snd_hwdep_dsp_image {
   unsigned int index ;
   unsigned char name[64] ;
   unsigned char __attribute__((__noderef__, __address_space__(1)))  *image ;
   size_t length ;
   unsigned long driver_data ;
};
//#line  144 "include/sound/asound.h"
typedef unsigned long snd_pcm_uframes_t;
//#line  169 "include/sound/asound.h"
typedef int snd_pcm_access_t;
//#line  177 "include/sound/asound.h"
typedef int snd_pcm_format_t;
//#line  241 "include/sound/asound.h"
typedef int snd_pcm_subformat_t;
//#line  260 "include/sound/asound.h"
typedef int snd_pcm_state_t;
//#line  278 "include/sound/asound.h"
union snd_pcm_sync_id {
   unsigned char id[16] ;
   unsigned short id16[8] ;
   unsigned int id32[4] ;
};
//#line  300 "include/sound/asound.h"
typedef int snd_pcm_hw_param_t;
//#line  334 "include/sound/asound.h"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned int openmin : 1 ;
   unsigned int openmax : 1 ;
   unsigned int integer : 1 ;
   unsigned int empty : 1 ;
};
//#line  344 "include/sound/asound.h"
struct snd_mask {
   u_int32_t bits[8] ;
};
//#line  348 "include/sound/asound.h"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3] ;
   struct snd_mask mres[5] ;
   struct snd_interval intervals[12] ;
   struct snd_interval ires[9] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64] ;
};
//#line  407 "include/sound/asound.h"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
//#line  415 "include/sound/asound.h"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
//#line  725 "include/sound/asound.h"
typedef int snd_ctl_elem_type_t;
//#line  735 "include/sound/asound.h"
typedef int snd_ctl_elem_iface_t;
//#line  769 "include/sound/asound.h"
struct snd_ctl_elem_id {
   unsigned int numid ;
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char name[44] ;
   unsigned int index ;
};
//#line  787 "include/sound/asound.h"
struct __anonstruct_integer_219 {
   long min ;
   long max ;
   long step ;
};
struct __anonstruct_integer64_220 {
   long long min ;
   long long max ;
   long long step ;
};
struct __anonstruct_enumerated_221 {
   unsigned int items ;
   unsigned int item ;
   char name[64] ;
};
union __anonunion_value_218 {
   struct __anonstruct_integer_219 integer ;
   struct __anonstruct_integer64_220 integer64 ;
   struct __anonstruct_enumerated_221 enumerated ;
   unsigned char reserved[128] ;
};
union __anonunion_dimen_222 {
   unsigned short d[4] ;
   unsigned short *d_ptr ;
};
struct snd_ctl_elem_info {
   struct snd_ctl_elem_id id ;
   snd_ctl_elem_type_t type ;
   unsigned int access ;
   unsigned int count ;
   pid_t owner ;
   union __anonunion_value_218 value ;
   union __anonunion_dimen_222 dimen ;
   unsigned char reserved[64UL - 4UL * sizeof(unsigned short )] ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_integer_224 {
   long value[128] ;
   long *value_ptr ;
};
union __anonunion_integer64_225 {
   long long value[64] ;
   long long *value_ptr ;
};
union __anonunion_enumerated_226 {
   unsigned int item[128] ;
   unsigned int *item_ptr ;
};
union __anonunion_bytes_227 {
   unsigned char data[512] ;
   unsigned char *data_ptr ;
};
union __anonunion_value_223 {
   union __anonunion_integer_224 integer ;
   union __anonunion_integer64_225 integer64 ;
   union __anonunion_enumerated_226 enumerated ;
   union __anonunion_bytes_227 bytes ;
   struct snd_aes_iec958 iec958 ;
};
struct snd_ctl_elem_value {
   struct snd_ctl_elem_id id ;
   unsigned int indirect : 1 ;
   union __anonunion_value_223 value ;
   struct timespec tstamp ;
   unsigned char reserved[128UL - sizeof(struct timespec )] ;
};
//#line  29 "include/sound/control.h"
struct snd_kcontrol;
struct snd_kcontrol;
//#line  30 "include/sound/control.h"
typedef int snd_kcontrol_info_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo );
//#line  31 "include/sound/control.h"
typedef int snd_kcontrol_get_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  32 "include/sound/control.h"
typedef int snd_kcontrol_put_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  33 "include/sound/control.h"
typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                                  unsigned int __attribute__((__noderef__, __address_space__(1)))  *tlv );
//#line  39 "include/sound/control.h"
union __anonunion_tlv_232 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
struct snd_kcontrol_new {
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char *name ;
   unsigned int index ;
   unsigned int access ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_232 tlv ;
   unsigned long private_value ;
};
//#line  57
struct snd_ctl_file;
struct snd_kcontrol_volatile {
   struct snd_ctl_file *owner ;
   pid_t owner_pid ;
   unsigned int access ;
};
//#line  63 "include/sound/control.h"
union __anonunion_tlv_233 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
struct snd_kcontrol {
   struct list_head list ;
   struct snd_ctl_elem_id id ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_233 tlv ;
   unsigned long private_value ;
   void *private_data ;
   void (*private_free)(struct snd_kcontrol *kcontrol ) ;
   struct snd_kcontrol_volatile vd[0] ;
};
//#line  90 "include/sound/control.h"
struct snd_ctl_file {
   struct list_head list ;
   struct snd_card *card ;
   pid_t pid ;
   int prefer_pcm_subdevice ;
   int prefer_rawmidi_subdevice ;
   wait_queue_head_t change_sleep ;
   spinlock_t read_lock ;
   struct fasync_struct *fasync ;
   int subscribed ;
   struct list_head events ;
};
//#line  27 "include/sound/memalloc.h"
struct device;
//#line  32 "include/sound/memalloc.h"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
//#line  55 "include/sound/memalloc.h"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
//#line  25 "include/sound/pcm_oss.h"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned int disable : 1 ;
   unsigned int direct : 1 ;
   unsigned int block : 1 ;
   unsigned int nonblock : 1 ;
   unsigned int partialfrag : 1 ;
   unsigned int nosilence : 1 ;
   unsigned int buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
//#line  39
struct snd_pcm_plugin;
struct snd_pcm_oss_runtime {
   unsigned int params : 1 ;
   unsigned int prepare : 1 ;
   unsigned int trigger : 1 ;
   unsigned int sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_interrupt ;
};
//#line  67
struct snd_pcm_substream;
//#line  71 "include/sound/pcm_oss.h"
struct snd_pcm_oss_substream {
   unsigned int oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
//#line  76 "include/sound/pcm_oss.h"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
//#line  84 "include/sound/pcm_oss.h"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
//#line  44 "include/sound/pcm.h"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
//#line  60
struct snd_pcm_substream;
//#line  62 "include/sound/pcm.h"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream *substream ) ;
   int (*close)(struct snd_pcm_substream *substream ) ;
   int (*ioctl)(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
   int (*hw_params)(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *params ) ;
   int (*hw_free)(struct snd_pcm_substream *substream ) ;
   int (*prepare)(struct snd_pcm_substream *substream ) ;
   int (*trigger)(struct snd_pcm_substream *substream , int cmd ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream ) ;
   int (*copy)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
               void __attribute__((__noderef__, __address_space__(1)))  *buf , snd_pcm_uframes_t count ) ;
   int (*silence)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
                  snd_pcm_uframes_t count ) ;
   struct page *(*page)(struct snd_pcm_substream *substream , unsigned long offset ) ;
   int (*mmap)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ) ;
   int (*ack)(struct snd_pcm_substream *substream ) ;
};
//#line  204
struct snd_pcm_hw_rule;
struct snd_pcm_hw_rule;
//#line  208 "include/sound/pcm.h"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) ;
   int var ;
   int deps[4] ;
   void *private ;
};
//#line  216 "include/sound/pcm.h"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3] ;
   struct snd_interval intervals[12] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
//#line  258 "include/sound/pcm.h"
struct snd_pcm_hw_constraint_list {
   unsigned int count ;
   unsigned int *list ;
   unsigned int mask ;
};
//#line  264 "include/sound/pcm.h"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   wait_queue_head_t sleep ;
   struct fasync_struct *fasync ;
   void *private_data ;
   void (*private_free)(struct snd_pcm_runtime *runtime ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream *substream ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream *substream ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char * __attribute__((__noderef__, __address_space__(2))) dma_area ;
   dma_addr_t __attribute__((__noderef__, __address_space__(2)))  dma_addr ;
   size_t __attribute__((__noderef__, __address_space__(2)))  dma_bytes ;
   struct snd_dma_buffer * __attribute__((__noderef__, __address_space__(2))) dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
};
//#line  342 "include/sound/pcm.h"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
//#line  348
struct snd_pcm;
struct snd_pcm_str;
struct snd_timer;
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   void *private_data ;
   int number ;
   char name[32] ;
   int stream ;
   char latency_id[20] ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime *runtime ;
   struct snd_timer *timer ;
   unsigned int timer_running : 1 ;
   spinlock_t timer_lock ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned int hw_opened : 1 ;
};
//#line  400 "include/sound/pcm.h"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
};
//#line  421 "include/sound/pcm.h"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64] ;
   char name[80] ;
   struct snd_pcm_str streams[2] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_pcm *pcm ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
//#line  34 "include/sound/seq_device.h"
struct snd_seq_device {
   struct snd_card *card ;
   int device ;
   char id[32] ;
   char name[80] ;
   int argsize ;
   void *driver_data ;
   int status ;
   void *private_data ;
   void (*private_free)(struct snd_seq_device *device ) ;
   struct list_head list ;
};
//#line  47 "include/sound/rawmidi.h"
struct snd_rawmidi;
struct snd_rawmidi;
//#line  49
struct snd_seq_port_info;
struct snd_seq_port_info;
//#line  58 "include/sound/rawmidi.h"
struct snd_rawmidi_global_ops {
   int (*dev_register)(struct snd_rawmidi *rmidi ) ;
   int (*dev_unregister)(struct snd_rawmidi *rmidi ) ;
   void (*get_port_info)(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *info ) ;
};
//#line  88
struct snd_rawmidi_str;
//#line  111 "include/sound/rawmidi.h"
struct snd_rawmidi_str {
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct list_head substreams ;
};
//#line  117 "include/sound/rawmidi.h"
struct snd_rawmidi {
   struct snd_card *card ;
   struct list_head list ;
   unsigned int device ;
   unsigned int info_flags ;
   char id[64] ;
   char name[80] ;
   int ossreg ;
   struct snd_rawmidi_global_ops *ops ;
   struct snd_rawmidi_str streams[2] ;
   void *private_data ;
   void (*private_free)(struct snd_rawmidi *rmidi ) ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   struct snd_info_entry *dev ;
   struct snd_info_entry *proc_entry ;
   struct snd_seq_device *seq_dev ;
};
//#line  28 "include/sound/hwdep.h"
struct snd_hwdep;
struct snd_hwdep;
//#line  30 "include/sound/hwdep.h"
struct snd_hwdep_ops {
   long long (*llseek)(struct snd_hwdep *hw , struct file *file , long long offset ,
                       int orig ) ;
   long (*read)(struct snd_hwdep *hw , char __attribute__((__noderef__, __address_space__(1)))  *buf ,
                long count , loff_t *offset ) ;
   long (*write)(struct snd_hwdep *hw , char const __attribute__((__noderef__, __address_space__(1)))  *buf ,
                 long count , loff_t *offset ) ;
   int (*open)(struct snd_hwdep *hw , struct file *file ) ;
   int (*release)(struct snd_hwdep *hw , struct file *file ) ;
   unsigned int (*poll)(struct snd_hwdep *hw , struct file *file , poll_table *wait ) ;
   int (*ioctl)(struct snd_hwdep *hw , struct file *file , unsigned int cmd , unsigned long arg ) ;
   int (*ioctl_compat)(struct snd_hwdep *hw , struct file *file , unsigned int cmd ,
                       unsigned long arg ) ;
   int (*mmap)(struct snd_hwdep *hw , struct file *file , struct vm_area_struct *vma ) ;
   int (*dsp_status)(struct snd_hwdep *hw , struct snd_hwdep_dsp_status *status ) ;
   int (*dsp_load)(struct snd_hwdep *hw , struct snd_hwdep_dsp_image *image ) ;
};
//#line  44 "include/sound/hwdep.h"
struct snd_hwdep {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   char id[32] ;
   char name[80] ;
   int iface ;
   char oss_dev[32] ;
   int oss_type ;
   int ossreg ;
   struct snd_hwdep_ops ops ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_hwdep *hwdep ) ;
   struct mutex open_mutex ;
   int used ;
   unsigned int dsp_loaded ;
   unsigned int exclusive : 1 ;
};
//#line  53 "include/sound/timer.h"
struct snd_timer;
//#line  55 "include/sound/timer.h"
struct snd_timer_hardware {
   unsigned int flags ;
   unsigned long resolution ;
   unsigned long resolution_min ;
   unsigned long resolution_max ;
   unsigned long ticks ;
   int (*open)(struct snd_timer *timer ) ;
   int (*close)(struct snd_timer *timer ) ;
   unsigned long (*c_resolution)(struct snd_timer *timer ) ;
   int (*start)(struct snd_timer *timer ) ;
   int (*stop)(struct snd_timer *timer ) ;
   int (*set_period)(struct snd_timer *timer , unsigned long period_num , unsigned long period_den ) ;
   int (*precise_resolution)(struct snd_timer *timer , unsigned long *num , unsigned long *den ) ;
};
//#line  72 "include/sound/timer.h"
struct snd_timer {
   int tmr_class ;
   struct snd_card *card ;
   struct module *module ;
   int tmr_device ;
   int tmr_subdevice ;
   char id[64] ;
   char name[80] ;
   unsigned int flags ;
   int running ;
   unsigned long sticks ;
   void *private_data ;
   void (*private_free)(struct snd_timer *timer ) ;
   struct snd_timer_hardware hw ;
   spinlock_t lock ;
   struct list_head device_list ;
   struct list_head open_list_head ;
   struct list_head active_list_head ;
   struct list_head ack_list_head ;
   struct list_head sack_list_head ;
   struct tasklet_struct task_queue ;
};
//#line  160 "include/sound/asequencer.h"
struct snd_seq_addr {
   unsigned char client ;
   unsigned char port ;
};
//#line  511 "include/sound/asequencer.h"
struct snd_seq_port_info {
   struct snd_seq_addr addr ;
   char name[64] ;
   unsigned int capability ;
   unsigned int type ;
   int midi_channels ;
   int midi_voices ;
   int synth_voices ;
   int read_use ;
   int write_use ;
   void *kernel ;
   unsigned int flags ;
   unsigned char time_queue ;
   char reserved[59] ;
};
//#line  32 "include/sound/seq_midi_emul.h"
struct snd_midi_channel {
   void *private ;
   int number ;
   int client ;
   int port ;
   unsigned char midi_mode ;
   unsigned int drum_channel : 1 ;
   unsigned int param_type : 1 ;
   unsigned char midi_aftertouch ;
   unsigned char midi_pressure ;
   unsigned char midi_program ;
   short midi_pitchbend ;
   unsigned char control[128] ;
   unsigned char note[128] ;
   short gm_rpn_pitch_bend_range ;
   short gm_rpn_fine_tuning ;
   short gm_rpn_coarse_tuning ;
};
//#line  67 "include/sound/seq_midi_emul.h"
struct snd_midi_channel_set {
   void *private_data ;
   int client ;
   int port ;
   int max_channels ;
   struct snd_midi_channel *channels ;
   unsigned char midi_mode ;
   unsigned char gs_master_volume ;
   unsigned char gs_chorus_mode ;
   unsigned char gs_reverb_mode ;
};
//#line  237 "include/sound/opl3.h"
struct snd_opl3;
struct snd_opl3;
//#line  244 "include/sound/opl3.h"
struct fm_operator {
   unsigned char am_vib ;
   unsigned char ksl_level ;
   unsigned char attack_decay ;
   unsigned char sustain_release ;
   unsigned char wave_select ;
} __attribute__((__packed__)) ;
//#line  253 "include/sound/opl3.h"
struct fm_instrument {
   struct fm_operator op[4] ;
   unsigned char feedback_connection[2] ;
   unsigned char echo_delay ;
   unsigned char echo_atten ;
   unsigned char chorus_spread ;
   unsigned char trnsps ;
   unsigned char fix_dur ;
   unsigned char modes ;
   unsigned char fix_key ;
};
//#line  270 "include/sound/opl3.h"
struct fm_patch {
   unsigned char prog ;
   unsigned char bank ;
   unsigned char type ;
   struct fm_instrument inst ;
   char name[24] ;
   struct fm_patch *next ;
};
//#line  283 "include/sound/opl3.h"
struct snd_opl3_voice {
   int state ;
   unsigned int time ;
   unsigned char note ;
   unsigned long note_off ;
   int note_off_check ;
   unsigned char keyon_reg ;
   struct snd_midi_channel *chan ;
};
//#line  301 "include/sound/opl3.h"
struct snd_opl3 {
   unsigned long l_port ;
   unsigned long r_port ;
   struct resource *res_l_port ;
   struct resource *res_r_port ;
   unsigned short hardware ;
   void (*command)(struct snd_opl3 *opl3 , unsigned short cmd , unsigned char val ) ;
   unsigned short timer_enable ;
   int seq_dev_num ;
   struct snd_timer *timer1 ;
   struct snd_timer *timer2 ;
   spinlock_t timer_lock ;
   void *private_data ;
   void (*private_free)(struct snd_opl3 * ) ;
   struct snd_hwdep *hwdep ;
   spinlock_t reg_lock ;
   struct snd_card *card ;
   unsigned char fm_mode ;
   unsigned char rhythm ;
   unsigned char max_voices ;
   int synth_mode ;
   int seq_client ;
   struct snd_seq_device *seq_dev ;
   struct snd_midi_channel_set *chset ;
   struct snd_seq_device *oss_seq_dev ;
   struct snd_midi_channel_set *oss_chset ;
   struct fm_patch *patch_table[32] ;
   struct snd_opl3_voice voices[18] ;
   int use_time ;
   unsigned short connection_reg ;
   unsigned char drum_reg ;
   spinlock_t voice_lock ;
   struct timer_list tlist ;
   int sys_timer_status ;
   spinlock_t sys_timer_lock ;
};
//#line  11 "include/linux/proc_fs.h"
struct completion;
//#line  12
struct mm_struct;
//#line  49 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
//#line  51 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char const __attribute__((__noderef__,
                         __address_space__(1)))  *buffer , unsigned long count , void *data );
//#line  54 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
//#line  124
struct pid_namespace;
//#line  436 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
struct cmipci_pcm {
   struct snd_pcm_substream *substream ;
   u8 running ;
   u8 fmt ;
   u8 is_dac ;
   u8 needs_silencing ;
   unsigned int dma_size ;
   unsigned int shift ;
   unsigned int ch ;
   unsigned int offset ;
};
//#line  449 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
struct cmipci_mixer_auto_switches {
   char const   *name ;
   int toggle_on ;
};
//#line  462
static struct cmipci_mixer_auto_switches  const  ( __attribute__((__noderef__, __address_space__(2))) cm_saved_mixer)[4] ;
static struct cmipci_mixer_auto_switches  const  ( __attribute__((__noderef__, __address_space__(2))) cm_saved_mixer)[4] ;
static struct cmipci_mixer_auto_switches  const  ( __attribute__((__noderef__, __address_space__(2))) cm_saved_mixer)[4] ;
static struct cmipci_mixer_auto_switches  const  ( __attribute__((__noderef__, __address_space__(2))) cm_saved_mixer)[4] ;
struct cmipci {
   struct snd_card *card ;
   struct pci_dev *pci ;
   unsigned int device ;
   int irq ;
   unsigned long iobase ;
   unsigned int ctrl ;
   struct snd_pcm *pcm ;
   struct snd_pcm *pcm2 ;
   struct snd_pcm *pcm_spdif ;
   int chip_version ;
   int max_channels ;
   unsigned int can_ac3_sw : 1 ;
   unsigned int can_ac3_hw : 1 ;
   unsigned int can_multi_ch : 1 ;
   unsigned int can_96k : 1 ;
   unsigned int do_soft_ac3 : 1 ;
   unsigned int spdif_playback_avail : 1 ;
   unsigned int spdif_playback_enabled : 1 ;
   int spdif_counter ;
   unsigned int dig_status ;
   unsigned int dig_pcm_status ;
   struct snd_pcm_hardware *hw_info[3] ;
   int opened[2] ;
   struct mutex open_mutex ;
   unsigned int mixer_insensitive : 1 ;
   struct snd_kcontrol *mixer_res_ctl[sizeof(cm_saved_mixer) / sizeof(cm_saved_mixer[0]) + (sizeof(char [1]) - 1UL)] ;
   int mixer_res_status[sizeof(cm_saved_mixer) / sizeof(cm_saved_mixer[0]) + (sizeof(char [1]) - 1UL)] ;
   struct cmipci_pcm channel[2] ;
   struct snd_rawmidi *rmidi ;
   struct gameport *gameport ;
   spinlock_t reg_lock ;
   unsigned int saved_regs[32] ;
   unsigned char saved_mixers[32] ;
};
//#line  1991 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
struct cmipci_sb_reg {
   unsigned int left_reg ;
   unsigned int right_reg ;
   unsigned int left_shift ;
   unsigned int right_shift ;
   unsigned int mask ;
   unsigned int invert : 1 ;
   unsigned int stereo : 1 ;
};
//#line  2325 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
struct cmipci_switch_args {
   int reg ;
   unsigned int mask ;
   unsigned int mask_on ;
   unsigned int is_byte : 1 ;
   unsigned int ac3_sensitive : 1 ;
};
//#line  1 "cmipci.merged.kernel.c"
#pragma merger(0,"./cmipci_annotated.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  118 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static unsigned char ( __attribute__((__always_inline__)) inb)(unsigned short port ) 
{ 
  unsigned char _v ;

  {
  __asm__  volatile   ("in"
                       "b"
                       " %"
                       "w"
                       "1,%"
                       ""
                       "0": "=a" (_v): "Nd" (port));
  return (_v);
}
}
//#line  121 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static unsigned short ( __attribute__((__always_inline__)) inw)(unsigned short port ) 
{ 
  unsigned short _v ;

  {
  __asm__  volatile   ("in"
                       "w"
                       " %"
                       "w"
                       "1,%"
                       ""
                       "0": "=a" (_v): "Nd" (port));
  return (_v);
}
}
//#line  124 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static unsigned int ( __attribute__((__always_inline__)) inl)(unsigned short port ) 
{ 
  unsigned int _v ;

  {
  __asm__  volatile   ("in"
                       "l"
                       " %"
                       "w"
                       "1,%"
                       ""
                       "0": "=a" (_v): "Nd" (port));
  return (_v);
}
}
//#line  127 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static void ( __attribute__((__always_inline__)) outb)(unsigned char value ,
                                                                unsigned short port ) 
{ 


  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0,%"
                       "w"
                       "1": : "a" (value), "Nd" (port));
  return;
}
}
//#line  128 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static void ( __attribute__((__always_inline__)) outw)(unsigned short value ,
                                                                unsigned short port ) 
{ 


  {
  __asm__  volatile   ("out"
                       "w"
                       " %"
                       "w"
                       "0,%"
                       "w"
                       "1": : "a" (value), "Nd" (port));
  return;
}
}
//#line  129 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/io_64.h"
__inline static void ( __attribute__((__always_inline__)) outl)(unsigned int value ,
                                                                unsigned short port ) 
{ 


  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       "0,%"
                       "w"
                       "1": : "a" (value), "Nd" (port));
  return;
}
}
//#line  178 "include/linux/kernel.h"
extern int ( /* format attribute */  sprintf)(char *buf , char const   *fmt  , ...) ;
//#line  238
extern int ( /* format attribute */  printk)(char const   *fmt  , ...) ;
//#line  37 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/irqflags.h"
__inline static void ( __attribute__((__always_inline__)) native_irq_enable)(void) 
{ 


  {
//#line  39
  __asm__  volatile   ("sti": : : "memory");
//#line  40
  return;
}
}
//#line  74 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/irqflags.h"
__inline static void ( __attribute__((__always_inline__)) raw_local_irq_enable)(void) 
{ 


  {
  {
//#line  76
  native_irq_enable();
  }
//#line  77
  return;
}
}
//#line  47 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/string_64.h"
extern void *memset(void *s , int c , size_t n ) ;
//#line  53
extern unsigned long strlen(char const   *s ) ;
//#line  54
extern char *strcpy(char *dest , char const   *src ) ;
//#line  56
extern int strcmp(char const   *cs , char const   *ct ) ;
//#line  28 "include/linux/string.h"
extern size_t strlcpy(char * , char const   * , size_t  ) ;
//#line  99 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) __ticket_spin_unlock)(raw_spinlock_t *lock ) 
{ 


  {
//#line  101
  __asm__  volatile   ("incb %0": "+m" (lock->slock): : "memory", "cc");
//#line  105
  return;
}
}
//#line  260 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/spinlock.h"
__inline static void ( __attribute__((__always_inline__)) __raw_spin_unlock)(raw_spinlock_t *lock ) 
{ 


  {
  {
//#line  262
  __ticket_spin_unlock(lock);
  }
//#line  263
  return;
}
}
//#line  22 "include/linux/spinlock_api_smp.h"
extern void _spin_lock(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  32
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  16 "/scratch/sym/annotated/linux-2.6.29-ipc-cmipci/arch/x86/include/asm/delay.h"
extern void __const_udelay(unsigned long xloops ) ;
//#line  46 "include/linux/delay.h"
extern void msleep(unsigned int msecs ) ;
//#line  137 "include/linux/wait.h"
extern void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
//#line  106 "include/linux/mutex.h"
extern void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
//#line  135
extern void mutex_lock(struct mutex *lock ) ;
//#line  151
extern void mutex_unlock(struct mutex *lock ) ;
//#line  129 "include/linux/slab.h"
extern void kfree(void const   * ) ;
//#line  205 "include/linux/slub_def.h"
extern void *__kmalloc(size_t size , gfp_t flags ) ;
//#line  212 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  {
//#line  227
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
//#line  304 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
//#line  306
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
//#line  76 "include/linux/interrupt.h"
extern int request_irq(unsigned int  , irqreturn_t (*handler)(int  , void * ) , unsigned long  ,
                       char const   * , void * ) ;
//#line  78
extern void free_irq(unsigned int  , void * ) ;
//#line  108 "include/linux/ioport.h"
extern struct resource ioport_resource ;
//#line  144
extern struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
//#line  159 "include/linux/moduleparam.h"
extern int param_set_int(char const   *val , struct kernel_param *kp ) ;
//#line  160
extern int param_get_int(char *buffer , struct kernel_param *kp ) ;
//#line  167
extern int param_set_long(char const   *val , struct kernel_param *kp ) ;
//#line  168
extern int param_get_long(char *buffer , struct kernel_param *kp ) ;
//#line  175
extern int param_set_charp(char const   *val , struct kernel_param *kp ) ;
//#line  176
extern int param_get_charp(char *buffer , struct kernel_param *kp ) ;
//#line  179
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
//#line  180
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
//#line  199
extern int param_array_set(char const   *val , struct kernel_param *kp ) ;
//#line  200
extern int param_array_get(char *buffer , struct kernel_param *kp ) ;
//#line  67 "include/linux/module.h"
int init_module(void) ;
//#line  68
void cleanup_module(void) ;
//#line  86
extern struct module __this_module ;
//#line  428 "include/linux/device.h"
__inline static char const   *( __attribute__((__always_inline__)) dev_name)(struct device  const  *dev ) 
{ 


  {
//#line  431
  return ((char const   *)(dev->bus_id));
}
}
//#line  456 "include/linux/device.h"
__inline static void *( __attribute__((__always_inline__)) dev_get_drvdata)(struct device  const  *dev ) 
{ 


  {
//#line  458
  return ((void *)dev->driver_data);
}
}
//#line  461 "include/linux/device.h"
__inline static void ( __attribute__((__always_inline__)) dev_set_drvdata)(struct device *dev ,
                                                                           void *data ) 
{ 


  {
//#line  463
  dev->driver_data = (char * __attribute__((__noderef__, __address_space__(2))) )data;
//#line  464
  return;
}
}
//#line  603 "include/linux/pci.h"
extern int pci_dev_present(struct pci_device_id  const  *ids ) ;
//#line  645
extern int pci_enable_device(struct pci_dev *dev ) ;
//#line  657
extern void pci_disable_device(struct pci_dev *dev ) ;
//#line  658
extern void pci_set_master(struct pci_dev *dev ) ;
//#line  690
extern int pci_save_state(struct pci_dev *dev ) ;
//#line  691
extern int pci_restore_state(struct pci_dev *dev ) ;
//#line  692
extern int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
//#line  693
extern pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
//#line  721
extern int pci_request_regions(struct pci_dev * , char const   * ) ;
//#line  723
extern void pci_release_regions(struct pci_dev * ) ;
//#line  742
extern int __pci_register_driver(struct pci_driver * , struct module * , char const   *mod_name ) ;
//#line  751
extern void pci_unregister_driver(struct pci_driver *dev ) ;
//#line  1076 "include/linux/pci.h"
__inline static void *( __attribute__((__always_inline__)) pci_get_drvdata)(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
//#line  1078
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
//#line  1081 "include/linux/pci.h"
__inline static void ( __attribute__((__always_inline__)) pci_set_drvdata)(struct pci_dev *pdev ,
                                                                           void *data ) 
{ 


  {
  {
//#line  1083
  dev_set_drvdata(& pdev->dev, data);
  }
//#line  1084
  return;
}
}
//#line  1089 "include/linux/pci.h"
__inline static char const   *( __attribute__((__always_inline__)) pci_name)(struct pci_dev *pdev ) 
{ 
  char const   *tmp ;

  {
  {
//#line  1091
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
//#line  74 "include/linux/gameport.h"
extern void __gameport_register_port(struct gameport *gameport , struct module *owner ) ;
//#line  75 "include/linux/gameport.h"
__inline static void ( __attribute__((__always_inline__)) gameport_register_port)(struct gameport *gameport ) 
{ 


  {
  {
//#line  77
  __gameport_register_port(gameport, & __this_module);
  }
//#line  78
  return;
}
}
//#line  80
extern void gameport_unregister_port(struct gameport *gameport ) ;
//#line  82
extern void ( /* format attribute */  gameport_set_phys)(struct gameport *gameport ,
                                                         char const   *fmt  , ...) ;
//#line  105 "include/linux/gameport.h"
__inline static struct gameport *( __attribute__((__always_inline__)) gameport_allocate_port)(void) 
{ 
  struct gameport *gameport ;
  void *tmp ;

  {
  {
//#line  107
  tmp = kzalloc(sizeof(struct gameport ), 208U);
  gameport = (struct gameport *)tmp;
  }
//#line  109
  return (gameport);
}
}
//#line  117 "include/linux/gameport.h"
__inline static void ( __attribute__((__always_inline__)) gameport_set_name)(struct gameport *gameport ,
                                                                             char const   *name ) 
{ 


  {
  {
//#line  119
  strlcpy(gameport->name, name, sizeof(gameport->name));
  }
//#line  120
  return;
}
}
//#line  177 "include/sound/core.h"
__inline static void ( __attribute__((__always_inline__)) snd_power_change_state)(struct snd_card *card ,
                                                                                  unsigned int state ) 
{ 


  {
  {
//#line  179
  card->power_state = state;
//#line  180
  __wake_up(& card->power_sleep, 3U, 1, (void *)0);
  }
//#line  181
  return;
}
}
//#line  299
extern struct snd_card *snd_card_new(int idx , char const   *id , struct module *module ,
                                     int extra_size ) ;
//#line  301
extern int snd_card_disconnect(struct snd_card *card ) ;
//#line  302
extern int snd_card_free(struct snd_card *card ) ;
//#line  304
extern int snd_card_register(struct snd_card *card ) ;
//#line  317
extern int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                          struct snd_device_ops *ops ) ;
//#line  338
extern void release_and_free_resource(struct resource *res ) ;
//#line  412 "include/sound/core.h"
__inline static int ( __attribute__((__always_inline__)) __snd_bug_on)(int cond ) 
{ 


  {
//#line  414
  return (0);
}
}
//#line  114 "include/sound/info.h"
extern int ( /* format attribute */  snd_iprintf)(struct snd_info_buffer *buffer ,
                                                  char *fmt  , ...) ;
//#line  139
extern int snd_card_proc_new(struct snd_card *card , char const   *name , struct snd_info_entry **entryp ) ;
//#line  142 "include/sound/info.h"
__inline static void ( __attribute__((__always_inline__)) snd_info_set_text_ops)(struct snd_info_entry *entry ,
                                                                                 void *private_data ,
                                                                                 void (*read)(struct snd_info_entry * ,
                                                                                              struct snd_info_buffer * ) ) 
{ 


  {
//#line  146
  entry->private_data = (struct ensoniq *)private_data;
//#line  147
  entry->c.text.read = read;
//#line  148
  return;
}
}
//#line  109 "include/sound/control.h"
extern void snd_ctl_notify(struct snd_card *card , unsigned int mask , struct snd_ctl_elem_id *id ) ;
//#line  111
extern struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew ,
                                         void *private_data ) ;
//#line  113
extern int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) ;
//#line  118
extern struct snd_kcontrol *snd_ctl_find_id(struct snd_card *card , struct snd_ctl_elem_id *id ) ;
//#line  164
extern int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
//#line  454 "include/sound/pcm.h"
extern int snd_pcm_new(struct snd_card *card , char *id , int device , int playback_count ,
                       int capture_count , struct snd_pcm **rpcm ) ;
//#line  477
extern int snd_pcm_suspend_all(struct snd_pcm *pcm ) ;
//#line  787 "include/sound/pcm.h"
__inline static struct snd_interval *( __attribute__((__always_inline__)) hw_param_interval)(struct snd_pcm_hw_params *params ,
                                                                                             snd_pcm_hw_param_t var ) 
{ 


  {
//#line  790
  return (& params->intervals[var - 8]);
}
}
//#line  842
extern int snd_pcm_hw_constraint_minmax(struct snd_pcm_runtime *runtime , snd_pcm_hw_param_t var ,
                                        unsigned int min , unsigned int max ) ;
//#line  845
extern int snd_pcm_hw_constraint_list(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                      snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_list *l ) ;
//#line  857
extern int snd_pcm_hw_constraint_msbits(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                        unsigned int width , unsigned int msbits ) ;
//#line  918
extern int snd_pcm_format_width(snd_pcm_format_t format ) ;
//#line  925
extern void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) ;
//#line  928
extern int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd ,
                             void *arg ) ;
//#line  936
extern void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) ;
//#line  995
extern int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm , int type ,
                                                 void *data , size_t size , size_t max ) ;
//#line  998
extern int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream , size_t size ) ;
//#line  999
extern int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream ) ;
//#line  125 "include/sound/mpu401.h"
extern irqreturn_t snd_mpu401_uart_interrupt(int irq , void *dev_id ) ;
//#line  128
extern int snd_mpu401_uart_new(struct snd_card *card , int device , unsigned short hardware ,
                               unsigned long port , unsigned int info_flags , int irq ,
                               int irq_flags , struct snd_rawmidi **rrawmidi ) ;
//#line  360 "include/sound/opl3.h"
extern int snd_opl3_create(struct snd_card *card , unsigned long l_port , unsigned long r_port ,
                           unsigned short hardware , int integrated , struct snd_opl3 **opl3 ) ;
//#line  366
extern int snd_opl3_hwdep_new(struct snd_opl3 *opl3 , int device , int seq_device ,
                              struct snd_hwdep **rhwdep ) ;
//#line  7 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__DUMMY(void *x ) 
{ 


  {
//#line  8
  return;
}
}
//#line  12 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void *MICRODRIVERS__MODIF_kmem_cache_zalloc(struct kmem_cache *a , gfp_t b ) 
{ 


  {
//#line  14
  return ((void *)0);
}
}
//#line  18 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
unsigned long MICRODRIVERS__MODIF__spin_lock_irqsave(spinlock_t *lock ) 
{ 


  {
//#line  20
  return (0UL);
}
}
//#line  24 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
//#line  26
  return;
}
}
//#line  30 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_pci_disable_device(struct pci_dev *dev ) 
{ 


  {
  {
//#line  32
  MICRODRIVERS__DUMMY((void *)dev->bus);
//#line  33
  MICRODRIVERS__DUMMY((void *)dev->devfn);
  }
//#line  34
  return;
}
}
//#line  38 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_pci_set_master(struct pci_dev *dev ) 
{ 


  {
  {
//#line  40
  MICRODRIVERS__DUMMY((void *)dev->bus);
//#line  41
  MICRODRIVERS__DUMMY((void *)dev->devfn);
//#line  42
  MICRODRIVERS__DUMMY((void *)(dev->dev.bus_id));
  }
//#line  43
  return;
}
}
//#line  47 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF___release_region(struct resource *a , resource_size_t b ,
                                          resource_size_t c ) 
{ 


  {
//#line  50
  return;
}
}
//#line  54 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF___spin_lock_init(spinlock_t *lock , char const   *name ,
                                          struct lock_class_key *key ) 
{ 


  {
//#line  56
  return;
}
}
//#line  60 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
struct resource *MICRODRIVERS__MODIF___request_region(struct resource *a , resource_size_t start ,
                                                      resource_size_t n , char const   *name ) 
{ 


  {
//#line  63
  return ((struct resource *)0);
}
}
//#line  67 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_enable_device(struct pci_dev *dev ) 
{ 


  {
//#line  70
  return (0);
}
}
//#line  74 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_pci_unregister_driver(struct pci_driver *drv ) 
{ 


  {
  {
//#line  76
  MICRODRIVERS__DUMMY((void *)(& drv->driver));
  }
//#line  77
  return;
}
}
//#line  81 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock(spinlock_t *lock ) 
{ 


  {
//#line  83
  return;
}
}
//#line  87 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock(spinlock_t *lock ) 
{ 


  {
//#line  89
  return;
}
}
//#line  92 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock_bh(spinlock_t *lock ) 
{ 


  {
//#line  94
  return;
}
}
//#line  98 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF___pci_register_driver(struct pci_driver *drv , struct module *owner ) 
{ 


  {
  {
//#line  100
  MICRODRIVERS__DUMMY((void *)drv->driver.name);
//#line  101
  MICRODRIVERS__DUMMY((void *)drv->name);
//#line  102
  MICRODRIVERS__DUMMY((void *)drv->driver.bus);
//#line  103
  MICRODRIVERS__DUMMY((void *)drv->driver.owner);
//#line  104
  MICRODRIVERS__DUMMY((void *)(& drv->dynids.lock));
//#line  105
  MICRODRIVERS__DUMMY((void *)(& drv->dynids.list));
//#line  106
  MICRODRIVERS__DUMMY((void *)(& drv->driver));
//#line  107
  MICRODRIVERS__DUMMY((void *)drv->probe);
  }
//#line  109
  return (0);
}
}
//#line  113 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_request_irq(unsigned int a , irqreturn_t (*handler)(int  ,
                                                                            void * ,
                                                                            struct pt_regs * ) ,
                                    unsigned long b , char const   *c , void *d ) 
{ 


  {
//#line  117
  return (0);
}
}
//#line  121 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
//#line  123
  return;
}
}
//#line  127 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock_irq(spinlock_t *lock ) 
{ 


  {
//#line  128
  return;
}
}
//#line  132 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_mutex_unlock(struct mutex *lock ) 
{ 


  {
//#line  133
  return;
}
}
//#line  137 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_mutex_lock(struct mutex *lock ) 
{ 


  {
//#line  138
  return;
}
}
//#line  142 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
//#line  143
  return;
}
}
//#line  146 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF___wake_up(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                                   void *key ) 
{ 


  {
//#line  148
  return;
}
}
//#line  151 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_pci_release_regions(struct pci_dev *pdev ) 
{ 


  {
//#line  152
  return;
}
}
//#line  155 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF_free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
//#line  156
  return;
}
}
//#line  159 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_set_power_state(struct pci_dev *dev , pci_power_t state ) 
{ 


  {
//#line  160
  return (0);
}
}
//#line  163 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_save_state(struct pci_dev *dev ) 
{ 


  {
//#line  164
  return (0);
}
}
//#line  167 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_restore_state(struct pci_dev *dev ) 
{ 


  {
//#line  168
  return (0);
}
}
//#line  171 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u8 *val ) 
{ 


  {
//#line  175
  return (0);
}
}
//#line  178 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
void MICRODRIVERS__MODIF___mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) 
{ 


  {
//#line  179
  return;
}
}
//#line  182 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u16 *val ) 
{ 


  {
//#line  186
  return (0);
}
}
//#line  189 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 


  {
//#line  191
  return (0);
}
}
//#line  194 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_device_create_file(struct device *dev , struct device_attribute *attr ) 
{ 


  {
  {
//#line  195
  MICRODRIVERS__DUMMY((void *)attr->attr.mode);
//#line  196
  MICRODRIVERS__DUMMY((void *)attr->attr.name);
  }
//#line  198
  return (0);
}
}
//#line  201 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) 
{ 


  {
  {
//#line  202
  MICRODRIVERS__DUMMY((void *)tp->tv_sec);
//#line  203
  MICRODRIVERS__DUMMY((void *)tp->tv_nsec);
  }
//#line  204
  return (0);
}
}
//#line  207 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
struct proc_dir_entry *MICRODRIVERS__MODIF_create_proc_entry(char const   *name ,
                                                             mode_t mode , struct proc_dir_entry *parent ) 
{ 


  {
  {
//#line  208
  MICRODRIVERS__DUMMY((void *)name);
//#line  209
  MICRODRIVERS__DUMMY((void *)mode);
//#line  210
  MICRODRIVERS__DUMMY((void *)parent);
//#line  211
  MICRODRIVERS__DUMMY((void *)parent->name);
  }
//#line  212
  return ((struct proc_dir_entry *)((void *)0));
}
}
//#line  215 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
struct proc_dir_entry *MICRODRIVERS__MODIF_proc_symlink(char const   *name , struct proc_dir_entry *parent ,
                                                        char const   *dest ) 
{ 


  {
  {
//#line  217
  MICRODRIVERS__DUMMY((void *)parent->name);
  }
//#line  218
  return ((struct proc_dir_entry *)((void *)0));
}
}
//#line  221 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_logWrite(void *addr , char *what , char *where , char *file ,
                                 int line ) 
{ 


  {
//#line  222
  return (0);
}
}
//#line  225 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_logRead(void *addr , char *what , char *where , char *file ,
                                int line ) 
{ 


  {
//#line  226
  return (0);
}
}
//#line  229 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_logStackFrame(char *func ) 
{ 


  {
//#line  230
  return (0);
}
}
//#line  233 "/scratch/sym/ipc_drivers/cmipci/modif_annots.h"
int MICRODRIVERS__MODIF_logAlloc(void *addr , int size , char *fn , char *file , char *allocfn ,
                                 int line ) 
{ 


  {
//#line  234
  return (0);
}
}
static char const   __mod_author47[36]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  47 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'T', 
        (char const   )'a',      (char const   )'k',      (char const   )'a',      (char const   )'s', 
        (char const   )'h',      (char const   )'i',      (char const   )' ',      (char const   )'I', 
        (char const   )'w',      (char const   )'a',      (char const   )'i',      (char const   )' ', 
        (char const   )'<',      (char const   )'t',      (char const   )'i',      (char const   )'w', 
        (char const   )'a',      (char const   )'i',      (char const   )'@',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'.', 
        (char const   )'d',      (char const   )'e',      (char const   )'>',      (char const   )'\000'};
static char const   __mod_description48[32]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  48
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'C',      (char const   )'-',      (char const   )'M',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'a',      (char const   )' ', 
        (char const   )'C',      (char const   )'M',      (char const   )'I',      (char const   )'8', 
        (char const   )'x',      (char const   )'3',      (char const   )'8',      (char const   )' ', 
        (char const   )'P',      (char const   )'C',      (char const   )'I',      (char const   )'\000'};
static char const   __mod_license49[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  49
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
static int ( __attribute__((__noderef__, __address_space__(2))) index)[32]  = 
//#line  59
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
static char *( __attribute__((__noderef__, __address_space__(2))) id)[32]  = 
//#line  60
  {      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0)};
static int ( __attribute__((__noderef__, __address_space__(2))) enable)[32]  = 
//#line  61
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
//#line  62 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static long ( __attribute__((__noderef__, __address_space__(2))) mpu_port)[32]  ;
static long ( __attribute__((__noderef__, __address_space__(2))) fm_port)[32]  = 
//#line  63
  {      1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L, 
        1L,      1L,      1L,      1L};
static int ( __attribute__((__noderef__, __address_space__(2))) soft_ac3)[32]  = 
//#line  64
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
//#line  66 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int ( __attribute__((__noderef__, __address_space__(2))) joystick_port)[32]  ;
//#line  69 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_index  =    {(unsigned int )(sizeof(index) / sizeof(index[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(index[0]),
    (void *)(index)};
static char const   __param_str_index[6]  = {      (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000'};
static struct kernel_param  const  __param_index  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_index, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_index}};
static char const   __mod_indextype69[28]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_index70[50]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  70
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'I', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'C', 
        (char const   )'-',      (char const   )'M',      (char const   )'e',      (char const   )'d', 
        (char const   )'i',      (char const   )'a',      (char const   )' ',      (char const   )'P', 
        (char const   )'C',      (char const   )'I',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'c',      (char const   )'a',      (char const   )'r',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
//#line  71 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_id  =    {(unsigned int )(sizeof(id) / sizeof(id[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_charp, & param_get_charp, (unsigned int )sizeof(id[0]), (void *)(id)};
static char const   __param_str_id[3]  = {      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
static struct kernel_param  const  __param_id  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_id, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_id}};
static char const   __mod_idtype71[27]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'p',      (char const   )'\000'};
static char const   __mod_id72[45]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  72
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'C',      (char const   )'-', 
        (char const   )'M',      (char const   )'e',      (char const   )'d',      (char const   )'i', 
        (char const   )'a',      (char const   )' ',      (char const   )'P',      (char const   )'C', 
        (char const   )'I',      (char const   )' ',      (char const   )'s',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'c', 
        (char const   )'a',      (char const   )'r',      (char const   )'d',      (char const   )'.', 
        (char const   )'\000'};
//#line  73 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_enable  =    {(unsigned int )(sizeof(enable) / sizeof(enable[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_bool, & param_get_bool, (unsigned int )sizeof(enable[0]),
    (void *)(enable)};
static char const   __param_str_enable[7]  = {      (char const   )'e',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
static struct kernel_param  const  __param_enable  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_enable}};
static char const   __mod_enabletype73[30]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
static char const   __mod_enable74[42]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  74
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'E',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'C', 
        (char const   )'-',      (char const   )'M',      (char const   )'e',      (char const   )'d', 
        (char const   )'i',      (char const   )'a',      (char const   )' ',      (char const   )'P', 
        (char const   )'C',      (char const   )'I',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'c',      (char const   )'a',      (char const   )'r',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
//#line  75 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_mpu_port  =    {(unsigned int )(sizeof(mpu_port) / sizeof(mpu_port[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_long, & param_get_long, (unsigned int )sizeof(mpu_port[0]),
    (void *)(mpu_port)};
static char const   __param_str_mpu_port[9]  = 
  {      (char const   )'m',      (char const   )'p',      (char const   )'u',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'\000'};
static struct kernel_param  const  __param_mpu_port  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_mpu_port, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_mpu_port}};
static char const   __mod_mpu_porttype75[32]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'m',      (char const   )'p',      (char const   )'u', 
        (char const   )'_',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'n',      (char const   )'g',      (char const   )'\000'};
static char const   __mod_mpu_port76[28]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  76
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'m',      (char const   )'p',      (char const   )'u', 
        (char const   )'_',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )':',      (char const   )'M',      (char const   )'P', 
        (char const   )'U',      (char const   )'-',      (char const   )'4',      (char const   )'0', 
        (char const   )'1',      (char const   )' ',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )'.',      (char const   )'\000'};
//#line  77 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_fm_port  =    {(unsigned int )(sizeof(fm_port) / sizeof(fm_port[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_long, & param_get_long, (unsigned int )sizeof(fm_port[0]),
    (void *)(fm_port)};
static char const   __param_str_fm_port[8]  = 
  {      (char const   )'f',      (char const   )'m',      (char const   )'_',      (char const   )'p', 
        (char const   )'o',      (char const   )'r',      (char const   )'t',      (char const   )'\000'};
static struct kernel_param  const  __param_fm_port  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_fm_port, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_fm_port}};
static char const   __mod_fm_porttype77[31]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'f',      (char const   )'m',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )':',      (char const   )'a',      (char const   )'r',      (char const   )'r', 
        (char const   )'a',      (char const   )'y',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'o', 
        (char const   )'n',      (char const   )'g',      (char const   )'\000'};
static char const   __mod_fm_port78[22]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  78
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'f',      (char const   )'m',      (char const   )'_', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )':',      (char const   )'F',      (char const   )'M',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'.',      (char const   )'\000'};
//#line  79 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_soft_ac3  =    {(unsigned int )(sizeof(soft_ac3) / sizeof(soft_ac3[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_bool, & param_get_bool, (unsigned int )sizeof(soft_ac3[0]),
    (void *)(soft_ac3)};
static char const   __param_str_soft_ac3[9]  = 
  {      (char const   )'s',      (char const   )'o',      (char const   )'f',      (char const   )'t', 
        (char const   )'_',      (char const   )'a',      (char const   )'c',      (char const   )'3', 
        (char const   )'\000'};
static struct kernel_param  const  __param_soft_ac3  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_soft_ac3, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_soft_ac3}};
static char const   __mod_soft_ac3type79[32]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'s',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'_',      (char const   )'a',      (char const   )'c', 
        (char const   )'3',      (char const   )':',      (char const   )'a',      (char const   )'r', 
        (char const   )'r',      (char const   )'a',      (char const   )'y',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'b', 
        (char const   )'o',      (char const   )'o',      (char const   )'l',      (char const   )'\000'};
static char const   __mod_soft_ac380[72]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  80
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'s',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'_',      (char const   )'a',      (char const   )'c', 
        (char const   )'3',      (char const   )':',      (char const   )'S',      (char const   )'o', 
        (char const   )'f',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )'-',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'w',      (char const   )' ', 
        (char const   )'S',      (char const   )'P',      (char const   )'D',      (char const   )'I', 
        (char const   )'F',      (char const   )' ',      (char const   )'p',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'e',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'(',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'l', 
        (char const   )' ',      (char const   )'0',      (char const   )'3',      (char const   )'3', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )')',      (char const   )'.',      (char const   )'\000'};
//#line  82 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct kparam_array  const  __param_arr_joystick_port  =    {(unsigned int )(sizeof(joystick_port) / sizeof(joystick_port[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(joystick_port[0]),
    (void *)(joystick_port)};
static char const   __param_str_joystick_port[14]  = 
  {      (char const   )'j',      (char const   )'o',      (char const   )'y',      (char const   )'s', 
        (char const   )'t',      (char const   )'i',      (char const   )'c',      (char const   )'k', 
        (char const   )'_',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )'\000'};
static struct kernel_param  const  __param_joystick_port  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_joystick_port, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_joystick_port}};
static char const   __mod_joystick_porttype82[36]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'j',      (char const   )'o',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'i',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_joystick_port83[42]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  83
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'j',      (char const   )'o',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'i',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )':',      (char const   )'J', 
        (char const   )'o',      (char const   )'y',      (char const   )'s',      (char const   )'t', 
        (char const   )'i',      (char const   )'c',      (char const   )'k',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'.',      (char const   )'\000'};
//#line  453 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_mixer_auto_switches  const  ( __attribute__((__noderef__, __address_space__(2))) cm_saved_mixer)[4]  = {      {str_82022903,
      0}, 
        {str_436717668, 1}, 
        {str_49675815, 0}, 
        {str_5821155, 0}};
//#line  519 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static void ( __attribute__((__always_inline__)) snd_cmipci_write)(struct cmipci *cm ,
                                                                            unsigned int cmd ,
                                                                            unsigned int data ) 
{ 


  {
  {
//#line  521
  outl(data, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  522
  return;
}
}
//#line  524 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static unsigned int ( __attribute__((__always_inline__)) snd_cmipci_read)(struct cmipci *cm ,
                                                                                   unsigned int cmd ) 
{ 
  unsigned int tmp ;

  {
  {
//#line  526
  tmp = inl((unsigned short )(cm->iobase + (unsigned long )cmd));
  }
  return (tmp);
}
}
//#line  530 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static void ( __attribute__((__always_inline__)) snd_cmipci_write_w)(struct cmipci *cm ,
                                                                              unsigned int cmd ,
                                                                              unsigned short data ) 
{ 


  {
  {
//#line  532
  outw(data, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  533
  return;
}
}
//#line  535 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static unsigned short ( __attribute__((__always_inline__)) snd_cmipci_read_w)(struct cmipci *cm ,
                                                                                       unsigned int cmd ) 
{ 
  unsigned short tmp ;

  {
  {
//#line  537
  tmp = inw((unsigned short )(cm->iobase + (unsigned long )cmd));
  }
  return (tmp);
}
}
//#line  541 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static void ( __attribute__((__always_inline__)) snd_cmipci_write_b)(struct cmipci *cm ,
                                                                              unsigned int cmd ,
                                                                              unsigned char data ) 
{ 


  {
  {
//#line  543
  outb(data, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  544
  return;
}
}
//#line  546 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static unsigned char ( __attribute__((__always_inline__)) snd_cmipci_read_b)(struct cmipci *cm ,
                                                                                      unsigned int cmd ) 
{ 
  unsigned char tmp ;

  {
  {
//#line  548
  tmp = inb((unsigned short )(cm->iobase + (unsigned long )cmd));
  }
  return (tmp);
}
}
//#line  552 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_set_bit(struct cmipci *cm , unsigned int cmd , unsigned int flag ) 
{ 
  unsigned int val ;
  unsigned int oval ;

  {
  {
//#line  555
  oval = inl((unsigned short )(cm->iobase + (unsigned long )cmd));
  val = oval;
//#line  556
  val |= flag;
  }
//#line  557
  if (val == oval) {
//#line  558
    return (0);
  }
  {
//#line  559
  outl(val, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  560
  return (1);
}
}
//#line  563 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_clear_bit(struct cmipci *cm , unsigned int cmd , unsigned int flag ) 
{ 
  unsigned int val ;
  unsigned int oval ;

  {
  {
//#line  566
  oval = inl((unsigned short )(cm->iobase + (unsigned long )cmd));
  val = oval;
//#line  567
  val &= ~ flag;
  }
//#line  568
  if (val == oval) {
//#line  569
    return (0);
  }
  {
//#line  570
  outl(val, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  571
  return (1);
}
}
//#line  575 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_set_bit_b(struct cmipci *cm , unsigned int cmd , unsigned char flag ) 
{ 
  unsigned char val ;
  unsigned char oval ;

  {
  {
//#line  578
  oval = inb((unsigned short )(cm->iobase + (unsigned long )cmd));
  val = oval;
//#line  579
  val = (unsigned char )((int )val | (int )flag);
  }
//#line  580
  if ((int )val == (int )oval) {
//#line  581
    return (0);
  }
  {
//#line  582
  outb(val, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  583
  return (1);
}
}
//#line  586 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_clear_bit_b(struct cmipci *cm , unsigned int cmd , unsigned char flag ) 
{ 
  unsigned char val ;
  unsigned char oval ;

  {
  {
//#line  589
  oval = inb((unsigned short )(cm->iobase + (unsigned long )cmd));
  val = oval;
//#line  590
  val = (unsigned char )((int )val & ~ ((int )flag));
  }
//#line  591
  if ((int )val == (int )oval) {
//#line  592
    return (0);
  }
  {
//#line  593
  outb(val, (unsigned short )(cm->iobase + (unsigned long )cmd));
  }
//#line  594
  return (1);
}
}
static unsigned int ( __attribute__((__noderef__, __address_space__(2))) rates)[8]  = 
//#line  606
  {      5512U,      11025U,      22050U,      44100U, 
        8000U,      16000U,      32000U,      48000U};
//#line  608 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static unsigned int snd_cmipci_rate_freq(unsigned int rate ) 
{ 
  unsigned int i ;

  {
//#line  612
  i = 0U;
  {
  {
  while (1) {


    if (! ((unsigned long )i < sizeof(rates) / sizeof(rates[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break;
    }
//#line  613
    if (rates[i] == rate) {
//#line  614
      return (i);
    }
//#line  612
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


//#line  616
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  617
  return (0U);
}
}
//#line  686 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_interval *tmp ;
  int tmp___0 ;

  {
  {
//#line  689
  tmp = hw_param_interval(hw_params, 18);
  tmp___0 = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
  return (tmp___0);
}
}
//#line  692 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback2_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct cmipci *cm ;
  struct snd_interval *tmp ;
  struct snd_interval *tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  695
  cm = (struct cmipci *)substream->private_data;
//#line  696
  tmp = hw_param_interval(hw_params, 10);
  }
//#line  696
  if (tmp->min > 2U) {
    {
//#line  697
    mutex_lock(& cm->open_mutex);
    }
//#line  698
    if (cm->opened[0]) {
      {
//#line  699
      mutex_unlock(& cm->open_mutex);
      }
//#line  700
      return (-16);
    }
    {
//#line  703
    cm->opened[0] = 144;
//#line  704
    mutex_unlock(& cm->open_mutex);
    }
  }
  {
//#line  706
  tmp___0 = hw_param_interval(hw_params, 18);
  tmp___1 = snd_pcm_lib_malloc_pages(substream, (size_t )tmp___0->min);
  }
  return (tmp___1);
}
}
//#line  709 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void snd_cmipci_ch_reset(struct cmipci *cm , int ch ) 
{ 
  int reset ;

  {
  {
//#line  711
  reset = 262144 << cm->channel[ch].ch;
//#line  712
  snd_cmipci_write(cm, 0U, cm->ctrl | (unsigned int )reset);
//#line  713
  snd_cmipci_write(cm, 0U, cm->ctrl & (unsigned int )(~ reset));
//#line  714
  __const_udelay(42950UL);
  }
//#line  715
  return;
}
}
//#line  717 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_hw_free(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  {
//#line  719
  tmp = snd_pcm_lib_free_pages(substream);
  }
  return (tmp);
}
}
//#line  726 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static unsigned int ( __attribute__((__noderef__, __address_space__(2))) hw_channels)[5]  = {      1U,      2U,      4U,      6U, 
        8U};
//#line  727 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_pcm_hw_constraint_list  __attribute__((__noderef__, __address_space__(2))) hw_constraints_channels_4  =    {3U,
    (unsigned int *)(hw_channels), 0U};
//#line  732 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_pcm_hw_constraint_list  __attribute__((__noderef__, __address_space__(2))) hw_constraints_channels_6  =    {4U,
    (unsigned int *)(hw_channels), 0U};
//#line  737 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_pcm_hw_constraint_list  __attribute__((__noderef__, __address_space__(2))) hw_constraints_channels_8  =    {5U,
    (unsigned int *)(hw_channels), 0U};
//#line  743 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int set_dac_channels(struct cmipci *cm , struct cmipci_pcm *rec , int channels ) 
{ 


  {
//#line  745
  if (channels > 2) {
//#line  746
    if (! cm->can_multi_ch) {
//#line  747
      return (-22);
    } else
//#line  746
    if (! rec->ch) {
//#line  747
      return (-22);
    }
//#line  748
    if ((int )rec->fmt != 3) {
//#line  749
      return (-22);
    }
  }
//#line  752
  if (cm->can_multi_ch) {
    {
//#line  753
    _spin_lock_irq(& cm->reg_lock);
    }
//#line  754
    if (channels > 2) {
      {
//#line  755
      snd_cmipci_set_bit(cm, 20U, 2147483648U);
//#line  756
      snd_cmipci_set_bit(cm, 24U, 4194304U);
      }
    } else {
      {
//#line  758
      snd_cmipci_clear_bit(cm, 20U, 2147483648U);
//#line  759
      snd_cmipci_clear_bit(cm, 24U, 4194304U);
      }
    }
//#line  761
    if (channels == 8) {
      {
//#line  762
      snd_cmipci_set_bit(cm, 144U, 2097152U);
      }
    } else {
      {
//#line  764
      snd_cmipci_clear_bit(cm, 144U, 2097152U);
      }
    }
//#line  765
    if (channels == 6) {
      {
//#line  766
      snd_cmipci_set_bit(cm, 8U, 2147483648U);
//#line  767
      snd_cmipci_set_bit(cm, 20U, 32768U);
      }
    } else {
      {
//#line  769
      snd_cmipci_clear_bit(cm, 8U, 2147483648U);
//#line  770
      snd_cmipci_clear_bit(cm, 20U, 32768U);
      }
    }
//#line  772
    if (channels == 4) {
      {
//#line  773
      snd_cmipci_set_bit(cm, 8U, 536870912U);
      }
    } else {
      {
//#line  775
      snd_cmipci_clear_bit(cm, 8U, 536870912U);
      }
    }
    {
    {
    while (1) {


      {
//#line  776
      __raw_spin_unlock(& cm->reg_lock.raw_lock);
      }
      {
      {
      while (1) {


        {
        {
        while (1) {


          goto while_break___1;
        }

        }
        while_break___1: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_break___0;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
      goto while_break;
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
//#line  778
  return (0);
}
}
//#line  786 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_pcm_prepare(struct cmipci *cm , struct cmipci_pcm *rec , struct snd_pcm_substream *substream ) 
{ 
  unsigned int reg ;
  unsigned int freq ;
  unsigned int freq_ext ;
  unsigned int val ;
  unsigned int period_size ;
  struct snd_pcm_runtime *runtime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  791
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  793
  rec->fmt = (u8 )0;
//#line  794
  rec->shift = 0U;
//#line  795
  tmp___0 = snd_pcm_format_width(runtime->format);
  }
//#line  795
  if (tmp___0 >= 16) {
    {
//#line  796
    rec->fmt = (u8 )((int )rec->fmt | 2);
//#line  797
    tmp = snd_pcm_format_width(runtime->format);
    }
//#line  797
    if (tmp > 16) {
//#line  798
      (rec->shift) ++;
    }
  }
//#line  800
  if (runtime->channels > 1U) {
//#line  801
    rec->fmt = (u8 )((int )rec->fmt | 1);
  }
  if (rec->is_dac) {
    {
//#line  802
    tmp___1 = set_dac_channels(cm, rec, (int )runtime->channels);
    }
//#line  802
    if (tmp___1 < 0) {
      {
      {
      while (1) {


//#line  803
        goto while_break;
      }

      }
      while_break: /* CIL Label */ ;
      }
//#line  804
      return (-22);
    }
  }
//#line  807
  rec->offset = (unsigned int )runtime->dma_addr;
//#line  809
  rec->dma_size = (unsigned int )(runtime->buffer_size << rec->shift);
//#line  810
  period_size = (unsigned int )(runtime->period_size << rec->shift);
//#line  811
  if (runtime->channels > 2U) {
//#line  813
    rec->dma_size = (rec->dma_size * runtime->channels) / 2U;
//#line  814
    period_size = (period_size * runtime->channels) / 2U;
  }
  {
//#line  817
  _spin_lock_irq(& cm->reg_lock);
  }
  if (rec->ch) {
    reg = 136U;
  } else {
//#line  820
    reg = 128U;
  }
  {
//#line  821
  snd_cmipci_write(cm, reg, rec->offset);
  }
  if (rec->ch) {
    reg = 140U;
  } else {
//#line  823
    reg = 132U;
  }
  {
//#line  824
  snd_cmipci_write_w(cm, reg, (unsigned short )(rec->dma_size - 1U));
//#line  825
  snd_cmipci_write_w(cm, reg + 2U, (unsigned short )(period_size - 1U));
  }
  if (rec->ch) {
    val = 2U;
  } else {
//#line  828
    val = 1U;
  }
//#line  829
  if (rec->is_dac) {
//#line  830
    cm->ctrl &= ~ val;
  } else {
//#line  832
    cm->ctrl |= val;
  }
  {
//#line  833
  snd_cmipci_write(cm, 0U, cm->ctrl);
//#line  837
  freq = 0U;
//#line  838
  freq_ext = 0U;
  }
//#line  839
  if (runtime->rate > 48000U) {
    {
    if ((int )runtime->rate == 88200) {
//#line  841
      goto case_88200;
    }
    if ((int )runtime->rate == 96000) {
//#line  842
      goto case_96000;
    }
    if ((int )runtime->rate == 128000) {
//#line  843
      goto case_128000;
    }
//#line  844
    goto switch_default;
    case_88200: /* CIL Label */ 
//#line  841
    freq_ext = 256U;
    goto switch_break;
    case_96000: /* CIL Label */ 
//#line  842
    freq_ext = 512U;
    goto switch_break;
    case_128000: /* CIL Label */ 
//#line  843
    freq_ext = 768U;
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
    {
    while (1) {


//#line  844
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
//#line  847
    freq = snd_cmipci_rate_freq(runtime->rate);
    }
  }
  {
//#line  848
  val = snd_cmipci_read(cm, 4U);
  }
//#line  849
  if (rec->ch) {
//#line  850
    val &= 4294909951U;
//#line  851
    val |= (freq << 13) & 57344U;
  } else {
//#line  853
    val &= 4294960127U;
//#line  854
    val |= (freq << 10) & 7168U;
  }
  {
//#line  856
  snd_cmipci_write(cm, 4U, val);
//#line  860
  val = snd_cmipci_read(cm, 8U);
  }
//#line  861
  if (rec->ch) {
//#line  862
    val &= 4294967283U;
//#line  863
    val |= (unsigned int )((int )rec->fmt << 2);
  } else {
//#line  865
    val &= 4294967292U;
//#line  866
    val |= (unsigned int )((int )rec->fmt);
  }
//#line  868
  if (cm->can_96k) {
//#line  869
    val &= (unsigned int )(~ (768 << rec->ch * 2U));
//#line  870
    val |= freq_ext << rec->ch * 2U;
  }
  {
//#line  872
  snd_cmipci_write(cm, 8U, val);
  }
  if (! rec->is_dac) {
//#line  875
    if (cm->chip_version) {
//#line  876
      if (runtime->rate > 44100U) {
        {
//#line  877
        snd_cmipci_set_bit(cm, 144U, 268435456U);
        }
      } else {
        {
//#line  879
        snd_cmipci_clear_bit(cm, 144U, 268435456U);
        }
      }
    }
  }
//#line  882
  rec->running = (u8 )0;
  {
  {
  while (1) {


    {
//#line  883
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___3;
      }

      }
      while_break___3: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___2;
    }

    }
    while_break___2: /* CIL Label */ ;
    }
    goto while_break___1;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  885
  return (0);
}
}
//#line  891 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_pcm_trigger(struct cmipci *cm , struct cmipci_pcm *rec , int cmd ) 
{ 
  unsigned int inthld ;
  unsigned int chen ;
  unsigned int reset ;
  unsigned int pause ;
  int result ;

  {
  {
//#line  895
  result = 0;
//#line  897
  inthld = (unsigned int )(65536 << rec->ch);
//#line  898
  chen = (unsigned int )(65536 << rec->ch);
//#line  899
  reset = (unsigned int )(262144 << rec->ch);
//#line  900
  pause = (unsigned int )(4 << rec->ch);
//#line  902
  _spin_lock(& cm->reg_lock);
  }
  {
  if (cmd == 1) {
//#line  904
    goto case_1;
  }
  if (cmd == 0) {
//#line  913
    goto case_0;
  }
  if (cmd == 3) {
//#line  923
    goto case_3;
  }
  if (cmd == 5) {
//#line  924
    goto case_3;
  }
  if (cmd == 4) {
//#line  928
    goto case_4;
  }
  if (cmd == 6) {
//#line  929
    goto case_4;
  }
//#line  933
  goto switch_default;
  case_1: /* CIL Label */ 
  {
//#line  905
  rec->running = (u8 )1;
//#line  907
  snd_cmipci_set_bit(cm, 12U, inthld);
//#line  908
  cm->ctrl |= chen;
//#line  910
  snd_cmipci_write(cm, 0U, cm->ctrl);
  }
//#line  912
  goto switch_break;
  case_0: /* CIL Label */ 
  {
//#line  914
  rec->running = (u8 )0;
//#line  916
  snd_cmipci_clear_bit(cm, 12U, inthld);
//#line  918
  cm->ctrl &= ~ chen;
//#line  919
  snd_cmipci_write(cm, 0U, cm->ctrl | reset);
//#line  920
  snd_cmipci_write(cm, 0U, cm->ctrl & ~ reset);
//#line  921
  rec->needs_silencing = rec->is_dac;
  }
//#line  922
  goto switch_break;
  case_3: /* CIL Label */ 
  {
//#line  925
  cm->ctrl |= pause;
//#line  926
  snd_cmipci_write(cm, 0U, cm->ctrl);
  }
//#line  927
  goto switch_break;
  case_4: /* CIL Label */ 
  {
//#line  930
  cm->ctrl &= ~ pause;
//#line  931
  snd_cmipci_write(cm, 0U, cm->ctrl);
  }
//#line  932
  goto switch_break;
  switch_default: /* CIL Label */ 
//#line  934
  result = -22;
//#line  935
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


    {
//#line  937
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  938
  return (result);
}
}
//#line  944 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static snd_pcm_uframes_t snd_cmipci_pcm_pointer(struct cmipci *cm , struct cmipci_pcm *rec ,
                                                struct snd_pcm_substream *substream ) 
{ 
  size_t ptr ;
  unsigned int reg ;
  unsigned short tmp ;

  {
//#line  949
  if (! rec->running) {
//#line  950
    return ((snd_pcm_uframes_t )0);
  }
  if (rec->ch) {
    reg = 140U;
  } else {
//#line  952
    reg = 132U;
  }
  {
//#line  953
  tmp = snd_cmipci_read_w(cm, reg);
  ptr = (size_t )(rec->dma_size - (unsigned int )((int )tmp + 1));
//#line  954
  ptr >>= rec->shift;
  }
//#line  960
  if ((substream->runtime)->channels > 2U) {
//#line  961
    ptr = (ptr * 2UL) / (size_t )(substream->runtime)->channels;
  }
//#line  962
  return (ptr);
}
}
//#line  969 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  972
  cm = (struct cmipci *)substream->private_data;
//#line  973
  tmp = snd_cmipci_pcm_trigger(cm, & cm->channel[0], cmd);
  }
  return (tmp);
}
}
//#line  976 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static snd_pcm_uframes_t snd_cmipci_playback_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  snd_pcm_uframes_t tmp ;

  {
  {
//#line  978
  cm = (struct cmipci *)substream->private_data;
//#line  979
  tmp = snd_cmipci_pcm_pointer(cm, & cm->channel[0], substream);
  }
  return (tmp);
}
}
//#line  988 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  991
  cm = (struct cmipci *)substream->private_data;
//#line  992
  tmp = snd_cmipci_pcm_trigger(cm, & cm->channel[1], cmd);
  }
  return (tmp);
}
}
//#line  995 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static snd_pcm_uframes_t snd_cmipci_capture_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  snd_pcm_uframes_t tmp ;

  {
  {
//#line  997
  cm = (struct cmipci *)substream->private_data;
//#line  998
  tmp = snd_cmipci_pcm_pointer(cm, & cm->channel[1], substream);
  }
  return (tmp);
}
}
//#line  1006 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_default_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
//#line  1009
  uinfo->type = 5;
//#line  1010
  uinfo->count = 1U;
//#line  1011
  return (0);
}
}
//#line  1014 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_default_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *chip ;
  int i ;

  {
  {
//#line  1017
  chip = (struct cmipci *)kcontrol->private_data;
//#line  1020
  _spin_lock_irq(& chip->reg_lock);
//#line  1021
  i = 0;
  }
  {
  {
  while (1) {


    if (! (i < 4)) {
      goto while_break;
    }
//#line  1022
    ucontrol->value.iec958.status[i] = (unsigned char )((chip->dig_status >> i * 8) & 255U);
//#line  1021
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


    {
//#line  1023
    __raw_spin_unlock(& chip->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___2;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  1024
  return (0);
}
}
//#line  1027 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_default_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *chip ;
  int i ;
  int change ;
  unsigned int val ;

  {
  {
//#line  1030
  chip = (struct cmipci *)kcontrol->private_data;
//#line  1034
  val = 0U;
//#line  1035
  _spin_lock_irq(& chip->reg_lock);
//#line  1036
  i = 0;
  }
  {
  {
  while (1) {


    if (! (i < 4)) {
      goto while_break;
    }
//#line  1037
    val |= (unsigned int )ucontrol->value.iec958.status[i] << i * 8;
//#line  1036
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  1038
  change = val != chip->dig_status;
//#line  1039
  chip->dig_status = val;
  {
  {
  while (1) {


    {
//#line  1040
    __raw_spin_unlock(& chip->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___2;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  1041
  return (change);
}
}
static struct snd_kcontrol_new snd_cmipci_spdif_default  __attribute__((__section__(".devinit.data")))  = 
//#line  1044
     {3, 0U, 0U, (unsigned char *)str_375887647, 0U, 0U, 0U, & snd_cmipci_spdif_default_info,
    & snd_cmipci_spdif_default_get, & snd_cmipci_spdif_default_put, {(snd_kcontrol_tlv_rw_t *)0},
    0UL};
//#line  1053 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_mask_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
//#line  1056
  uinfo->type = 5;
//#line  1057
  uinfo->count = 1U;
//#line  1058
  return (0);
}
}
//#line  1061 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_mask_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 


  {
//#line  1064
  ucontrol->value.iec958.status[0] = (unsigned char)255;
//#line  1065
  ucontrol->value.iec958.status[1] = (unsigned char)255;
//#line  1066
  ucontrol->value.iec958.status[2] = (unsigned char)255;
//#line  1067
  ucontrol->value.iec958.status[3] = (unsigned char)255;
//#line  1068
  return (0);
}
}
static struct snd_kcontrol_new snd_cmipci_spdif_mask  __attribute__((__section__(".devinit.data")))  = 
//#line  1071
     {3, 0U, 0U, (unsigned char *)str_287061104, 0U, 1U, 0U, & snd_cmipci_spdif_mask_info,
    & snd_cmipci_spdif_mask_get, (snd_kcontrol_put_t *)0, {(snd_kcontrol_tlv_rw_t *)0},
    0UL};
//#line  1080 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_stream_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
//#line  1083
  uinfo->type = 5;
//#line  1084
  uinfo->count = 1U;
//#line  1085
  return (0);
}
}
//#line  1088 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_stream_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *chip ;
  int i ;

  {
  {
//#line  1091
  chip = (struct cmipci *)kcontrol->private_data;
//#line  1094
  _spin_lock_irq(& chip->reg_lock);
//#line  1095
  i = 0;
  }
  {
  {
  while (1) {


    if (! (i < 4)) {
      goto while_break;
    }
//#line  1096
    ucontrol->value.iec958.status[i] = (unsigned char )((chip->dig_pcm_status >> i * 8) & 255U);
//#line  1095
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


    {
//#line  1097
    __raw_spin_unlock(& chip->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___2;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  1098
  return (0);
}
}
//#line  1101 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdif_stream_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *chip ;
  int i ;
  int change ;
  unsigned int val ;

  {
  {
//#line  1104
  chip = (struct cmipci *)kcontrol->private_data;
//#line  1108
  val = 0U;
//#line  1109
  _spin_lock_irq(& chip->reg_lock);
//#line  1110
  i = 0;
  }
  {
  {
  while (1) {


    if (! (i < 4)) {
      goto while_break;
    }
//#line  1111
    val |= (unsigned int )ucontrol->value.iec958.status[i] << i * 8;
//#line  1110
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  1112
  change = val != chip->dig_pcm_status;
//#line  1113
  chip->dig_pcm_status = val;
  {
  {
  while (1) {


    {
//#line  1114
    __raw_spin_unlock(& chip->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___2;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___1;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  1115
  return (change);
}
}
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_spdif_stream  __attribute__((__section__(".devinit.data")))  = 
//#line  1118
     {3, 0U, 0U, (unsigned char *)str_1012473204, 0U, (unsigned int )((1 | (1 << 1)) | (1 << 8)),
    0U, & snd_cmipci_spdif_stream_info, & snd_cmipci_spdif_stream_get, & snd_cmipci_spdif_stream_put,
    {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  1132 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int save_mixer_state(struct cmipci *cm ) 
{ 
  struct snd_ctl_elem_value *val ;
  unsigned int i ;
  void *tmp ;
  struct snd_kcontrol *ctl ;
  int event ;

  {
//#line  1134
  if (! cm->mixer_insensitive) {
    {
//#line  1138
    tmp = kmalloc(sizeof(*val), 32U);
    val = (struct snd_ctl_elem_value *)tmp;
    }
//#line  1139
    if (! val) {
//#line  1140
      return (-12);
    }
//#line  1141
    i = 0U;
    {
    {
    while (1) {


      if (! ((unsigned long )i < sizeof(cm_saved_mixer) / sizeof(cm_saved_mixer[0]) + (sizeof(char [1]) - 1UL))) {
        goto while_break;
      }
//#line  1142
      ctl = cm->mixer_res_ctl[i];
//#line  1143
      if (ctl) {
        {
//#line  1145
        memset((void *)val, 0, sizeof(*val));
//#line  1146
        (*(ctl->get))(ctl, val);
//#line  1147
        cm->mixer_res_status[i] = (int )val->value.integer.value[0];
//#line  1148
        val->value.integer.value[0] = (long )cm_saved_mixer[i].toggle_on;
//#line  1149
        event = 1 << 1;
        }
//#line  1150
        if ((long )cm->mixer_res_status[i] != val->value.integer.value[0]) {
          {
//#line  1151
          (*(ctl->put))(ctl, val);
//#line  1152
          event |= 1;
          }
        }
        {
//#line  1154
        ctl->vd[0].access |= (unsigned int )(1 << 8);
//#line  1155
        snd_ctl_notify(cm->card, (unsigned int )event, & ctl->id);
        }
      }
//#line  1141
      i ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
    {
//#line  1158
    kfree((void const   *)val);
//#line  1159
    cm->mixer_insensitive = 1U;
    }
  }
//#line  1161
  return (0);
}
}
//#line  1166 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void restore_mixer_state(struct cmipci *cm ) 
{ 
  struct snd_ctl_elem_value *val ;
  unsigned int i ;
  void *tmp ;
  struct snd_kcontrol *ctl ;
  int event ;

  {
//#line  1168
  if (cm->mixer_insensitive) {
    {
//#line  1172
    tmp = kmalloc(sizeof(*val), 208U);
    val = (struct snd_ctl_elem_value *)tmp;
    }
//#line  1173
    if (! val) {
//#line  1174
      return;
    }
//#line  1175
    cm->mixer_insensitive = 0U;
//#line  1177
    i = 0U;
    {
    {
    while (1) {


      if (! ((unsigned long )i < sizeof(cm_saved_mixer) / sizeof(cm_saved_mixer[0]) + (sizeof(char [1]) - 1UL))) {
        goto while_break;
      }
//#line  1178
      ctl = cm->mixer_res_ctl[i];
//#line  1179
      if (ctl) {
        {
//#line  1182
        memset((void *)val, 0, sizeof(*val));
//#line  1183
        ctl->vd[0].access &= (unsigned int )(~ (1 << 8));
//#line  1184
        (*(ctl->get))(ctl, val);
//#line  1185
        event = 1 << 1;
        }
//#line  1186
        if (val->value.integer.value[0] != (long )cm->mixer_res_status[i]) {
          {
//#line  1187
          val->value.integer.value[0] = (long )cm->mixer_res_status[i];
//#line  1188
          (*(ctl->put))(ctl, val);
//#line  1189
          event |= 1;
          }
        }
        {
//#line  1191
        snd_ctl_notify(cm->card, (unsigned int )event, & ctl->id);
        }
      }
//#line  1177
      i ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
    {
//#line  1194
    kfree((void const   *)val);
    }
  }
//#line  1196
  return;
}
}
//#line  1199 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void setup_ac3(struct cmipci *cm , struct snd_pcm_substream *subs , int do_ac3 ,
                      int rate ) 
{ 
  int tmp ;

  {
//#line  1201
  if (do_ac3) {
    {
//#line  1203
    snd_cmipci_set_bit(cm, 8U, 1048576U);
//#line  1205
    snd_cmipci_set_bit(cm, 24U, 262144U);
    }
//#line  1207
    if (cm->can_ac3_hw) {
      {
//#line  1210
      snd_cmipci_set_bit(cm, 8U, 131072U);
//#line  1211
      snd_cmipci_clear_bit(cm, 24U, 2097152U);
      }
    } else {
      {
//#line  1214
      snd_cmipci_set_bit(cm, 24U, 2097152U);
      }
//#line  1216
      if (cm->chip_version == 33) {
//#line  1217
        if (rate >= 48000) {
          {
//#line  1218
          snd_cmipci_set_bit(cm, 8U, 512U);
          }
        } else {
          {
//#line  1220
          snd_cmipci_clear_bit(cm, 8U, 512U);
          }
        }
      }
    }
  } else {
    {
//#line  1226
    snd_cmipci_clear_bit(cm, 8U, 1048576U);
//#line  1227
    snd_cmipci_clear_bit(cm, 24U, 262144U);
    }
//#line  1229
    if (cm->can_ac3_hw) {
      {
//#line  1231
      tmp = snd_pcm_format_width((subs->runtime)->format);
      }
//#line  1231
      if (tmp > 16) {
        {
//#line  1232
        snd_cmipci_set_bit(cm, 24U, 2097152U);
//#line  1233
        snd_cmipci_set_bit(cm, 8U, 131072U);
        }
      } else {
        {
//#line  1235
        snd_cmipci_clear_bit(cm, 24U, 2097152U);
//#line  1236
        snd_cmipci_clear_bit(cm, 8U, 131072U);
        }
      }
    } else {
      {
//#line  1239
      snd_cmipci_clear_bit(cm, 24U, 2097152U);
//#line  1240
      snd_cmipci_clear_bit(cm, 8U, 131072U);
//#line  1241
      snd_cmipci_clear_bit(cm, 8U, 512U);
      }
    }
  }
//#line  1244
  return;
}
}
//#line  1246 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int setup_spdif_playback(struct cmipci *cm , struct snd_pcm_substream *subs ,
                                int up___0 , int do_ac3 ) 
{ 
  int rate ;
  int err ;

  {
//#line  1250
  rate = (int )(subs->runtime)->rate;
  if (up___0) {
//#line  1252
    if (do_ac3) {
      {
//#line  1253
      err = save_mixer_state(cm);
      }
//#line  1253
      if (err < 0) {
//#line  1254
        return (err);
      }
    }
  }
  {
//#line  1256
  _spin_lock_irq(& cm->reg_lock);
//#line  1257
  cm->spdif_playback_avail = (unsigned int )up___0;
  }
//#line  1258
  if (up___0) {
//#line  1262
    if (cm->spdif_playback_enabled) {
      {
//#line  1263
      snd_cmipci_set_bit(cm, 4U, 256U);
      }
    }
    {
//#line  1264
    setup_ac3(cm, subs, do_ac3, rate);
    }
//#line  1266
    if (rate == 48000) {
      {
//#line  1267
      snd_cmipci_set_bit(cm, 24U, 16809984U);
      }
    } else
//#line  1266
    if (rate == 96000) {
      {
//#line  1267
      snd_cmipci_set_bit(cm, 24U, 16809984U);
      }
    } else {
      {
//#line  1269
      snd_cmipci_clear_bit(cm, 24U, 16809984U);
      }
    }
//#line  1270
    if (rate > 48000) {
      {
//#line  1271
      snd_cmipci_set_bit(cm, 8U, 64U);
      }
    } else {
      {
//#line  1273
      snd_cmipci_clear_bit(cm, 8U, 64U);
      }
    }
  } else {
    {
//#line  1278
    snd_cmipci_clear_bit(cm, 8U, 64U);
//#line  1279
    snd_cmipci_clear_bit(cm, 4U, 256U);
//#line  1280
    setup_ac3(cm, subs, 0, 0);
    }
  }
  {
  {
  while (1) {


    {
//#line  1282
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  1283
  return (0);
}
}
//#line  1292 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int rate ;
  int err ;
  int do_spdif ;
  int do_ac3 ;
  int tmp ;
  int tmp___0 ;

  {
//#line  1294
  cm = (struct cmipci *)substream->private_data;
//#line  1295
  rate = (int )(substream->runtime)->rate;
//#line  1296
  do_ac3 = 0;
  if (rate >= 44100) {
    if (rate <= 96000) {
      if ((substream->runtime)->format == 2) {
        if ((substream->runtime)->channels == 2U) {
          tmp = 1;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
//#line  1298
    tmp = 0;
  }
  do_spdif = tmp;
  if (do_spdif) {
//#line  1301
    if (cm->can_ac3_hw) {
//#line  1302
      do_ac3 = (int )(cm->dig_pcm_status & (unsigned int )(1 << 1));
    }
  }
  {
//#line  1303
  err = setup_spdif_playback(cm, substream, do_spdif, do_ac3);
  }
//#line  1303
  if (err < 0) {
//#line  1304
    return (err);
  }
  {
//#line  1305
  tmp___0 = snd_cmipci_pcm_prepare(cm, & cm->channel[0], substream);
  }
  return (tmp___0);
}
}
//#line  1309 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_spdif_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int err ;
  int do_ac3 ;
  int tmp ;

  {
//#line  1311
  cm = (struct cmipci *)substream->private_data;
//#line  1314
  if (cm->can_ac3_hw) {
//#line  1315
    do_ac3 = (int )(cm->dig_pcm_status & (unsigned int )(1 << 1));
  } else {
//#line  1317
    do_ac3 = 1;
  }
  {
//#line  1318
  err = setup_spdif_playback(cm, substream, 1, do_ac3);
  }
//#line  1318
  if (err < 0) {
//#line  1319
    return (err);
  }
  {
//#line  1320
  tmp = snd_cmipci_pcm_prepare(cm, & cm->channel[0], substream);
  }
  return (tmp);
}
}
//#line  1331 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void snd_cmipci_silence_hack(struct cmipci *cm , struct cmipci_pcm *rec ) 
{ 
  struct snd_pcm_runtime *runtime ;
  unsigned int reg ;
  unsigned int val ;

  {
//#line  1333
  runtime = (struct snd_pcm_runtime *)(rec->substream)->runtime;
  if (rec->needs_silencing) {
    if (runtime) {
//#line  1336
      if (runtime->dma_area) {
        {
//#line  1338
        memset((void *)runtime->dma_area, 0, 1UL << 12);
        }
        if (rec->ch) {
          reg = 140U;
        } else {
//#line  1339
          reg = 132U;
        }
        {
//#line  1340
        val = (unsigned int )(((1UL << 12) / 4UL - 1UL) | ((((1UL << 12) / 4UL) / 2UL - 1UL) << 16));
//#line  1341
        snd_cmipci_write(cm, reg, val);
        }
//#line  1344
        if (runtime->channels > 2U) {
          {
//#line  1345
          set_dac_channels(cm, rec, 2);
          }
        }
        {
//#line  1346
        _spin_lock_irq(& cm->reg_lock);
//#line  1347
        val = snd_cmipci_read(cm, 4U);
//#line  1348
        val &= (unsigned int )(~ (7168 << rec->ch * 3U));
//#line  1349
        val |= (unsigned int )((4 << 10) << rec->ch * 3U);
//#line  1350
        snd_cmipci_write(cm, 4U, val);
//#line  1351
        val = snd_cmipci_read(cm, 8U);
//#line  1352
        val &= (unsigned int )(~ (3 << rec->ch * 2U));
//#line  1353
        val |= (unsigned int )(3 << rec->ch * 2U);
        }
//#line  1354
        if (cm->can_96k) {
//#line  1355
          val &= (unsigned int )(~ (768 << rec->ch * 2U));
        }
        {
//#line  1356
        snd_cmipci_write(cm, 8U, val);
//#line  1359
        cm->ctrl |= (unsigned int )(65536 << rec->ch);
//#line  1360
        snd_cmipci_write(cm, 0U, cm->ctrl);
        }
        {
        {
        while (1) {


          {
//#line  1361
          __raw_spin_unlock(& cm->reg_lock.raw_lock);
          }
          {
          {
          while (1) {


            {
            {
            while (1) {


              goto while_break___1;
            }

            }
            while_break___1: /* CIL Label */ ;
            }
            {
            raw_local_irq_enable();
            }
            goto while_break___0;
          }

          }
          while_break___0: /* CIL Label */ ;
          }
          goto while_break;
        }

        }
        while_break: /* CIL Label */ ;
        }
        {
//#line  1363
        msleep(1U);
//#line  1366
        _spin_lock_irq(& cm->reg_lock);
//#line  1367
        cm->ctrl &= (unsigned int )(~ (65536 << rec->ch));
//#line  1368
        val = (unsigned int )(262144 << rec->ch);
//#line  1369
        snd_cmipci_write(cm, 0U, cm->ctrl | val);
//#line  1370
        snd_cmipci_write(cm, 0U, cm->ctrl & ~ val);
        }
        {
        {
        while (1) {


          {
//#line  1371
          __raw_spin_unlock(& cm->reg_lock.raw_lock);
          }
          {
          {
          while (1) {


            {
            {
            while (1) {


              goto while_break___4;
            }

            }
            while_break___4: /* CIL Label */ ;
            }
            {
            raw_local_irq_enable();
            }
            goto while_break___3;
          }

          }
          while_break___3: /* CIL Label */ ;
          }
          goto while_break___2;
        }

        }
        while_break___2: /* CIL Label */ ;
        }
//#line  1373
        rec->needs_silencing = (u8 )0;
      }
    }
  }
//#line  1375
  return;
}
}
//#line  1377 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  1379
  cm = (struct cmipci *)substream->private_data;
//#line  1380
  setup_spdif_playback(cm, substream, 0, 0);
//#line  1381
  restore_mixer_state(cm);
//#line  1382
  snd_cmipci_silence_hack(cm, & cm->channel[0]);
//#line  1383
  tmp = snd_cmipci_hw_free(substream);
  }
  return (tmp);
}
}
//#line  1386 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback2_hw_free(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  1388
  cm = (struct cmipci *)substream->private_data;
//#line  1389
  snd_cmipci_silence_hack(cm, & cm->channel[1]);
//#line  1390
  tmp = snd_cmipci_hw_free(substream);
  }
  return (tmp);
}
}
//#line  1394 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  1396
  cm = (struct cmipci *)substream->private_data;
//#line  1397
  tmp = snd_cmipci_pcm_prepare(cm, & cm->channel[1], substream);
  }
  return (tmp);
}
}
//#line  1401 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_spdif_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  1403
  cm = (struct cmipci *)substream->private_data;
//#line  1405
  _spin_lock_irq(& cm->reg_lock);
//#line  1406
  snd_cmipci_set_bit(cm, 4U, 512U);
  }
//#line  1407
  if (cm->can_96k) {
//#line  1408
    if ((substream->runtime)->rate > 48000U) {
      {
//#line  1409
      snd_cmipci_set_bit(cm, 8U, 64U);
      }
    } else {
      {
//#line  1411
      snd_cmipci_clear_bit(cm, 8U, 64U);
      }
    }
  }
  {
//#line  1413
  tmp = snd_pcm_format_width((substream->runtime)->format);
  }
//#line  1413
  if (tmp > 16) {
    {
//#line  1414
    snd_cmipci_set_bit(cm, 24U, 2097152U);
    }
  } else {
    {
//#line  1416
    snd_cmipci_clear_bit(cm, 24U, 2097152U);
    }
  }
  {
  {
  while (1) {


    {
//#line  1418
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  1420
  tmp___0 = snd_cmipci_pcm_prepare(cm, & cm->channel[1], substream);
  }
  return (tmp___0);
}
}
//#line  1423 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_spdif_hw_free(struct snd_pcm_substream *subs ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  1425
  cm = (struct cmipci *)subs->private_data;
//#line  1427
  _spin_lock_irq(& cm->reg_lock);
//#line  1428
  snd_cmipci_clear_bit(cm, 4U, 512U);
//#line  1429
  snd_cmipci_clear_bit(cm, 24U, 2097152U);
  }
  {
  {
  while (1) {


    {
//#line  1430
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  1432
  tmp = snd_cmipci_hw_free(subs);
  }
  return (tmp);
}
}
//#line  1439 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static irqreturn_t snd_cmipci_interrupt(int irq , void *dev_id ) 
{ 
  struct cmipci *cm ;
  unsigned int status ;
  unsigned int mask ;

  {
  {
//#line  1441
  cm = (struct cmipci *)dev_id;
//#line  1442
  mask = 0U;
//#line  1445
  status = snd_cmipci_read(cm, 16U);
  }
//#line  1446
  if (! (status & 2147483648U)) {
//#line  1447
    return (0);
  }
  {
//#line  1450
  _spin_lock(& cm->reg_lock);
  }
//#line  1451
  if (status & 1U) {
//#line  1452
    mask |= 65536U;
  }
//#line  1453
  if (status & 2U) {
//#line  1454
    mask |= 131072U;
  }
  {
//#line  1455
  snd_cmipci_clear_bit(cm, 12U, mask);
//#line  1456
  snd_cmipci_set_bit(cm, 12U, mask);
  }
  {
  {
  while (1) {


    {
//#line  1457
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  if (cm->rmidi) {
//#line  1459
    if (status & 65536U) {
      {
//#line  1460
      snd_mpu401_uart_interrupt(irq, (void *)(cm->rmidi)->private_data);
      }
    }
  }
//#line  1462
  if (cm->pcm) {
    if (status & 1U) {
//#line  1463
      if (cm->channel[0].running) {
        {
//#line  1464
        snd_pcm_period_elapsed(cm->channel[0].substream);
        }
      }
    }
    if (status & 2U) {
//#line  1465
      if (cm->channel[1].running) {
        {
//#line  1466
        snd_pcm_period_elapsed(cm->channel[1].substream);
        }
      }
    }
  }
//#line  1468
  return (1);
}
}
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback  = 
//#line  1476
     {852227U, (1ULL << 1) | (1ULL << 2), (unsigned int )(1 | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    5512U, 48000U, 1U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U,
    (size_t )0};
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_capture  = 
//#line  1496
     {852227U, (1ULL << 1) | (1ULL << 2), (unsigned int )(1 | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    5512U, 48000U, 1U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U,
    (size_t )0};
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback2  = 
//#line  1516
     {852227U, 1ULL << 2, (unsigned int )(1 | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    5512U, 48000U, 2U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U,
    (size_t )0};
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback_spdif  = 
//#line  1536
     {852227U, 1ULL << 2, (unsigned int )((1 << 6) | (1 << 7)), 44100U, 48000U, 2U,
    2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U, (size_t )0};
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback_iec958_subframe  = 
//#line  1556
     {852227U, 1ULL << 18, (unsigned int )((1 << 6) | (1 << 7)), 44100U, 48000U, 2U,
    2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U, (size_t )0};
static struct snd_pcm_hardware  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_capture_spdif  = 
//#line  1576
     {852227U, (1ULL << 2) | (1ULL << 18), (unsigned int )((1 << 6) | (1 << 7)), 44100U,
    48000U, 2U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 2U, 1024U, (size_t )0};
static unsigned int ( __attribute__((__noderef__,
__address_space__(2))) rate_constraints)[11]  = 
//#line  1596
  {      5512U,      8000U,      11025U,      16000U, 
        22050U,      32000U,      44100U,      48000U, 
        88200U,      96000U,      128000U};
//#line  1598 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_pcm_hw_constraint_list  __attribute__((__noderef__, __address_space__(2))) hw_constraints_rates  =    {(unsigned int )(sizeof(rate_constraints) / sizeof(rate_constraints[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)(rate_constraints), 0U};
//#line  1607 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int open_device_check(struct cmipci *cm , int mode , struct snd_pcm_substream *subs ) 
{ 
  int ch ;

  {
  {
//#line  1609
  ch = mode & 1;
//#line  1616
  mutex_lock(& cm->open_mutex);
  }
//#line  1617
  if (cm->opened[ch]) {
    {
//#line  1618
    mutex_unlock(& cm->open_mutex);
    }
//#line  1619
    return (-16);
  }
//#line  1621
  cm->opened[ch] = mode;
//#line  1622
  cm->channel[ch].substream = subs;
//#line  1623
  if (! (mode & 16)) {
    {
//#line  1625
    cm->channel[ch].is_dac = (u8 )0;
//#line  1626
    _spin_lock_irq(& cm->reg_lock);
//#line  1627
    snd_cmipci_clear_bit(cm, 24U, 8388608U);
    }
    {
    {
    while (1) {


      {
//#line  1628
      __raw_spin_unlock(& cm->reg_lock.raw_lock);
      }
      {
      {
      while (1) {


        {
        {
        while (1) {


          goto while_break___1;
        }

        }
        while_break___1: /* CIL Label */ ;
        }
        {
        raw_local_irq_enable();
        }
        goto while_break___0;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
      goto while_break;
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
  {
//#line  1630
  mutex_unlock(& cm->open_mutex);
  }
//#line  1631
  return (0);
}
}
//#line  1634 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void close_device_check(struct cmipci *cm , int mode ) 
{ 
  int ch ;

  {
  {
//#line  1636
  ch = mode & 1;
//#line  1638
  mutex_lock(& cm->open_mutex);
  }
//#line  1639
  if (cm->opened[ch] == mode) {
//#line  1640
    if (cm->channel[ch].substream) {
      {
//#line  1641
      snd_cmipci_ch_reset(cm, ch);
//#line  1642
      cm->channel[ch].running = (u8 )0;
//#line  1643
      cm->channel[ch].substream = (struct snd_pcm_substream *)((void *)0);
      }
    }
//#line  1645
    cm->opened[ch] = 0;
//#line  1646
    if (! cm->channel[ch].is_dac) {
      {
//#line  1648
      cm->channel[ch].is_dac = (u8 )1;
//#line  1649
      _spin_lock_irq(& cm->reg_lock);
//#line  1650
      snd_cmipci_set_bit(cm, 24U, 8388608U);
      }
      {
      {
      while (1) {


        {
//#line  1651
        __raw_spin_unlock(& cm->reg_lock.raw_lock);
        }
        {
        {
        while (1) {


          {
          {
          while (1) {


            goto while_break___1;
          }

          }
          while_break___1: /* CIL Label */ ;
          }
          {
          raw_local_irq_enable();
          }
          goto while_break___0;
        }

        }
        while_break___0: /* CIL Label */ ;
        }
        goto while_break;
      }

      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
//#line  1654
  mutex_unlock(& cm->open_mutex);
  }
//#line  1655
  return;
}
}
//#line  1660 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_open(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  struct snd_pcm_runtime *runtime ;
  int err ;

  {
  {
//#line  1662
  cm = (struct cmipci *)substream->private_data;
//#line  1663
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1666
  err = open_device_check(cm, 16, substream);
  }
//#line  1666
  if (err < 0) {
//#line  1667
    return (err);
  }
//#line  1668
  runtime->hw = (struct snd_pcm_hardware )snd_cmipci_playback;
//#line  1669
  if (cm->chip_version == 68) {
//#line  1670
    runtime->hw.rates |= (unsigned int )((1 << 9) | (1 << 10));
//#line  1672
    runtime->hw.rate_max = 96000U;
  } else
//#line  1673
  if (cm->chip_version == 55) {
    {
//#line  1674
    err = snd_pcm_hw_constraint_list(runtime, 0U, 11, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_rates));
    }
//#line  1676
    if (err < 0) {
//#line  1677
      return (err);
    }
//#line  1678
    runtime->hw.rates |= (unsigned int )(1 << 31);
//#line  1679
    runtime->hw.rate_max = 128000U;
  }
  {
//#line  1681
  snd_pcm_hw_constraint_minmax(runtime, 17, 0U, 65536U);
//#line  1682
  cm->dig_pcm_status = cm->dig_status;
  }
//#line  1683
  return (0);
}
}
//#line  1686 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_open(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  struct snd_pcm_runtime *runtime ;
  int err ;

  {
  {
//#line  1688
  cm = (struct cmipci *)substream->private_data;
//#line  1689
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1692
  err = open_device_check(cm, 33, substream);
  }
//#line  1692
  if (err < 0) {
//#line  1693
    return (err);
  }
//#line  1694
  runtime->hw = (struct snd_pcm_hardware )snd_cmipci_capture;
//#line  1695
  if (cm->chip_version == 68) {
//#line  1696
    runtime->hw.rate_min = 41000U;
//#line  1697
    runtime->hw.rates = (unsigned int )((1 << 6) | (1 << 7));
  } else
//#line  1698
  if (cm->chip_version == 55) {
    {
//#line  1699
    err = snd_pcm_hw_constraint_list(runtime, 0U, 11, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_rates));
    }
//#line  1701
    if (err < 0) {
//#line  1702
      return (err);
    }
//#line  1703
    runtime->hw.rates |= (unsigned int )(1 << 31);
//#line  1704
    runtime->hw.rate_max = 128000U;
  }
  {
//#line  1706
  snd_pcm_hw_constraint_minmax(runtime, 17, 0U, 65536U);
  }
//#line  1707
  return (0);
}
}
//#line  1710 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback2_open(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  struct snd_pcm_runtime *runtime ;
  int err ;

  {
  {
//#line  1712
  cm = (struct cmipci *)substream->private_data;
//#line  1713
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1716
  err = open_device_check(cm, 17, substream);
  }
//#line  1716
  if (err < 0) {
//#line  1717
    return (err);
  }
  {
//#line  1718
  runtime->hw = (struct snd_pcm_hardware )snd_cmipci_playback2;
//#line  1719
  mutex_lock(& cm->open_mutex);
  }
//#line  1720
  if (! cm->opened[0]) {
//#line  1721
    if (cm->can_multi_ch) {
//#line  1722
      runtime->hw.channels_max = (unsigned int )cm->max_channels;
//#line  1723
      if (cm->max_channels == 4) {
        {
//#line  1724
        snd_pcm_hw_constraint_list(runtime, 0U, 10, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_channels_4));
        }
      } else
//#line  1725
      if (cm->max_channels == 6) {
        {
//#line  1726
        snd_pcm_hw_constraint_list(runtime, 0U, 10, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_channels_6));
        }
      } else
//#line  1727
      if (cm->max_channels == 8) {
        {
//#line  1728
        snd_pcm_hw_constraint_list(runtime, 0U, 10, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_channels_8));
        }
      }
    }
  }
  {
//#line  1731
  mutex_unlock(& cm->open_mutex);
  }
//#line  1732
  if (cm->chip_version == 68) {
//#line  1733
    runtime->hw.rates |= (unsigned int )((1 << 9) | (1 << 10));
//#line  1735
    runtime->hw.rate_max = 96000U;
  } else
//#line  1736
  if (cm->chip_version == 55) {
    {
//#line  1737
    err = snd_pcm_hw_constraint_list(runtime, 0U, 11, (struct snd_pcm_hw_constraint_list *)(& hw_constraints_rates));
    }
//#line  1739
    if (err < 0) {
//#line  1740
      return (err);
    }
//#line  1741
    runtime->hw.rates |= (unsigned int )(1 << 31);
//#line  1742
    runtime->hw.rate_max = 128000U;
  }
  {
//#line  1744
  snd_pcm_hw_constraint_minmax(runtime, 17, 0U, 65536U);
  }
//#line  1745
  return (0);
}
}
//#line  1748 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_spdif_open(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  struct snd_pcm_runtime *runtime ;
  int err ;

  {
  {
//#line  1750
  cm = (struct cmipci *)substream->private_data;
//#line  1751
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1754
  err = open_device_check(cm, 80, substream);
  }
//#line  1754
  if (err < 0) {
//#line  1755
    return (err);
  }
//#line  1756
  if (cm->can_ac3_hw) {
//#line  1757
    runtime->hw = (struct snd_pcm_hardware )snd_cmipci_playback_spdif;
//#line  1758
    if (cm->chip_version >= 37) {
      {
//#line  1759
      runtime->hw.formats |= 1ULL << 10;
//#line  1760
      snd_pcm_hw_constraint_msbits(runtime, 0U, 32U, 24U);
      }
    }
//#line  1762
    if (cm->can_96k) {
//#line  1763
      runtime->hw.rates |= (unsigned int )((1 << 9) | (1 << 10));
//#line  1765
      runtime->hw.rate_max = 96000U;
    }
  } else {
//#line  1768
    runtime->hw = (struct snd_pcm_hardware )snd_cmipci_playback_iec958_subframe;
  }
  {
//#line  1770
  snd_pcm_hw_constraint_minmax(runtime, 17, 0U, 262144U);
//#line  1771
  cm->dig_pcm_status = cm->dig_status;
  }
//#line  1772
  return (0);
}
}
//#line  1775 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_spdif_open(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;
  struct snd_pcm_runtime *runtime ;
  int err ;

  {
  {
//#line  1777
  cm = (struct cmipci *)substream->private_data;
//#line  1778
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1781
  err = open_device_check(cm, 97, substream);
  }
//#line  1781
  if (err < 0) {
//#line  1782
    return (err);
  }
//#line  1783
  runtime->hw = (struct snd_pcm_hardware )snd_cmipci_capture_spdif;
  if (cm->can_96k) {
//#line  1784
    if (! (cm->chip_version == 68)) {
//#line  1785
      runtime->hw.rates |= (unsigned int )((1 << 9) | (1 << 10));
//#line  1787
      runtime->hw.rate_max = 96000U;
    }
  }
  {
//#line  1789
  snd_pcm_hw_constraint_minmax(runtime, 17, 0U, 262144U);
  }
//#line  1790
  return (0);
}
}
//#line  1797 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_close(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  1799
  cm = (struct cmipci *)substream->private_data;
//#line  1800
  close_device_check(cm, 16);
  }
//#line  1801
  return (0);
}
}
//#line  1804 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_close(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  1806
  cm = (struct cmipci *)substream->private_data;
//#line  1807
  close_device_check(cm, 33);
  }
//#line  1808
  return (0);
}
}
//#line  1811 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback2_close(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  1813
  cm = (struct cmipci *)substream->private_data;
//#line  1814
  close_device_check(cm, 17);
//#line  1815
  close_device_check(cm, 144);
  }
//#line  1816
  return (0);
}
}
//#line  1819 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_playback_spdif_close(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  1821
  cm = (struct cmipci *)substream->private_data;
//#line  1822
  close_device_check(cm, 80);
  }
//#line  1823
  return (0);
}
}
//#line  1826 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_capture_spdif_close(struct snd_pcm_substream *substream ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  1828
  cm = (struct cmipci *)substream->private_data;
//#line  1829
  close_device_check(cm, 97);
  }
//#line  1830
  return (0);
}
}
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback_ops  = 
//#line  1837
     {& snd_cmipci_playback_open, & snd_cmipci_playback_close, & snd_pcm_lib_ioctl,
    & snd_cmipci_hw_params, & snd_cmipci_playback_hw_free, & snd_cmipci_playback_prepare,
    & snd_cmipci_playback_trigger, & snd_cmipci_playback_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                           int channel ,
                                                                           snd_pcm_uframes_t pos ,
                                                                           void __attribute__((__noderef__,
                                                                           __address_space__(1)))  *buf ,
                                                                           snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_capture_ops  = 
//#line  1848
     {& snd_cmipci_capture_open, & snd_cmipci_capture_close, & snd_pcm_lib_ioctl, & snd_cmipci_hw_params,
    & snd_cmipci_hw_free, & snd_cmipci_capture_prepare, & snd_cmipci_capture_trigger,
    & snd_cmipci_capture_pointer, (int (*)(struct snd_pcm_substream *substream , int channel ,
                                           snd_pcm_uframes_t pos , void __attribute__((__noderef__,
                                           __address_space__(1)))  *buf , snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback2_ops  = 
//#line  1859
     {& snd_cmipci_playback2_open, & snd_cmipci_playback2_close, & snd_pcm_lib_ioctl,
    & snd_cmipci_playback2_hw_params, & snd_cmipci_playback2_hw_free, & snd_cmipci_capture_prepare,
    & snd_cmipci_capture_trigger, & snd_cmipci_capture_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                         int channel ,
                                                                         snd_pcm_uframes_t pos ,
                                                                         void __attribute__((__noderef__,
                                                                         __address_space__(1)))  *buf ,
                                                                         snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_playback_spdif_ops  = 
//#line  1870
     {& snd_cmipci_playback_spdif_open, & snd_cmipci_playback_spdif_close, & snd_pcm_lib_ioctl,
    & snd_cmipci_hw_params, & snd_cmipci_playback_hw_free, & snd_cmipci_playback_spdif_prepare,
    & snd_cmipci_playback_trigger, & snd_cmipci_playback_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                           int channel ,
                                                                           snd_pcm_uframes_t pos ,
                                                                           void __attribute__((__noderef__,
                                                                           __address_space__(1)))  *buf ,
                                                                           snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_capture_spdif_ops  = 
//#line  1881
     {& snd_cmipci_capture_spdif_open, & snd_cmipci_capture_spdif_close, & snd_pcm_lib_ioctl,
    & snd_cmipci_hw_params, & snd_cmipci_capture_spdif_hw_free, & snd_cmipci_capture_spdif_prepare,
    & snd_cmipci_capture_trigger, & snd_cmipci_capture_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                         int channel ,
                                                                         snd_pcm_uframes_t pos ,
                                                                         void __attribute__((__noderef__,
                                                                         __address_space__(1)))  *buf ,
                                                                         snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
//#line  1896
static int snd_cmipci_pcm_new(struct cmipci *cm , int device )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_pcm_new(struct cmipci *cm , int device ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
  {
//#line  1901
  err = snd_pcm_new(cm->card, (cm->card)->driver, device, 1, 1, & pcm);
  }
//#line  1902
  if (err < 0) {
//#line  1903
    return (err);
  }
  {
//#line  1905
  snd_pcm_set_ops(pcm, 0, (struct snd_pcm_ops *)(& snd_cmipci_playback_ops));
//#line  1906
  snd_pcm_set_ops(pcm, 1, (struct snd_pcm_ops *)(& snd_cmipci_capture_ops));
//#line  1908
  pcm->private_data = (void *)cm;
//#line  1909
  pcm->info_flags = 0U;
//#line  1910
  strcpy(pcm->name, str_573849695);
//#line  1911
  cm->pcm = pcm;
//#line  1913
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (cm->pci)->dev), (size_t )65536,
                                        (size_t )131072);
  }
//#line  1916
  return (0);
}
}
//#line  1919
static int snd_cmipci_pcm2_new(struct cmipci *cm , int device )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_pcm2_new(struct cmipci *cm , int device ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
  {
//#line  1924
  err = snd_pcm_new(cm->card, (cm->card)->driver, device, 1, 0, & pcm);
  }
//#line  1925
  if (err < 0) {
//#line  1926
    return (err);
  }
  {
//#line  1928
  snd_pcm_set_ops(pcm, 0, (struct snd_pcm_ops *)(& snd_cmipci_playback2_ops));
//#line  1930
  pcm->private_data = (void *)cm;
//#line  1931
  pcm->info_flags = 0U;
//#line  1932
  strcpy(pcm->name, str_916388850);
//#line  1933
  cm->pcm2 = pcm;
//#line  1935
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (cm->pci)->dev), (size_t )65536,
                                        (size_t )131072);
  }
//#line  1938
  return (0);
}
}
//#line  1941
static int snd_cmipci_pcm_spdif_new(struct cmipci *cm , int device )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_pcm_spdif_new(struct cmipci *cm , int device ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
  {
//#line  1946
  err = snd_pcm_new(cm->card, (cm->card)->driver, device, 1, 1, & pcm);
  }
//#line  1947
  if (err < 0) {
//#line  1948
    return (err);
  }
  {
//#line  1950
  snd_pcm_set_ops(pcm, 0, (struct snd_pcm_ops *)(& snd_cmipci_playback_spdif_ops));
//#line  1951
  snd_pcm_set_ops(pcm, 1, (struct snd_pcm_ops *)(& snd_cmipci_capture_spdif_ops));
//#line  1953
  pcm->private_data = (void *)cm;
//#line  1954
  pcm->info_flags = 0U;
//#line  1955
  strcpy(pcm->name, str_43107761);
//#line  1956
  cm->pcm_spdif = pcm;
//#line  1958
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (cm->pci)->dev), (size_t )65536,
                                        (size_t )131072);
  }
//#line  1961
  return (0);
}
}
//#line  1973 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void snd_cmipci_mixer_write(struct cmipci *s , unsigned char idx , unsigned char data ) 
{ 


  {
  {
//#line  1975
  outb(idx, (unsigned short )(s->iobase + 35UL));
//#line  1976
  outb(data, (unsigned short )(s->iobase + 34UL));
  }
//#line  1977
  return;
}
}
//#line  1979 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static unsigned char snd_cmipci_mixer_read(struct cmipci *s , unsigned char idx ) 
{ 
  unsigned char v ;

  {
  {
//#line  1983
  outb(idx, (unsigned short )(s->iobase + 35UL));
//#line  1984
  v = inb((unsigned short )(s->iobase + 34UL));
  }
//#line  1985
  return (v);
}
}
//#line  2014 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void cmipci_sb_reg_decode(struct cmipci_sb_reg *r , unsigned long val ) 
{ 


  {
//#line  2016
  r->left_reg = (unsigned int )(val & 255UL);
//#line  2017
  r->right_reg = (unsigned int )((val >> 8) & 255UL);
//#line  2018
  r->left_shift = (unsigned int )((val >> 16) & 7UL);
//#line  2019
  r->right_shift = (unsigned int )((val >> 19) & 7UL);
//#line  2020
  r->invert = (unsigned int )((val >> 22) & 1UL);
//#line  2021
  r->stereo = (unsigned int )((val >> 23) & 1UL);
//#line  2022
  r->mask = (unsigned int )((val >> 24) & 255UL);
//#line  2023
  return;
}
}
//#line  2025 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_info_volume(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct cmipci_sb_reg reg ;

  {
  {
//#line  2030
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
  }
  if (reg.mask == 1U) {
    uinfo->type = 1;
  } else {
//#line  2031
    uinfo->type = 2;
  }
//#line  2032
  uinfo->count = reg.stereo + 1U;
//#line  2033
  uinfo->value.integer.min = 0L;
//#line  2034
  uinfo->value.integer.max = (long )reg.mask;
//#line  2035
  return (0);
}
}
//#line  2038 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_get_volume(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  int val ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
//#line  2041
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2045
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2046
  _spin_lock_irq(& cm->reg_lock);
//#line  2047
  tmp = snd_cmipci_mixer_read(cm, (unsigned char )reg.left_reg);
  val = (int )((unsigned int )((int )tmp >> reg.left_shift) & reg.mask);
  }
//#line  2048
  if (reg.invert) {
//#line  2049
    val = (int )(reg.mask - (unsigned int )val);
  }
//#line  2050
  ucontrol->value.integer.value[0] = (long )val;
//#line  2051
  if (reg.stereo) {
    {
//#line  2052
    tmp___0 = snd_cmipci_mixer_read(cm, (unsigned char )reg.right_reg);
    val = (int )((unsigned int )((int )tmp___0 >> reg.right_shift) & reg.mask);
    }
//#line  2053
    if (reg.invert) {
//#line  2054
      val = (int )(reg.mask - (unsigned int )val);
    }
//#line  2055
    ucontrol->value.integer.value[1] = (long )val;
  }
  {
  {
  while (1) {


    {
//#line  2057
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2058
  return (0);
}
}
//#line  2061 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_put_volume(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  int change ;
  int left ;
  int right ;
  int oleft ;
  int oright ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
//#line  2064
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2069
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2070
  left = (int )(ucontrol->value.integer.value[0] & (long )reg.mask);
  }
//#line  2071
  if (reg.invert) {
//#line  2072
    left = (int )(reg.mask - (unsigned int )left);
  }
//#line  2073
  left <<= reg.left_shift;
//#line  2074
  if (reg.stereo) {
//#line  2075
    right = (int )(ucontrol->value.integer.value[1] & (long )reg.mask);
//#line  2076
    if (reg.invert) {
//#line  2077
      right = (int )(reg.mask - (unsigned int )right);
    }
//#line  2078
    right <<= reg.right_shift;
  } else {
//#line  2080
    right = 0;
  }
  {
//#line  2081
  _spin_lock_irq(& cm->reg_lock);
//#line  2082
  tmp = snd_cmipci_mixer_read(cm, (unsigned char )reg.left_reg);
  oleft = (int )tmp;
//#line  2083
  left = (int )((unsigned int )left | ((unsigned int )oleft & ~ (reg.mask << reg.left_shift)));
//#line  2084
  change = left != oleft;
  }
//#line  2085
  if (reg.stereo) {
//#line  2086
    if (reg.left_reg != reg.right_reg) {
      {
//#line  2087
      snd_cmipci_mixer_write(cm, (unsigned char )reg.left_reg, (unsigned char )left);
//#line  2088
      tmp___0 = snd_cmipci_mixer_read(cm, (unsigned char )reg.right_reg);
      oright = (int )tmp___0;
      }
    } else {
//#line  2090
      oright = left;
    }
    {
//#line  2091
    right = (int )((unsigned int )right | ((unsigned int )oright & ~ (reg.mask << reg.right_shift)));
//#line  2092
    change |= right != oright;
//#line  2093
    snd_cmipci_mixer_write(cm, (unsigned char )reg.right_reg, (unsigned char )right);
    }
  } else {
    {
//#line  2095
    snd_cmipci_mixer_write(cm, (unsigned char )reg.left_reg, (unsigned char )left);
    }
  }
  {
  {
  while (1) {


    {
//#line  2096
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2097
  return (change);
}
}
//#line  2110 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_info_input_sw(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
//#line  2113
  uinfo->type = 1;
//#line  2114
  uinfo->count = 4U;
//#line  2115
  uinfo->value.integer.min = 0L;
//#line  2116
  uinfo->value.integer.max = 1L;
//#line  2117
  return (0);
}
}
//#line  2120 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_get_input_sw(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  int val1 ;
  int val2 ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  {
//#line  2123
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2127
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2128
  _spin_lock_irq(& cm->reg_lock);
//#line  2129
  tmp = snd_cmipci_mixer_read(cm, (unsigned char )reg.left_reg);
  val1 = (int )tmp;
//#line  2130
  tmp___0 = snd_cmipci_mixer_read(cm, (unsigned char )reg.right_reg);
  val2 = (int )tmp___0;
  }
  {
  {
  while (1) {


    {
//#line  2131
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2132
  ucontrol->value.integer.value[0] = (long )((val1 >> reg.left_shift) & 1);
//#line  2133
  ucontrol->value.integer.value[1] = (long )((val2 >> reg.left_shift) & 1);
//#line  2134
  ucontrol->value.integer.value[2] = (long )((val1 >> reg.right_shift) & 1);
//#line  2135
  ucontrol->value.integer.value[3] = (long )((val2 >> reg.right_shift) & 1);
//#line  2136
  return (0);
}
}
//#line  2139 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_put_input_sw(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  int change ;
  int val1 ;
  int val2 ;
  int oval1 ;
  int oval2 ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  2142
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2147
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2148
  _spin_lock_irq(& cm->reg_lock);
//#line  2149
  tmp = snd_cmipci_mixer_read(cm, (unsigned char )reg.left_reg);
  oval1 = (int )tmp;
//#line  2150
  tmp___0 = snd_cmipci_mixer_read(cm, (unsigned char )reg.right_reg);
  oval2 = (int )tmp___0;
//#line  2151
  val1 = oval1 & ~ ((1 << reg.left_shift) | (1 << reg.right_shift));
//#line  2152
  val2 = oval2 & ~ ((1 << reg.left_shift) | (1 << reg.right_shift));
//#line  2153
  val1 = (int )((long )val1 | ((ucontrol->value.integer.value[0] & 1L) << reg.left_shift));
//#line  2154
  val2 = (int )((long )val2 | ((ucontrol->value.integer.value[1] & 1L) << reg.left_shift));
//#line  2155
  val1 = (int )((long )val1 | ((ucontrol->value.integer.value[2] & 1L) << reg.right_shift));
//#line  2156
  val2 = (int )((long )val2 | ((ucontrol->value.integer.value[3] & 1L) << reg.right_shift));
  }
  if (val1 != oval1) {
    tmp___1 = 1;
  } else
  if (val2 != oval2) {
    tmp___1 = 1;
  } else {
//#line  2157
    tmp___1 = 0;
  }
  {
  change = tmp___1;
//#line  2158
  snd_cmipci_mixer_write(cm, (unsigned char )reg.left_reg, (unsigned char )val1);
//#line  2159
  snd_cmipci_mixer_write(cm, (unsigned char )reg.right_reg, (unsigned char )val2);
  }
  {
  {
  while (1) {


    {
//#line  2160
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2161
  return (change);
}
}
//#line  2196 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_info_native_mixer(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct cmipci_sb_reg reg ;

  {
  {
//#line  2201
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
  }
  if (reg.mask == 1U) {
    uinfo->type = 1;
  } else {
//#line  2202
    uinfo->type = 2;
  }
//#line  2203
  uinfo->count = reg.stereo + 1U;
//#line  2204
  uinfo->value.integer.min = 0L;
//#line  2205
  uinfo->value.integer.max = (long )reg.mask;
//#line  2206
  return (0);
}
}
//#line  2210 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_get_native_mixer(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  unsigned char oreg ;
  unsigned char val ;

  {
  {
//#line  2213
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2217
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2218
  _spin_lock_irq(& cm->reg_lock);
//#line  2219
  oreg = inb((unsigned short )(cm->iobase + (unsigned long )reg.left_reg));
//#line  2220
  val = (unsigned char )((unsigned int )((int )oreg >> reg.left_shift) & reg.mask);
  }
//#line  2221
  if (reg.invert) {
//#line  2222
    val = (unsigned char )(reg.mask - (unsigned int )val);
  }
//#line  2223
  ucontrol->value.integer.value[0] = (long )val;
//#line  2224
  if (reg.stereo) {
//#line  2225
    val = (unsigned char )((unsigned int )((int )oreg >> reg.right_shift) & reg.mask);
//#line  2226
    if (reg.invert) {
//#line  2227
      val = (unsigned char )(reg.mask - (unsigned int )val);
    }
//#line  2228
    ucontrol->value.integer.value[1] = (long )val;
  }
  {
  {
  while (1) {


    {
//#line  2230
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2231
  return (0);
}
}
//#line  2234 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_put_native_mixer(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  struct cmipci_sb_reg reg ;
  unsigned char oreg ;
  unsigned char nreg ;
  unsigned char val ;

  {
  {
//#line  2237
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2241
  cmipci_sb_reg_decode(& reg, kcontrol->private_value);
//#line  2242
  _spin_lock_irq(& cm->reg_lock);
//#line  2243
  oreg = inb((unsigned short )(cm->iobase + (unsigned long )reg.left_reg));
//#line  2244
  val = (unsigned char )(ucontrol->value.integer.value[0] & (long )reg.mask);
  }
//#line  2245
  if (reg.invert) {
//#line  2246
    val = (unsigned char )(reg.mask - (unsigned int )val);
  }
//#line  2247
  nreg = (unsigned char )((unsigned int )oreg & ~ (reg.mask << reg.left_shift));
//#line  2248
  nreg = (unsigned char )((int )nreg | ((int )val << reg.left_shift));
//#line  2249
  if (reg.stereo) {
//#line  2250
    val = (unsigned char )(ucontrol->value.integer.value[1] & (long )reg.mask);
//#line  2251
    if (reg.invert) {
//#line  2252
      val = (unsigned char )(reg.mask - (unsigned int )val);
    }
//#line  2253
    nreg = (unsigned char )((unsigned int )nreg & ~ (reg.mask << reg.right_shift));
//#line  2254
    nreg = (unsigned char )((int )nreg | ((int )val << reg.right_shift));
  }
  {
//#line  2256
  outb(nreg, (unsigned short )(cm->iobase + (unsigned long )reg.left_reg));
  }
  {
  {
  while (1) {


    {
//#line  2257
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2258
  return ((int )nreg != (int )oreg);
}
}
//#line  2264 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_get_native_mixer_sensitive(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  int tmp ;

  {
  {
//#line  2268
  tmp = snd_cmipci_get_native_mixer(kcontrol, ucontrol);
  }
  return (tmp);
}
}
//#line  2271 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_put_native_mixer_sensitive(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
//#line  2274
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2275
  if (cm->mixer_insensitive) {
//#line  2277
    return (0);
  }
  {
//#line  2279
  tmp = snd_cmipci_put_native_mixer(kcontrol, ucontrol);
  }
  return (tmp);
}
}
static struct snd_kcontrol_new snd_cmipci_mixers[27]  __attribute__((__section__(".devinit.data")))  = 
//#line  2283
  {      {2, 0U, 0U, (unsigned char *)str_625602805, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((48 | (49 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_338056805, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((36 | (36 << 8)) | (1 << 16)) | (1 << 19)) | (1 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_88429757, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((50 | (51 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_82022903, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer_sensitive, & snd_cmipci_put_native_mixer_sensitive,
      {(snd_kcontrol_tlv_rw_t *)0}, (unsigned long )(((((36 | (36 << 8)) | (6 << 16)) | (6 << 19)) | (1 << 24)) | (1 << 22))}, 
        {2,
      0U, 0U, (unsigned char *)str_171248176, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((36 | (36 << 8)) | (3 << 16)) | (2 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_449269183, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((52 | (53 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_442862329, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((36 | (36 << 8)) | (7 << 16)) | (7 << 19)) | (1 << 24)) | (1 << 22))}, 
        {2,
      0U, 0U, (unsigned char *)str_453010511, 0U, 0U, 0U, & snd_cmipci_info_input_sw,
      & snd_cmipci_get_input_sw, & snd_cmipci_put_input_sw, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((61 | (62 << 8)) | (6 << 16)) | (5 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_488424356, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((54 | (55 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_482017502, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((60 | (60 << 8)) | (2 << 16)) | (1 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_450144620, 0U, 0U, 0U, & snd_cmipci_info_input_sw,
      & snd_cmipci_get_input_sw, & snd_cmipci_put_input_sw, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((61 | (62 << 8)) | (2 << 16)) | (1 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_701583115, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((56 | (57 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_695176261, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((60 | (60 << 8)) | (4 << 16)) | (3 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_147350971, 0U, 0U, 0U, & snd_cmipci_info_input_sw,
      & snd_cmipci_get_input_sw, & snd_cmipci_put_input_sw, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((61 | (62 << 8)) | (4 << 16)) | (3 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_129101994, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((58 | (58 << 8)) | (3 << 16)) | (3 << 19)) | (31 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_122695140, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((60 | (60 << 8)) | (1 << 24))}, 
        {2, 0U, 0U, (unsigned char *)str_851541551, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((61 | (62 << 8)) | (1 << 24))}, 
        {2, 0U, 0U, (unsigned char *)str_465611289, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((59 | (59 << 8)) | (6 << 16)) | (6 << 19)) | (3 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_751998455, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((38 | (38 << 8)) | (4 << 16)) | (15 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_745591601, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((37 | (37 << 8)) | (4 << 16)) | (5 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_1053863758, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((((37 | (37 << 8)) | (6 << 16)) | (7 << 19)) | (1 << 24)) | (1 << 23))}, 
        {2,
      0U, 0U, (unsigned char *)str_682558423, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(((37 | (37 << 8)) | (1 << 24)) | (1 << 22))}, 
        {2, 0U, 0U, (unsigned char *)str_857948405, 0U, 0U, 0U, & snd_cmipci_info_native_mixer,
      & snd_cmipci_get_native_mixer, & snd_cmipci_put_native_mixer, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((37 | (37 << 8)) | (1 << 16)) | (1 << 19)) | (7 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_689470853, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((240 | (240 << 8)) | (5 << 16)) | (5 << 19)) | (7 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_683063999, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((240 | (240 << 8)) | (4 << 16)) | (4 << 19)) | (1 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_459204435, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((((240 | (240 << 8)) | (3 << 16)) | (3 << 19)) | (1 << 24))}, 
        {2,
      0U, 0U, (unsigned char *)str_824495312, 0U, 0U, 0U, & snd_cmipci_info_volume,
      & snd_cmipci_get_volume, & snd_cmipci_put_volume, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )((240 | (240 << 8)) | (1 << 24))}};
//#line  2337 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int _snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ,
                                   struct cmipci_switch_args *args ) 
{ 
  unsigned int val ;
  struct cmipci *cm ;
  unsigned char tmp ;

  {
  {
//#line  2342
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2344
  _spin_lock_irq(& cm->reg_lock);
  }
  if (args->ac3_sensitive) {
//#line  2345
    if (cm->mixer_insensitive) {
//#line  2346
      ucontrol->value.integer.value[0] = 0L;
      {
      {
      while (1) {


        {
//#line  2347
        __raw_spin_unlock(& cm->reg_lock.raw_lock);
        }
        {
        {
        while (1) {


          {
          {
          while (1) {


            goto while_break___1;
          }

          }
          while_break___1: /* CIL Label */ ;
          }
          {
          raw_local_irq_enable();
          }
          goto while_break___0;
        }

        }
        while_break___0: /* CIL Label */ ;
        }
        goto while_break;
      }

      }
      while_break: /* CIL Label */ ;
      }
//#line  2348
      return (0);
    }
  }
//#line  2350
  if (args->is_byte) {
    {
//#line  2351
    tmp = inb((unsigned short )(cm->iobase + (unsigned long )args->reg));
    val = (unsigned int )tmp;
    }
  } else {
    {
//#line  2353
    val = snd_cmipci_read(cm, (unsigned int )args->reg);
    }
  }
  if ((val & args->mask) == args->mask_on) {
    ucontrol->value.integer.value[0] = 1L;
  } else {
//#line  2354
    ucontrol->value.integer.value[0] = 0L;
  }
  {
  {
  while (1) {


    {
//#line  2355
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___4;
      }

      }
      while_break___4: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___3;
    }

    }
    while_break___3: /* CIL Label */ ;
    }
    goto while_break___2;
  }

  }
  while_break___2: /* CIL Label */ ;
  }
//#line  2356
  return (0);
}
}
//#line  2359 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_uswitch_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci_switch_args *args ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  2363
  args = (struct cmipci_switch_args *)kcontrol->private_value;
//#line  2364
  tmp = __snd_bug_on(0);
  }
//#line  2364
  if (tmp) {
//#line  2365
    return (-22);
  }
  {
//#line  2366
  tmp___0 = _snd_cmipci_uswitch_get(kcontrol, ucontrol, args);
  }
  return (tmp___0);
}
}
//#line  2369 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int _snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ,
                                   struct cmipci_switch_args *args ) 
{ 
  unsigned int val ;
  int change ;
  struct cmipci *cm ;
  unsigned char tmp ;
  unsigned int tmp___0 ;

  {
  {
//#line  2375
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2377
  _spin_lock_irq(& cm->reg_lock);
  }
  if (args->ac3_sensitive) {
//#line  2378
    if (cm->mixer_insensitive) {
      {
      {
      while (1) {


        {
//#line  2380
        __raw_spin_unlock(& cm->reg_lock.raw_lock);
        }
        {
        {
        while (1) {


          {
          {
          while (1) {


            goto while_break___1;
          }

          }
          while_break___1: /* CIL Label */ ;
          }
          {
          raw_local_irq_enable();
          }
          goto while_break___0;
        }

        }
        while_break___0: /* CIL Label */ ;
        }
        goto while_break;
      }

      }
      while_break: /* CIL Label */ ;
      }
//#line  2381
      return (0);
    }
  }
//#line  2383
  if (args->is_byte) {
    {
//#line  2384
    tmp = inb((unsigned short )(cm->iobase + (unsigned long )args->reg));
    val = (unsigned int )tmp;
    }
  } else {
    {
//#line  2386
    val = snd_cmipci_read(cm, (unsigned int )args->reg);
    }
  }
  if (ucontrol->value.integer.value[0]) {
    tmp___0 = args->mask_on;
  } else {
//#line  2387
    tmp___0 = args->mask & ~ args->mask_on;
  }
  change = (val & args->mask) != tmp___0;
//#line  2389
  if (change) {
//#line  2390
    val &= ~ args->mask;
//#line  2391
    if (ucontrol->value.integer.value[0]) {
//#line  2392
      val |= args->mask_on;
    } else {
//#line  2394
      val |= args->mask & ~ args->mask_on;
    }
//#line  2395
    if (args->is_byte) {
      {
//#line  2396
      outb((unsigned char )val, (unsigned short )(cm->iobase + (unsigned long )args->reg));
      }
    } else {
      {
//#line  2398
      snd_cmipci_write(cm, (unsigned int )args->reg, val);
      }
    }
  }
  {
  {
  while (1) {


    {
//#line  2400
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___4;
      }

      }
      while_break___4: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___3;
    }

    }
    while_break___3: /* CIL Label */ ;
    }
    goto while_break___2;
  }

  }
  while_break___2: /* CIL Label */ ;
  }
//#line  2401
  return (change);
}
}
//#line  2404 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_uswitch_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci_switch_args *args ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  2408
  args = (struct cmipci_switch_args *)kcontrol->private_value;
//#line  2409
  tmp = __snd_bug_on(0);
  }
//#line  2409
  if (tmp) {
//#line  2410
    return (-22);
  }
  {
//#line  2411
  tmp___0 = _snd_cmipci_uswitch_put(kcontrol, ucontrol, args);
  }
  return (tmp___0);
}
}
//#line  2430 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_in_sel1  =    {8,
    524288U, 524288U, 0U, 0U};
//#line  2431 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_in_sel2  =    {24,
    256U, 256U, 0U, 0U};
//#line  2432 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_enable  =    {20,
    8388608U, 8388608U, 0U, 0U};
//#line  2433 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdo2dac  =    {4,
    64U, 64U, 0U, 1U};
//#line  2434 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdi_valid  =    {39,
    2U, 2U, 1U, 0U};
//#line  2435 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_copyright  =    {20,
    4194304U, 4194304U, 0U, 0U};
//#line  2436 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_dac_out  =    {20,
    2097152U, 2097152U, 0U, 1U};
//#line  2437 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdo_5v  =    {24,
    33554432U, 0U, 0U, 0U};
//#line  2439 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdif_loop  =    {4,
    128U, 128U, 0U, 1U};
//#line  2440 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdi_monitor  =    {36,
    1U, 1U, 1U, 0U};
//#line  2442 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdi_phase  =    {39,
    4U, 4U, 1U, 0U};
//#line  2443 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_spdi_phase2  =    {8,
    128U, 128U, 0U, 0U};
//#line  2447 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_exchange_dac  =    {24,
    4194304U, 4194304U, 0U, 0U};
//#line  2449 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_fourch  =    {24,
    67108864U, 67108864U, 0U, 0U};
//#line  2453 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct cmipci_switch_args  __attribute__((__noderef__, __address_space__(2))) cmipci_switch_arg_modem  =    {24,
    96U, 64U, 0U, 0U};
//#line  2472 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdout_enable_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  int changed ;
  int tmp ;

  {
  {
//#line  2476
  changed = _snd_cmipci_uswitch_get(kcontrol, ucontrol, (struct cmipci_switch_args *)(& cmipci_switch_arg_spdif_enable));
//#line  2477
  tmp = _snd_cmipci_uswitch_get(kcontrol, ucontrol, (struct cmipci_switch_args *)(& cmipci_switch_arg_spdo2dac));
  changed |= tmp;
  }
//#line  2478
  return (changed);
}
}
//#line  2481 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_spdout_enable_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *chip ;
  int changed ;
  int tmp ;

  {
  {
//#line  2484
  chip = (struct cmipci *)kcontrol->private_data;
//#line  2486
  changed = _snd_cmipci_uswitch_put(kcontrol, ucontrol, (struct cmipci_switch_args *)(& cmipci_switch_arg_spdif_enable));
//#line  2487
  tmp = _snd_cmipci_uswitch_put(kcontrol, ucontrol, (struct cmipci_switch_args *)(& cmipci_switch_arg_spdo2dac));
  changed |= tmp;
  }
//#line  2488
  if (changed) {
//#line  2489
    if (ucontrol->value.integer.value[0]) {
//#line  2490
      if (chip->spdif_playback_avail) {
        {
//#line  2491
        snd_cmipci_set_bit(chip, 4U, 256U);
        }
      }
    } else
//#line  2493
    if (chip->spdif_playback_avail) {
      {
//#line  2494
      snd_cmipci_clear_bit(chip, 4U, 256U);
      }
    }
  }
//#line  2497
  chip->spdif_playback_enabled = (unsigned int )ucontrol->value.integer.value[0];
//#line  2498
  return (changed);
}
}
//#line  2506
static int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
static char *texts[3]  = {      (char *)str_629297690,      (char *)str_1033184297,      (char *)str_420826266};
//#line  2502 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_line_in_mode_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  struct cmipci *cm ;

  {
//#line  2505
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2507
  uinfo->type = 3;
//#line  2508
  uinfo->count = 1U;
  if (cm->chip_version >= 39) {
    uinfo->value.enumerated.items = 3U;
  } else {
//#line  2509
    uinfo->value.enumerated.items = 2U;
  }
//#line  2510
  if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) {
//#line  2511
    uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1U;
  }
  {
//#line  2512
  strcpy(uinfo->value.enumerated.name, (char const   *)texts[uinfo->value.enumerated.item]);
  }
//#line  2513
  return (0);
}
}
//#line  2516 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
__inline static unsigned int ( __attribute__((__always_inline__)) get_line_in_mode)(struct cmipci *cm ) 
{ 
  unsigned int val ;
  unsigned char tmp ;

  {
//#line  2519
  if (cm->chip_version >= 39) {
    {
//#line  2520
    val = snd_cmipci_read(cm, 20U);
    }
//#line  2521
    if (val & 24576U) {
//#line  2522
      return (2U);
    }
  }
  {
//#line  2524
  tmp = snd_cmipci_read_b(cm, 36U);
  val = (unsigned int )tmp;
  }
//#line  2525
  if (val & 32U) {
//#line  2526
    return (1U);
  }
//#line  2527
  return (0U);
}
}
//#line  2530 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_line_in_mode_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;

  {
  {
//#line  2533
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2535
  _spin_lock_irq(& cm->reg_lock);
//#line  2536
  ucontrol->value.enumerated.item[0] = get_line_in_mode(cm);
  }
  {
  {
  while (1) {


    {
//#line  2537
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2538
  return (0);
}
}
//#line  2541 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_line_in_mode_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  int change ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  2544
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2547
  _spin_lock_irq(& cm->reg_lock);
  }
//#line  2548
  if (ucontrol->value.enumerated.item[0] == 2U) {
    {
//#line  2549
    change = snd_cmipci_set_bit(cm, 20U, 24576U);
    }
  } else {
    {
//#line  2551
    change = snd_cmipci_clear_bit(cm, 20U, 24576U);
    }
  }
//#line  2552
  if (ucontrol->value.enumerated.item[0] == 1U) {
    {
//#line  2553
    tmp = snd_cmipci_set_bit_b(cm, 36U, (unsigned char)32);
    change |= tmp;
    }
  } else {
    {
//#line  2555
    tmp___0 = snd_cmipci_clear_bit_b(cm, 36U, (unsigned char)32);
    change |= tmp___0;
    }
  }
  {
  {
  while (1) {


    {
//#line  2556
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2557
  return (change);
}
}
//#line  2563
static int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
static char *texts___0[2]  = {      (char *)str_205040111,      (char *)str_487403672};
//#line  2560 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_mic_in_mode_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
//#line  2564
  uinfo->type = 3;
//#line  2565
  uinfo->count = 1U;
//#line  2566
  uinfo->value.enumerated.items = 2U;
//#line  2567
  if (uinfo->value.enumerated.item >= uinfo->value.enumerated.items) {
//#line  2568
    uinfo->value.enumerated.item = uinfo->value.enumerated.items - 1U;
  }
  {
//#line  2569
  strcpy(uinfo->value.enumerated.name, (char const   *)texts___0[uinfo->value.enumerated.item]);
  }
//#line  2570
  return (0);
}
}
//#line  2573 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_mic_in_mode_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  unsigned char tmp___0 ;

  {
  {
//#line  2576
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2578
  _spin_lock_irq(& cm->reg_lock);
//#line  2579
  tmp___0 = snd_cmipci_read_b(cm, 39U);
  }
  if ((int )tmp___0 & 4) {
    ucontrol->value.enumerated.item[0] = 1U;
  } else {
    ucontrol->value.enumerated.item[0] = 0U;
  }
  {
  {
  while (1) {


    {
//#line  2581
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2582
  return (0);
}
}
//#line  2585 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_mic_in_mode_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct cmipci *cm ;
  int change ;

  {
  {
//#line  2588
  cm = (struct cmipci *)kcontrol->private_data;
//#line  2591
  _spin_lock_irq(& cm->reg_lock);
  }
//#line  2592
  if (ucontrol->value.enumerated.item[0]) {
    {
//#line  2593
    change = snd_cmipci_set_bit_b(cm, 39U, (unsigned char)4);
    }
  } else {
    {
//#line  2595
    change = snd_cmipci_clear_bit_b(cm, 39U, (unsigned char)4);
    }
  }
  {
  {
  while (1) {


    {
//#line  2596
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2597
  return (change);
}
}
//#line  2601 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_cmipci_mixer_switches)[2]  __attribute__((__section__(".devinit.data")))  = {      {2,
      0U, 0U, (unsigned char *)str_163141482, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_fourch)}, 
        {2, 0U, 0U, (unsigned char *)str_1061823061, 0U, 0U, 0U, & snd_cmipci_line_in_mode_info,
      & snd_cmipci_line_in_mode_get, & snd_cmipci_line_in_mode_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}};
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_nomulti_switch  __attribute__((__section__(".devinit.data")))  = 
//#line  2613
     {2, 0U, 0U, (unsigned char *)str_541433933, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
    (unsigned long )(& cmipci_switch_arg_exchange_dac)};
//#line  2617 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_cmipci_8738_mixer_switches)[6]  __attribute__((__section__(".devinit.data")))  = {      {2,
      0U, 0U, (unsigned char *)str_436717668, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_spdout_enable_get, & snd_cmipci_spdout_enable_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {2, 0U, 0U, (unsigned char *)str_851283624, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdi_valid)}, 
        {2, 0U, 0U, (unsigned char *)str_623789268, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdif_copyright)}, 
        {2, 0U, 0U, (unsigned char *)str_181451256, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdo_5v)}, 
        {2, 0U, 0U, (unsigned char *)str_5821155, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdif_loop)}, 
        {2, 0U, 0U, (unsigned char *)str_908489522, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdi_monitor)}};
//#line  2639 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_cmipci_old_mixer_switches)[3]  __attribute__((__section__(".devinit.data")))  = {      {2,
      0U, 0U, (unsigned char *)str_49675815, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdif_dac_out)}, 
        {2, 0U, 0U, (unsigned char *)str_532174899, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdi_phase)}, 
        {2, 0U, 0U, (unsigned char *)str_61353136, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdif_in_sel1)}};
//#line  2646 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct snd_kcontrol_new ( __attribute__((__noderef__, __address_space__(2))) snd_cmipci_extra_mixer_switches)[3]  __attribute__((__section__(".devinit.data")))  = {      {2,
      0U, 0U, (unsigned char *)str_61353136, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdif_in_sel2)}, 
        {2, 0U, 0U, (unsigned char *)str_532174899, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
      (unsigned long )(& cmipci_switch_arg_spdi_phase2)}, 
        {2, 0U, 0U, (unsigned char *)str_124421908, 0U, 0U, 0U, & snd_cmipci_mic_in_mode_info,
      & snd_cmipci_mic_in_mode_get, & snd_cmipci_mic_in_mode_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}};
static struct snd_kcontrol_new  __attribute__((__noderef__, __address_space__(2))) snd_cmipci_modem_switch  __attribute__((__section__(".devinit.data")))  = 
//#line  2659
     {0, 0U, 0U, (unsigned char *)str_10834194, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_cmipci_uswitch_get, & snd_cmipci_uswitch_put, {(snd_kcontrol_tlv_rw_t *)0},
    (unsigned long )(& cmipci_switch_arg_modem)};
//#line  2663
static int snd_cmipci_mixer_new(struct cmipci *cm , int pcm_spdif_device )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_mixer_new(struct cmipci *cm , int pcm_spdif_device ) 
{ 
  struct snd_card *card ;
  struct snd_kcontrol_new *sw ;
  struct snd_kcontrol *kctl ;
  unsigned int idx ;
  int err ;
  int tmp ;
  int tmp___0 ;
  struct snd_kcontrol *tmp___1 ;
  struct snd_kcontrol *tmp___2 ;
  struct snd_kcontrol *tmp___3 ;
  struct snd_kcontrol *tmp___4 ;
  struct snd_kcontrol *tmp___5 ;
  struct snd_kcontrol *tmp___6 ;
  struct snd_kcontrol *tmp___7 ;
  struct snd_ctl_elem_id elem_id ;
  struct snd_kcontrol *ctl ;

  {
  {
//#line  2671
  tmp = __snd_bug_on(0);
  }
//#line  2671
  if (tmp) {
//#line  2672
    return (-22);
  }
  {
//#line  2674
  card = cm->card;
//#line  2676
  strcpy(card->mixername, str_970171951);
//#line  2678
  _spin_lock_irq(& cm->reg_lock);
//#line  2679
  snd_cmipci_mixer_write(cm, (unsigned char)0, (unsigned char)0);
  }
  {
  {
  while (1) {


    {
//#line  2680
    __raw_spin_unlock(& cm->reg_lock.raw_lock);
    }
    {
    {
    while (1) {


      {
      {
      while (1) {


        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
      raw_local_irq_enable();
      }
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2682
  idx = 0U;
  {
  {
  while (1) {


    if (! ((unsigned long )idx < sizeof(snd_cmipci_mixers) / sizeof(snd_cmipci_mixers[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break___2;
    }
//#line  2683
    if (cm->chip_version == 68) {
      {
//#line  2684
      tmp___0 = strcmp((char const   *)snd_cmipci_mixers[idx].name, str_88429757);
      }
//#line  2684
      if (! tmp___0) {
//#line  2686
        goto __Cont;
      }
    }
    {
//#line  2688
    tmp___1 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_mixers[idx]),
                           (void *)cm);
    err = snd_ctl_add(card, tmp___1);
    }
//#line  2688
    if (err < 0) {
//#line  2689
      return (err);
    }
    __Cont: /* CIL Label */ 
//#line  2682
    idx ++;
  }

  }
  while_break___2: /* CIL Label */ ;
  }
//#line  2693
  sw = (struct snd_kcontrol_new *)(snd_cmipci_mixer_switches);
//#line  2694
  idx = 0U;
  {
  {
  while (1) {


    if (! ((unsigned long )idx < sizeof(snd_cmipci_mixer_switches) / sizeof(snd_cmipci_mixer_switches[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break___3;
    }
    {
//#line  2695
    tmp___2 = snd_ctl_new1((struct snd_kcontrol_new  const  *)sw, (void *)cm);
    err = snd_ctl_add(cm->card, tmp___2);
    }
//#line  2696
    if (err < 0) {
//#line  2697
      return (err);
    }
//#line  2694
    idx ++;
    sw ++;
  }

  }
  while_break___3: /* CIL Label */ ;
  }
//#line  2699
  if (! cm->can_multi_ch) {
    {
//#line  2700
    tmp___3 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_nomulti_switch),
                           (void *)cm);
    err = snd_ctl_add(cm->card, tmp___3);
    }
//#line  2701
    if (err < 0) {
//#line  2702
      return (err);
    }
  }
  if (cm->device == 273U) {
    goto _L;
  } else
//#line  2704
  if (cm->device == 274U) {
    _L: /* CIL Label */ 
//#line  2706
    sw = (struct snd_kcontrol_new *)(snd_cmipci_8738_mixer_switches);
//#line  2707
    idx = 0U;
    {
    {
    while (1) {


      if (! ((unsigned long )idx < sizeof(snd_cmipci_8738_mixer_switches) / sizeof(snd_cmipci_8738_mixer_switches[0]) + (sizeof(char [1]) - 1UL))) {
        goto while_break___4;
      }
      {
//#line  2708
      tmp___4 = snd_ctl_new1((struct snd_kcontrol_new  const  *)sw, (void *)cm);
      err = snd_ctl_add(cm->card, tmp___4);
      }
//#line  2709
      if (err < 0) {
//#line  2710
        return (err);
      }
//#line  2707
      idx ++;
      sw ++;
    }

    }
    while_break___4: /* CIL Label */ ;
    }
//#line  2712
    if (cm->can_ac3_hw) {
      {
//#line  2713
      kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_spdif_default),
                          (void *)cm);
      err = snd_ctl_add(card, kctl);
      }
//#line  2713
      if (err < 0) {
//#line  2714
        return (err);
      }
      {
//#line  2715
      kctl->id.device = (unsigned int )pcm_spdif_device;
//#line  2716
      kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_spdif_mask),
                          (void *)cm);
      err = snd_ctl_add(card, kctl);
      }
//#line  2716
      if (err < 0) {
//#line  2717
        return (err);
      }
      {
//#line  2718
      kctl->id.device = (unsigned int )pcm_spdif_device;
//#line  2719
      kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_spdif_stream),
                          (void *)cm);
      err = snd_ctl_add(card, kctl);
      }
//#line  2719
      if (err < 0) {
//#line  2720
        return (err);
      }
//#line  2721
      kctl->id.device = (unsigned int )pcm_spdif_device;
    }
//#line  2723
    if (cm->chip_version <= 37) {
//#line  2724
      sw = (struct snd_kcontrol_new *)(snd_cmipci_old_mixer_switches);
//#line  2725
      idx = 0U;
      {
      {
      while (1) {


        if (! ((unsigned long )idx < sizeof(snd_cmipci_old_mixer_switches) / sizeof(snd_cmipci_old_mixer_switches[0]) + (sizeof(char [1]) - 1UL))) {
          goto while_break___5;
        }
        {
//#line  2726
        tmp___5 = snd_ctl_new1((struct snd_kcontrol_new  const  *)sw, (void *)cm);
        err = snd_ctl_add(cm->card, tmp___5);
        }
//#line  2727
        if (err < 0) {
//#line  2728
          return (err);
        }
//#line  2725
        idx ++;
        sw ++;
      }

      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
//#line  2732
  if (cm->chip_version >= 39) {
//#line  2733
    sw = (struct snd_kcontrol_new *)(snd_cmipci_extra_mixer_switches);
//#line  2734
    idx = 0U;
    {
    {
    while (1) {


      if (! ((unsigned long )idx < sizeof(snd_cmipci_extra_mixer_switches) / sizeof(snd_cmipci_extra_mixer_switches[0]) + (sizeof(char [1]) - 1UL))) {
        goto while_break___6;
      }
      {
//#line  2735
      tmp___6 = snd_ctl_new1((struct snd_kcontrol_new  const  *)sw, (void *)cm);
      err = snd_ctl_add(cm->card, tmp___6);
      }
//#line  2736
      if (err < 0) {
//#line  2737
        return (err);
      }
//#line  2734
      idx ++;
      sw ++;
    }

    }
    while_break___6: /* CIL Label */ ;
    }
  }
//#line  2746
  if (cm->chip_version < 39) {
    {
//#line  2747
    tmp___7 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_cmipci_modem_switch),
                           (void *)cm);
    err = snd_ctl_add(cm->card, tmp___7);
    }
//#line  2749
    if (err < 0) {
//#line  2750
      return (err);
    }
  }
//#line  2753
  idx = 0U;
  {
  {
  while (1) {


    if (! ((unsigned long )idx < sizeof(cm_saved_mixer) / sizeof(cm_saved_mixer[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break___7;
    }
    {
//#line  2756
    memset((void *)(& elem_id), 0, sizeof(elem_id));
//#line  2757
    elem_id.iface = 2;
//#line  2758
    strcpy((char *)(elem_id.name), (char const   *)cm_saved_mixer[idx].name);
//#line  2759
    ctl = snd_ctl_find_id(cm->card, & elem_id);
    }
//#line  2760
    if (ctl) {
//#line  2761
      cm->mixer_res_ctl[idx] = ctl;
    }
//#line  2753
    idx ++;
  }

  }
  while_break___7: /* CIL Label */ ;
  }
//#line  2764
  return (0);
}
}
//#line  2773 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void snd_cmipci_proc_read(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) 
{ 
  struct cmipci *cm ;
  int i ;
  int v ;
  unsigned char tmp ;

  {
  {
//#line  2776
  cm = (struct cmipci *)entry->private_data;
//#line  2779
  snd_iprintf(buffer, (char *)str_15552, (cm->card)->longname);
//#line  2780
  i = 0;
  }
  {
  {
  while (1) {


    if (! (i < 148)) {
      goto while_break;
    }
//#line  2781
    if (i == 40) {
//#line  2782
      i = 144;
    }
    {
//#line  2783
    tmp = inb((unsigned short )(cm->iobase + (unsigned long )i));
    v = (int )tmp;
    }
//#line  2784
    if (i % 4 == 0) {
      {
//#line  2785
      snd_iprintf(buffer, (char *)str_29932487, i);
      }
    }
    {
//#line  2786
    snd_iprintf(buffer, (char *)str_4442453, v);
//#line  2780
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  2788
  snd_iprintf(buffer, (char *)str_10);
  }
//#line  2789
  return;
}
}
//#line  2791
static void snd_cmipci_proc_init(struct cmipci *cm )  __attribute__((__section__(".devinit.text"))) ;
static void snd_cmipci_proc_init(struct cmipci *cm ) 
{ 
  struct snd_info_entry *entry ;
  int tmp ;

  {
  {
//#line  2795
  tmp = snd_card_proc_new(cm->card, str_260101403, & entry);
  }
//#line  2795
  if (! tmp) {
    {
//#line  2796
    snd_info_set_text_ops(entry, (void *)cm, & snd_cmipci_proc_read);
    }
  }
//#line  2797
  return;
}
}
//#line  2803 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct pci_device_id ( __attribute__((__noderef__, __address_space__(2))) snd_cmipci_ids)[6]  = {      {(__u32 )5110,
      (__u32 )256, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )5110,
      (__u32 )257, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )5110,
      (__u32 )273, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )5110,
      (__u32 )274, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )4281,
      (__u32 )273, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0, (kernel_ulong_t )0}, 
        {(__u32 )0,
      0U, 0U, 0U, 0U, 0U, 0UL}};
//#line  2817
static void query_chip(struct cmipci *cm )  __attribute__((__section__(".devinit.text"))) ;
static void query_chip(struct cmipci *cm ) 
{ 
  unsigned int detect ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
//#line  2822
  tmp = snd_cmipci_read(cm, 12U);
  detect = tmp & 4278190080U;
  }
//#line  2823
  if (! detect) {
    {
//#line  2825
    tmp___0 = snd_cmipci_read(cm, 8U);
    detect = tmp___0 & 520093696U;
    }
    {
    if ((int )detect == 0) {
//#line  2827
      goto case_0;
    }
    if ((int )detect == 16777216) {
//#line  2834
      goto case_16777216;
    }
//#line  2838
    goto switch_default;
    case_0: /* CIL Label */ 
//#line  2828
    cm->chip_version = 33;
//#line  2829
    if (cm->do_soft_ac3) {
//#line  2830
      cm->can_ac3_sw = 1U;
    } else {
//#line  2832
      cm->can_ac3_hw = 1U;
    }
//#line  2833
    goto switch_break;
    case_16777216: /* CIL Label */ 
//#line  2835
    cm->chip_version = 37;
//#line  2836
    cm->can_ac3_hw = 1U;
//#line  2837
    goto switch_break;
    switch_default: /* CIL Label */ 
//#line  2839
    cm->chip_version = 39;
//#line  2840
    cm->can_ac3_hw = 1U;
//#line  2841
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
//#line  2843
    cm->max_channels = 2;
  } else {
//#line  2845
    if (detect & 67108864U) {
//#line  2846
      cm->chip_version = 39;
//#line  2847
      if (detect & 16777216U) {
//#line  2848
        cm->max_channels = 6;
      } else {
//#line  2850
        cm->max_channels = 4;
      }
    } else
//#line  2851
    if (detect & 536870912U) {
//#line  2852
      cm->chip_version = 68;
//#line  2853
      cm->max_channels = 8;
//#line  2854
      cm->can_96k = 1U;
    } else {
//#line  2856
      cm->chip_version = 55;
//#line  2857
      cm->max_channels = 6;
//#line  2858
      cm->can_96k = 1U;
    }
//#line  2860
    cm->can_ac3_hw = 1U;
//#line  2861
    cm->can_multi_ch = 1U;
  }
//#line  2863
  return;
}
}
//#line  2868
static int snd_cmipci_create_gameport(struct cmipci *cm , int dev )  __attribute__((__section__(".devinit.text"))) ;
static int ports[3]  = {      513,      512,      0};
//#line  2866
static int snd_cmipci_create_gameport(struct cmipci *cm , int dev )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_create_gameport(struct cmipci *cm , int dev ) 
{ 
  struct gameport *gp ;
  struct resource *r ;
  int i ;
  int io_port ;
  char const   *tmp ;

  {
//#line  2870
  r = (struct resource *)((void *)0);
//#line  2871
  io_port = 0;
//#line  2873
  if (joystick_port[dev] == 0) {
//#line  2874
    return (-19);
  }
//#line  2876
  if (joystick_port[dev] == 1) {
//#line  2877
    i = 0;
    {
    {
    while (1) {


      if (! ports[i]) {
        goto while_break;
      }
      {
//#line  2878
      io_port = ports[i];
//#line  2879
      r = __request_region(& ioport_resource, (resource_size_t )io_port, (resource_size_t )1,
                           str_645250580, 0);
      }
//#line  2880
      if (r) {
//#line  2881
        goto while_break;
      }
//#line  2877
      i ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
//#line  2884
    io_port = joystick_port[dev];
//#line  2885
    r = __request_region(& ioport_resource, (resource_size_t )io_port, (resource_size_t )1,
                         str_645250580, 0);
    }
  }
//#line  2888
  if (! r) {
    {
//#line  2889
    printk(str_385748318);
    }
//#line  2890
    return (-16);
  }
  {
//#line  2893
  gp = gameport_allocate_port();
  cm->gameport = gp;
  }
//#line  2894
  if (! gp) {
    {
//#line  2895
    printk(str_425593287);
//#line  2896
    release_and_free_resource(r);
    }
//#line  2897
    return (-12);
  }
  {
//#line  2899
  gameport_set_name(gp, str_582694837);
//#line  2900
  tmp = pci_name(cm->pci);
  gameport_set_phys(gp, str_367676234, tmp);
//#line  2901
  gp->dev.parent = (struct device *)(& (cm->pci)->dev);
//#line  2902
  gp->io = io_port;
//#line  2903
  gp->port_data = (void *)r;
//#line  2905
  snd_cmipci_set_bit(cm, 4U, 2U);
//#line  2907
  gameport_register_port(cm->gameport);
  }
//#line  2909
  return (0);
}
}
//#line  2912 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static void snd_cmipci_free_gameport(struct cmipci *cm ) 
{ 
  struct resource *r ;

  {
//#line  2914
  if (cm->gameport) {
    {
//#line  2915
    r = (struct resource *)(cm->gameport)->port_data;
//#line  2917
    gameport_unregister_port(cm->gameport);
//#line  2918
    cm->gameport = (struct gameport *)((void *)0);
//#line  2920
    snd_cmipci_clear_bit(cm, 4U, 2U);
//#line  2921
    release_and_free_resource(r);
    }
  }
//#line  2923
  return;
}
}
//#line  2929 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_free(struct cmipci *cm ) 
{ 


  {
//#line  2931
  if (cm->irq >= 0) {
    {
//#line  2932
    snd_cmipci_clear_bit(cm, 24U, 524288U);
//#line  2933
    snd_cmipci_clear_bit(cm, 20U, 8388608U);
//#line  2934
    snd_cmipci_write(cm, 12U, 0U);
//#line  2935
    snd_cmipci_ch_reset(cm, 0);
//#line  2936
    snd_cmipci_ch_reset(cm, 1);
//#line  2937
    snd_cmipci_write(cm, 0U, 0U);
//#line  2938
    snd_cmipci_write(cm, 4U, 0U);
//#line  2941
    snd_cmipci_mixer_write(cm, (unsigned char)0, (unsigned char)0);
//#line  2943
    free_irq((unsigned int )cm->irq, (void *)cm);
    }
  }
  {
//#line  2946
  snd_cmipci_free_gameport(cm);
//#line  2947
  pci_release_regions(cm->pci);
//#line  2948
  pci_disable_device(cm->pci);
//#line  2949
  kfree((void const   *)cm);
  }
//#line  2950
  return (0);
}
}
//#line  2953 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_dev_free(struct snd_device *device ) 
{ 
  struct cmipci *cm ;
  int tmp ;

  {
  {
//#line  2955
  cm = (struct cmipci *)device->device_data;
//#line  2956
  tmp = snd_cmipci_free(cm);
  }
  return (tmp);
}
}
//#line  2959
static int snd_cmipci_create_fm(struct cmipci *cm , long fm_port___0 )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_create_fm(struct cmipci *cm , long fm_port___0 ) 
{ 
  long iosynth ;
  unsigned int val ;
  struct snd_opl3 *opl3 ;
  int err ;
  unsigned int tmp ;
  int tmp___0 ;

  {
//#line  2966
  if (! fm_port___0) {
//#line  2967
    goto disable_fm;
  }
//#line  2969
  if (cm->chip_version >= 39) {
    {
//#line  2971
    iosynth = (long )(cm->iobase + 80UL);
//#line  2972
    err = snd_opl3_create(cm->card, (unsigned long )iosynth, (unsigned long )(iosynth + 2L),
                          (unsigned short)768, 1, & opl3);
    }
  } else {
//#line  2975
    err = -5;
  }
//#line  2977
  if (err < 0) {
    {
//#line  2979
    tmp = snd_cmipci_read(cm, 20U);
    val = tmp & 4244635647U;
//#line  2980
    iosynth = fm_port___0;
    }
    {
    if ((int )iosynth == 1000) {
//#line  2982
      goto case_1000;
    }
    if ((int )iosynth == 992) {
//#line  2983
      goto case_992;
    }
    if ((int )iosynth == 968) {
//#line  2984
      goto case_968;
    }
    if ((int )iosynth == 904) {
//#line  2985
      goto case_904;
    }
//#line  2986
    goto switch_default;
    case_1000: /* CIL Label */ 
//#line  2982
    val |= 50331648U;
    goto switch_break;
    case_992: /* CIL Label */ 
//#line  2983
    val |= 33554432U;
    goto switch_break;
    case_968: /* CIL Label */ 
//#line  2984
    val |= 16777216U;
    goto switch_break;
    case_904: /* CIL Label */ 
//#line  2985
    val = val;
    goto switch_break;
    switch_default: /* CIL Label */ 
//#line  2987
    goto disable_fm;
    switch_break: /* CIL Label */ ;
    }
    {
//#line  2989
    snd_cmipci_write(cm, 20U, val);
//#line  2991
    snd_cmipci_set_bit(cm, 24U, 524288U);
//#line  2993
    tmp___0 = snd_opl3_create(cm->card, (unsigned long )iosynth, (unsigned long )(iosynth + 2L),
                              (unsigned short)768, 0, & opl3);
    }
//#line  2993
    if (tmp___0 < 0) {
      {
//#line  2995
      printk(str_247204062, iosynth);
      }
//#line  2997
      goto disable_fm;
    }
  }
  {
//#line  3000
  err = snd_opl3_hwdep_new(opl3, 0, 1, (struct snd_hwdep **)((void *)0));
  }
//#line  3000
  if (err < 0) {
    {
//#line  3001
    printk(str_537495551);
    }
//#line  3002
    return (err);
  }
//#line  3004
  return (0);
  disable_fm: 
  {
//#line  3007
  snd_cmipci_clear_bit(cm, 20U, 50331648U);
//#line  3008
  snd_cmipci_clear_bit(cm, 24U, 524288U);
  }
//#line  3009
  return (0);
}
}
//#line  3017
static int snd_cmipci_create(struct snd_card *card , struct pci_dev *pci , int dev ,
                             struct cmipci **rcmipci )  __attribute__((__section__(".devinit.text"))) ;
static struct snd_device_ops  __attribute__((__noderef__, __address_space__(2))) ops  =    {(int (* __attribute__((__noderef__,
    __address_space__(2))) )(struct snd_device *dev ))(& snd_cmipci_dev_free), (int (* __attribute__((__noderef__,
    __address_space__(2))) )(struct snd_device *dev ))0, (int (* __attribute__((__noderef__,
    __address_space__(2))) )(struct snd_device *dev ))0};
//#line  3025
static int snd_cmipci_create(struct snd_card *card , struct pci_dev *pci , int dev ,
                             struct cmipci **rcmipci )  __attribute__((__section__(".devinit.text"))) ;
static struct pci_device_id ( __attribute__((__noderef__, __address_space__(2))) intel_82437vx)[2]  = {      {(__u32 )32902,
      (__u32 )28720, (__u32 )(~ 0), (__u32 )(~ 0), 0U, 0U, 0UL}, 
        {(__u32 )0, (__u32 )0, (__u32 )0, (__u32 )0, (__u32 )0, (__u32 )0, (kernel_ulong_t )0}};
//#line  3043 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static struct lock_class_key __key___0  ;
//#line  3012
static int snd_cmipci_create(struct snd_card *card , struct pci_dev *pci , int dev ,
                             struct cmipci **rcmipci )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_create(struct snd_card *card , struct pci_dev *pci , int dev ,
                             struct cmipci **rcmipci ) 
{ 
  struct cmipci *cm ;
  int err ;
  unsigned int val ;
  long iomidi ;
  int integrated_midi ;
  char modelstr[16] ;
  int pcm_index ;
  int pcm_spdif_index ;
  void *tmp ;
  spinlock_t __constr_expr_0 ;
  u8 tmp___0 ;
  int tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  int tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
//#line  3022
  integrated_midi = 0;
//#line  3031
  *rcmipci = (struct cmipci *)((void *)0);
//#line  3033
  err = pci_enable_device(pci);
  }
//#line  3033
  if (err < 0) {
//#line  3034
    return (err);
  }
  {
//#line  3036
  tmp = kzalloc(sizeof(*cm), 208U);
  cm = (struct cmipci *)tmp;
  }
//#line  3037
  if ((unsigned long )cm == (unsigned long )((void *)0)) {
    {
//#line  3038
    pci_disable_device(pci);
    }
//#line  3039
    return (-12);
  }
  {
  {
  while (1) {


//#line  3042
    __constr_expr_0.raw_lock.slock = 0U;
    cm->reg_lock = __constr_expr_0;
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


    {
//#line  3043
    __mutex_init(& cm->open_mutex, str_799428759, & __key___0);
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  3044
  cm->device = (unsigned int )pci->device;
//#line  3045
  cm->card = card;
//#line  3046
  cm->pci = pci;
//#line  3047
  cm->irq = -1;
//#line  3048
  cm->channel[0].ch = 0U;
//#line  3049
  cm->channel[1].ch = 1U;
//#line  3050
  tmp___0 = (u8 )1;
  cm->channel[1].is_dac = tmp___0;
  cm->channel[0].is_dac = tmp___0;
//#line  3052
  err = pci_request_regions(pci, (char const   *)(card->driver));
  }
//#line  3052
  if (err < 0) {
    {
//#line  3053
    kfree((void const   *)cm);
//#line  3054
    pci_disable_device(pci);
    }
//#line  3055
    return (err);
  }
  {
//#line  3057
  cm->iobase = (unsigned long )pci->resource[0].start;
//#line  3059
  tmp___1 = request_irq(pci->irq, & snd_cmipci_interrupt, 128UL, (char const   *)(card->driver),
                        (void *)cm);
  }
//#line  3059
  if (tmp___1) {
    {
//#line  3061
    printk(str_235265470, pci->irq);
//#line  3062
    snd_cmipci_free(cm);
    }
//#line  3063
    return (-16);
  }
  {
//#line  3065
  cm->irq = (int )pci->irq;
//#line  3067
  pci_set_master(cm->pci);
//#line  3073
  cm->chip_version = 0;
//#line  3074
  cm->max_channels = 2;
//#line  3075
  cm->do_soft_ac3 = (unsigned int )soft_ac3[dev];
  }
  if ((int )pci->device != 256) {
//#line  3077
    if ((int )pci->device != 257) {
      {
//#line  3079
      query_chip(cm);
      }
    }
  }
//#line  3081
  if (cm->can_multi_ch) {
    {
//#line  3082
    tmp___2 = strlen((char const   *)((cm->card)->driver));
    sprintf((cm->card)->driver + tmp___2, str_6417578, cm->max_channels);
    }
  } else
//#line  3084
  if (cm->can_ac3_sw) {
    {
//#line  3085
    tmp___3 = strlen((char const   *)((cm->card)->driver));
    strcpy((cm->card)->driver + tmp___3, str_122865562);
    }
  }
  {
//#line  3087
  cm->dig_status = (unsigned int )((((1 << 7) << 8) | (2 << 8)) | (2 << 24));
//#line  3088
  cm->dig_pcm_status = (unsigned int )((((1 << 7) << 8) | (2 << 8)) | (2 << 24));
//#line  3093
  cm->ctrl = 2U;
//#line  3097
  snd_cmipci_set_bit(cm, 24U, 1073741824U);
//#line  3098
  snd_cmipci_clear_bit(cm, 24U, 1073741824U);
//#line  3099
  snd_cmipci_write(cm, 12U, 0U);
//#line  3100
  snd_cmipci_ch_reset(cm, 0);
//#line  3101
  snd_cmipci_ch_reset(cm, 1);
//#line  3102
  snd_cmipci_write(cm, 0U, 0U);
//#line  3103
  snd_cmipci_write(cm, 4U, 0U);
//#line  3105
  snd_cmipci_write(cm, 8U, 0U);
//#line  3106
  snd_cmipci_set_bit(cm, 24U, 75497472U);
//#line  3110
  snd_cmipci_clear_bit(cm, 24U, 4194304U);
  }
//#line  3112
  if (cm->chip_version) {
    {
//#line  3113
    snd_cmipci_write_b(cm, 144U, (unsigned char)32);
//#line  3114
    snd_cmipci_write_b(cm, 145U, (unsigned char)9);
    }
  }
  {
//#line  3117
  snd_cmipci_set_bit(cm, 4U, 16U);
  }
  {
  if ((int )pci->device == 273) {
//#line  3121
    goto case_273;
  }
  if ((int )pci->device == 274) {
//#line  3122
    goto case_273;
  }
//#line  3126
  goto switch_default;
  case_273: /* CIL Label */ 
  {
//#line  3123
  tmp___4 = pci_dev_present((struct pci_device_id  const  *)(intel_82437vx));
  }
//#line  3123
  if (! tmp___4) {
    {
//#line  3124
    snd_cmipci_set_bit(cm, 24U, 134217728U);
    }
  }
//#line  3125
  goto switch_break;
  switch_default: /* CIL Label */ 
//#line  3127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  3130
  if (cm->chip_version < 68) {
    if ((int )pci->device < 272) {
      val = 8338U;
    } else {
//#line  3131
      val = 8738U;
    }
  } else {
    {
//#line  3133
    tmp___5 = snd_cmipci_read_b(cm, 15U);
    }
    {
    if (((int )tmp___5 & 3) == 0) {
//#line  3134
      goto case_0;
    }
    if (((int )tmp___5 & 3) == 2) {
//#line  3137
      goto case_2;
    }
//#line  3140
    goto switch_default___0;
    case_0: /* CIL Label */ 
//#line  3135
    val = 8769U;
//#line  3136
    goto switch_break___0;
    case_2: /* CIL Label */ 
//#line  3138
    val = 8762U;
//#line  3139
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 334927713) {
//#line  3143
      goto case_334927713;
    }
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 1481455425) {
//#line  3144
      goto case_334927713;
    }
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 1481455441) {
//#line  3145
      goto case_334927713;
    }
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 1481455457) {
//#line  3146
      goto case_334927713;
    }
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 1481455473) {
//#line  3147
      goto case_334927713;
    }
    if ((((int )pci->subsystem_vendor << 16) | (int )pci->subsystem_device) == 1921287044) {
//#line  3148
      goto case_334927713;
    }
//#line  3151
    goto switch_default___1;
    case_334927713: /* CIL Label */ 
//#line  3149
    val = 8770U;
//#line  3150
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
//#line  3152
    val = 8768U;
//#line  3153
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
//#line  3157
  sprintf(card->shortname, str_1050924700, val);
  }
//#line  3158
  if (cm->chip_version < 68) {
    {
//#line  3159
    sprintf(modelstr, str_184869755, cm->chip_version);
    }
  } else {
//#line  3161
    modelstr[0] = (char )'\000';
  }
  {
//#line  3162
  sprintf(card->longname, str_533589931, card->shortname, modelstr, cm->iobase, cm->irq);
//#line  3165
  err = snd_device_new(card, 8192, (void *)cm, (struct snd_device_ops *)(& ops));
  }
//#line  3165
  if (err < 0) {
    {
//#line  3166
    snd_cmipci_free(cm);
    }
//#line  3167
    return (err);
  }
//#line  3170
  if (cm->chip_version >= 39) {
    {
//#line  3171
    tmp___6 = snd_cmipci_read_b(cm, 65U);
    val = (unsigned int )tmp___6;
    }
    if (val != 0U) {
//#line  3172
      if (val != 255U) {
//#line  3173
        iomidi = (long )(cm->iobase + 64UL);
//#line  3174
        integrated_midi = 1;
      }
    }
  }
//#line  3177
  if (! integrated_midi) {
//#line  3178
    val = 0U;
//#line  3179
    iomidi = mpu_port[dev];
    {
    if ((int )iomidi == 800) {
//#line  3181
      goto case_800;
    }
    if ((int )iomidi == 784) {
//#line  3182
      goto case_784;
    }
    if ((int )iomidi == 768) {
//#line  3183
      goto case_768;
    }
    if ((int )iomidi == 816) {
//#line  3184
      goto case_816;
    }
//#line  3185
    goto switch_default___2;
    case_800: /* CIL Label */ 
//#line  3181
    val = 536870912U;
    goto switch_break___2;
    case_784: /* CIL Label */ 
//#line  3182
    val = 1073741824U;
    goto switch_break___2;
    case_768: /* CIL Label */ 
//#line  3183
    val = 1610612736U;
    goto switch_break___2;
    case_816: /* CIL Label */ 
//#line  3184
    val = 0U;
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
//#line  3186
    iomidi = 0L;
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
//#line  3188
    if (iomidi > 0L) {
      {
//#line  3189
      snd_cmipci_write(cm, 20U, val);
//#line  3191
      snd_cmipci_set_bit(cm, 4U, 4U);
//#line  3192
      tmp___7 = inb((unsigned short )(iomidi + 1L));
      }
//#line  3192
      if ((int )tmp___7 == 255) {
        {
//#line  3193
        printk(str_13950841, iomidi);
//#line  3195
        snd_cmipci_clear_bit(cm, 4U, 4U);
//#line  3197
        iomidi = 0L;
        }
      }
    }
  }
//#line  3202
  if (cm->chip_version < 68) {
    {
//#line  3203
    err = snd_cmipci_create_fm(cm, fm_port[dev]);
    }
//#line  3204
    if (err < 0) {
//#line  3205
      return (err);
    }
  }
  {
//#line  3209
  snd_cmipci_mixer_write(cm, (unsigned char)0, (unsigned char)0);
//#line  3211
  snd_cmipci_proc_init(cm);
//#line  3214
  pcm_spdif_index = 0;
  pcm_index = pcm_spdif_index;
//#line  3215
  err = snd_cmipci_pcm_new(cm, pcm_index);
  }
//#line  3215
  if (err < 0) {
//#line  3216
    return (err);
  }
  {
//#line  3217
  pcm_index ++;
//#line  3218
  err = snd_cmipci_pcm2_new(cm, pcm_index);
  }
//#line  3218
  if (err < 0) {
//#line  3219
    return (err);
  }
//#line  3220
  pcm_index ++;
  if (cm->can_ac3_hw) {
    goto _L;
  } else
//#line  3221
  if (cm->can_ac3_sw) {
    _L: /* CIL Label */ 
    {
//#line  3222
    pcm_spdif_index = pcm_index;
//#line  3223
    err = snd_cmipci_pcm_spdif_new(cm, pcm_index);
    }
//#line  3223
    if (err < 0) {
//#line  3224
      return (err);
    }
  }
  {
//#line  3228
  err = snd_cmipci_mixer_new(cm, pcm_spdif_index);
  }
//#line  3228
  if (err < 0) {
//#line  3229
    return (err);
  }
//#line  3231
  if (iomidi > 0L) {
    if (integrated_midi) {
      tmp___8 = 1 << 2;
    } else {
//#line  3232
      tmp___8 = 0;
    }
    {
    err = snd_mpu401_uart_new(card, 0, (unsigned short)15, (unsigned long )iomidi,
                              (unsigned int )tmp___8, cm->irq, 0, & cm->rmidi);
    }
//#line  3232
    if (err < 0) {
      {
//#line  3237
      printk(str_782745852, iomidi);
      }
    }
  }
  {
//#line  3251
  tmp___9 = snd_cmipci_create_gameport(cm, dev);
  }
//#line  3251
  if (tmp___9 < 0) {
    {
//#line  3252
    snd_cmipci_clear_bit(cm, 4U, 2U);
    }
  }
//#line  3254
  card->dev = (struct device *)(& pci->dev);
//#line  3256
  *rcmipci = cm;
//#line  3257
  return (0);
}
}
//#line  3263
extern struct pci_device_id  const  __mod_pci_device_table  __attribute__((__unused__,
__alias__("snd_cmipci_ids"))) ;
//#line  3268 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int dev  ;
//#line  3265
static int snd_cmipci_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id )  __attribute__((__section__(".devinit.text"))) ;
static int snd_cmipci_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id ) 
{ 
  struct snd_card *card ;
  struct cmipci *cm ;
  int err ;

  {
  {
//#line  3273
  printk(str_293594775, str_240831266);
  }
//#line  3275
  if (dev >= 32) {
//#line  3276
    return (-19);
  }
//#line  3277
  if (! enable[dev]) {
//#line  3278
    dev ++;
//#line  3279
    return (-2);
  }
  {
//#line  3282
  card = snd_card_new(index[dev], (char const   *)id[dev], & __this_module, 0);
  }
//#line  3283
  if ((unsigned long )card == (unsigned long )((void *)0)) {
//#line  3284
    return (-12);
  }
  {
  if ((int )pci->device == 273) {
//#line  3287
    goto case_273;
  }
  if ((int )pci->device == 274) {
//#line  3288
    goto case_273;
  }
  if ((int )pci->device == 256) {
//#line  3291
    goto case_256;
  }
  if ((int )pci->device == 257) {
//#line  3292
    goto case_256;
  }
//#line  3295
  goto switch_default;
  case_273: /* CIL Label */ 
  {
//#line  3289
  strcpy(card->driver, str_131426595);
  }
//#line  3290
  goto switch_break;
  case_256: /* CIL Label */ 
  {
//#line  3293
  strcpy(card->driver, str_131425151);
  }
//#line  3294
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  3296
  strcpy(card->driver, str_176464283);
  }
//#line  3297
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
//#line  3300
  err = snd_cmipci_create(card, pci, dev, & cm);
  }
//#line  3300
  if (err < 0) {
    {
//#line  3301
    snd_card_free(card);
    }
//#line  3302
    return (err);
  }
  {
//#line  3304
  card->private_data = (void *)cm;
//#line  3306
  err = snd_card_register(card);
  }
//#line  3306
  if (err < 0) {
    {
//#line  3307
    snd_card_free(card);
    }
//#line  3308
    return (err);
  }
  {
//#line  3310
  pci_set_drvdata(pci, (void *)card);
//#line  3311
  dev ++;
  }
//#line  3312
  return (0);
}
}
//#line  3316
static void snd_cmipci_remove(struct pci_dev *pci )  __attribute__((__section__(".devexit.text"))) ;
static void snd_cmipci_remove(struct pci_dev *pci ) 
{ 
  void *tmp ;

  {
  {
//#line  3318
  tmp = pci_get_drvdata(pci);
  snd_card_free((struct snd_card *)tmp);
//#line  3319
  pci_set_drvdata(pci, (void *)0);
  }
//#line  3320
  return;
}
}
static unsigned char ( __attribute__((__noderef__, __address_space__(2))) saved_regs)[17]  = 
//#line  3327
  {      (unsigned char)4,      (unsigned char)8,      (unsigned char)20,      (unsigned char)24, 
        (unsigned char)32,      (unsigned char)36,      (unsigned char)37,      (unsigned char)36, 
        (unsigned char)248,      (unsigned char)128,      (unsigned char)132,      (unsigned char)136, 
        (unsigned char)140,      (unsigned char)144,      (unsigned char)16,      (unsigned char)12, 
        (unsigned char)0};
static unsigned char ( __attribute__((__noderef__, __address_space__(2))) saved_mixers)[16]  = 
//#line  3335
  {      (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)240,      (unsigned char)60,      (unsigned char)61,      (unsigned char)62};
//#line  3346 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_suspend(struct pci_dev *pci , pm_message_t state ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct cmipci *cm ;
  int i ;
  pci_power_t tmp___0 ;

  {
  {
//#line  3348
  tmp = pci_get_drvdata(pci);
  card = (struct snd_card *)tmp;
//#line  3349
  cm = (struct cmipci *)card->private_data;
//#line  3352
  snd_power_change_state(card, 768U);
//#line  3354
  snd_pcm_suspend_all(cm->pcm);
//#line  3355
  snd_pcm_suspend_all(cm->pcm2);
//#line  3356
  snd_pcm_suspend_all(cm->pcm_spdif);
//#line  3359
  i = 0;
  }
  {
  {
  while (1) {


    if (! ((unsigned long )i < sizeof(saved_regs) / sizeof(saved_regs[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break;
    }
    {
//#line  3360
    cm->saved_regs[i] = snd_cmipci_read(cm, (unsigned int )saved_regs[i]);
//#line  3359
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  3361
  i = 0;
  {
  {
  while (1) {


    if (! ((unsigned long )i < sizeof(saved_mixers) / sizeof(saved_mixers[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break___0;
    }
    {
//#line  3362
    cm->saved_mixers[i] = snd_cmipci_mixer_read(cm, saved_mixers[i]);
//#line  3361
    i ++;
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  3365
  snd_cmipci_write(cm, 12U, 0U);
//#line  3367
  pci_disable_device(pci);
//#line  3368
  pci_save_state(pci);
//#line  3369
  tmp___0 = pci_choose_state(pci, state);
  pci_set_power_state(pci, tmp___0);
  }
//#line  3370
  return (0);
}
}
//#line  3373 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
static int snd_cmipci_resume(struct pci_dev *pci ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct cmipci *cm ;
  int i ;
  int tmp___0 ;

  {
  {
//#line  3375
  tmp = pci_get_drvdata(pci);
  card = (struct snd_card *)tmp;
//#line  3376
  cm = (struct cmipci *)card->private_data;
//#line  3379
  pci_set_power_state(pci, 0);
//#line  3380
  pci_restore_state(pci);
//#line  3381
  tmp___0 = pci_enable_device(pci);
  }
//#line  3381
  if (tmp___0 < 0) {
    {
//#line  3382
    printk(str_235676013);
//#line  3384
    snd_card_disconnect(card);
    }
//#line  3385
    return (-5);
  }
  {
//#line  3387
  pci_set_master(pci);
//#line  3390
  snd_cmipci_write(cm, 12U, 0U);
//#line  3391
  snd_cmipci_ch_reset(cm, 0);
//#line  3392
  snd_cmipci_ch_reset(cm, 1);
//#line  3393
  snd_cmipci_mixer_write(cm, (unsigned char)0, (unsigned char)0);
//#line  3396
  i = 0;
  }
  {
  {
  while (1) {


    if (! ((unsigned long )i < sizeof(saved_regs) / sizeof(saved_regs[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break;
    }
    {
//#line  3397
    snd_cmipci_write(cm, (unsigned int )saved_regs[i], cm->saved_regs[i]);
//#line  3396
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  3398
  i = 0;
  {
  {
  while (1) {


    if (! ((unsigned long )i < sizeof(saved_mixers) / sizeof(saved_mixers[0]) + (sizeof(char [1]) - 1UL))) {
      goto while_break___0;
    }
    {
//#line  3399
    snd_cmipci_mixer_write(cm, saved_mixers[i], cm->saved_mixers[i]);
//#line  3398
    i ++;
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  3401
  snd_power_change_state(card, 0U);
  }
//#line  3402
  return (0);
}
}
static struct pci_driver driver  = 
//#line  3406
     {{(struct list_head *)0, (struct list_head *)0}, (char *)str_377684264, (struct pci_device_id  const  *)(snd_cmipci_ids),
    & snd_cmipci_probe, & snd_cmipci_remove, & snd_cmipci_suspend, (int (*)(struct pci_dev *dev ,
                                                                            pm_message_t state ))0,
    (int (*)(struct pci_dev *dev ))0, & snd_cmipci_resume, (void (*)(struct pci_dev *dev ))0,
    (struct pci_error_handlers *)0, {(char const   *)0, (struct bus_type *)0, (struct module *)0,
                                     (char const   *)0, (int (*)(struct device *dev ))0,
                                     (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
                                     (int (*)(struct device *dev , pm_message_t state ))0,
                                     (int (*)(struct device *dev ))0, (struct attribute_group **)0,
                                     (struct dev_pm_ops *)0, (struct driver_private *)0},
    {{{0U}}, {(struct list_head *)0, (struct list_head *)0}}};
//#line  3417
static int alsa_card_cmipci_init(void)  __attribute__((__section__(".init.text"),
__no_instrument_function__)) ;
static int alsa_card_cmipci_init(void) 
{ 
  int tmp ;

  {
  {
//#line  3419
  tmp = __pci_register_driver(& driver, & __this_module, str_260101403);
  }
  return (tmp);
}
}
//#line  3422
static void alsa_card_cmipci_exit(void)  __attribute__((__section__(".exit.text"))) ;
static void alsa_card_cmipci_exit(void) 
{ 


  {
  {
//#line  3424
  pci_unregister_driver(& driver);
  }
//#line  3425
  return;
}
}
//#line  3427 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
int init_module(void) 
{  
#include "../../common/master_init_module.h" //Matt E3 
 
  int tmp ;

  {
  {
  tmp = alsa_card_cmipci_init();
  }
  return (tmp);
}
}
//#line  3428 "/scratch/sym/ipc_drivers/cmipci/cmipci_annotated.c"
void cleanup_module(void) 
{ 


  {
  {
  alsa_card_cmipci_exit();
  }
  return;
}
}
void __MARSH_WRAP__snd_opl3_hwdep_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_opl3 *opl3 ;
  int device ;
  int seq_device ;
  struct snd_hwdep **rhwdep ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  opl3 = 0U;
  fetch_marshbuf_ptr("snd_opl3_hwdep_new", _buf_, & _off_, (void **)(& opl3), sizeof(struct snd_opl3 ),
                     sizeof(struct snd_opl3 ));
  fetch_marshbuf("snd_opl3_hwdep_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_opl3_hwdep_new", _buf_, & _off_, sizeof(int ), (void *)(& seq_device));
  rhwdep = 0U;
  fetch_marshbuf_ptr("snd_opl3_hwdep_new", _buf_, & _off_, (void **)(& rhwdep), sizeof(struct snd_hwdep *),
                     sizeof(struct snd_hwdep *));
  if (rhwdep != 0U) {
    fetch_marshbuf_ptr("snd_opl3_hwdep_new", _buf_, & _off_, (void **)rhwdep, sizeof(struct snd_hwdep ),
                       sizeof(struct snd_hwdep ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_opl3_hwdep_new(opl3, device, seq_device, rhwdep);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_opl3_hwdep_new", & _buf_, & _off_, & opl3);
  fill_marshbuf("snd_opl3_hwdep_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_opl3_hwdep_new", & _buf_, & _off_, (void *)(& seq_device), sizeof(int ));
  fill_marshbuf_ptr("snd_opl3_hwdep_new", & _buf_, & _off_, & rhwdep);
  if (rhwdep != 0U) {
    fill_marshbuf_ptr("snd_opl3_hwdep_new", & _buf_, & _off_, rhwdep);
  }
  fill_marshbuf("snd_opl3_hwdep_new", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_unregister_driver(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_driver *dev ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_unregister_driver", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_driver ),
                     sizeof(struct pci_driver ));
  if (dev != 0U) {
    tmp_fld6 = & dev->driver;
    tmp_lv5 = dev;
    nooks_ot_storeoffset_kern_w(dev, tmp_fld6 - tmp_lv5, sizeof(struct device_driver ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  pci_unregister_driver(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_unregister_driver", & _buf_, & _off_, & dev);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_set_power_state(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  pci_power_t state ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_set_power_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_set_power_state", _buf_, & _off_, sizeof(int ), (void *)(& state));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_set_power_state(dev, state);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_set_power_state", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_set_power_state", & _buf_, & _off_, (void *)(& state), sizeof(int ));
  fill_marshbuf("pci_set_power_state", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_card_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  int idx ;
  char const   *id ;
  struct module *module ;
  int extra_size ;
  struct snd_card *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& idx));
  id = 0U;
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& id), sizeof(char const   ),
                     sizeof(char const   ));
  if (id != 0U) {
    fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(char const   ), (void *)id);
  }
  module = 0U;
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& module), sizeof(struct module ),
                     sizeof(struct module ));
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& extra_size));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct snd_card *)snd_card_new(idx, id, module, extra_size);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& idx), sizeof(int ));
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)id, sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & module);
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& extra_size), sizeof(int ));
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_mpu401_uart_interrupt(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  int irq ;
  void *dev_id ;
  irqreturn_t _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("snd_mpu401_uart_interrupt", _buf_, & _off_, sizeof(int ), (void *)(& irq));
  dev_id = 0U;
  fetch_marshbuf_ptr("snd_mpu401_uart_interrupt", _buf_, & _off_, & dev_id, sizeof(void ),
                     sizeof(void ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (irqreturn_t )snd_mpu401_uart_interrupt(irq, dev_id);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("snd_mpu401_uart_interrupt", & _buf_, & _off_, (void *)(& irq), sizeof(int ));
  fill_marshbuf_ptr("snd_mpu401_uart_interrupt", & _buf_, & _off_, & dev_id);
  fill_marshbuf("snd_mpu401_uart_interrupt", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strcmp(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *cs ;
  char const   *ct ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  cs = 0U;
  fetch_marshbuf_ptr("strcmp", _buf_, & _off_, (void **)(& cs), sizeof(char const   ),
                     sizeof(char const   ));
  if (cs != 0U) {
    fetch_marshbuf("strcmp", _buf_, & _off_, sizeof(char const   ), (void *)cs);
  }
  ct = 0U;
  fetch_marshbuf_ptr("strcmp", _buf_, & _off_, (void **)(& ct), sizeof(char const   ),
                     sizeof(char const   ));
  if (ct != 0U) {
    fetch_marshbuf("strcmp", _buf_, & _off_, sizeof(char const   ), (void *)ct);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )strcmp(cs, ct);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strcmp", & _buf_, & _off_, & cs);
  if (cs != 0U) {
    fill_marshbuf("strcmp", & _buf_, & _off_, (void *)cs, sizeof(char const   ));
  }
  fill_marshbuf_ptr("strcmp", & _buf_, & _off_, & ct);
  if (ct != 0U) {
    fill_marshbuf("strcmp", & _buf_, & _off_, (void *)ct, sizeof(char const   ));
  }
  fill_marshbuf("strcmp", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_release_regions(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *arg0 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("pci_release_regions", _buf_, & _off_, (void **)(& arg0), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  pci_release_regions(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_release_regions", & _buf_, & _off_, & arg0);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__printk(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fmt = 0U;
  fetch_marshbuf_ptr("printk", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("printk", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )printk(fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("printk", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("printk", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  fill_marshbuf("printk", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_lib_malloc_pages(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_substream *substream ;
  size_t size ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  substream = 0U;
  fetch_marshbuf_ptr("snd_pcm_lib_malloc_pages", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  fetch_marshbuf("snd_pcm_lib_malloc_pages", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& size));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_lib_malloc_pages(substream, size);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_lib_malloc_pages", & _buf_, & _off_, & substream);
  fill_marshbuf("snd_pcm_lib_malloc_pages", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf("snd_pcm_lib_malloc_pages", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__gameport_unregister_port(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct gameport *gameport ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  gameport = 0U;
  fetch_marshbuf_ptr("gameport_unregister_port", _buf_, & _off_, (void **)(& gameport),
                     sizeof(struct gameport ), sizeof(struct gameport ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  gameport_unregister_port(gameport);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("gameport_unregister_port", & _buf_, & _off_, & gameport);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP___spin_lock_irq(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  spinlock_t *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("_spin_lock_irq", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ),
                     sizeof(spinlock_t ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _spin_lock_irq(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("_spin_lock_irq", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_hw_constraint_list(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_runtime *runtime ;
  unsigned int cond ;
  snd_pcm_hw_param_t var ;
  struct snd_pcm_hw_constraint_list *l ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  runtime = 0U;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_list", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ), sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_list", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& cond));
  fetch_marshbuf("snd_pcm_hw_constraint_list", _buf_, & _off_, sizeof(int ), (void *)(& var));
  l = 0U;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_list", _buf_, & _off_, (void **)(& l),
                     sizeof(struct snd_pcm_hw_constraint_list ), sizeof(struct snd_pcm_hw_constraint_list ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_hw_constraint_list(runtime, cond, var, l);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_list", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_list", & _buf_, & _off_, (void *)(& cond),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_list", & _buf_, & _off_, (void *)(& var), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_hw_constraint_list", & _buf_, & _off_, & l);
  fill_marshbuf("snd_pcm_hw_constraint_list", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_iprintf(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_info_buffer *buffer ;
  char *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  buffer = 0U;
  fetch_marshbuf_ptr("snd_iprintf", _buf_, & _off_, (void **)(& buffer), sizeof(struct snd_info_buffer ),
                     sizeof(struct snd_info_buffer ));
  fmt = 0U;
  fetch_marshbuf_ptr("snd_iprintf", _buf_, & _off_, (void **)(& fmt), sizeof(char ),
                     sizeof(char ));
  if (fmt != 0U) {
    fetch_marshbuf("snd_iprintf", _buf_, & _off_, sizeof(char ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_iprintf(buffer, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_iprintf", & _buf_, & _off_, & buffer);
  fill_marshbuf_ptr("snd_iprintf", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("snd_iprintf", & _buf_, & _off_, (void *)fmt, sizeof(char ));
  }
  fill_marshbuf("snd_iprintf", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____wake_up(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  wait_queue_head_t *q ;
  unsigned int mode ;
  int nr ;
  void *key ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  q = 0U;
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ),
                     sizeof(wait_queue_head_t ));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mode));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(int ), (void *)(& nr));
  key = 0U;
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, & key, sizeof(void ), sizeof(void ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  __wake_up(q, mode, nr, key);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & q);
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& mode), sizeof(unsigned int ));
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& nr), sizeof(int ));
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & key);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_mpu401_uart_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  int device ;
  unsigned short hardware ;
  unsigned long port ;
  unsigned int info_flags ;
  int irq ;
  int irq_flags ;
  struct snd_rawmidi **rrawmidi ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_mpu401_uart_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(unsigned short ), (void *)(& hardware));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(unsigned long ), (void *)(& port));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(unsigned int ), (void *)(& info_flags));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(int ), (void *)(& irq));
  fetch_marshbuf("snd_mpu401_uart_new", _buf_, & _off_, sizeof(int ), (void *)(& irq_flags));
  rrawmidi = 0U;
  fetch_marshbuf_ptr("snd_mpu401_uart_new", _buf_, & _off_, (void **)(& rrawmidi),
                     sizeof(struct snd_rawmidi *), sizeof(struct snd_rawmidi *));
  if (rrawmidi != 0U) {
    fetch_marshbuf_ptr("snd_mpu401_uart_new", _buf_, & _off_, (void **)rrawmidi, sizeof(struct snd_rawmidi ),
                       sizeof(struct snd_rawmidi ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_mpu401_uart_new(card, device, hardware, port, info_flags, irq,
                                       irq_flags, rrawmidi);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_mpu401_uart_new", & _buf_, & _off_, & card);
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& hardware), sizeof(unsigned short ));
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& port), sizeof(unsigned long ));
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& info_flags), sizeof(unsigned int ));
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& irq), sizeof(int ));
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& irq_flags), sizeof(int ));
  fill_marshbuf_ptr("snd_mpu401_uart_new", & _buf_, & _off_, & rrawmidi);
  if (rrawmidi != 0U) {
    fill_marshbuf_ptr("snd_mpu401_uart_new", & _buf_, & _off_, rrawmidi);
  }
  fill_marshbuf("snd_mpu401_uart_new", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__msleep(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  unsigned int msecs ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("msleep", _buf_, & _off_, sizeof(unsigned int ), (void *)(& msecs));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  msleep(msecs);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("msleep", & _buf_, & _off_, (void *)(& msecs), sizeof(unsigned int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_request_regions(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *arg0 ;
  char const   *arg1 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("pci_request_regions", _buf_, & _off_, (void **)(& arg0), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  arg1 = 0U;
  fetch_marshbuf_ptr("pci_request_regions", _buf_, & _off_, (void **)(& arg1), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg1 != 0U) {
    fetch_marshbuf("pci_request_regions", _buf_, & _off_, sizeof(char const   ), (void *)arg1);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_request_regions(arg0, arg1);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_request_regions", & _buf_, & _off_, & arg0);
  fill_marshbuf_ptr("pci_request_regions", & _buf_, & _off_, & arg1);
  if (arg1 != 0U) {
    fill_marshbuf("pci_request_regions", & _buf_, & _off_, (void *)arg1, sizeof(char const   ));
  }
  fill_marshbuf("pci_request_regions", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ctl_find_id(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  struct snd_ctl_elem_id *id ;
  struct snd_kcontrol *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_ctl_find_id", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  id = 0U;
  fetch_marshbuf_ptr("snd_ctl_find_id", _buf_, & _off_, (void **)(& id), sizeof(struct snd_ctl_elem_id ),
                     sizeof(struct snd_ctl_elem_id ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct snd_kcontrol *)snd_ctl_find_id(card, id);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_ctl_find_id", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_ctl_find_id", & _buf_, & _off_, & id);
  fill_marshbuf_ptr("snd_ctl_find_id", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_choose_state(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  pm_message_t state ;
  pci_power_t _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_choose_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (pci_power_t )pci_choose_state(dev, state);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_choose_state", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_choose_state", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP___spin_lock(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  spinlock_t *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("_spin_lock", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ),
                     sizeof(spinlock_t ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _spin_lock(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("_spin_lock", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  char *id ;
  int device ;
  int playback_count ;
  int capture_count ;
  struct snd_pcm **rpcm ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  id = 0U;
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& id), sizeof(char ),
                     sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& playback_count));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& capture_count));
  rpcm = 0U;
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& rpcm), sizeof(struct snd_pcm *),
                     sizeof(struct snd_pcm *));
  if (rpcm != 0U) {
    fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)rpcm, sizeof(struct snd_pcm ),
                       sizeof(struct snd_pcm ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_new(card, id, device, playback_count, capture_count, rpcm);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)id, sizeof(char ));
  }
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& playback_count), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& capture_count), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & rpcm);
  if (rpcm != 0U) {
    fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, rpcm);
  }
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_card_proc_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  char const   *name ;
  struct snd_info_entry **entryp ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  name = 0U;
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  entryp = 0U;
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& entryp), sizeof(struct snd_info_entry *),
                     sizeof(struct snd_info_entry *));
  if (entryp != 0U) {
    fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)entryp, sizeof(struct snd_info_entry ),
                       sizeof(struct snd_info_entry ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_card_proc_new(card, name, entryp);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("snd_card_proc_new", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & entryp);
  if (entryp != 0U) {
    fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, entryp);
  }
  fill_marshbuf("snd_card_proc_new", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_lib_free_pages(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_substream *substream ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  substream = 0U;
  fetch_marshbuf_ptr("snd_pcm_lib_free_pages", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_lib_free_pages(substream);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_lib_free_pages", & _buf_, & _off_, & substream);
  fill_marshbuf("snd_pcm_lib_free_pages", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_lib_preallocate_pages_for_all(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm *pcm ;
  int type ;
  void *data ;
  size_t size ;
  size_t max ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  pcm = 0U;
  fetch_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, (void **)(& pcm),
                     sizeof(struct snd_pcm ), sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(int ),
                 (void *)(& type));
  data = 0U;
  fetch_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, & data,
                     sizeof(void ), sizeof(void ));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& size));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& max));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_lib_preallocate_pages_for_all(pcm, type, data, size, max);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& type),
                sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, & data);
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& size),
                sizeof(unsigned long ));
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& max),
                sizeof(unsigned long ));
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__memset(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void *s ;
  int c ;
  size_t n ;
  void *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  s = 0U;
  fetch_marshbuf_ptr("memset", _buf_, & _off_, & s, sizeof(void ), sizeof(void ));
  fetch_marshbuf("memset", _buf_, & _off_, sizeof(int ), (void *)(& c));
  fetch_marshbuf("memset", _buf_, & _off_, sizeof(unsigned long ), (void *)(& n));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (void *)memset(s, c, n);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("memset", & _buf_, & _off_, & s);
  fill_marshbuf("memset", & _buf_, & _off_, (void *)(& c), sizeof(int ));
  fill_marshbuf("memset", & _buf_, & _off_, (void *)(& n), sizeof(unsigned long ));
  fill_marshbuf_ptr("memset", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____gameport_register_port(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct gameport *gameport ;
  struct module *owner ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  gameport = 0U;
  fetch_marshbuf_ptr("__gameport_register_port", _buf_, & _off_, (void **)(& gameport),
                     sizeof(struct gameport ), sizeof(struct gameport ));
  owner = 0U;
  fetch_marshbuf_ptr("__gameport_register_port", _buf_, & _off_, (void **)(& owner),
                     sizeof(struct module ), sizeof(struct module ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  __gameport_register_port(gameport, owner);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__gameport_register_port", & _buf_, & _off_, & gameport);
  fill_marshbuf_ptr("__gameport_register_port", & _buf_, & _off_, & owner);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__gameport_set_phys(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct gameport *gameport ;
  char const   *fmt ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  gameport = 0U;
  fetch_marshbuf_ptr("gameport_set_phys", _buf_, & _off_, (void **)(& gameport), sizeof(struct gameport ),
                     sizeof(struct gameport ));
  fmt = 0U;
  fetch_marshbuf_ptr("gameport_set_phys", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("gameport_set_phys", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  gameport_set_phys(gameport, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("gameport_set_phys", & _buf_, & _off_, & gameport);
  fill_marshbuf_ptr("gameport_set_phys", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("gameport_set_phys", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__release_and_free_resource(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct resource *res ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  res = 0U;
  fetch_marshbuf_ptr("release_and_free_resource", _buf_, & _off_, (void **)(& res),
                     sizeof(struct resource ), sizeof(struct resource ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  release_and_free_resource(res);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("release_and_free_resource", & _buf_, & _off_, & res);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_opl3_create(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  unsigned long l_port ;
  unsigned long r_port ;
  unsigned short hardware ;
  int integrated ;
  struct snd_opl3 **opl3 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_opl3_create", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_opl3_create", _buf_, & _off_, sizeof(unsigned long ), (void *)(& l_port));
  fetch_marshbuf("snd_opl3_create", _buf_, & _off_, sizeof(unsigned long ), (void *)(& r_port));
  fetch_marshbuf("snd_opl3_create", _buf_, & _off_, sizeof(unsigned short ), (void *)(& hardware));
  fetch_marshbuf("snd_opl3_create", _buf_, & _off_, sizeof(int ), (void *)(& integrated));
  opl3 = 0U;
  fetch_marshbuf_ptr("snd_opl3_create", _buf_, & _off_, (void **)(& opl3), sizeof(struct snd_opl3 *),
                     sizeof(struct snd_opl3 *));
  if (opl3 != 0U) {
    fetch_marshbuf_ptr("snd_opl3_create", _buf_, & _off_, (void **)opl3, sizeof(struct snd_opl3 ),
                       sizeof(struct snd_opl3 ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_opl3_create(card, l_port, r_port, hardware, integrated, opl3);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_opl3_create", & _buf_, & _off_, & card);
  fill_marshbuf("snd_opl3_create", & _buf_, & _off_, (void *)(& l_port), sizeof(unsigned long ));
  fill_marshbuf("snd_opl3_create", & _buf_, & _off_, (void *)(& r_port), sizeof(unsigned long ));
  fill_marshbuf("snd_opl3_create", & _buf_, & _off_, (void *)(& hardware), sizeof(unsigned short ));
  fill_marshbuf("snd_opl3_create", & _buf_, & _off_, (void *)(& integrated), sizeof(int ));
  fill_marshbuf_ptr("snd_opl3_create", & _buf_, & _off_, & opl3);
  if (opl3 != 0U) {
    fill_marshbuf_ptr("snd_opl3_create", & _buf_, & _off_, opl3);
  }
  fill_marshbuf("snd_opl3_create", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_suspend_all(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm *pcm ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  pcm = 0U;
  fetch_marshbuf_ptr("snd_pcm_suspend_all", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ),
                     sizeof(struct snd_pcm ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_suspend_all(pcm);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_suspend_all", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_suspend_all", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ctl_new1(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol_new  const  *kcontrolnew ;
  void *private_data ;
  struct snd_kcontrol *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  kcontrolnew = 0U;
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, (void **)(& kcontrolnew), sizeof(struct snd_kcontrol_new  const  ),
                     sizeof(struct snd_kcontrol_new  const  ));
  private_data = 0U;
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, & private_data, sizeof(void ),
                     sizeof(void ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct snd_kcontrol *)snd_ctl_new1(kcontrolnew, private_data);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & kcontrolnew);
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & private_data);
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_restore_state(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_restore_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_restore_state(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_restore_state", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_restore_state", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____mutex_init(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;
  char const   *name ;
  struct lock_class_key *key ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  name = 0U;
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__mutex_init", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  key = 0U;
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& key), sizeof(struct lock_class_key ),
                     sizeof(struct lock_class_key ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  __mutex_init(lock, name, key);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & lock);
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__mutex_init", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & key);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strcpy(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *dest ;
  char const   *src ;
  char *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dest = 0U;
  fetch_marshbuf_ptr("strcpy", _buf_, & _off_, (void **)(& dest), sizeof(char ), sizeof(char ));
  if (dest != 0U) {
    fetch_marshbuf("strcpy", _buf_, & _off_, sizeof(char ), (void *)dest);
  }
  src = 0U;
  fetch_marshbuf_ptr("strcpy", _buf_, & _off_, (void **)(& src), sizeof(char const   ),
                     sizeof(char const   ));
  if (src != 0U) {
    fetch_marshbuf("strcpy", _buf_, & _off_, sizeof(char const   ), (void *)src);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (char *)strcpy(dest, src);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strcpy", & _buf_, & _off_, & dest);
  if (dest != 0U) {
    fill_marshbuf("strcpy", & _buf_, & _off_, (void *)dest, sizeof(char ));
  }
  fill_marshbuf_ptr("strcpy", & _buf_, & _off_, & src);
  if (src != 0U) {
    fill_marshbuf("strcpy", & _buf_, & _off_, (void *)src, sizeof(char const   ));
  }
  fill_marshbuf_ptr("strcpy", & _buf_, & _off_, & _retval_);
  if (_retval_ != 0U) {
    fill_marshbuf("strcpy", & _buf_, & _off_, (void *)_retval_, sizeof(char ));
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_enable_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_enable_device", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_enable_device(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_enable_device", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_enable_device", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_dev_present(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_device_id  const  *ids ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ids = 0U;
  fetch_marshbuf_ptr("pci_dev_present", _buf_, & _off_, (void **)(& ids), sizeof(struct pci_device_id  const  ),
                     sizeof(struct pci_device_id  const  ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_dev_present(ids);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_dev_present", & _buf_, & _off_, & ids);
  fill_marshbuf("pci_dev_present", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____kmalloc(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  size_t size ;
  gfp_t flags ;
  void *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("__kmalloc", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fetch_marshbuf("__kmalloc", _buf_, & _off_, sizeof(unsigned int ), (void *)(& flags));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (void *)__kmalloc(size, flags);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("__kmalloc", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf("__kmalloc", & _buf_, & _off_, (void *)(& flags), sizeof(unsigned int ));
  fill_marshbuf_ptr("__kmalloc", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__free_irq(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  unsigned int arg0 ;
  void *arg1 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("free_irq", _buf_, & _off_, sizeof(unsigned int ), (void *)(& arg0));
  arg1 = 0U;
  fetch_marshbuf_ptr("free_irq", _buf_, & _off_, & arg1, sizeof(void ), sizeof(void ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  free_irq(arg0, arg1);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("free_irq", & _buf_, & _off_, (void *)(& arg0), sizeof(unsigned int ));
  fill_marshbuf_ptr("free_irq", & _buf_, & _off_, & arg1);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_disable_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_disable_device", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (dev != 0U) {
    fetch_marshbuf("pci_disable_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& dev->devfn));
    fetch_marshbuf_ptr("pci_disable_device", _buf_, & _off_, (void **)(& dev->bus),
                       sizeof(struct pci_bus ), sizeof(struct pci_bus ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  pci_disable_device(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_disable_device", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    fill_marshbuf("pci_disable_device", & _buf_, & _off_, (void *)(& dev->devfn),
                  sizeof(unsigned int ));
    fill_marshbuf_ptr("pci_disable_device", & _buf_, & _off_, & dev->bus);
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strlcpy(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *arg0 ;
  char const   *arg1 ;
  size_t arg2 ;
  size_t _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("strlcpy", _buf_, & _off_, (void **)(& arg0), sizeof(char ),
                     sizeof(char ));
  if (arg0 != 0U) {
    fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(char ), (void *)arg0);
  }
  arg1 = 0U;
  fetch_marshbuf_ptr("strlcpy", _buf_, & _off_, (void **)(& arg1), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg1 != 0U) {
    fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(char const   ), (void *)arg1);
  }
  fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg2));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (size_t )strlcpy(arg0, arg1, arg2);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strlcpy", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)arg0, sizeof(char ));
  }
  fill_marshbuf_ptr("strlcpy", & _buf_, & _off_, & arg1);
  if (arg1 != 0U) {
    fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)arg1, sizeof(char const   ));
  }
  fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)(& arg2), sizeof(unsigned long ));
  fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)(& _retval_), sizeof(unsigned long ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__mutex_unlock(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("mutex_unlock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  mutex_unlock(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("mutex_unlock", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_set_master(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct device *STRUCTADDRXdevdev ;
  int idx_arr28 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_set_master", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (dev != 0U) {
    tmp_fld6 = & dev->dev;
    tmp_lv5 = dev;
    nooks_ot_storeoffset_kern_w(dev, tmp_fld6 - tmp_lv5, sizeof(struct device ));
    STRUCTADDRXdevdev = & dev->dev;
    idx_arr28 = 0;
    while (idx_arr28 < 20) {
      fetch_marshbuf("pci_set_master", _buf_, & _off_, sizeof(char ), (void *)(& STRUCTADDRXdevdev->bus_id[idx_arr28]));
      idx_arr28 ++;
    }
    fetch_marshbuf("pci_set_master", _buf_, & _off_, sizeof(unsigned int ), (void *)(& dev->devfn));
    fetch_marshbuf_ptr("pci_set_master", _buf_, & _off_, (void **)(& dev->bus), sizeof(struct pci_bus ),
                       sizeof(struct pci_bus ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  pci_set_master(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_set_master", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    STRUCTADDRXdevdev = & dev->dev;
    idx_arr28 = 0;
    while (idx_arr28 < 20) {
      fill_marshbuf("pci_set_master", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdev->bus_id[idx_arr28]),
                    sizeof(char ));
      idx_arr28 ++;
    }
    fill_marshbuf("pci_set_master", & _buf_, & _off_, (void *)(& dev->devfn), sizeof(unsigned int ));
    fill_marshbuf_ptr("pci_set_master", & _buf_, & _off_, & dev->bus);
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ctl_add(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  struct snd_kcontrol *kcontrol ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& kcontrol), sizeof(struct snd_kcontrol ),
                     sizeof(struct snd_kcontrol ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_ctl_add(card, kcontrol);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & kcontrol);
  fill_marshbuf("snd_ctl_add", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____const_udelay(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  unsigned long xloops ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("__const_udelay", _buf_, & _off_, sizeof(unsigned long ), (void *)(& xloops));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  __const_udelay(xloops);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("__const_udelay", & _buf_, & _off_, (void *)(& xloops), sizeof(unsigned long ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strlen(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *s ;
  unsigned long _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  s = 0U;
  fetch_marshbuf_ptr("strlen", _buf_, & _off_, (void **)(& s), sizeof(char const   ),
                     sizeof(char const   ));
  if (s != 0U) {
    fetch_marshbuf("strlen", _buf_, & _off_, sizeof(char const   ), (void *)s);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (unsigned long )strlen(s);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strlen", & _buf_, & _off_, & s);
  if (s != 0U) {
    fill_marshbuf("strlen", & _buf_, & _off_, (void *)s, sizeof(char const   ));
  }
  fill_marshbuf("strlen", & _buf_, & _off_, (void *)(& _retval_), sizeof(unsigned long ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__request_irq(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  unsigned int arg0 ;
  irqreturn_t (*handler)(int  , void * ) ;
  unsigned long arg2 ;
  char const   *arg3 ;
  void *arg4 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(unsigned int ), (void *)(& arg0));
  handler = 0U;
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, (void **)(& handler), sizeof(irqreturn_t (int  ,
                                                                                              void * )),
                     sizeof(irqreturn_t (int  , void * )));
  fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg2));
  arg3 = 0U;
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, (void **)(& arg3), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg3 != 0U) {
    fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(char const   ), (void *)arg3);
  }
  arg4 = 0U;
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, & arg4, sizeof(void ), sizeof(void ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )request_irq(arg0, handler, arg2, arg3, arg4);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("request_irq", & _buf_, & _off_, (void *)(& arg0), sizeof(unsigned int ));
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & handler);
  fill_marshbuf("request_irq", & _buf_, & _off_, (void *)(& arg2), sizeof(unsigned long ));
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & arg3);
  if (arg3 != 0U) {
    fill_marshbuf("request_irq", & _buf_, & _off_, (void *)arg3, sizeof(char const   ));
  }
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & arg4);
  fill_marshbuf("request_irq", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____pci_register_driver(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_driver *arg0 ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct device_driver *STRUCTADDRXarg0driver ;
  int strlen10 ;
  struct module *arg1 ;
  char const   *mod_name ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg0), sizeof(struct pci_driver ),
                     sizeof(struct pci_driver ));
  if (arg0 != 0U) {
    tmp_fld6 = & arg0->dynids.list;
    tmp_lv5 = & arg0->dynids;
    nooks_ot_storeoffset_kern_w(& arg0->dynids, tmp_fld6 - tmp_lv5, sizeof(struct list_head ));
    tmp_fld6 = & arg0->dynids.lock;
    tmp_lv5 = & arg0->dynids;
    nooks_ot_storeoffset_kern_w(& arg0->dynids, tmp_fld6 - tmp_lv5, sizeof(spinlock_t ));
    tmp_fld6 = & arg0->driver;
    tmp_lv5 = arg0;
    nooks_ot_storeoffset_kern_w(arg0, tmp_fld6 - tmp_lv5, sizeof(struct device_driver ));
    STRUCTADDRXarg0driver = & arg0->driver;
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXarg0driver->name),
                       sizeof(char const   ), sizeof(char const   ));
    if (STRUCTADDRXarg0driver->name != 0U) {
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(int ), & strlen10);
      nooks_ot_alloc_arraymem_kern_w((void *)(& STRUCTADDRXarg0driver->name), strlen10,
                                     sizeof(char const   ), 0);
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, strlen10 * sizeof(char const   ),
                     (void *)STRUCTADDRXarg0driver->name);
    }
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXarg0driver->bus),
                       sizeof(struct bus_type ), sizeof(struct bus_type ));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXarg0driver->owner),
                       sizeof(struct module ), sizeof(struct module ));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg0->probe),
                       sizeof(int (struct pci_dev *dev , struct pci_device_id  const  *id )),
                       sizeof(int (struct pci_dev *dev , struct pci_device_id  const  *id )));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg0->name),
                       sizeof(char ), sizeof(char ));
    if (arg0->name != 0U) {
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(char ), (void *)arg0->name);
    }
  }
  arg1 = 0U;
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg1), sizeof(struct module ),
                     sizeof(struct module ));
  mod_name = 0U;
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& mod_name),
                     sizeof(char const   ), sizeof(char const   ));
  if (mod_name != 0U) {
    fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(char const   ),
                   (void *)mod_name);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )__pci_register_driver(arg0, arg1, mod_name);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    STRUCTADDRXarg0driver = & arg0->driver;
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXarg0driver->name);
    if (STRUCTADDRXarg0driver->name != 0U) {
      strlen10 = (int )strlen((void *)STRUCTADDRXarg0driver->name);
      strlen10 ++;
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, & strlen10, sizeof(int ));
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)STRUCTADDRXarg0driver->name,
                    strlen10 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXarg0driver->bus);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXarg0driver->owner);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg0->probe);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg0->name);
    if (arg0->name != 0U) {
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)arg0->name,
                    sizeof(char ));
    }
  }
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg1);
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & mod_name);
  if (mod_name != 0U) {
    fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)mod_name, sizeof(char const   ));
  }
  fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_hw_constraint_minmax(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_runtime *runtime ;
  snd_pcm_hw_param_t var ;
  unsigned int min ;
  unsigned int max ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  runtime = 0U;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_minmax", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ), sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(int ), (void *)(& var));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& min));
  fetch_marshbuf("snd_pcm_hw_constraint_minmax", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& max));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_hw_constraint_minmax(runtime, var, min, max);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& var),
                sizeof(int ));
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& min),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& max),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_minmax", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_card_free(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_card_free", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_card_free(card);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_card_free", & _buf_, & _off_, & card);
  fill_marshbuf("snd_card_free", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__pci_save_state(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct pci_dev *dev ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("pci_save_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )pci_save_state(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("pci_save_state", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_save_state", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_format_width(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  snd_pcm_format_t format ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("snd_pcm_format_width", _buf_, & _off_, sizeof(int ), (void *)(& format));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_format_width(format);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("snd_pcm_format_width", & _buf_, & _off_, (void *)(& format), sizeof(int ));
  fill_marshbuf("snd_pcm_format_width", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_period_elapsed(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_substream *substream ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  substream = 0U;
  fetch_marshbuf_ptr("snd_pcm_period_elapsed", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  snd_pcm_period_elapsed(substream);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_period_elapsed", & _buf_, & _off_, & substream);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ctl_notify(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  unsigned int mask ;
  struct snd_ctl_elem_id *id ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_ctl_notify", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_ctl_notify", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mask));
  id = 0U;
  fetch_marshbuf_ptr("snd_ctl_notify", _buf_, & _off_, (void **)(& id), sizeof(struct snd_ctl_elem_id ),
                     sizeof(struct snd_ctl_elem_id ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  snd_ctl_notify(card, mask, id);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_ctl_notify", & _buf_, & _off_, & card);
  fill_marshbuf("snd_ctl_notify", & _buf_, & _off_, (void *)(& mask), sizeof(unsigned int ));
  fill_marshbuf_ptr("snd_ctl_notify", & _buf_, & _off_, & id);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____request_region(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct resource *arg0 ;
  resource_size_t start ;
  resource_size_t n ;
  char const   *name ;
  int flags ;
  struct resource *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("__request_region", _buf_, & _off_, (void **)(& arg0), sizeof(struct resource ),
                     sizeof(struct resource ));
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& start));
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& n));
  name = 0U;
  fetch_marshbuf_ptr("__request_region", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(int ), (void *)(& flags));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct resource *)__request_region(arg0, start, n, name, flags);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__request_region", & _buf_, & _off_, & arg0);
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& start), sizeof(unsigned long long ));
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& n), sizeof(unsigned long long ));
  fill_marshbuf_ptr("__request_region", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__request_region", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& flags), sizeof(int ));
  fill_marshbuf_ptr("__request_region", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_set_ops(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm *pcm ;
  int direction ;
  struct snd_pcm_ops *ops ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  pcm = 0U;
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ),
                     sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_set_ops", _buf_, & _off_, sizeof(int ), (void *)(& direction));
  ops = 0U;
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_pcm_ops ),
                     sizeof(struct snd_pcm_ops ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  snd_pcm_set_ops(pcm, direction, ops);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_set_ops", & _buf_, & _off_, (void *)(& direction), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & ops);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_card_disconnect(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_card_disconnect", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_card_disconnect(card);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_card_disconnect", & _buf_, & _off_, & card);
  fill_marshbuf("snd_card_disconnect", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_device_new(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  snd_device_type_t type ;
  void *device_data ;
  struct snd_device_ops *ops ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_device_new", _buf_, & _off_, sizeof(int ), (void *)(& type));
  device_data = 0U;
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, & device_data, sizeof(void ),
                     sizeof(void ));
  ops = 0U;
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_device_ops ),
                     sizeof(struct snd_device_ops ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_device_new(card, type, device_data, ops);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & card);
  fill_marshbuf("snd_device_new", & _buf_, & _off_, (void *)(& type), sizeof(int ));
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & device_data);
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & ops);
  fill_marshbuf("snd_device_new", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__kfree(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void const   *arg0 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("kfree", _buf_, & _off_, (void **)(& arg0), sizeof(void const   ),
                     sizeof(void const   ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  kfree(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("kfree", & _buf_, & _off_, & arg0);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_pcm_hw_constraint_msbits(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_runtime *runtime ;
  unsigned int cond ;
  unsigned int width ;
  unsigned int msbits ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  runtime = 0U;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_msbits", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ), sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_msbits", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& cond));
  fetch_marshbuf("snd_pcm_hw_constraint_msbits", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& width));
  fetch_marshbuf("snd_pcm_hw_constraint_msbits", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& msbits));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_pcm_hw_constraint_msbits(runtime, cond, width, msbits);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_msbits", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_msbits", & _buf_, & _off_, (void *)(& cond),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_msbits", & _buf_, & _off_, (void *)(& width),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_msbits", & _buf_, & _off_, (void *)(& msbits),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_msbits", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__mutex_lock(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("mutex_lock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  mutex_lock(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("mutex_lock", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__sprintf(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *buf ;
  char const   *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  buf = 0U;
  fetch_marshbuf_ptr("sprintf", _buf_, & _off_, (void **)(& buf), sizeof(char ), sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("sprintf", _buf_, & _off_, sizeof(char ), (void *)buf);
  }
  fmt = 0U;
  fetch_marshbuf_ptr("sprintf", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("sprintf", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )sprintf(buf, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("sprintf", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    fill_marshbuf("sprintf", & _buf_, & _off_, (void *)buf, sizeof(char ));
  }
  fill_marshbuf_ptr("sprintf", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("sprintf", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  fill_marshbuf("sprintf", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_card_register(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_card *card ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  card = 0U;
  fetch_marshbuf_ptr("snd_card_register", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snd_card_register(card);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snd_card_register", & _buf_, & _off_, & card);
  fill_marshbuf("snd_card_register", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
extern int disp_kern(char *function_name , struct req_args *rqargs ) 
{ 
  struct marshret_struct retval ;

  {
  retval.buf = 0U;
  if (rqargs->function_id == 1299) {
    __MARSH_WRAP__snd_opl3_hwdep_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1163) {
    __MARSH_WRAP__pci_unregister_driver(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1162) {
    __MARSH_WRAP__pci_set_power_state(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1181) {
    __MARSH_WRAP__snd_card_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1296) {
    __MARSH_WRAP__snd_mpu401_uart_interrupt(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1401) {
    __MARSH_WRAP__strcmp(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1156) {
    __MARSH_WRAP__pci_release_regions(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1165) {
    __MARSH_WRAP__printk(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1306) {
    __MARSH_WRAP__snd_pcm_lib_malloc_pages(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1101) {
    __MARSH_WRAP__gameport_unregister_port(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1068) {
    __MARSH_WRAP___spin_lock_irq(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1301) {
    __MARSH_WRAP__snd_pcm_hw_constraint_list(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1295) {
    __MARSH_WRAP__snd_iprintf(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1064) {
    __MARSH_WRAP____wake_up(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1297) {
    __MARSH_WRAP__snd_mpu401_uart_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1131) {
    __MARSH_WRAP__msleep(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1157) {
    __MARSH_WRAP__pci_request_regions(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1290) {
    __MARSH_WRAP__snd_ctl_find_id(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1150) {
    __MARSH_WRAP__pci_choose_state(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1067) {
    __MARSH_WRAP___spin_lock(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1308) {
    __MARSH_WRAP__snd_pcm_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1182) {
    __MARSH_WRAP__snd_card_proc_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1304) {
    __MARSH_WRAP__snd_pcm_lib_free_pages(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1307) {
    __MARSH_WRAP__snd_pcm_lib_preallocate_pages_for_all(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1129) {
    __MARSH_WRAP__memset(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1040) {
    __MARSH_WRAP____gameport_register_port(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1100) {
    __MARSH_WRAP__gameport_set_phys(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1170) {
    __MARSH_WRAP__release_and_free_resource(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1298) {
    __MARSH_WRAP__snd_opl3_create(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1311) {
    __MARSH_WRAP__snd_pcm_suspend_all(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1291) {
    __MARSH_WRAP__snd_ctl_new1(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1158) {
    __MARSH_WRAP__pci_restore_state(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1043) {
    __MARSH_WRAP____mutex_init(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1402) {
    __MARSH_WRAP__strcpy(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1153) {
    __MARSH_WRAP__pci_enable_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1151) {
    __MARSH_WRAP__pci_dev_present(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1042) {
    __MARSH_WRAP____kmalloc(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1096) {
    __MARSH_WRAP__free_irq(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1152) {
    __MARSH_WRAP__pci_disable_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1403) {
    __MARSH_WRAP__strlcpy(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1133) {
    __MARSH_WRAP__mutex_unlock(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1161) {
    __MARSH_WRAP__pci_set_master(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1288) {
    __MARSH_WRAP__snd_ctl_add(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1039) {
    __MARSH_WRAP____const_udelay(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1404) {
    __MARSH_WRAP__strlen(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1171) {
    __MARSH_WRAP__request_irq(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1058) {
    __MARSH_WRAP____pci_register_driver(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1302) {
    __MARSH_WRAP__snd_pcm_hw_constraint_minmax(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1180) {
    __MARSH_WRAP__snd_card_free(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1159) {
    __MARSH_WRAP__pci_save_state(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1300) {
    __MARSH_WRAP__snd_pcm_format_width(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1309) {
    __MARSH_WRAP__snd_pcm_period_elapsed(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1292) {
    __MARSH_WRAP__snd_ctl_notify(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1060) {
    __MARSH_WRAP____request_region(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1310) {
    __MARSH_WRAP__snd_pcm_set_ops(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1179) {
    __MARSH_WRAP__snd_card_disconnect(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1293) {
    __MARSH_WRAP__snd_device_new(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1120) {
    __MARSH_WRAP__kfree(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1303) {
    __MARSH_WRAP__snd_pcm_hw_constraint_msbits(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1132) {
    __MARSH_WRAP__mutex_lock(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1314) {
    __MARSH_WRAP__sprintf(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1183) {
    __MARSH_WRAP__snd_card_register(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  return (1);
}
}
void register_functions(void) 
{ 


  {
  nooks_ot_register_kernfn_w(param_set_int, 1148);
  nooks_ot_register_kernfn_w(param_get_int, 1144);
  nooks_ot_register_kernfn_w(param_set_long, 1149);
  nooks_ot_register_kernfn_w(param_get_long, 1145);
  nooks_ot_register_kernfn_w(param_set_charp, 1147);
  nooks_ot_register_kernfn_w(param_get_charp, 1143);
  nooks_ot_register_kernfn_w(param_set_bool, 1146);
  nooks_ot_register_kernfn_w(param_get_bool, 1142);
  nooks_ot_register_kernfn_w(param_array_set, 1141);
  nooks_ot_register_kernfn_w(param_array_get, 1140);
  nooks_ot_register_kernfn_w(snd_ctl_boolean_mono_info, 1289);
  nooks_ot_register_kernfn_w(snd_pcm_lib_ioctl, 1305);
}
}
void register_globals(void) 
{ 


  {
  nooks_ot_register_kernfn_w(str_782745852, 1390);
  nooks_ot_register_kernfn_w(__param_str_mpu_port, 1056);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_in_sel1, 1085);
  nooks_ot_register_kernfn_w(str_10, 1320);
  nooks_ot_register_kernfn_w(& snd_cmipci_modem_switch, 1228);
  nooks_ot_register_kernfn_w(str_205040111, 1341);
  nooks_ot_register_kernfn_w(str_147350971, 1334);
  nooks_ot_register_kernfn_w(& __param_arr_id, 1046);
  nooks_ot_register_kernfn_w(str_287061104, 1347);
  nooks_ot_register_kernfn_w(str_235676013, 1343);
  nooks_ot_register_kernfn_w(& __param_arr_soft_ac3, 1050);
  nooks_ot_register_kernfn_w(str_367676234, 1351);
  nooks_ot_register_kernfn_w(id, 1111);
  nooks_ot_register_kernfn_w(str_623789268, 1378);
  nooks_ot_register_kernfn_w(& snd_cmipci_playback2_ops, 1241);
  nooks_ot_register_kernfn_w(str_745591601, 1388);
  nooks_ot_register_kernfn_w(str_338056805, 1350);
  nooks_ot_register_kernfn_w(rates, 1168);
  nooks_ot_register_kernfn_w(str_122865562, 1328);
  nooks_ot_register_kernfn_w(& ioport_resource, 1118);
  nooks_ot_register_kernfn_w(__param_str_fm_port, 1052);
  nooks_ot_register_kernfn_w(str_10834194, 1326);
  nooks_ot_register_kernfn_w(ports, 1164);
  nooks_ot_register_kernfn_w(str_459204435, 1364);
  nooks_ot_register_kernfn_w(texts___0, 1406);
  nooks_ot_register_kernfn_w(str_488424356, 1368);
  nooks_ot_register_kernfn_w(str_82022903, 1392);
  nooks_ot_register_kernfn_w(snd_cmipci_ids, 1212);
  nooks_ot_register_kernfn_w(str_293594775, 1348);
  nooks_ot_register_kernfn_w(__param_str_index, 1054);
  nooks_ot_register_kernfn_w(str_260101403, 1346);
  nooks_ot_register_kernfn_w(str_487403672, 1367);
  nooks_ot_register_kernfn_w(str_129101994, 1330);
  nooks_ot_register_kernfn_w(joystick_port, 1119);
  nooks_ot_register_kernfn_w(str_1012473204, 1321);
  nooks_ot_register_kernfn_w(str_377684264, 1353);
  nooks_ot_register_kernfn_w(mpu_port, 1130);
  nooks_ot_register_kernfn_w(str_247204062, 1345);
  nooks_ot_register_kernfn_w(& snd_cmipci_capture_ops, 1187);
  nooks_ot_register_kernfn_w(str_181451256, 1339);
  nooks_ot_register_kernfn_w(str_1053863758, 1324);
  nooks_ot_register_kernfn_w(cm_saved_mixer, 1073);
  nooks_ot_register_kernfn_w(str_88429757, 1397);
  nooks_ot_register_kernfn_w(__param_str_soft_ac3, 1057);
  nooks_ot_register_kernfn_w(str_1050924700, 1323);
  nooks_ot_register_kernfn_w(str_970171951, 1400);
  nooks_ot_register_kernfn_w(str_824495312, 1393);
  nooks_ot_register_kernfn_w(str_482017502, 1366);
  nooks_ot_register_kernfn_w(str_436717668, 1358);
  nooks_ot_register_kernfn_w(& snd_cmipci_capture_spdif_ops, 1193);
  nooks_ot_register_kernfn_w(str_240831266, 1344);
  nooks_ot_register_kernfn_w(str_645250580, 1382);
  nooks_ot_register_kernfn_w(str_163141482, 1336);
  nooks_ot_register_kernfn_w(str_122695140, 1327);
  nooks_ot_register_kernfn_w(str_573849695, 1374);
  nooks_ot_register_kernfn_w(& snd_cmipci_spdif_default, 1269);
  nooks_ot_register_kernfn_w(str_537495551, 1372);
  nooks_ot_register_kernfn_w(hw_channels, 1105);
  nooks_ot_register_kernfn_w(snd_cmipci_mixer_switches, 1225);
  nooks_ot_register_kernfn_w(texts, 1405);
  nooks_ot_register_kernfn_w(str_908489522, 1398);
  nooks_ot_register_kernfn_w(str_682558423, 1383);
  nooks_ot_register_kernfn_w(str_171248176, 1337);
  nooks_ot_register_kernfn_w(index, 1113);
  nooks_ot_register_kernfn_w(str_184869755, 1340);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_modem, 1077);
  nooks_ot_register_kernfn_w(str_15552, 1335);
  nooks_ot_register_kernfn_w(str_629297690, 1380);
  nooks_ot_register_kernfn_w(str_450144620, 1362);
  nooks_ot_register_kernfn_w(& snd_cmipci_playback_ops, 1245);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_fourch, 1076);
  nooks_ot_register_kernfn_w(str_49675815, 1369);
  nooks_ot_register_kernfn_w(str_131426595, 1332);
  nooks_ot_register_kernfn_w(str_385748318, 1354);
  nooks_ot_register_kernfn_w(& snd_cmipci_spdif_mask, 1273);
  nooks_ot_register_kernfn_w(snd_cmipci_mixers, 1227);
  nooks_ot_register_kernfn_w(str_1061823061, 1325);
  nooks_ot_register_kernfn_w(__param_str_id, 1053);
  nooks_ot_register_kernfn_w(str_851541551, 1395);
  nooks_ot_register_kernfn_w(str_916388850, 1399);
  nooks_ot_register_kernfn_w(& __param_arr_enable, 1044);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_exchange_dac, 1075);
  nooks_ot_register_kernfn_w(str_799428759, 1391);
  nooks_ot_register_kernfn_w(soft_ac3, 1313);
  nooks_ot_register_kernfn_w(str_532174899, 1370);
  nooks_ot_register_kernfn_w(& hw_constraints_channels_4, 1106);
  nooks_ot_register_kernfn_w(str_857948405, 1396);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdi_monitor, 1078);
  nooks_ot_register_kernfn_w(str_449269183, 1361);
  nooks_ot_register_kernfn_w(enable, 1094);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdi_phase, 1079);
  nooks_ot_register_kernfn_w(str_533589931, 1371);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdo_5v, 1089);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdi_phase2, 1080);
  nooks_ot_register_kernfn_w(str_29932487, 1349);
  nooks_ot_register_kernfn_w(str_1033184297, 1322);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_loop, 1087);
  nooks_ot_register_kernfn_w(str_701583115, 1387);
  nooks_ot_register_kernfn_w(rate_constraints, 1167);
  nooks_ot_register_kernfn_w(str_5821155, 1375);
  nooks_ot_register_kernfn_w(str_131425151, 1331);
  nooks_ot_register_kernfn_w(str_425593287, 1356);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_dac_out, 1083);
  nooks_ot_register_kernfn_w(& ops, 1136);
  nooks_ot_register_kernfn_w(str_541433933, 1373);
  nooks_ot_register_kernfn_w(str_465611289, 1365);
  nooks_ot_register_kernfn_w(str_43107761, 1357);
  nooks_ot_register_kernfn_w(& snd_cmipci_playback_spdif_ops, 1250);
  nooks_ot_register_kernfn_w(str_235265470, 1342);
  nooks_ot_register_kernfn_w(& __param_arr_mpu_port, 1049);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdi_valid, 1081);
  nooks_ot_register_kernfn_w(str_61353136, 1377);
  nooks_ot_register_kernfn_w(& __this_module, 1062);
  nooks_ot_register_kernfn_w(& __param_arr_index, 1047);
  nooks_ot_register_kernfn_w(str_689470853, 1385);
  nooks_ot_register_kernfn_w(& hw_constraints_channels_6, 1107);
  nooks_ot_register_kernfn_w(saved_regs, 1175);
  nooks_ot_register_kernfn_w(saved_mixers, 1174);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_copyright, 1082);
  nooks_ot_register_kernfn_w(str_442862329, 1359);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdo2dac, 1088);
  nooks_ot_register_kernfn_w(str_13950841, 1333);
  nooks_ot_register_kernfn_w(& driver, 1093);
  nooks_ot_register_kernfn_w(snd_cmipci_extra_mixer_switches, 1203);
  nooks_ot_register_kernfn_w(& __key___0, 1041);
  nooks_ot_register_kernfn_w(str_4442453, 1360);
  nooks_ot_register_kernfn_w(& snd_cmipci_nomulti_switch, 1229);
  nooks_ot_register_kernfn_w(str_420826266, 1355);
  nooks_ot_register_kernfn_w(& __param_arr_fm_port, 1045);
  nooks_ot_register_kernfn_w(str_695176261, 1386);
  nooks_ot_register_kernfn_w(& __param_arr_joystick_port, 1048);
  nooks_ot_register_kernfn_w(__param_str_joystick_port, 1055);
  nooks_ot_register_kernfn_w(str_375887647, 1352);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_enable, 1084);
  nooks_ot_register_kernfn_w(str_176464283, 1338);
  nooks_ot_register_kernfn_w(str_582694837, 1376);
  nooks_ot_register_kernfn_w(str_851283624, 1394);
  nooks_ot_register_kernfn_w(__param_str_enable, 1051);
  nooks_ot_register_kernfn_w(str_751998455, 1389);
  nooks_ot_register_kernfn_w(str_625602805, 1379);
  nooks_ot_register_kernfn_w(snd_cmipci_old_mixer_switches, 1230);
  nooks_ot_register_kernfn_w(intel_82437vx, 1116);
  nooks_ot_register_kernfn_w(& hw_constraints_rates, 1109);
  nooks_ot_register_kernfn_w(& cmipci_switch_arg_spdif_in_sel2, 1086);
  nooks_ot_register_kernfn_w(str_6417578, 1381);
  nooks_ot_register_kernfn_w(& snd_cmipci_spdif_stream, 1276);
  nooks_ot_register_kernfn_w(snd_cmipci_8738_mixer_switches, 1184);
  nooks_ot_register_kernfn_w(str_124421908, 1329);
  nooks_ot_register_kernfn_w(str_683063999, 1384);
  nooks_ot_register_kernfn_w(fm_port, 1095);
  nooks_ot_register_kernfn_w(& hw_constraints_channels_8, 1108);
  nooks_ot_register_kernfn_w(str_453010511, 1363);
}
}
