/* Generated by CIL v. 1.4.0 */
/* print_CIL_Input is true */

#include "../../common/slave_top.h" // Matt E1
int disp_kern(char *function_name , struct req_args *rqargs ) ;
char function_id_map[1348][128]  = 
  {      "0", 
        "1", 
        "2", 
        "3", 
        "4", 
        "5", 
        "6", 
        "7", 
        "8", 
        "9", 
        "10", 
        "11", 
        "12", 
        "13", 
        "14", 
        "15", 
        "16", 
        "17", 
        "18", 
        "19", 
        "20", 
        "21", 
        "22", 
        "23", 
        "24", 
        "25", 
        "26", 
        "27", 
        "28", 
        "29", 
        "30", 
        "31", 
        "32", 
        "33", 
        "34", 
        "35", 
        "36", 
        "37", 
        "38", 
        "39", 
        "40", 
        "41", 
        "42", 
        "43", 
        "44", 
        "45", 
        "46", 
        "47", 
        "48", 
        "49", 
        "50", 
        "51", 
        "52", 
        "53", 
        "54", 
        "55", 
        "56", 
        "57", 
        "58", 
        "59", 
        "60", 
        "61", 
        "62", 
        "63", 
        "64", 
        "65", 
        "66", 
        "67", 
        "68", 
        "69", 
        "70", 
        "71", 
        "72", 
        "73", 
        "74", 
        "75", 
        "76", 
        "77", 
        "78", 
        "79", 
        "80", 
        "81", 
        "82", 
        "83", 
        "84", 
        "85", 
        "86", 
        "87", 
        "88", 
        "89", 
        "90", 
        "91", 
        "92", 
        "93", 
        "94", 
        "95", 
        "96", 
        "97", 
        "98", 
        "99", 
        "100", 
        "101", 
        "102", 
        "103", 
        "104", 
        "105", 
        "106", 
        "107", 
        "108", 
        "109", 
        "110", 
        "111", 
        "112", 
        "113", 
        "114", 
        "115", 
        "116", 
        "117", 
        "118", 
        "119", 
        "120", 
        "121", 
        "122", 
        "123", 
        "124", 
        "125", 
        "126", 
        "127", 
        "128", 
        "129", 
        "130", 
        "131", 
        "132", 
        "133", 
        "134", 
        "135", 
        "136", 
        "137", 
        "138", 
        "139", 
        "140", 
        "141", 
        "142", 
        "143", 
        "144", 
        "145", 
        "146", 
        "147", 
        "148", 
        "149", 
        "150", 
        "151", 
        "152", 
        "153", 
        "154", 
        "155", 
        "156", 
        "157", 
        "158", 
        "159", 
        "160", 
        "161", 
        "162", 
        "163", 
        "164", 
        "165", 
        "166", 
        "167", 
        "168", 
        "169", 
        "170", 
        "171", 
        "172", 
        "173", 
        "174", 
        "175", 
        "176", 
        "177", 
        "178", 
        "179", 
        "180", 
        "181", 
        "182", 
        "183", 
        "184", 
        "185", 
        "186", 
        "187", 
        "188", 
        "189", 
        "190", 
        "191", 
        "192", 
        "193", 
        "194", 
        "195", 
        "196", 
        "197", 
        "198", 
        "199", 
        "200", 
        "201", 
        "202", 
        "203", 
        "204", 
        "205", 
        "206", 
        "207", 
        "208", 
        "209", 
        "210", 
        "211", 
        "212", 
        "213", 
        "214", 
        "215", 
        "216", 
        "217", 
        "218", 
        "219", 
        "220", 
        "221", 
        "222", 
        "223", 
        "224", 
        "225", 
        "226", 
        "227", 
        "228", 
        "229", 
        "230", 
        "231", 
        "232", 
        "233", 
        "234", 
        "235", 
        "236", 
        "237", 
        "238", 
        "239", 
        "240", 
        "241", 
        "242", 
        "243", 
        "244", 
        "245", 
        "246", 
        "247", 
        "248", 
        "249", 
        "250", 
        "251", 
        "252", 
        "253", 
        "254", 
        "255", 
        "256", 
        "257", 
        "258", 
        "259", 
        "260", 
        "261", 
        "262", 
        "263", 
        "264", 
        "265", 
        "266", 
        "267", 
        "268", 
        "269", 
        "270", 
        "271", 
        "272", 
        "273", 
        "274", 
        "275", 
        "276", 
        "277", 
        "278", 
        "279", 
        "280", 
        "281", 
        "282", 
        "283", 
        "284", 
        "285", 
        "286", 
        "287", 
        "288", 
        "289", 
        "290", 
        "291", 
        "292", 
        "293", 
        "294", 
        "295", 
        "296", 
        "297", 
        "298", 
        "299", 
        "300", 
        "301", 
        "302", 
        "303", 
        "304", 
        "305", 
        "306", 
        "307", 
        "308", 
        "309", 
        "310", 
        "311", 
        "312", 
        "313", 
        "314", 
        "315", 
        "316", 
        "317", 
        "318", 
        "319", 
        "320", 
        "321", 
        "322", 
        "323", 
        "324", 
        "325", 
        "326", 
        "327", 
        "328", 
        "329", 
        "330", 
        "331", 
        "332", 
        "333", 
        "334", 
        "335", 
        "336", 
        "337", 
        "338", 
        "339", 
        "340", 
        "341", 
        "342", 
        "343", 
        "344", 
        "345", 
        "346", 
        "347", 
        "348", 
        "349", 
        "350", 
        "351", 
        "352", 
        "353", 
        "354", 
        "355", 
        "356", 
        "357", 
        "358", 
        "359", 
        "360", 
        "361", 
        "362", 
        "363", 
        "364", 
        "365", 
        "366", 
        "367", 
        "368", 
        "369", 
        "370", 
        "371", 
        "372", 
        "373", 
        "374", 
        "375", 
        "376", 
        "377", 
        "378", 
        "379", 
        "380", 
        "381", 
        "382", 
        "383", 
        "384", 
        "385", 
        "386", 
        "387", 
        "388", 
        "389", 
        "390", 
        "391", 
        "392", 
        "393", 
        "394", 
        "395", 
        "396", 
        "397", 
        "398", 
        "399", 
        "400", 
        "401", 
        "402", 
        "403", 
        "404", 
        "405", 
        "406", 
        "407", 
        "408", 
        "409", 
        "410", 
        "411", 
        "412", 
        "413", 
        "414", 
        "415", 
        "416", 
        "417", 
        "418", 
        "419", 
        "420", 
        "421", 
        "422", 
        "423", 
        "424", 
        "425", 
        "426", 
        "427", 
        "428", 
        "429", 
        "430", 
        "431", 
        "432", 
        "433", 
        "434", 
        "435", 
        "436", 
        "437", 
        "438", 
        "439", 
        "440", 
        "441", 
        "442", 
        "443", 
        "444", 
        "445", 
        "446", 
        "447", 
        "448", 
        "449", 
        "450", 
        "451", 
        "452", 
        "453", 
        "454", 
        "455", 
        "456", 
        "457", 
        "458", 
        "459", 
        "460", 
        "461", 
        "462", 
        "463", 
        "464", 
        "465", 
        "466", 
        "467", 
        "468", 
        "469", 
        "470", 
        "471", 
        "472", 
        "473", 
        "474", 
        "475", 
        "476", 
        "477", 
        "478", 
        "479", 
        "480", 
        "481", 
        "482", 
        "483", 
        "484", 
        "485", 
        "486", 
        "487", 
        "488", 
        "489", 
        "490", 
        "491", 
        "492", 
        "493", 
        "494", 
        "495", 
        "496", 
        "497", 
        "498", 
        "499", 
        "500", 
        "501", 
        "502", 
        "503", 
        "504", 
        "505", 
        "506", 
        "507", 
        "508", 
        "509", 
        "510", 
        "511", 
        "512", 
        "513", 
        "514", 
        "515", 
        "516", 
        "517", 
        "518", 
        "519", 
        "520", 
        "521", 
        "522", 
        "523", 
        "524", 
        "525", 
        "526", 
        "527", 
        "528", 
        "529", 
        "530", 
        "531", 
        "532", 
        "533", 
        "534", 
        "535", 
        "536", 
        "537", 
        "538", 
        "539", 
        "540", 
        "541", 
        "542", 
        "543", 
        "544", 
        "545", 
        "546", 
        "547", 
        "548", 
        "549", 
        "550", 
        "551", 
        "552", 
        "553", 
        "554", 
        "555", 
        "556", 
        "557", 
        "558", 
        "559", 
        "560", 
        "561", 
        "562", 
        "563", 
        "564", 
        "565", 
        "566", 
        "567", 
        "568", 
        "569", 
        "570", 
        "571", 
        "572", 
        "573", 
        "574", 
        "575", 
        "576", 
        "577", 
        "578", 
        "579", 
        "580", 
        "581", 
        "582", 
        "583", 
        "584", 
        "585", 
        "586", 
        "587", 
        "588", 
        "589", 
        "590", 
        "591", 
        "592", 
        "593", 
        "594", 
        "595", 
        "596", 
        "597", 
        "598", 
        "599", 
        "600", 
        "601", 
        "602", 
        "603", 
        "604", 
        "605", 
        "606", 
        "607", 
        "608", 
        "609", 
        "610", 
        "611", 
        "612", 
        "613", 
        "614", 
        "615", 
        "616", 
        "617", 
        "618", 
        "619", 
        "620", 
        "621", 
        "622", 
        "623", 
        "624", 
        "625", 
        "626", 
        "627", 
        "628", 
        "629", 
        "630", 
        "631", 
        "632", 
        "633", 
        "634", 
        "635", 
        "636", 
        "637", 
        "638", 
        "639", 
        "640", 
        "641", 
        "642", 
        "643", 
        "644", 
        "645", 
        "646", 
        "647", 
        "648", 
        "649", 
        "650", 
        "651", 
        "652", 
        "653", 
        "654", 
        "655", 
        "656", 
        "657", 
        "658", 
        "659", 
        "660", 
        "661", 
        "662", 
        "663", 
        "664", 
        "665", 
        "666", 
        "667", 
        "668", 
        "669", 
        "670", 
        "671", 
        "672", 
        "673", 
        "674", 
        "675", 
        "676", 
        "677", 
        "678", 
        "679", 
        "680", 
        "681", 
        "682", 
        "683", 
        "684", 
        "685", 
        "686", 
        "687", 
        "688", 
        "689", 
        "690", 
        "691", 
        "692", 
        "693", 
        "694", 
        "695", 
        "696", 
        "697", 
        "698", 
        "699", 
        "700", 
        "701", 
        "702", 
        "703", 
        "704", 
        "705", 
        "706", 
        "707", 
        "708", 
        "709", 
        "710", 
        "711", 
        "712", 
        "713", 
        "714", 
        "715", 
        "716", 
        "717", 
        "718", 
        "719", 
        "720", 
        "721", 
        "722", 
        "723", 
        "724", 
        "725", 
        "726", 
        "727", 
        "728", 
        "729", 
        "730", 
        "731", 
        "732", 
        "733", 
        "734", 
        "735", 
        "736", 
        "737", 
        "738", 
        "739", 
        "740", 
        "741", 
        "742", 
        "743", 
        "744", 
        "745", 
        "746", 
        "747", 
        "748", 
        "749", 
        "750", 
        "751", 
        "752", 
        "753", 
        "754", 
        "755", 
        "756", 
        "757", 
        "758", 
        "759", 
        "760", 
        "761", 
        "762", 
        "763", 
        "764", 
        "765", 
        "766", 
        "767", 
        "768", 
        "769", 
        "770", 
        "771", 
        "772", 
        "773", 
        "774", 
        "775", 
        "776", 
        "777", 
        "778", 
        "779", 
        "780", 
        "781", 
        "782", 
        "783", 
        "784", 
        "785", 
        "786", 
        "787", 
        "788", 
        "789", 
        "790", 
        "791", 
        "792", 
        "793", 
        "794", 
        "795", 
        "796", 
        "797", 
        "798", 
        "799", 
        "800", 
        "801", 
        "802", 
        "803", 
        "804", 
        "805", 
        "806", 
        "807", 
        "808", 
        "809", 
        "810", 
        "811", 
        "812", 
        "813", 
        "814", 
        "815", 
        "816", 
        "817", 
        "818", 
        "819", 
        "820", 
        "821", 
        "822", 
        "823", 
        "824", 
        "825", 
        "826", 
        "827", 
        "828", 
        "829", 
        "830", 
        "831", 
        "832", 
        "833", 
        "834", 
        "835", 
        "836", 
        "837", 
        "838", 
        "839", 
        "840", 
        "841", 
        "842", 
        "843", 
        "844", 
        "845", 
        "846", 
        "847", 
        "848", 
        "849", 
        "850", 
        "851", 
        "852", 
        "853", 
        "854", 
        "855", 
        "856", 
        "857", 
        "858", 
        "859", 
        "860", 
        "861", 
        "862", 
        "863", 
        "864", 
        "865", 
        "866", 
        "867", 
        "868", 
        "869", 
        "870", 
        "871", 
        "872", 
        "873", 
        "874", 
        "875", 
        "876", 
        "877", 
        "878", 
        "879", 
        "880", 
        "881", 
        "882", 
        "883", 
        "884", 
        "885", 
        "886", 
        "887", 
        "888", 
        "889", 
        "890", 
        "891", 
        "892", 
        "893", 
        "894", 
        "895", 
        "896", 
        "897", 
        "898", 
        "899", 
        "900", 
        "901", 
        "902", 
        "903", 
        "904", 
        "905", 
        "906", 
        "907", 
        "908", 
        "909", 
        "910", 
        "911", 
        "912", 
        "913", 
        "914", 
        "915", 
        "916", 
        "917", 
        "918", 
        "919", 
        "920", 
        "921", 
        "922", 
        "923", 
        "924", 
        "925", 
        "926", 
        "927", 
        "928", 
        "929", 
        "930", 
        "931", 
        "932", 
        "933", 
        "934", 
        "935", 
        "936", 
        "937", 
        "938", 
        "939", 
        "940", 
        "941", 
        "942", 
        "943", 
        "944", 
        "945", 
        "946", 
        "947", 
        "948", 
        "949", 
        "950", 
        "951", 
        "952", 
        "953", 
        "954", 
        "955", 
        "956", 
        "957", 
        "958", 
        "959", 
        "960", 
        "961", 
        "962", 
        "963", 
        "964", 
        "965", 
        "966", 
        "967", 
        "968", 
        "969", 
        "970", 
        "971", 
        "972", 
        "973", 
        "974", 
        "975", 
        "976", 
        "977", 
        "978", 
        "979", 
        "980", 
        "981", 
        "982", 
        "983", 
        "984", 
        "985", 
        "986", 
        "987", 
        "988", 
        "989", 
        "990", 
        "991", 
        "992", 
        "993", 
        "994", 
        "995", 
        "996", 
        "997", 
        "998", 
        "999", 
        "MICRODRIVERS__DUMMY", 
        "MICRODRIVERS__MODIF___mutex_init", 
        "MICRODRIVERS__MODIF___pci_register_driver", 
        "MICRODRIVERS__MODIF___release_region", 
        "MICRODRIVERS__MODIF___request_region", 
        "MICRODRIVERS__MODIF___spin_lock_init", 
        "MICRODRIVERS__MODIF___wake_up", 
        "MICRODRIVERS__MODIF__spin_lock", 
        "MICRODRIVERS__MODIF__spin_lock_bh", 
        "MICRODRIVERS__MODIF__spin_lock_irq", 
        "MICRODRIVERS__MODIF__spin_lock_irqsave", 
        "MICRODRIVERS__MODIF__spin_unlock", 
        "MICRODRIVERS__MODIF__spin_unlock_bh", 
        "MICRODRIVERS__MODIF__spin_unlock_irq", 
        "MICRODRIVERS__MODIF__spin_unlock_irqrestore", 
        "MICRODRIVERS__MODIF_create_proc_entry", 
        "MICRODRIVERS__MODIF_device_create_file", 
        "MICRODRIVERS__MODIF_free_irq", 
        "MICRODRIVERS__MODIF_hrtimer_get_res", 
        "MICRODRIVERS__MODIF_kmem_cache_zalloc", 
        "MICRODRIVERS__MODIF_logAlloc", 
        "MICRODRIVERS__MODIF_logRead", 
        "MICRODRIVERS__MODIF_logStackFrame", 
        "MICRODRIVERS__MODIF_logWrite", 
        "MICRODRIVERS__MODIF_mutex_lock", 
        "MICRODRIVERS__MODIF_mutex_unlock", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_byte", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_word", 
        "MICRODRIVERS__MODIF_pci_disable_device", 
        "MICRODRIVERS__MODIF_pci_enable_device", 
        "MICRODRIVERS__MODIF_pci_release_regions", 
        "MICRODRIVERS__MODIF_pci_request_regions", 
        "MICRODRIVERS__MODIF_pci_restore_state", 
        "MICRODRIVERS__MODIF_pci_save_state", 
        "MICRODRIVERS__MODIF_pci_set_master", 
        "MICRODRIVERS__MODIF_pci_set_power_state", 
        "MICRODRIVERS__MODIF_pci_unregister_driver", 
        "MICRODRIVERS__MODIF_proc_symlink", 
        "MICRODRIVERS__MODIF_request_irq", 
        "__builtin_prefetch", 
        "__const_udelay", 
        "__gameport_register_port", 
        "__key___4", 
        "__key___5", 
        "__kmalloc", 
        "__mutex_init", 
        "__param_arr_enable", 
        "__param_arr_id", 
        "__param_arr_index", 
        "__param_arr_joystick_port", 
        "__param_arr_lineio", 
        "__param_arr_spdif", 
        "__param_str_enable", 
        "__param_str_id", 
        "__param_str_index", 
        "__param_str_joystick_port", 
        "__param_str_lineio", 
        "__param_str_spdif", 
        "__pci_register_driver", 
        "__release_region", 
        "__request_region", 
        "__spin_lock_init", 
        "__this_module", 
        "__wake_up", 
        "_cond_resched", 
        "_spin_lock", 
        "_spin_lock_irq", 
        "_spin_lock_irqsave", 
        "_spin_unlock", 
        "_spin_unlock_irq", 
        "_spin_unlock_irqrestore", 
        "alsa_card_ens137x_exit", 
        "alsa_card_ens137x_init", 
        "bytes_to_frames", 
        "cleanup_module", 
        "cond_resched", 
        "dev_get_drvdata", 
        "dev_name", 
        "dev_set_drvdata", 
        "driver", 
        "enable", 
        "ens1371_checkpoint", 
        "ens1371_restore", 
        "ens1373_line_quirk", 
        "es1371_ac97_reset_hack", 
        "es1371_adc_clock", 
        "es1371_amplifier_hack", 
        "es1371_dac_clock", 
        "es1371_quirk_lookup", 
        "es1371_spdif_present", 
        "frames_to_bytes", 
        "free_irq", 
        "gameport_allocate_port", 
        "gameport_register_port", 
        "gameport_set_name", 
        "gameport_set_phys", 
        "gameport_unregister_port", 
        "heapifyfree", 
        "heapifymalloc", 
        "hw_param_interval", 
        "id", 
        "inb", 
        "index", 
        "init_module", 
        "inl", 
        "ioport_resource", 
        "joystick_port", 
        "kfree", 
        "kmalloc", 
        "kzalloc", 
        "lineio", 
        "logAlloc", 
        "logFree", 
        "logRead", 
        "logSfiFrame", 
        "logStackFrame", 
        "logStackVar", 
        "logWrite", 
        "memset", 
        "mutex_lock_nested", 
        "mutex_trylock", 
        "mutex_unlock", 
        "ops", 
        "ops___0", 
        "outb", 
        "outl", 
        "param_array_get", 
        "param_array_set", 
        "param_get_bool", 
        "param_get_charp", 
        "param_get_int", 
        "param_set_bool", 
        "param_set_charp", 
        "param_set_int", 
        "pci_choose_state", 
        "pci_disable_device", 
        "pci_enable_device", 
        "pci_get_drvdata", 
        "pci_name", 
        "pci_release_regions", 
        "pci_request_regions", 
        "pci_restore_state", 
        "pci_save_state", 
        "pci_set_drvdata", 
        "pci_set_master", 
        "pci_set_power_state", 
        "pci_unregister_driver", 
        "printk", 
        "request_irq", 
        "snd_ac97_bus", 
        "snd_ac97_mixer", 
        "snd_ac97_resume", 
        "snd_ac97_suspend", 
        "snd_audiopci_ids", 
        "snd_audiopci_interrupt", 
        "snd_audiopci_probe", 
        "snd_audiopci_remove", 
        "snd_card_disconnect", 
        "snd_card_free", 
        "snd_card_new", 
        "snd_card_proc_new", 
        "snd_card_register", 
        "snd_ctl_add", 
        "snd_ctl_boolean_mono_info", 
        "snd_ctl_new1", 
        "snd_device_new", 
        "snd_ens1373_line", 
        "snd_ens1373_rear", 
        "snd_ens1373_spdif_default_get", 
        "snd_ens1373_spdif_default_put", 
        "snd_ens1373_spdif_info", 
        "snd_ens1373_spdif_mask_get", 
        "snd_ens1373_spdif_stream_get", 
        "snd_ens1373_spdif_stream_put", 
        "snd_ensoniq_1371_mixer", 
        "snd_ensoniq_capture_close", 
        "snd_ensoniq_capture_open", 
        "snd_ensoniq_capture_ops", 
        "snd_ensoniq_capture_pointer", 
        "snd_ensoniq_capture_prepare", 
        "snd_ensoniq_chip_init", 
        "snd_ensoniq_create", 
        "snd_ensoniq_create_gameport", 
        "snd_ensoniq_dev_free", 
        "snd_ensoniq_free", 
        "snd_ensoniq_free_gameport", 
        "snd_ensoniq_get_joystick_port", 
        "snd_ensoniq_hw_free", 
        "snd_ensoniq_hw_params", 
        "snd_ensoniq_midi", 
        "snd_ensoniq_midi_input", 
        "snd_ensoniq_midi_input_close", 
        "snd_ensoniq_midi_input_open", 
        "snd_ensoniq_midi_input_trigger", 
        "snd_ensoniq_midi_interrupt", 
        "snd_ensoniq_midi_output", 
        "snd_ensoniq_midi_output_close", 
        "snd_ensoniq_midi_output_open", 
        "snd_ensoniq_midi_output_trigger", 
        "snd_ensoniq_mixer_free_ac97", 
        "snd_ensoniq_pcm", 
        "snd_ensoniq_pcm2", 
        "snd_ensoniq_playback1_close", 
        "snd_ensoniq_playback1_open", 
        "snd_ensoniq_playback1_ops", 
        "snd_ensoniq_playback1_pointer", 
        "snd_ensoniq_playback1_prepare", 
        "snd_ensoniq_playback2_close", 
        "snd_ensoniq_playback2_open", 
        "snd_ensoniq_playback2_ops", 
        "snd_ensoniq_playback2_pointer", 
        "snd_ensoniq_playback2_prepare", 
        "snd_ensoniq_proc_init", 
        "snd_ensoniq_proc_read", 
        "snd_ensoniq_resume", 
        "snd_ensoniq_sample_shift", 
        "snd_ensoniq_suspend", 
        "snd_ensoniq_trigger", 
        "snd_es1371_adc_rate", 
        "snd_es1371_codec_read", 
        "snd_es1371_codec_wait", 
        "snd_es1371_codec_write", 
        "snd_es1371_dac1_rate", 
        "snd_es1371_dac2_rate", 
        "snd_es1371_hw_constraints_adc_clock", 
        "snd_es1371_hw_constraints_dac_clock", 
        "snd_es1371_mixer_spdif", 
        "snd_es1371_spdif_get", 
        "snd_es1371_spdif_put", 
        "snd_es1371_src_read", 
        "snd_es1371_src_write", 
        "snd_es1371_wait_src_ready", 
        "snd_es1373_line_get", 
        "snd_es1373_line_put", 
        "snd_es1373_rear_get", 
        "snd_es1373_rear_put", 
        "snd_info_set_text_ops", 
        "snd_iprintf", 
        "snd_pci_quirk_lookup", 
        "snd_pcm_format_width", 
        "snd_pcm_hw_constraint_ratdens", 
        "snd_pcm_hw_constraint_ratnums", 
        "snd_pcm_lib_buffer_bytes", 
        "snd_pcm_lib_free_pages", 
        "snd_pcm_lib_ioctl", 
        "snd_pcm_lib_malloc_pages", 
        "snd_pcm_lib_period_bytes", 
        "snd_pcm_lib_preallocate_pages_for_all", 
        "snd_pcm_new", 
        "snd_pcm_period_elapsed", 
        "snd_pcm_set_ops", 
        "snd_pcm_set_sync", 
        "snd_pcm_suspend_all", 
        "snd_pcm_trigger_done", 
        "snd_power_change_state", 
        "snd_rawmidi_new", 
        "snd_rawmidi_receive", 
        "snd_rawmidi_set_ops", 
        "snd_rawmidi_transmit", 
        "spdif", 
        "sprintf", 
        "stackguard_get_ra", 
        "stackguard_pop", 
        "stackguard_push", 
        "stackguard_set_ra", 
        "stackguard_stack", 
        "str_1012473204", 
        "str_1025924976", 
        "str_1034057403", 
        "str_1035699315", 
        "str_1039574295", 
        "str_108773245", 
        "str_112964058", 
        "str_130227268", 
        "str_173238353", 
        "str_182023070", 
        "str_182023141", 
        "str_188578368", 
        "str_212077587", 
        "str_212077948", 
        "str_212077949", 
        "str_216941979", 
        "str_218451996", 
        "str_2219", 
        "str_228836090", 
        "str_229248278", 
        "str_235265470", 
        "str_238696912", 
        "str_265323660", 
        "str_270898770", 
        "str_270906351", 
        "str_271048946", 
        "str_294126970", 
        "str_297936691", 
        "str_298879367", 
        "str_367676234", 
        "str_368086832", 
        "str_375887647", 
        "str_395763820", 
        "str_417657113", 
        "str_42111", 
        "str_42459933", 
        "str_445311958", 
        "str_542964445", 
        "str_543407206", 
        "str_54849971", 
        "str_603776742", 
        "str_604382372", 
        "str_629286318", 
        "str_679919104", 
        "str_711075343", 
        "str_712681085", 
        "str_722882140", 
        "str_722885693", 
        "str_738175023", 
        "str_741517731", 
        "str_744380086", 
        "str_784473421", 
        "str_784473757", 
        "str_784540269", 
        "str_784561127", 
        "str_794415929", 
        "str_796733679", 
        "str_810807268", 
        "str_845284242", 
        "str_87276860", 
        "str_878364613", 
        "str_8982834", 
        "str_912128440", 
        "str_913711678", 
        "str_9379010", 
        "str_941290500", 
        "str_941294053", 
        "str_947039464", 
        "str_947043017", 
        "str_948573379", 
        "str_964300407", 
        "str_964303960", 
        "str_969183744", 
        "str_980588047", 
        "str_98566182", 
        "str_993283191", 
        "str_993283210", 
        "str_993283229", 
        "str_993283248", 
        "strcpy", 
        "strlcpy", 
        "synchronize_irq"};
int function_id_map_len  =    1348;
char str_395763820[40]  =    "<3>wait src ready timeout 0x%lx [0x%x]\n";
char str_218451996[40]  =    "<3>codec write timeout at 0x%lx [0x%x]\n";
char str_294126970[59]  =    "<3>codec read timeout (final) at 0x%lx, reg = 0x%x [0x%x]\n";
char str_54849971[47]  =    "<3>es1371: codec read timeout at 0x%lx [0x%x]\n";
char str_298879367[28]  =    "snd_ensoniq_playback1_close";
char str_297936691[24]  =    "substream->private_data";
char str_679919104[53]  =    "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c";
char str_542964445[29]  =    "ensoniq->playback1_substream";
char str_784540269[14]  =    "ensoniq->mode";
char str_212077948[9]  =    "ES1371/1";
char str_1039574295[16]  =    "ES1371 DAC2/ADC";
char str_212077949[9]  =    "ES1371/2";
char str_794415929[12]  =    "ES1371 DAC1";
char str_845284242[23]  =    "snd_ens1373_spdif_info";
char str_98566182[12]  =    "uinfo->type";
char str_796733679[13]  =    "uinfo->count";
char str_969183744[30]  =    "snd_ens1373_spdif_default_get";
char str_108773245[23]  =    "kcontrol->private_data";
char str_87276860[18]  =    "ensoniq->reg_lock";
char str_993283191[33]  =    "ucontrol->value.iec958.status[0]";
char str_912128440[23]  =    "ensoniq->spdif_default";
char str_993283210[33]  =    "ucontrol->value.iec958.status[1]";
char str_993283229[33]  =    "ucontrol->value.iec958.status[2]";
char str_993283248[33]  =    "ucontrol->value.iec958.status[3]";
char str_741517731[27]  =    "snd_ens1373_spdif_mask_get";
char str_964300407[29]  =    "snd_ens1373_spdif_stream_get";
char str_878364613[22]  =    "ensoniq->spdif_stream";
char str_964303960[29]  =    "snd_ens1373_spdif_stream_put";
char str_784561127[14]  =    "ensoniq->port";
char str_543407206[29]  =    "ensoniq->playback2_substream";
char str_941290500[21]  =    "snd_es1371_spdif_get";
char str_784473757[14]  =    "ensoniq->ctrl";
char str_712681085[33]  =    "ucontrol->value.integer.value[0]";
char str_941294053[21]  =    "snd_es1371_spdif_put";
char str_784473421[14]  =    "ensoniq->cssr";
char str_228836090[23]  =    "IEC958 Playback Switch";
char str_375887647[24]  =    "IEC958 Playback Default";
char str_913711678[21]  =    "IEC958 Playback Mask";
char str_1012473204[27]  =    "IEC958 Playback PCM Stream";
char str_722882140[20]  =    "snd_es1373_rear_get";
char str_722885693[20]  =    "snd_es1373_rear_put";
char str_188578368[26]  =    "AC97 2ch->4ch Copy Switch";
char str_947039464[20]  =    "snd_es1373_line_get";
char str_947043017[20]  =    "snd_es1373_line_put";
char str_604382372[25]  =    "Line In->Rear Out Switch";
char str_173238353[38]  =    "<3>ens1371: invalid joystick port %#x";
char str_603776742[18]  =    "ens137x: gameport";
char str_445311958[41]  =    "<4>ens137x: no gameport ports available\n";
char str_216941979[43]  =    "<4>ens137x: gameport io port 0x%#x in use\n";
char str_738175023[49]  =    "<3>ens137x: cannot allocate memory for gameport\n";
char str_182023141[7]  =    "ES137x";
char str_367676234[16]  =    "pci%s/gameport0";
char str_1034057403[22]  =    "snd_ensoniq_proc_read";
char str_417657113[20]  =    "entry->private_data";
char str_1035699315[26]  =    "Ensoniq AudioPCI ES1371\n\n";
char str_2219[3]  =    "on";
char str_42111[4]  =    "off";
char str_711075343[23]  =    "Joystick enable  : %s\n";
char str_368086832[25]  =    "Joystick port    : 0x%x\n";
char str_810807268[15]  =    "Buffer is %s.\n";
char str_130227268[9]  =    "audiopci";
char str_42459933[21]  =    "ens1371_checkpoint.\n";
char str_8982834[17]  =    "ens1371_resume.\n";
char str_238696912[56]  =    "<3>ENS1371: pci_enable_device failed, disabling device\n";
char str_9379010[19]  =    "ensoniq->src_mutex";
char str_980588047[17]  =    "Ensoniq AudioPCI";
char str_235265470[26]  =    "<3>unable to grab IRQ %d\n";
char str_270898770[27]  =    "tick failed at line:2252.\n";
char str_270906351[27]  =    "tick failed at line:2264.\n";
char str_1025924976[32]  =    "snd_ensoniq_midi_output_trigger";
char str_629286318[33]  =    "(substream->rmidi)->private_data";
char str_112964058[17]  =    "substream->rmidi";
char str_948573379[15]  =    "ensoniq->uartc";
char str_271048946[27]  =    "tick failed at line:2380.\n";
char str_212077587[9]  =    "ES1370/1";
char str_182023070[7]  =    "ES1371";
char str_229248278[8]  =    "ENS1371";
char str_265323660[23]  =    "%s %s at 0x%lx, irq %i";
char str_744380086[8]  =    "ens1371";
int logRead(void *addr , char *what , char *where , char *file , int line ) ;
int logWrite(void *addr , char *what , char *where , char *file , int line ) ;
int logStackFrame(char *func ) ;
int logStackVar(char *var ) ;
//#line  17 "include/asm-generic/int-ll64.h"
typedef signed char __s8;
//#line  20 "include/asm-generic/int-ll64.h"
typedef short __s16;
//#line  21 "include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
//#line  23 "include/asm-generic/int-ll64.h"
typedef int __s32;
//#line  24 "include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
//#line  27 "include/asm-generic/int-ll64.h"
typedef long long __s64;
//#line  28 "include/asm-generic/int-ll64.h"
typedef unsigned long long __u64;
//#line  40 "include/asm-generic/int-ll64.h"
typedef signed char s8;
//#line  41 "include/asm-generic/int-ll64.h"
typedef unsigned char u8;
//#line  44 "include/asm-generic/int-ll64.h"
typedef unsigned short u16;
//#line  47 "include/asm-generic/int-ll64.h"
typedef unsigned int u32;
//#line  49 "include/asm-generic/int-ll64.h"
typedef long long s64;
//#line  50 "include/asm-generic/int-ll64.h"
typedef unsigned long long u64;
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_mode_t;
//#line  12 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_nlink_t;
//#line  13 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_off_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_pid_t;
//#line  16 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_uid_t;
//#line  17 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef unsigned int __kernel_gid_t;
//#line  18 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef unsigned long __kernel_size_t;
//#line  19 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_ssize_t;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_time_t;
//#line  23 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef long __kernel_clock_t;
//#line  24 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_timer_t;
//#line  25 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef int __kernel_clockid_t;
//#line  32 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef long long __kernel_loff_t;
//#line  41 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_uid_t __kernel_uid32_t;
//#line  42 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/posix_types_64.h"
typedef __kernel_gid_t __kernel_gid32_t;
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/types.h"
typedef unsigned short umode_t;
//#line  28 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/types.h"
typedef u64 dma_addr_t;
//#line  16 "include/linux/types.h"
typedef __u32 __kernel_dev_t;
//#line  19 "include/linux/types.h"
typedef __kernel_dev_t dev_t;
//#line  21 "include/linux/types.h"
typedef __kernel_mode_t mode_t;
//#line  22 "include/linux/types.h"
typedef __kernel_nlink_t nlink_t;
//#line  23 "include/linux/types.h"
typedef __kernel_off_t off_t;
//#line  24 "include/linux/types.h"
typedef __kernel_pid_t pid_t;
//#line  28 "include/linux/types.h"
typedef __kernel_timer_t timer_t;
//#line  29 "include/linux/types.h"
typedef __kernel_clockid_t clockid_t;
//#line  35 "include/linux/types.h"
typedef __kernel_uid32_t uid_t;
//#line  36 "include/linux/types.h"
typedef __kernel_gid32_t gid_t;
//#line  57 "include/linux/types.h"
typedef __kernel_loff_t loff_t;
//#line  66 "include/linux/types.h"
typedef __kernel_size_t size_t;
//#line  71 "include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
//#line  81 "include/linux/types.h"
typedef __kernel_time_t time_t;
//#line  86 "include/linux/types.h"
typedef __kernel_clock_t clock_t;
//#line  113 "include/linux/types.h"
typedef __u32 u_int32_t;
//#line  114 "include/linux/types.h"
typedef __s32 int32_t;
//#line  120 "include/linux/types.h"
typedef __u32 uint32_t;
//#line  145 "include/linux/types.h"
typedef unsigned long sector_t;
//#line  146 "include/linux/types.h"
typedef unsigned long blkcnt_t;
//#line  186 "include/linux/types.h"
typedef unsigned int gfp_t;
//#line  187 "include/linux/types.h"
typedef unsigned int fmode_t;
//#line  190 "include/linux/types.h"
typedef u64 phys_addr_t;
//#line  195 "include/linux/types.h"
typedef phys_addr_t resource_size_t;
//#line  197 "include/linux/types.h"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_7 atomic_t;
//#line  202 "include/linux/types.h"
struct __anonstruct_atomic64_t_8 {
   long volatile   counter ;
};
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
//#line  12 "include/linux/thread_info.h"
struct timespec;
struct timespec;
//#line  13
struct compat_timespec;
struct compat_timespec;
//#line  18 "include/linux/thread_info.h"
struct __anonstruct____missing_field_name_10 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
struct __anonstruct_futex_11 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
struct __anonstruct_nanosleep_12 {
   clockid_t index ;
   struct timespec  __attribute__((__noderef__, __address_space__(1))) *rmtp ;
   struct compat_timespec  __attribute__((__noderef__, __address_space__(1))) *compat_rmtp ;
   u64 expires ;
};
struct pollfd;
struct __anonstruct_poll_13 {
   struct pollfd  __attribute__((__noderef__, __address_space__(1))) *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
union __anonunion____missing_field_name_9 {
   struct __anonstruct____missing_field_name_10 __annonCompField4 ;
   struct __anonstruct_futex_11 futex ;
   struct __anonstruct_nanosleep_12 nanosleep ;
   struct __anonstruct_poll_13 poll ;
};
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_9 __annonCompField5 ;
};
//#line  59 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/alternative.h"
struct module;
struct module;
//#line  80 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/page_64.h"
typedef unsigned long pgdval_t;
//#line  81 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/page_64.h"
typedef unsigned long pgprotval_t;
//#line  83
struct page;
//#line  56 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/page.h"
struct __anonstruct_pgd_t_15 {
   pgdval_t pgd ;
};
typedef struct __anonstruct_pgd_t_15 pgd_t;
//#line  57 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/page.h"
struct __anonstruct_pgprot_t_16 {
   pgprotval_t pgprot ;
};
typedef struct __anonstruct_pgprot_t_16 pgprot_t;
//#line  69
struct page;
//#line  20 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/thread_info.h"
struct task_struct;
struct task_struct;
//#line  21
struct exec_domain;
struct exec_domain;
//#line  7 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct task_struct;
//#line  8
struct mm_struct;
struct mm_struct;
//#line  98 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/ptrace.h"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
//#line  135
struct task_struct;
//#line  141 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/vm86.h"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/math_emu.h"
union __anonunion____missing_field_name_19 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_19 __annonCompField6 ;
};
//#line  40 "/usr/lib/gcc/x86_64-redhat-linux/4.4.6/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
//#line  102 "/usr/lib/gcc/x86_64-redhat-linux/4.4.6/include/stdarg.h"
typedef __gnuc_va_list va_list;
//#line  10 "include/asm-generic/bug.h"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
//#line  114 "include/linux/kernel.h"
struct completion;
struct completion;
//#line  115
struct pt_regs;
//#line  208
struct pid;
struct pid;
//#line  21 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/current.h"
struct task_struct;
//#line  20 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/system.h"
struct task_struct;
//#line  22 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/desc_defs.h"
struct __anonstruct____missing_field_name_23 {
   unsigned int a ;
   unsigned int b ;
};
struct __anonstruct____missing_field_name_24 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
union __anonunion____missing_field_name_22 {
   struct __anonstruct____missing_field_name_23 __annonCompField8 ;
   struct __anonstruct____missing_field_name_24 __annonCompField9 ;
};
struct desc_struct {
   union __anonunion____missing_field_name_22 __annonCompField10 ;
} __attribute__((__packed__)) ;
//#line  33 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/ds.h"
struct task_struct;
//#line  34
struct ds_context;
struct ds_context;
//#line  36
struct bts_tracer;
struct bts_tracer;
//#line  10 "include/linux/personality.h"
struct exec_domain;
//#line  11
struct pt_regs;
//#line  88
struct map_segment;
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
//#line  144 "include/linux/cpumask.h"
struct cpumask {
   unsigned long bits[((255UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct cpumask cpumask_t;
//#line  252 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct thread_struct;
//#line  289 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
//#line  305 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct __anonstruct____missing_field_name_33 {
   u64 rip ;
   u64 rdp ;
};
struct __anonstruct____missing_field_name_34 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
union __anonunion____missing_field_name_32 {
   struct __anonstruct____missing_field_name_33 __annonCompField11 ;
   struct __anonstruct____missing_field_name_34 __annonCompField12 ;
};
union __anonunion____missing_field_name_35 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_32 __annonCompField13 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_35 __annonCompField14 ;
} __attribute__((__aligned__(16))) ;
//#line  340 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
//#line  360 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
//#line  366 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
} __attribute__((__packed__, __aligned__(64))) ;
//#line  372 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
//#line  386
struct kmem_cache;
//#line  391 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   struct ds_context *ds_ctx ;
   unsigned int bts_ovfl_signal ;
};
//#line  593 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/processor.h"
struct __anonstruct_mm_segment_t_36 {
   unsigned long seg ;
};
typedef struct __anonstruct_mm_segment_t_36 mm_segment_t;
//#line  23 "include/asm-generic/atomic.h"
typedef atomic64_t atomic_long_t;
//#line  26 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/thread_info.h"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void __attribute__((__noderef__, __address_space__(1)))  *sysenter_return ;
};
//#line  19 "include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
//#line  540
struct hlist_node;
struct hlist_head {
   struct hlist_node *first ;
};
//#line  544 "include/linux/list.h"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
//#line  8 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/spinlock_types.h"
struct raw_spinlock {
   unsigned int slock ;
};
typedef struct raw_spinlock raw_spinlock_t;
//#line  14 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/spinlock_types.h"
struct __anonstruct_raw_rwlock_t_37 {
   unsigned int lock ;
};
typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
//#line  12 "include/linux/lockdep.h"
struct task_struct;
//#line  13
struct lockdep_map;
struct lockdep_map;
//#line  6 "include/linux/debug_locks.h"
struct task_struct;
//#line  40
struct task_struct;
//#line  4 "include/linux/stacktrace.h"
struct task_struct;
//#line  7 "include/linux/stacktrace.h"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
//#line  68 "include/linux/lockdep.h"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
//#line  72 "include/linux/lockdep.h"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
//#line  81 "include/linux/lockdep.h"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[9] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
};
//#line  166 "include/linux/lockdep.h"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache ;
   char const   *name ;
};
//#line  206 "include/linux/lockdep.h"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
};
//#line  20 "include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_38 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_spinlock_t_38 spinlock_t;
//#line  36 "include/linux/spinlock_types.h"
struct __anonstruct_rwlock_t_39 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
//#line  8 "include/linux/vmalloc.h"
struct vm_area_struct;
struct vm_area_struct;
//#line  68 "include/asm-generic/iomap.h"
struct pci_dev;
struct pci_dev;
//#line  19 "include/linux/irqreturn.h"
typedef int irqreturn_t;
//#line  18 "include/linux/capability.h"
struct task_struct;
//#line  99 "include/linux/capability.h"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
typedef struct kernel_cap_struct kernel_cap_t;
//#line  553
struct dentry;
struct dentry;
//#line  14 "include/linux/time.h"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
//#line  100 "include/linux/rbtree.h"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  110 "include/linux/rbtree.h"
struct rb_root {
   struct rb_node *rb_node ;
};
//#line  92 "include/linux/nodemask.h"
struct __anonstruct_nodemask_t_42 {
   unsigned long bits[(((unsigned long )(1 << 6) + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
typedef struct __anonstruct_nodemask_t_42 nodemask_t;
//#line  14 "include/linux/prio_tree.h"
struct prio_tree_node;
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
//#line  20 "include/linux/prio_tree.h"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
//#line  28 "include/linux/prio_tree.h"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
//#line  17 "include/linux/rwsem.h"
struct rw_semaphore;
struct rw_semaphore;
//#line  31 "include/linux/rwsem-spinlock.h"
struct rw_semaphore {
   __s32 activity ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
//#line  28 "include/linux/wait.h"
struct __wait_queue;
typedef struct __wait_queue wait_queue_t;
//#line  32 "include/linux/wait.h"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
//#line  50 "include/linux/wait.h"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
//#line  54 "include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
//#line  56
struct task_struct;
//#line  25 "include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
//#line  48 "include/linux/mutex.h"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
//#line  67 "include/linux/mutex.h"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct mutex *lock ;
   void *magic ;
};
//#line  11 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/mmu.h"
struct __anonstruct_mm_context_t_43 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
typedef struct __anonstruct_mm_context_t_43 mm_context_t;
//#line  22 "include/linux/mm_types.h"
struct address_space;
struct address_space;
//#line  27 "include/linux/mm_types.h"
typedef atomic_long_t mm_counter_t;
//#line  39 "include/linux/mm_types.h"
struct __anonstruct____missing_field_name_45 {
   u16 inuse ;
   u16 objects ;
};
union __anonunion____missing_field_name_44 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_45 __annonCompField15 ;
};
struct __anonstruct____missing_field_name_47 {
   unsigned long private ;
   struct address_space *mapping ;
};
union __anonunion____missing_field_name_46 {
   struct __anonstruct____missing_field_name_47 __annonCompField17 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
union __anonunion____missing_field_name_48 {
   unsigned long index ;
   void *freelist ;
};
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_44 __annonCompField16 ;
   union __anonunion____missing_field_name_46 __annonCompField18 ;
   union __anonunion____missing_field_name_48 __annonCompField19 ;
   struct list_head lru ;
};
//#line  104
struct file;
//#line  122 "include/linux/mm_types.h"
struct __anonstruct_vm_set_50 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
union __anonunion_shared_49 {
   struct __anonstruct_vm_set_50 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
struct anon_vma;
struct vm_operations_struct;
struct mempolicy;
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_49 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void * __attribute__((__noderef__, __address_space__(2))) vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
//#line  179 "include/linux/mm_types.h"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
//#line  184 "include/linux/mm_types.h"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
//#line  190 "include/linux/mm_types.h"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
//#line  7 "include/asm-generic/cputime.h"
typedef unsigned long cputime_t;
//#line  37 "include/linux/pm.h"
struct device;
struct device;
//#line  39 "include/linux/pm.h"
struct pm_message {
   int event ;
};
typedef struct pm_message pm_message_t;
//#line  170 "include/linux/pm.h"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
//#line  308
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
//#line  318 "include/linux/pm.h"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
//#line  21 "include/linux/kref.h"
struct kref {
   atomic_t refcount ;
};
//#line  60 "include/linux/pageblock-flags.h"
struct page;
//#line  8 "include/linux/memory_hotplug.h"
struct page;
//#line  749 "include/linux/mmzone.h"
struct file;
//#line  252 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/topology.h"
struct pci_bus;
struct pci_bus;
//#line  940 "include/linux/mmzone.h"
struct page;
//#line  8 "include/linux/gfp.h"
struct vm_area_struct;
//#line  46 "include/linux/ktime.h"
union ktime {
   s64 tv64 ;
};
//#line  59 "include/linux/ktime.h"
typedef union ktime ktime_t;
//#line  9 "include/linux/timer.h"
struct tvec_base;
struct tvec_base;
//#line  11 "include/linux/timer.h"
struct timer_list {
   struct list_head entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base *base ;
};
//#line  181
struct hrtimer;
struct hrtimer;
//#line  182
enum hrtimer_restart;
//#line  16 "include/linux/workqueue.h"
struct work_struct;
struct work_struct;
//#line  25 "include/linux/workqueue.h"
struct work_struct {
   atomic_long_t data ;
   struct list_head  __attribute__((__noderef__, __address_space__(2))) entry ;
   void (*func)(struct work_struct *work ) ;
   struct lockdep_map lockdep_map ;
};
//#line  39 "include/linux/workqueue.h"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
//#line  20 "include/linux/sysfs.h"
struct kobject;
struct kobject;
//#line  21
struct module;
//#line  28 "include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
//#line  34 "include/linux/sysfs.h"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
//#line  63
struct vm_area_struct;
//#line  65 "include/linux/sysfs.h"
struct bin_attribute {
   struct attribute attr ;
   size_t size ;
   void *private ;
   ssize_t (*read)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                   size_t  ) ;
   ssize_t (*write)(struct kobject * , struct bin_attribute * , char * , loff_t  ,
                    size_t  ) ;
   int (*mmap)(struct kobject * , struct bin_attribute *attr , struct vm_area_struct *vma ) ;
};
//#line  77 "include/linux/sysfs.h"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
//#line  82
struct sysfs_dirent;
struct sysfs_dirent;
//#line  59 "include/linux/kobject.h"
struct kset;
struct kobj_type;
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
//#line  104 "include/linux/kobject.h"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
//#line  110 "include/linux/kobject.h"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
//#line  117 "include/linux/kobject.h"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
//#line  151 "include/linux/kobject.h"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
//#line  35 "include/linux/slub_def.h"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
//#line  46 "include/linux/slub_def.h"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
//#line  63 "include/linux/slub_def.h"
struct kmem_cache_order_objects {
   unsigned long x ;
};
//#line  70 "include/linux/slub_def.h"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[255] ;
};
//#line  50 "include/linux/rcupdate.h"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
//#line  83 "include/linux/sem.h"
struct task_struct;
//#line  117
struct sem_undo_list;
//#line  130 "include/linux/sem.h"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
//#line  136 "include/linux/sem.h"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
//#line  10 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/signal.h"
struct siginfo;
struct siginfo;
//#line  30 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/signal.h"
struct __anonstruct_sigset_t_104 {
   unsigned long sig[1] ;
};
typedef struct __anonstruct_sigset_t_104 sigset_t;
//#line  17 "include/asm-generic/signal.h"
typedef void __signalfn_t(int  );
//#line  18 "include/asm-generic/signal.h"
typedef __signalfn_t __attribute__((__noderef__, __address_space__(1)))  *__sighandler_t;
//#line  20 "include/asm-generic/signal.h"
typedef void __restorefn_t(void);
//#line  21 "include/asm-generic/signal.h"
typedef __restorefn_t __attribute__((__noderef__, __address_space__(1)))  *__sigrestore_t;
//#line  167 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/signal.h"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
//#line  174 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/signal.h"
struct k_sigaction {
   struct sigaction sa ;
};
//#line  7 "include/asm-generic/siginfo.h"
union sigval {
   int sival_int ;
   void __attribute__((__noderef__, __address_space__(1)))  *sival_ptr ;
};
typedef union sigval sigval_t;
//#line  40 "include/asm-generic/siginfo.h"
struct __anonstruct__kill_106 {
   pid_t _pid ;
   uid_t _uid ;
};
struct __anonstruct__timer_107 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
struct __anonstruct__rt_108 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
struct __anonstruct__sigchld_109 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
struct __anonstruct__sigfault_110 {
   void __attribute__((__noderef__, __address_space__(1)))  *_addr ;
};
struct __anonstruct__sigpoll_111 {
   long _band ;
   int _fd ;
};
union __anonunion__sifields_105 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_106 _kill ;
   struct __anonstruct__timer_107 _timer ;
   struct __anonstruct__rt_108 _rt ;
   struct __anonstruct__sigchld_109 _sigchld ;
   struct __anonstruct__sigfault_110 _sigfault ;
   struct __anonstruct__sigpoll_111 _sigpoll ;
};
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_105 _sifields ;
};
typedef struct siginfo siginfo_t;
//#line  274
struct siginfo;
//#line  14 "include/linux/signal.h"
struct user_struct;
//#line  24 "include/linux/signal.h"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
//#line  242
struct pt_regs;
//#line  4 "include/linux/path.h"
struct dentry;
//#line  5
struct vfsmount;
struct vfsmount;
//#line  7 "include/linux/path.h"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
//#line  6 "include/linux/fs_struct.h"
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct path root ;
   struct path pwd ;
};
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
//#line  50 "include/linux/pid.h"
struct pid_namespace;
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
//#line  57 "include/linux/pid.h"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
//#line  69 "include/linux/pid.h"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
//#line  100
struct pid_namespace;
//#line  97 "include/linux/proportions.h"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
//#line  24 "include/linux/seccomp.h"
struct __anonstruct_seccomp_t_114 {

};
typedef struct __anonstruct_seccomp_t_114 seccomp_t;
//#line  80 "include/linux/plist.h"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
   spinlock_t *lock ;
};
//#line  38 "include/linux/rtmutex.h"
struct rt_mutex_waiter;
struct rt_mutex_waiter;
//#line  6 "include/linux/resource.h"
struct task_struct;
//#line  43 "include/linux/resource.h"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
//#line  26 "include/linux/hrtimer.h"
struct hrtimer_clock_base;
struct hrtimer_clock_base;
//#line  27
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
//#line  40
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
//#line  100 "include/linux/hrtimer.h"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
};
//#line  139 "include/linux/hrtimer.h"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
};
//#line  168 "include/linux/hrtimer.h"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
};
//#line  11 "include/linux/task_io_accounting.h"
struct task_io_accounting {

};
//#line  17 "include/linux/latencytop.h"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
//#line  25
struct task_struct;
//#line  32 "include/linux/sysctl.h"
struct file;
//#line  33
struct completion;
//#line  947
struct nsproxy;
struct nsproxy;
//#line  28 "include/linux/key.h"
typedef int32_t key_serial_t;
//#line  31 "include/linux/key.h"
typedef uint32_t key_perm_t;
//#line  33
struct key;
struct key;
//#line  73
struct seq_file;
struct seq_file;
//#line  74
struct user_struct;
//#line  75
struct signal_struct;
struct signal_struct;
//#line  76
struct cred;
struct cred;
//#line  78
struct key_type;
struct key_type;
//#line  80
struct keyring_list;
struct keyring_list;
//#line  123
struct key_user;
union __anonunion_type_data_169 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
union __anonunion_payload_170 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_169 type_data ;
   union __anonunion_payload_170 payload ;
};
//#line  19 "include/linux/cred.h"
struct user_struct;
//#line  20
struct cred;
//#line  21
struct inode;
struct inode;
//#line  29 "include/linux/cred.h"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
//#line  81 "include/linux/cred.h"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
//#line  114 "include/linux/cred.h"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
//#line  95 "include/linux/sched.h"
struct exec_domain;
//#line  96
struct futex_pi_state;
struct futex_pi_state;
//#line  97
struct robust_list_head;
struct robust_list_head;
//#line  98
struct bio;
struct bio;
//#line  99
struct bts_tracer;
//#line  140
struct seq_file;
//#line  242
struct task_struct;
//#line  336
struct nsproxy;
//#line  337
struct user_namespace;
struct user_namespace;
//#line  58 "include/linux/aio_abi.h"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
//#line  16 "include/linux/uio.h"
struct iovec {
   void __attribute__((__noderef__, __address_space__(1)))  *iov_base ;
   __kernel_size_t iov_len ;
};
//#line  15 "include/linux/aio.h"
struct kioctx;
struct kioctx;
//#line  87 "include/linux/aio.h"
union __anonunion_ki_obj_172 {
   void __attribute__((__noderef__, __address_space__(1)))  *user ;
   struct task_struct *tsk ;
};
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_172 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char __attribute__((__noderef__, __address_space__(1)))  *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
//#line  167 "include/linux/aio.h"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
//#line  180 "include/linux/aio.h"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
//#line  215
struct mm_struct;
//#line  426 "include/linux/sched.h"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
//#line  433 "include/linux/sched.h"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
//#line  452 "include/linux/sched.h"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
//#line  479 "include/linux/sched.h"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
//#line  492 "include/linux/sched.h"
union __anonunion____missing_field_name_173 {
   pid_t pgrp  __attribute__((__deprecated__)) ;
   pid_t __pgrp ;
};
union __anonunion____missing_field_name_174 {
   pid_t session  __attribute__((__deprecated__)) ;
   pid_t __session ;
};
struct tty_struct;
struct taskstats;
struct tty_audit_buf;
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   union __anonunion____missing_field_name_173 __annonCompField20 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_174 __annonCompField21 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
//#line  641 "include/linux/sched.h"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
//#line  686
struct backing_dev_info;
struct backing_dev_info;
//#line  687
struct reclaim_state;
struct reclaim_state;
//#line  690 "include/linux/sched.h"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
//#line  706 "include/linux/sched.h"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
//#line  751
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
//#line  827 "include/linux/sched.h"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
//#line  850
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
//#line  868 "include/linux/sched.h"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   char *name ;
   unsigned long span[] ;
};
//#line  960
struct io_context;
struct io_context;
//#line  969
struct audit_context;
struct audit_context;
//#line  970
struct mempolicy;
//#line  971
struct pipe_inode_info;
struct pipe_inode_info;
//#line  974
struct rq;
struct rq;
//#line  975
struct sched_domain;
//#line  977 "include/linux/sched.h"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
};
//#line  1027 "include/linux/sched.h"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
//#line  1041 "include/linux/sched.h"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
//#line  1098 "include/linux/sched.h"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
//#line  1114
struct linux_binfmt;
struct files_struct;
struct compat_robust_list_head;
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct bts_tracer *bts ;
   void *bts_buffer ;
   size_t bts_size ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int __attribute__((__noderef__, __address_space__(1)))  *set_child_tid ;
   int __attribute__((__noderef__, __address_space__(1)))  *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_timestamp ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48UL] ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   struct robust_list_head  __attribute__((__noderef__, __address_space__(1))) *robust_list ;
   struct compat_robust_list_head  __attribute__((__noderef__, __address_space__(1))) *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mempolicy *mempolicy ;
   short il_next ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
//#line  1486
struct pid_namespace;
//#line  77 "include/linux/irq.h"
struct proc_dir_entry;
struct proc_dir_entry;
//#line  16 "include/linux/profile.h"
struct proc_dir_entry;
//#line  17
struct pt_regs;
//#line  65
struct task_struct;
//#line  66
struct mm_struct;
//#line  88
struct pt_regs;
//#line  120 "include/linux/hardirq.h"
struct task_struct;
//#line  80 "include/linux/interrupt.h"
struct device;
//#line  318 "include/linux/interrupt.h"
struct tasklet_struct {
   struct tasklet_struct *next ;
   unsigned long state ;
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
};
//#line  12 "include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
//#line  17 "include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
//#line  18 "include/linux/ioport.h"
struct resource {
   resource_size_t start ;
   resource_size_t end ;
   char const   *name ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
//#line  165
struct device;
//#line  19 "include/linux/klist.h"
struct klist_node;
struct klist_node;
//#line  20 "include/linux/klist.h"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
//#line  39 "include/linux/klist.h"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
//#line  62 "include/linux/stat.h"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
//#line  40 "include/linux/kmod.h"
struct key;
//#line  41
struct file;
//#line  98
struct file;
//#line  279 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/elf.h"
struct task_struct;
//#line  10 "include/linux/elf.h"
struct file;
//#line  27 "include/linux/elf.h"
typedef __u64 Elf64_Addr;
//#line  28 "include/linux/elf.h"
typedef __u16 Elf64_Half;
//#line  32 "include/linux/elf.h"
typedef __u32 Elf64_Word;
//#line  33 "include/linux/elf.h"
typedef __u64 Elf64_Xword;
//#line  181 "include/linux/elf.h"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
typedef struct elf64_sym Elf64_Sym;
//#line  32 "include/linux/moduleparam.h"
struct kernel_param;
struct kernel_param;
//#line  39
struct kparam_string;
struct kparam_array;
union __anonunion____missing_field_name_182 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_182 __annonCompField22 ;
};
//#line  52 "include/linux/moduleparam.h"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
//#line  58 "include/linux/moduleparam.h"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
//#line  207
struct module;
//#line  18 "include/linux/marker.h"
struct module;
//#line  19
struct marker;
struct marker;
//#line  33 "include/linux/marker.h"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
//#line  36 "include/linux/marker.h"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
//#line  41 "include/linux/marker.h"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
//#line  20 "include/linux/tracepoint.h"
struct module;
//#line  21
struct tracepoint;
struct tracepoint;
//#line  23 "include/linux/tracepoint.h"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
//#line  5 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/module.h"
struct mod_arch_specific {

};
//#line  34 "include/linux/module.h"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
//#line  46
struct module;
//#line  48 "include/linux/module.h"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
//#line  58
struct module_param_attrs;
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
//#line  71
struct exception_table_entry;
struct exception_table_entry;
//#line  222
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
//#line  229
struct module_sect_attrs;
struct module_notes_attrs;
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
//#line  594
struct device_driver;
struct device_driver;
//#line  596
struct module;
//#line  16 "include/linux/semaphore.h"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
//#line  4 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/device.h"
struct dma_mapping_ops;
struct dev_archdata {
   void *acpi_handle ;
   struct dma_mapping_ops *dma_ops ;
   void *iommu ;
};
//#line  30 "include/linux/device.h"
struct device;
//#line  31
struct device_driver;
//#line  32
struct driver_private;
struct driver_private;
//#line  33
struct class;
struct class;
//#line  34
struct class_private;
struct class_private;
//#line  35
struct bus_type;
struct bus_type;
//#line  36
struct bus_type_private;
struct bus_type_private;
//#line  38 "include/linux/device.h"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
//#line  51
struct device_attribute;
struct driver_attribute;
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
//#line  122 "include/linux/device.h"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
//#line  155 "include/linux/device.h"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
//#line  187
struct class_attribute;
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
//#line  207
struct device_type;
//#line  240 "include/linux/device.h"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
//#line  287 "include/linux/device.h"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
//#line  300 "include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
//#line  360 "include/linux/device.h"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
//#line  369
struct dma_coherent_mem;
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   unsigned int uevent_suppress : 1 ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   char * __attribute__((__noderef__, __address_space__(2))) driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
//#line  25 "include/linux/io.h"
struct device;
//#line  60 "include/linux/pci.h"
struct hotplug_slot;
struct pci_slot {
   struct pci_bus *bus ;
   struct list_head list ;
   struct hotplug_slot *hotplug ;
   unsigned char number ;
   struct kobject kobj ;
};
//#line  110 "include/linux/pci.h"
typedef int pci_power_t;
//#line  128 "include/linux/pci.h"
typedef unsigned int pci_channel_state_t;
//#line  130
enum pci_channel_state {
    pci_channel_io_normal = 1,
    pci_channel_io_frozen = 2,
    pci_channel_io_perm_failure = 3
} ;
//#line  154 "include/linux/pci.h"
typedef unsigned short pci_dev_flags_t;
//#line  169 "include/linux/pci.h"
typedef unsigned short pci_bus_flags_t;
//#line  182
struct pci_vpd;
struct pci_vpd;
//#line  187
struct pci_driver;
struct pci_dev {
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   struct pci_slot *slot ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 revision ;
   u8 hdr_type ;
   u8 pcie_type ;
   u8 rom_base_reg ;
   u8 pin ;
   struct pci_driver *driver ;
   u64 dma_mask ;
   struct device_dma_parameters dma_parms ;
   pci_power_t current_state ;
   int pm_cap ;
   unsigned int pme_support : 5 ;
   unsigned int d1_support : 1 ;
   unsigned int d2_support : 1 ;
   unsigned int no_d1d2 : 1 ;
   pci_channel_state_t error_state ;
   struct device dev ;
   int cfg_size ;
   unsigned int irq ;
   struct resource resource[12] ;
   unsigned int transparent : 1 ;
   unsigned int multifunction : 1 ;
   unsigned int is_added : 1 ;
   unsigned int is_busmaster : 1 ;
   unsigned int no_msi : 1 ;
   unsigned int block_ucfg_access : 1 ;
   unsigned int broken_parity_status : 1 ;
   unsigned int irq_reroute_variant : 2 ;
   unsigned int msi_enabled : 1 ;
   unsigned int msix_enabled : 1 ;
   unsigned int ari_enabled : 1 ;
   unsigned int is_managed : 1 ;
   unsigned int is_pcie : 1 ;
   unsigned int state_saved : 1 ;
   pci_dev_flags_t dev_flags ;
   atomic_t enable_cnt ;
   u32 saved_config_space[16] ;
   struct hlist_head saved_cap_space ;
   struct bin_attribute *rom_attr ;
   int rom_attr_enabled ;
   struct bin_attribute *res_attr[12] ;
   struct bin_attribute *res_attr_wc[12] ;
   struct list_head msi_list ;
   struct pci_vpd *vpd ;
};
//#line  311
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct list_head slots ;
   struct resource *resource[16] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short bridge_ctl ;
   pci_bus_flags_t bus_flags ;
   struct device *bridge ;
   struct device dev ;
   struct bin_attribute *legacy_io ;
   struct bin_attribute *legacy_mem ;
   unsigned int is_added : 1 ;
};
//#line  366 "include/linux/pci.h"
struct pci_ops {
   int (*read)(struct pci_bus *bus , unsigned int devfn , int where , int size , u32 *val ) ;
   int (*write)(struct pci_bus *bus , unsigned int devfn , int where , int size ,
                u32 val ) ;
};
//#line  385 "include/linux/pci.h"
struct pci_dynids {
   spinlock_t lock ;
   struct list_head list ;
};
//#line  397 "include/linux/pci.h"
typedef unsigned int pci_ers_result_t;
//#line  417 "include/linux/pci.h"
struct pci_error_handlers {
   pci_ers_result_t (*error_detected)(struct pci_dev *dev , enum pci_channel_state error ) ;
   pci_ers_result_t (*mmio_enabled)(struct pci_dev *dev ) ;
   pci_ers_result_t (*link_reset)(struct pci_dev *dev ) ;
   pci_ers_result_t (*slot_reset)(struct pci_dev *dev ) ;
   void (*resume)(struct pci_dev *dev ) ;
};
//#line  437
struct module;
//#line  438 "include/linux/pci.h"
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*suspend_late)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume_early)(struct pci_dev *dev ) ;
   int (*resume)(struct pci_dev *dev ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
   struct pci_error_handlers *err_handler ;
   struct device_driver driver ;
   struct pci_dynids dynids ;
};
//#line  6 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/scatterlist.h"
struct scatterlist {
   unsigned long page_link ;
   unsigned int offset ;
   unsigned int length ;
   dma_addr_t dma_address ;
   unsigned int dma_length ;
};
//#line  17 "include/linux/mm.h"
struct mempolicy;
//#line  18
struct anon_vma;
//#line  19
struct file_ra_state;
struct file_ra_state;
//#line  20
struct user_struct;
//#line  21
struct writeback_control;
struct writeback_control;
//#line  382 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/pgtable.h"
struct file;
//#line  400
struct seq_file;
//#line  73 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/pgtable_64.h"
struct mm_struct;
//#line  542 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/pgtable.h"
struct vm_area_struct;
//#line  165 "include/linux/mm.h"
struct vm_fault {
   unsigned int flags ;
   unsigned long pgoff ;
   void __attribute__((__noderef__, __address_space__(1)))  *virtual_address ;
   struct page *page ;
};
//#line  182 "include/linux/mm.h"
struct vm_operations_struct {
   void (*open)(struct vm_area_struct *area ) ;
   void (*close)(struct vm_area_struct *area ) ;
   int (*fault)(struct vm_area_struct *vma , struct vm_fault *vmf ) ;
   int (*page_mkwrite)(struct vm_area_struct *vma , struct page *page ) ;
   int (*access)(struct vm_area_struct *vma , unsigned long addr , void *buf , int len ,
                 int write ) ;
   int (*set_policy)(struct vm_area_struct *vma , struct mempolicy *new ) ;
   struct mempolicy *(*get_policy)(struct vm_area_struct *vma , unsigned long addr ) ;
   int (*migrate)(struct vm_area_struct *vma , nodemask_t const   *from , nodemask_t const   *to ,
                  unsigned long flags ) ;
};
//#line  224
struct inode;
//#line  181 "include/linux/page-flags.h"
struct page;
//#line  6 "include/linux/swiotlb.h"
struct device;
//#line  8
struct scatterlist;
//#line  19 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/dma-mapping.h"
struct dma_mapping_ops {
   int (*mapping_error)(struct device *dev , dma_addr_t dma_addr ) ;
   void *(*alloc_coherent)(struct device *dev , size_t size , dma_addr_t *dma_handle ,
                           gfp_t gfp ) ;
   void (*free_coherent)(struct device *dev , size_t size , void *vaddr , dma_addr_t dma_handle ) ;
   dma_addr_t (*map_single)(struct device *hwdev , phys_addr_t ptr , size_t size ,
                            int direction ) ;
   void (*unmap_single)(struct device *dev , dma_addr_t addr , size_t size , int direction ) ;
   void (*sync_single_for_cpu)(struct device *hwdev , dma_addr_t dma_handle , size_t size ,
                               int direction ) ;
   void (*sync_single_for_device)(struct device *hwdev , dma_addr_t dma_handle , size_t size ,
                                  int direction ) ;
   void (*sync_single_range_for_cpu)(struct device *hwdev , dma_addr_t dma_handle ,
                                     unsigned long offset , size_t size , int direction ) ;
   void (*sync_single_range_for_device)(struct device *hwdev , dma_addr_t dma_handle ,
                                        unsigned long offset , size_t size , int direction ) ;
   void (*sync_sg_for_cpu)(struct device *hwdev , struct scatterlist *sg , int nelems ,
                           int direction ) ;
   void (*sync_sg_for_device)(struct device *hwdev , struct scatterlist *sg , int nelems ,
                              int direction ) ;
   int (*map_sg)(struct device *hwdev , struct scatterlist *sg , int nents , int direction ) ;
   void (*unmap_sg)(struct device *hwdev , struct scatterlist *sg , int nents , int direction ) ;
   int (*dma_supported)(struct device *hwdev , u64 mask ) ;
   int is_phys ;
};
struct gameport_driver;
struct gameport {
   void *port_data ;
   char name[32] ;
   char phys[32] ;
   int io ;
   int speed ;
   int fuzz ;
   void (*trigger)(struct gameport * ) ;
   unsigned char (*read)(struct gameport * ) ;
   int (*cooked_read)(struct gameport * , int * , int * ) ;
   int (*calibrate)(struct gameport * , int * , int * ) ;
   int (*open)(struct gameport * , int  ) ;
   void (*close)(struct gameport * ) ;
   struct timer_list poll_timer ;
   unsigned int poll_interval ;
   spinlock_t timer_lock ;
   unsigned int poll_cnt ;
   void (*poll_handler)(struct gameport * ) ;
   struct gameport *parent ;
   struct gameport *child ;
   struct gameport_driver *drv ;
   struct mutex drv_mutex ;
   struct device dev ;
   unsigned int registered ;
   struct list_head node ;
};
//#line  54 "include/linux/gameport.h"
struct gameport_driver {
   void *private ;
   char *description ;
   int (*connect)(struct gameport * , struct gameport_driver *drv ) ;
   int (*reconnect)(struct gameport * ) ;
   void (*disconnect)(struct gameport * ) ;
   struct device_driver driver ;
   unsigned int ignore ;
};
//#line  44 "include/sound/core.h"
struct pci_dev;
//#line  51 "include/sound/core.h"
typedef int snd_device_type_t;
//#line  67 "include/sound/core.h"
typedef int snd_device_state_t;
//#line  77
struct snd_device;
struct snd_device;
//#line  79 "include/sound/core.h"
struct snd_device_ops {
   int (* __attribute__((__noderef__, __address_space__(2))) dev_free)(struct snd_device *dev ) ;
   int (* __attribute__((__noderef__, __address_space__(2))) dev_register)(struct snd_device *dev ) ;
   int (* __attribute__((__noderef__, __address_space__(2))) dev_disconnect)(struct snd_device *dev ) ;
};
//#line  85
struct snd_card;
struct snd_device {
   struct list_head list ;
   struct snd_card *card ;
   snd_device_state_t state ;
   snd_device_type_t type ;
   void *device_data ;
   struct snd_device_ops * __attribute__((__noderef__, __address_space__(2))) ops ;
};
//#line  98
struct file_operations;
struct snd_monitor_file {
   struct file *file ;
   struct snd_monitor_file *next ;
   struct file_operations  const  *disconnected_f_op ;
   struct list_head shutdown_list ;
};
//#line  107
struct snd_info_entry;
struct snd_shutdown_f_ops;
struct snd_mixer_oss;
struct snd_card {
   int number ;
   char id[16] ;
   char driver[16] ;
   char shortname[32] ;
   char longname[80] ;
   char mixername[80] ;
   char components[128] ;
   struct module *module ;
   void *private_data ;
   void (*private_free)(struct snd_card *card ) ;
   struct list_head devices ;
   unsigned int last_numid ;
   struct rw_semaphore controls_rwsem ;
   rwlock_t ctl_files_rwlock ;
   int controls_count ;
   int user_ctl_count ;
   struct list_head controls ;
   struct list_head ctl_files ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_id ;
   struct proc_dir_entry *proc_root_link ;
   struct snd_monitor_file *files ;
   struct snd_shutdown_f_ops *s_f_ops ;
   spinlock_t files_lock ;
   int shutdown ;
   int free_on_last_close ;
   wait_queue_head_t shutdown_sleep ;
   struct device *dev ;
   unsigned int power_state ;
   struct mutex power_lock ;
   wait_queue_head_t power_sleep ;
   struct snd_mixer_oss *mixer_oss ;
   int mixer_oss_change_count ;
};
//#line  337
struct resource;
//#line  446 "include/sound/core.h"
struct snd_pci_quirk {
   unsigned short subvendor ;
   unsigned short subdevice ;
   int value ;
};
//#line  63 "include/sound/asound.h"
struct snd_aes_iec958 {
   unsigned char status[24] ;
   unsigned char subcode[147] ;
   unsigned char pad ;
   unsigned char dig_subframe[4] ;
};
//#line  144 "include/sound/asound.h"
typedef unsigned long snd_pcm_uframes_t;
//#line  145 "include/sound/asound.h"
typedef long snd_pcm_sframes_t;
//#line  169 "include/sound/asound.h"
typedef int snd_pcm_access_t;
//#line  177 "include/sound/asound.h"
typedef int snd_pcm_format_t;
//#line  241 "include/sound/asound.h"
typedef int snd_pcm_subformat_t;
//#line  260 "include/sound/asound.h"
typedef int snd_pcm_state_t;
//#line  278 "include/sound/asound.h"
union snd_pcm_sync_id {
   unsigned char id[16] ;
   unsigned short id16[8] ;
   unsigned int id32[4] ;
};
//#line  300 "include/sound/asound.h"
typedef int snd_pcm_hw_param_t;
//#line  334 "include/sound/asound.h"
struct snd_interval {
   unsigned int min ;
   unsigned int max ;
   unsigned int openmin : 1 ;
   unsigned int openmax : 1 ;
   unsigned int integer : 1 ;
   unsigned int empty : 1 ;
};
//#line  344 "include/sound/asound.h"
struct snd_mask {
   u_int32_t bits[8] ;
};
//#line  348 "include/sound/asound.h"
struct snd_pcm_hw_params {
   unsigned int flags ;
   struct snd_mask masks[3] ;
   struct snd_mask mres[5] ;
   struct snd_interval intervals[12] ;
   struct snd_interval ires[9] ;
   unsigned int rmask ;
   unsigned int cmask ;
   unsigned int info ;
   unsigned int msbits ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   snd_pcm_uframes_t fifo_size ;
   unsigned char reserved[64] ;
};
//#line  407 "include/sound/asound.h"
struct snd_pcm_mmap_status {
   snd_pcm_state_t state ;
   int pad1 ;
   snd_pcm_uframes_t hw_ptr ;
   struct timespec tstamp ;
   snd_pcm_state_t suspended_state ;
};
//#line  415 "include/sound/asound.h"
struct snd_pcm_mmap_control {
   snd_pcm_uframes_t appl_ptr ;
   snd_pcm_uframes_t avail_min ;
};
//#line  725 "include/sound/asound.h"
typedef int snd_ctl_elem_type_t;
//#line  735 "include/sound/asound.h"
typedef int snd_ctl_elem_iface_t;
//#line  769 "include/sound/asound.h"
struct snd_ctl_elem_id {
   unsigned int numid ;
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char name[44] ;
   unsigned int index ;
};
//#line  787 "include/sound/asound.h"
struct __anonstruct_integer_204 {
   long min ;
   long max ;
   long step ;
};
struct __anonstruct_integer64_205 {
   long long min ;
   long long max ;
   long long step ;
};
struct __anonstruct_enumerated_206 {
   unsigned int items ;
   unsigned int item ;
   char name[64] ;
};
union __anonunion_value_203 {
   struct __anonstruct_integer_204 integer ;
   struct __anonstruct_integer64_205 integer64 ;
   struct __anonstruct_enumerated_206 enumerated ;
   unsigned char reserved[128] ;
};
union __anonunion_dimen_207 {
   unsigned short d[4] ;
   unsigned short *d_ptr ;
};
struct snd_ctl_elem_info {
   struct snd_ctl_elem_id id ;
   snd_ctl_elem_type_t type ;
   unsigned int access ;
   unsigned int count ;
   pid_t owner ;
   union __anonunion_value_203 value ;
   union __anonunion_dimen_207 dimen ;
   unsigned char reserved[64UL - 4UL * sizeof(unsigned short )] ;
};
//#line  818 "include/sound/asound.h"
union __anonunion_integer_209 {
   long value[128] ;
   long *value_ptr ;
};
union __anonunion_integer64_210 {
   long long value[64] ;
   long long *value_ptr ;
};
union __anonunion_enumerated_211 {
   unsigned int item[128] ;
   unsigned int *item_ptr ;
};
union __anonunion_bytes_212 {
   unsigned char data[512] ;
   unsigned char *data_ptr ;
};
union __anonunion_value_208 {
   union __anonunion_integer_209 integer ;
   union __anonunion_integer64_210 integer64 ;
   union __anonunion_enumerated_211 enumerated ;
   union __anonunion_bytes_212 bytes ;
   struct snd_aes_iec958 iec958 ;
};
struct snd_ctl_elem_value {
   struct snd_ctl_elem_id id ;
   unsigned int indirect : 1 ;
   union __anonunion_value_208 value ;
   struct timespec tstamp ;
   unsigned char reserved[128UL - sizeof(struct timespec )] ;
};
//#line  29 "include/sound/control.h"
struct snd_kcontrol;
struct snd_kcontrol;
//#line  30 "include/sound/control.h"
typedef int snd_kcontrol_info_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo );
//#line  31 "include/sound/control.h"
typedef int snd_kcontrol_get_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  32 "include/sound/control.h"
typedef int snd_kcontrol_put_t(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol );
//#line  33 "include/sound/control.h"
typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *kcontrol , int op_flag , unsigned int size ,
                                  unsigned int __attribute__((__noderef__, __address_space__(1)))  *tlv );
//#line  39 "include/sound/control.h"
union __anonunion_tlv_217 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
struct snd_kcontrol_new {
   snd_ctl_elem_iface_t iface ;
   unsigned int device ;
   unsigned int subdevice ;
   unsigned char *name ;
   unsigned int index ;
   unsigned int access ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_217 tlv ;
   unsigned long private_value ;
};
//#line  57
struct snd_ctl_file;
struct snd_kcontrol_volatile {
   struct snd_ctl_file *owner ;
   pid_t owner_pid ;
   unsigned int access ;
};
//#line  63 "include/sound/control.h"
union __anonunion_tlv_218 {
   snd_kcontrol_tlv_rw_t *c ;
   unsigned int const   *p ;
};
struct ensoniq;
struct snd_kcontrol {
   struct list_head list ;
   struct snd_ctl_elem_id id ;
   unsigned int count ;
   snd_kcontrol_info_t *info ;
   snd_kcontrol_get_t *get ;
   snd_kcontrol_put_t *put ;
   union __anonunion_tlv_218 tlv ;
   unsigned long private_value ;
   struct ensoniq *private_data ;
   void (*private_free)(struct snd_kcontrol *kcontrol ) ;
   struct snd_kcontrol_volatile vd[0] ;
};
//#line  90
struct fasync_struct;
struct snd_ctl_file {
   struct list_head list ;
   struct snd_card *card ;
   pid_t pid ;
   int prefer_pcm_subdevice ;
   int prefer_rawmidi_subdevice ;
   wait_queue_head_t change_sleep ;
   spinlock_t read_lock ;
   struct fasync_struct *fasync ;
   int subscribed ;
   struct list_head events ;
};
//#line  27 "include/sound/memalloc.h"
struct device;
//#line  32 "include/sound/memalloc.h"
struct snd_dma_device {
   int type ;
   struct device *dev ;
};
//#line  55 "include/sound/memalloc.h"
struct snd_dma_buffer {
   struct snd_dma_device dev ;
   unsigned char *area ;
   dma_addr_t addr ;
   size_t bytes ;
   void *private_data ;
};
//#line  31 "include/asm-generic/poll.h"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
//#line  11 "include/linux/dcache.h"
struct nameidata;
struct nameidata;
//#line  12
struct path;
//#line  13
struct vfsmount;
//#line  33 "include/linux/dcache.h"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
//#line  89 "include/linux/dcache.h"
union __anonunion_d_u_220 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
struct dentry_operations;
struct super_block;
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_220 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[32] ;
};
//#line  134 "include/linux/dcache.h"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
//#line  61 "include/linux/radix-tree.h"
struct radix_tree_node;
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
//#line  14 "include/linux/fiemap.h"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
//#line  316 "include/linux/fs.h"
struct export_operations;
struct export_operations;
//#line  318
struct iovec;
//#line  319
struct nameidata;
//#line  320
struct kiocb;
//#line  321
struct pipe_inode_info;
//#line  322
struct poll_table_struct;
struct poll_table_struct;
//#line  323
struct kstatfs;
struct kstatfs;
//#line  324
struct vm_area_struct;
//#line  325
struct vfsmount;
//#line  326
struct cred;
//#line  378 "include/linux/fs.h"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
//#line  106 "include/linux/quota.h"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
//#line  127 "include/linux/quota.h"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
//#line  50 "include/linux/dqblk_xfs.h"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
//#line  137 "include/linux/dqblk_xfs.h"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
typedef struct fs_qfilestat fs_qfilestat_t;
//#line  143 "include/linux/dqblk_xfs.h"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
//#line  17 "include/linux/dqblk_qtree.h"
struct dquot;
struct dquot;
//#line  182 "include/linux/quota.h"
typedef __kernel_uid32_t qid_t;
//#line  183 "include/linux/quota.h"
typedef long long qsize_t;
//#line  197 "include/linux/quota.h"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
//#line  211
struct quota_format_type;
struct quota_format_type;
//#line  213 "include/linux/quota.h"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
//#line  226
struct super_block;
//#line  263 "include/linux/quota.h"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
//#line  285 "include/linux/quota.h"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
//#line  296 "include/linux/quota.h"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
//#line  314 "include/linux/quota.h"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
//#line  328 "include/linux/quota.h"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
//#line  372 "include/linux/quota.h"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
//#line  441 "include/linux/fs.h"
struct page;
//#line  442
struct address_space;
//#line  443
struct writeback_control;
//#line  486 "include/linux/fs.h"
union __anonunion_arg_226 {
   char __attribute__((__noderef__, __address_space__(1)))  *buf ;
   void *data ;
};
struct __anonstruct_read_descriptor_t_225 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_226 arg ;
   int error ;
};
typedef struct __anonstruct_read_descriptor_t_225 read_descriptor_t;
//#line  499 "include/linux/fs.h"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
//#line  548
struct backing_dev_info;
//#line  549 "include/linux/fs.h"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  573
struct hd_struct;
struct gendisk;
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
//#line  649
struct inode_operations;
struct file_lock;
struct cdev;
union __anonunion____missing_field_name_227 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
struct dnotify_struct;
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_227 __annonCompField23 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
//#line  804 "include/linux/fs.h"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
//#line  815 "include/linux/fs.h"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
//#line  838 "include/linux/fs.h"
union __anonunion_f_u_228 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
struct file {
   union __anonunion_f_u_228 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void * __attribute__((__noderef__, __address_space__(2))) private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
//#line  957 "include/linux/fs.h"
typedef struct files_struct *fl_owner_t;
//#line  959 "include/linux/fs.h"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
//#line  964 "include/linux/fs.h"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
//#line  8 "include/linux/nfs_fs_i.h"
struct nlm_lockowner;
struct nlm_lockowner;
//#line  13 "include/linux/nfs_fs_i.h"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
//#line  19
struct nfs4_lock_state;
struct nfs4_lock_state;
//#line  20 "include/linux/nfs_fs_i.h"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
//#line  986 "include/linux/fs.h"
struct __anonstruct_afs_230 {
   struct list_head link ;
   int state ;
};
union __anonunion_fl_u_229 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_230 afs ;
};
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_229 fl_u ;
};
//#line  1097 "include/linux/fs.h"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
//#line  1132
struct file_system_type;
struct super_operations;
struct xattr_handler;
struct mtd_info;
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
//#line  1258 "include/linux/fs.h"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
//#line  1310 "include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char __attribute__((__noderef__, __address_space__(1)))  * ,
                   size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const __attribute__((__noderef__, __address_space__(1)))  * ,
                    size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
//#line  1339 "include/linux/fs.h"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char __attribute__((__noderef__, __address_space__(1)))  * ,
                   int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
//#line  1368
struct seq_file;
//#line  1382 "include/linux/fs.h"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
//#line  1565 "include/linux/fs.h"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
//#line  1949
struct bio;
//#line  95 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/uaccess.h"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
//#line  26 "include/linux/poll.h"
struct poll_table_struct;
//#line  33 "include/linux/poll.h"
struct poll_table_struct {
   void (*qproc)(struct file * , wait_queue_head_t * , struct poll_table_struct * ) ;
};
typedef struct poll_table_struct poll_table;
//#line  25 "include/sound/pcm_oss.h"
struct snd_pcm_oss_setup {
   char *task_name ;
   unsigned int disable : 1 ;
   unsigned int direct : 1 ;
   unsigned int block : 1 ;
   unsigned int nonblock : 1 ;
   unsigned int partialfrag : 1 ;
   unsigned int nosilence : 1 ;
   unsigned int buggyptr : 1 ;
   unsigned int periods ;
   unsigned int period_size ;
   struct snd_pcm_oss_setup *next ;
};
//#line  39
struct snd_pcm_plugin;
struct snd_pcm_oss_runtime {
   unsigned int params : 1 ;
   unsigned int prepare : 1 ;
   unsigned int trigger : 1 ;
   unsigned int sync_trigger : 1 ;
   int rate ;
   int format ;
   unsigned int channels ;
   unsigned int fragshift ;
   unsigned int maxfrags ;
   unsigned int subdivision ;
   size_t period_bytes ;
   size_t period_frames ;
   size_t period_ptr ;
   unsigned int periods ;
   size_t buffer_bytes ;
   size_t bytes ;
   size_t mmap_bytes ;
   char *buffer ;
   size_t buffer_used ;
   struct mutex params_lock ;
   struct snd_pcm_plugin *plugin_first ;
   struct snd_pcm_plugin *plugin_last ;
   unsigned int prev_hw_ptr_interrupt ;
};
//#line  67
struct snd_pcm_substream;
//#line  71 "include/sound/pcm_oss.h"
struct snd_pcm_oss_substream {
   unsigned int oss : 1 ;
   struct snd_pcm_oss_setup setup ;
};
//#line  76 "include/sound/pcm_oss.h"
struct snd_pcm_oss_stream {
   struct snd_pcm_oss_setup *setup_list ;
   struct mutex setup_mutex ;
   struct snd_info_entry *proc_entry ;
};
//#line  84 "include/sound/pcm_oss.h"
struct snd_pcm_oss {
   int reg ;
   unsigned int reg_mask ;
};
//#line  44 "include/sound/pcm.h"
struct snd_pcm_hardware {
   unsigned int info ;
   u64 formats ;
   unsigned int rates ;
   unsigned int rate_min ;
   unsigned int rate_max ;
   unsigned int channels_min ;
   unsigned int channels_max ;
   size_t buffer_bytes_max ;
   size_t period_bytes_min ;
   size_t period_bytes_max ;
   unsigned int periods_min ;
   unsigned int periods_max ;
   size_t fifo_size ;
};
//#line  60
struct snd_pcm_substream;
//#line  62 "include/sound/pcm.h"
struct snd_pcm_ops {
   int (*open)(struct snd_pcm_substream *substream ) ;
   int (*close)(struct snd_pcm_substream *substream ) ;
   int (*ioctl)(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
   int (*hw_params)(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *params ) ;
   int (*hw_free)(struct snd_pcm_substream *substream ) ;
   int (*prepare)(struct snd_pcm_substream *substream ) ;
   int (*trigger)(struct snd_pcm_substream *substream , int cmd ) ;
   snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream ) ;
   int (*copy)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
               void __attribute__((__noderef__, __address_space__(1)))  *buf , snd_pcm_uframes_t count ) ;
   int (*silence)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
                  snd_pcm_uframes_t count ) ;
   struct page *(*page)(struct snd_pcm_substream *substream , unsigned long offset ) ;
   int (*mmap)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ) ;
   int (*ack)(struct snd_pcm_substream *substream ) ;
};
//#line  204
struct snd_pcm_hw_rule;
struct snd_pcm_hw_rule;
//#line  208 "include/sound/pcm.h"
struct snd_pcm_hw_rule {
   unsigned int cond ;
   int (*func)(struct snd_pcm_hw_params *params , struct snd_pcm_hw_rule *rule ) ;
   int var ;
   int deps[4] ;
   void *private ;
};
//#line  216 "include/sound/pcm.h"
struct snd_pcm_hw_constraints {
   struct snd_mask masks[3] ;
   struct snd_interval intervals[12] ;
   unsigned int rules_num ;
   unsigned int rules_all ;
   struct snd_pcm_hw_rule *rules ;
};
//#line  238 "include/sound/pcm.h"
struct snd_ratnum {
   unsigned int num ;
   unsigned int den_min ;
   unsigned int den_max ;
   unsigned int den_step ;
};
//#line  243 "include/sound/pcm.h"
struct snd_ratden {
   unsigned int num_min ;
   unsigned int num_max ;
   unsigned int num_step ;
   unsigned int den ;
};
//#line  248 "include/sound/pcm.h"
struct snd_pcm_hw_constraint_ratnums {
   int nrats ;
   struct snd_ratnum *rats ;
};
//#line  253 "include/sound/pcm.h"
struct snd_pcm_hw_constraint_ratdens {
   int nrats ;
   struct snd_ratden *rats ;
};
//#line  264 "include/sound/pcm.h"
struct snd_pcm_runtime {
   struct snd_pcm_substream *trigger_master ;
   struct timespec trigger_tstamp ;
   int overrange ;
   snd_pcm_uframes_t avail_max ;
   snd_pcm_uframes_t hw_ptr_base ;
   snd_pcm_uframes_t hw_ptr_interrupt ;
   snd_pcm_access_t access ;
   snd_pcm_format_t format ;
   snd_pcm_subformat_t subformat ;
   unsigned int rate ;
   unsigned int channels ;
   snd_pcm_uframes_t period_size ;
   unsigned int periods ;
   snd_pcm_uframes_t buffer_size ;
   snd_pcm_uframes_t min_align ;
   size_t byte_align ;
   unsigned int frame_bits ;
   unsigned int sample_bits ;
   unsigned int info ;
   unsigned int rate_num ;
   unsigned int rate_den ;
   int tstamp_mode ;
   unsigned int period_step ;
   snd_pcm_uframes_t start_threshold ;
   snd_pcm_uframes_t stop_threshold ;
   snd_pcm_uframes_t silence_threshold ;
   snd_pcm_uframes_t silence_size ;
   snd_pcm_uframes_t boundary ;
   snd_pcm_uframes_t silence_start ;
   snd_pcm_uframes_t silence_filled ;
   union snd_pcm_sync_id sync ;
   struct snd_pcm_mmap_status *status ;
   struct snd_pcm_mmap_control *control ;
   wait_queue_head_t sleep ;
   struct fasync_struct *fasync ;
   void *private_data ;
   void (*private_free)(struct snd_pcm_runtime *runtime ) ;
   struct snd_pcm_hardware hw ;
   struct snd_pcm_hw_constraints hw_constraints ;
   void (*transfer_ack_begin)(struct snd_pcm_substream *substream ) ;
   void (*transfer_ack_end)(struct snd_pcm_substream *substream ) ;
   unsigned int timer_resolution ;
   int tstamp_type ;
   unsigned char * __attribute__((__noderef__, __address_space__(2))) dma_area ;
   dma_addr_t __attribute__((__noderef__, __address_space__(2)))  dma_addr ;
   size_t __attribute__((__noderef__, __address_space__(2)))  dma_bytes ;
   struct snd_dma_buffer * __attribute__((__noderef__, __address_space__(2))) dma_buffer_p ;
   struct snd_pcm_oss_runtime oss ;
};
//#line  342 "include/sound/pcm.h"
struct snd_pcm_group {
   spinlock_t lock ;
   struct list_head substreams ;
   int count ;
};
//#line  348
struct snd_pcm;
struct snd_pcm_str;
struct snd_timer;
struct snd_pcm_substream {
   struct snd_pcm *pcm ;
   struct snd_pcm_str *pstr ;
   struct ensoniq *private_data ;
   int number ;
   char name[32] ;
   int stream ;
   char latency_id[20] ;
   size_t buffer_bytes_max ;
   struct snd_dma_buffer dma_buffer ;
   unsigned int dma_buf_id ;
   size_t dma_max ;
   struct snd_pcm_ops *ops ;
   struct snd_pcm_runtime *runtime ;
   struct snd_timer *timer ;
   unsigned int timer_running : 1 ;
   spinlock_t timer_lock ;
   struct snd_pcm_substream *next ;
   struct list_head link_list ;
   struct snd_pcm_group self_group ;
   struct snd_pcm_group *group ;
   void *file ;
   int ref_count ;
   atomic_t mmap_count ;
   unsigned int f_flags ;
   void (*pcm_release)(struct snd_pcm_substream * ) ;
   struct snd_pcm_oss_substream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
   struct snd_info_entry *proc_hw_params_entry ;
   struct snd_info_entry *proc_sw_params_entry ;
   struct snd_info_entry *proc_status_entry ;
   struct snd_info_entry *proc_prealloc_entry ;
   struct snd_info_entry *proc_prealloc_max_entry ;
   unsigned int hw_opened : 1 ;
};
//#line  400 "include/sound/pcm.h"
struct snd_pcm_str {
   int stream ;
   struct snd_pcm *pcm ;
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct snd_pcm_substream *substream ;
   struct snd_pcm_oss_stream oss ;
   struct snd_info_entry *proc_root ;
   struct snd_info_entry *proc_info_entry ;
};
//#line  421 "include/sound/pcm.h"
struct snd_pcm {
   struct snd_card *card ;
   struct list_head list ;
   int device ;
   unsigned int info_flags ;
   unsigned short dev_class ;
   unsigned short dev_subclass ;
   char id[64] ;
   char name[80] ;
   struct snd_pcm_str streams[2] ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   void *private_data ;
   void (*private_free)(struct snd_pcm *pcm ) ;
   struct device *dev ;
   struct snd_pcm_oss oss ;
};
//#line  34 "include/sound/seq_device.h"
struct snd_seq_device {
   struct snd_card *card ;
   int device ;
   char id[32] ;
   char name[80] ;
   int argsize ;
   void *driver_data ;
   int status ;
   void *private_data ;
   void (*private_free)(struct snd_seq_device *device ) ;
   struct list_head list ;
};
//#line  47 "include/sound/rawmidi.h"
struct snd_rawmidi;
struct snd_rawmidi;
//#line  48
struct snd_rawmidi_substream;
struct snd_rawmidi_substream;
//#line  49
struct snd_seq_port_info;
struct snd_seq_port_info;
//#line  51 "include/sound/rawmidi.h"
struct snd_rawmidi_ops {
   int (*open)(struct snd_rawmidi_substream *substream ) ;
   int (*close)(struct snd_rawmidi_substream *substream ) ;
   void (*trigger)(struct snd_rawmidi_substream *substream , int up ) ;
   void (*drain)(struct snd_rawmidi_substream *substream ) ;
};
//#line  58 "include/sound/rawmidi.h"
struct snd_rawmidi_global_ops {
   int (*dev_register)(struct snd_rawmidi *rmidi ) ;
   int (*dev_unregister)(struct snd_rawmidi *rmidi ) ;
   void (*get_port_info)(struct snd_rawmidi *rmidi , int number , struct snd_seq_port_info *info ) ;
};
//#line  65 "include/sound/rawmidi.h"
struct snd_rawmidi_runtime {
   unsigned int drain : 1 ;
   unsigned int oss : 1 ;
   unsigned char *buffer ;
   size_t buffer_size ;
   size_t appl_ptr ;
   size_t hw_ptr ;
   size_t avail_min ;
   size_t avail ;
   size_t xruns ;
   spinlock_t lock ;
   wait_queue_head_t sleep ;
   void (*event)(struct snd_rawmidi_substream *substream ) ;
   struct tasklet_struct tasklet ;
   void *private_data ;
   void (*private_free)(struct snd_rawmidi_substream *substream ) ;
};
//#line  88
struct snd_rawmidi_str;
struct snd_rawmidi_substream {
   struct list_head list ;
   int stream ;
   int number ;
   unsigned int opened : 1 ;
   unsigned int append : 1 ;
   unsigned int active_sensing : 1 ;
   int use_count ;
   size_t bytes ;
   struct snd_rawmidi *rmidi ;
   struct snd_rawmidi_str *pstr ;
   char name[32] ;
   struct snd_rawmidi_runtime *runtime ;
   struct snd_rawmidi_ops *ops ;
};
//#line  111 "include/sound/rawmidi.h"
struct snd_rawmidi_str {
   unsigned int substream_count ;
   unsigned int substream_opened ;
   struct list_head substreams ;
};
//#line  117 "include/sound/rawmidi.h"
struct snd_rawmidi {
   struct snd_card *card ;
   struct list_head list ;
   unsigned int device ;
   unsigned int info_flags ;
   char id[64] ;
   char name[80] ;
   int ossreg ;
   struct snd_rawmidi_global_ops *ops ;
   struct snd_rawmidi_str streams[2] ;
   struct ensoniq *private_data ;
   void (*private_free)(struct snd_rawmidi *rmidi ) ;
   struct mutex open_mutex ;
   wait_queue_head_t open_wait ;
   struct snd_info_entry *dev ;
   struct snd_info_entry *proc_entry ;
   struct snd_seq_device *seq_dev ;
};
//#line  28 "include/sound/info.h"
struct snd_info_buffer {
   char *buffer ;
   unsigned int curr ;
   unsigned int size ;
   unsigned int len ;
   int stop ;
   int error ;
};
//#line  40
struct snd_info_entry;
//#line  42 "include/sound/info.h"
struct snd_info_entry_text {
   void (*read)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
   void (*write)(struct snd_info_entry *entry , struct snd_info_buffer *buffer ) ;
};
//#line  49 "include/sound/info.h"
struct snd_info_entry_ops {
   int (*open)(struct snd_info_entry *entry , unsigned short mode , void **file_private_data ) ;
   int (*release)(struct snd_info_entry *entry , unsigned short mode , void *file_private_data ) ;
   long (*read)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                char __attribute__((__noderef__, __address_space__(1)))  *buf , unsigned long count ,
                unsigned long pos ) ;
   long (*write)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                 char const __attribute__((__noderef__, __address_space__(1)))  *buf ,
                 unsigned long count , unsigned long pos ) ;
   long long (*llseek)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                       long long offset , int orig ) ;
   unsigned int (*poll)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                        poll_table *wait ) ;
   int (*ioctl)(struct snd_info_entry *entry , void *file_private_data , struct file *file ,
                unsigned int cmd , unsigned long arg ) ;
   int (*mmap)(struct snd_info_entry *entry , void *file_private_data , struct inode *inode ,
               struct file *file , struct vm_area_struct *vma ) ;
};
//#line  73 "include/sound/info.h"
union __anonunion_c_234 {
   struct snd_info_entry_text text ;
   struct snd_info_entry_ops *ops ;
};
struct snd_info_entry {
   char const   *name ;
   mode_t mode ;
   long size ;
   unsigned short content ;
   union __anonunion_c_234 c ;
   struct snd_info_entry *parent ;
   struct snd_card *card ;
   struct module *module ;
   struct ensoniq *private_data ;
   void (*private_free)(struct snd_info_entry *entry ) ;
   struct proc_dir_entry *p ;
   struct mutex access ;
   struct list_head children ;
   struct list_head list ;
};
//#line  416 "include/sound/ac97_codec.h"
struct snd_ac97;
struct snd_ac97;
//#line  418 "include/sound/ac97_codec.h"
struct snd_ac97_build_ops {
   int (*build_3d)(struct snd_ac97 *ac97 ) ;
   int (*build_specific)(struct snd_ac97 *ac97 ) ;
   int (*build_spdif)(struct snd_ac97 *ac97 ) ;
   int (*build_post_spdif)(struct snd_ac97 *ac97 ) ;
   void (*suspend)(struct snd_ac97 *ac97 ) ;
   void (*resume)(struct snd_ac97 *ac97 ) ;
   void (*update_jacks)(struct snd_ac97 *ac97 ) ;
};
//#line  430 "include/sound/ac97_codec.h"
struct snd_ac97_bus_ops {
   void (*reset)(struct snd_ac97 *ac97 ) ;
   void (*warm_reset)(struct snd_ac97 *ac97 ) ;
   void (*write)(struct snd_ac97 *ac97 , unsigned short reg , unsigned short val ) ;
   unsigned short (*read)(struct snd_ac97 *ac97 , unsigned short reg ) ;
   void (*wait)(struct snd_ac97 *ac97 ) ;
   void (*init)(struct snd_ac97 *ac97 ) ;
};
//#line  439
struct ac97_pcm;
struct snd_ac97_bus {
   struct snd_ac97_bus_ops *ops ;
   void *private_data ;
   void (*private_free)(struct snd_ac97_bus *bus ) ;
   struct snd_card *card ;
   unsigned short num ;
   unsigned short no_vra : 1 ;
   unsigned short dra : 1 ;
   unsigned short isdin : 1 ;
   unsigned int clock ;
   spinlock_t bus_lock ;
   unsigned short used_slots[2][4] ;
   unsigned short pcms_count ;
   struct ac97_pcm *pcms ;
   struct snd_ac97 *codec[4] ;
   struct snd_info_entry *proc ;
};
//#line  462 "include/sound/ac97_codec.h"
struct snd_ac97_res_table {
   unsigned short reg ;
   unsigned short bits ;
};
//#line  467 "include/sound/ac97_codec.h"
struct snd_ac97_template {
   void *private_data ;
   void (*private_free)(struct snd_ac97 *ac97 ) ;
   struct pci_dev *pci ;
   unsigned short num ;
   unsigned short addr ;
   unsigned int scaps ;
   struct snd_ac97_res_table  const  *res_table ;
};
//#line  477 "include/sound/ac97_codec.h"
struct __anonstruct_ad18xx_236 {
   unsigned short unchained[3] ;
   unsigned short chained[3] ;
   unsigned short id[3] ;
   unsigned short pcmreg[3] ;
   unsigned short codec_cfg[3] ;
   unsigned char swap_mic_linein ;
   unsigned char lo_as_master ;
};
union __anonunion_spec_235 {
   struct __anonstruct_ad18xx_236 ad18xx ;
   unsigned int dev_flags ;
};
struct snd_ac97 {
   struct snd_ac97_build_ops *build_ops ;
   struct ensoniq *private_data ;
   void (*private_free)(struct snd_ac97 *ac97 ) ;
   struct snd_ac97_bus *bus ;
   struct pci_dev *pci ;
   struct snd_info_entry *proc ;
   struct snd_info_entry *proc_regs ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   struct mutex reg_mutex ;
   struct mutex page_mutex ;
   unsigned short num ;
   unsigned short addr ;
   unsigned int id ;
   unsigned short caps ;
   unsigned short ext_id ;
   unsigned short ext_mid ;
   struct snd_ac97_res_table  const  *res_table ;
   unsigned int scaps ;
   unsigned int flags ;
   unsigned int rates[6] ;
   unsigned int spdif_status ;
   unsigned short regs[128] ;
   unsigned long reg_accessed[((128UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   union __anonunion_spec_235 spec ;
   unsigned char indep_surround ;
   unsigned char channel_mode ;
   struct device dev ;
};
//#line  618 "include/sound/ac97_codec.h"
struct __anonstruct_r_238 {
   unsigned short slots ;
   unsigned short rslots[4] ;
   unsigned char rate_table[4] ;
   struct snd_ac97 *codec[4] ;
};
struct ac97_pcm {
   struct snd_ac97_bus *bus ;
   unsigned int stream : 1 ;
   unsigned int exclusive : 1 ;
   unsigned int copy_flag : 1 ;
   unsigned int spdif : 1 ;
   unsigned short aslots ;
   unsigned short cur_dbl ;
   unsigned int rates ;
   struct __anonstruct_r_238 r[2] ;
   unsigned long private_value ;
};
//#line  11 "include/linux/proc_fs.h"
struct completion;
//#line  12
struct mm_struct;
//#line  49 "include/linux/proc_fs.h"
typedef int read_proc_t(char *page , char **start , off_t off , int count , int *eof ,
                        void *data );
//#line  51 "include/linux/proc_fs.h"
typedef int write_proc_t(struct file *file , char const __attribute__((__noderef__,
                         __address_space__(1)))  *buffer , unsigned long count , void *data );
//#line  54 "include/linux/proc_fs.h"
struct proc_dir_entry {
   unsigned int low_ino ;
   unsigned short namelen ;
   char const   *name ;
   mode_t mode ;
   nlink_t nlink ;
   uid_t uid ;
   gid_t gid ;
   loff_t size ;
   struct inode_operations  const  *proc_iops ;
   struct file_operations  const  *proc_fops ;
   struct module *owner ;
   struct proc_dir_entry *next ;
   struct proc_dir_entry *parent ;
   struct proc_dir_entry *subdir ;
   void *data ;
   read_proc_t *read_proc ;
   write_proc_t *write_proc ;
   atomic_t count ;
   int pde_users ;
   spinlock_t pde_unload_lock ;
   struct completion *pde_unload_completion ;
   struct list_head pde_openers ;
};
//#line  124
struct pid_namespace;
//#line  389 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
struct __anonstruct_es1371_241 {
   struct snd_ac97 *ac97 ;
};
union __anonunion_u_240 {
   struct __anonstruct_es1371_241 es1371 ;
};
struct ensoniq {
   spinlock_t * __attribute__((__noderef__, __address_space__(2))) reg_lock ;
   struct mutex * __attribute__((__noderef__, __address_space__(2))) src_mutex ;
   int irq ;
   unsigned long playback1size ;
   unsigned long playback2size ;
   unsigned long capture3size ;
   unsigned long port ;
   unsigned int mode ;
   unsigned int uartm ;
   unsigned int ctrl ;
   unsigned int sctrl ;
   unsigned int cssr ;
   unsigned int uartc ;
   unsigned int rev ;
   union __anonunion_u_240 u ;
   struct pci_dev *pci ;
   struct snd_card *card ;
   struct snd_pcm *pcm1 ;
   struct snd_pcm *pcm2 ;
   struct snd_pcm_substream *playback1_substream ;
   struct snd_pcm_substream *playback2_substream ;
   struct snd_pcm_substream *capture_substream ;
   unsigned int p1_dma_size ;
   unsigned int p2_dma_size ;
   unsigned int c_dma_size ;
   unsigned int p1_period_size ;
   unsigned int p2_period_size ;
   unsigned int c_period_size ;
   struct snd_rawmidi *rmidi ;
   struct snd_rawmidi_substream *midi_input ;
   struct snd_rawmidi_substream *midi_output ;
   unsigned int spdif ;
   unsigned int spdif_default ;
   unsigned int spdif_stream ;
   struct gameport *gameport ;
};
//#line  1612 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
struct es1371_quirk {
   unsigned short vid ;
   unsigned short did ;
   unsigned char rev ;
};
//#line  2173
struct spinlock_t;
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
//#line  1 "ens1371.merged.sym.c"
#pragma merger(0,"./ens1371_annotated.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  118 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/io_64.h"
__inline static unsigned char ( __attribute__((__always_inline__)) inb)(unsigned short port ) 
{ 
  unsigned char _v ;

  {
  __asm__  volatile   ("in"
                       "b"
                       " %"
                       "w"
                       "1,%"
                       ""
                       "0": "=a" (_v): "Nd" (port));
  return (_v);
}
}
//#line  124 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/io_64.h"
__inline static unsigned int ( __attribute__((__always_inline__)) inl)(unsigned short port ) 
{ 
  unsigned int _v ;

  {
  __asm__  volatile   ("in"
                       "l"
                       " %"
                       "w"
                       "1,%"
                       ""
                       "0": "=a" (_v): "Nd" (port));
  return (_v);
}
}
//#line  127 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/io_64.h"
__inline static void ( __attribute__((__always_inline__)) outb)(unsigned char value ,
                                                                unsigned short port ) 
{ 


  {
  __asm__  volatile   ("out"
                       "b"
                       " %"
                       "b"
                       "0,%"
                       "w"
                       "1": : "a" (value), "Nd" (port));
  return;
}
}
//#line  129 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/io_64.h"
__inline static void ( __attribute__((__always_inline__)) outl)(unsigned int value ,
                                                                unsigned short port ) 
{ 


  {
  __asm__  volatile   ("out"
                       "l"
                       " %"
                       "0,%"
                       "w"
                       "1": : "a" (value), "Nd" (port));
  return;
}
}
//#line  119 "include/linux/kernel.h"
static int _cond_resched(void) ;
//#line  238
int printk(char const   *fmt  , ...) ;
//#line  47 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/string_64.h"
void *memset(void *s , int c , size_t n ) ;
//#line  54
char *strcpy(char *dest , char const   *src ) ;
//#line  28 "include/linux/string.h"
size_t strlcpy(char * , char const   * , size_t  ) ;
//#line  94 "include/linux/spinlock.h"
void __spin_lock_init(spinlock_t *lock , char const   *name , struct lock_class_key *key ) ;
//#line  22 "include/linux/spinlock_api_smp.h"
void _spin_lock(spinlock_t *lock ) ;
//#line  32
void _spin_lock_irq(spinlock_t *lock ) ;
//#line  35
unsigned long _spin_lock_irqsave(spinlock_t *lock ) ;
//#line  47
void _spin_unlock(spinlock_t *lock ) ;
//#line  53
void _spin_unlock_irq(spinlock_t *lock ) ;
//#line  56
void _spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
//#line  16 "/scratch/sym/annotated/linux-2.6.29-ipc-ens1371/arch/x86/include/asm/delay.h"
void __const_udelay(unsigned long xloops ) ;
//#line  137 "include/linux/wait.h"
static void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) ;
//#line  106 "include/linux/mutex.h"
static void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) ;
//#line  125
static void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) ;
//#line  150
static int mutex_trylock(struct mutex *lock ) ;
//#line  151
static void mutex_unlock(struct mutex *lock ) ;
//#line  205 "include/linux/slub_def.h"
void *__kmalloc(size_t size , gfp_t flags ) ;
//#line  212 "include/linux/slub_def.h"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  {
//#line  227
  tmp___2 = __kmalloc(size, flags);
  }
  return (tmp___2);
}
}
//#line  304 "include/linux/slab.h"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
//#line  306
  tmp = kmalloc(size, flags | 32768U);
  }
  return (tmp);
}
}
//#line  2177 "include/linux/sched.h"
__inline static int ( __attribute__((__always_inline__)) cond_resched)(void) 
{ 
  int tmp ;

  {
  {
//#line  2179
  tmp = _cond_resched();
  }
  return (tmp);
}
}
//#line  111 "include/linux/hardirq.h"
static void synchronize_irq(unsigned int irq ) ;
//#line  76 "include/linux/interrupt.h"
static int __attribute__((__warn_unused_result__))  request_irq(unsigned int  , irqreturn_t (*handler)(int  ,
                                                                                                       void * ) ,
                                                                unsigned long  , char const   * ,
                                                                void * ) ;
//#line  78
static void free_irq(unsigned int  , void * ) ;
//#line  108 "include/linux/ioport.h"
struct resource ioport_resource ;
//#line  144
static struct resource *__request_region(struct resource * , resource_size_t start ,
                                         resource_size_t n , char const   *name ,
                                         int flags ) ;
//#line  155
static void __release_region(struct resource * , resource_size_t  , resource_size_t  ) ;
//#line  159 "include/linux/moduleparam.h"
int param_set_int(char const   *val , struct kernel_param *kp ) ;
//#line  160
int param_get_int(char *buffer , struct kernel_param *kp ) ;
//#line  175
int param_set_charp(char const   *val , struct kernel_param *kp ) ;
//#line  176
int param_get_charp(char *buffer , struct kernel_param *kp ) ;
//#line  179
int param_set_bool(char const   *val , struct kernel_param *kp ) ;
//#line  180
int param_get_bool(char *buffer , struct kernel_param *kp ) ;
//#line  199
int param_array_set(char const   *val , struct kernel_param *kp ) ;
//#line  200
int param_array_get(char *buffer , struct kernel_param *kp ) ;
//#line  68 "include/linux/module.h"
void cleanup_module(void) ;
//#line  86
extern struct module __this_module ;
//#line  428 "include/linux/device.h"
__inline static char const   *( __attribute__((__always_inline__)) dev_name)(struct device  const  *dev ) 
{ 


  {
//#line  431
  return ((char const   *)(dev->bus_id));
}
}
//#line  456 "include/linux/device.h"
__inline static void *( __attribute__((__always_inline__)) dev_get_drvdata)(struct device  const  *dev ) 
{ 


  {
//#line  458
  return ((void *)dev->driver_data);
}
}
//#line  461 "include/linux/device.h"
__inline static void ( __attribute__((__always_inline__)) dev_set_drvdata)(struct device *dev ,
                                                                           void *data ) 
{ 


  {
//#line  463
  dev->driver_data = (char * __attribute__((__noderef__, __address_space__(2))) )data;
//#line  464
  return;
}
}
//#line  645 "include/linux/pci.h"
static int __attribute__((__warn_unused_result__))  pci_enable_device(struct pci_dev *dev ) ;
//#line  657
static void pci_disable_device(struct pci_dev *dev ) ;
//#line  658
static void pci_set_master(struct pci_dev *dev ) ;
//#line  690
static int pci_save_state(struct pci_dev *dev ) ;
//#line  691
static int pci_restore_state(struct pci_dev *dev ) ;
//#line  692
static int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) ;
//#line  693
static pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) ;
//#line  721
static int __attribute__((__warn_unused_result__))  pci_request_regions(struct pci_dev * ,
                                                                        char const   * ) ;
//#line  723
static void pci_release_regions(struct pci_dev * ) ;
//#line  751
static void pci_unregister_driver(struct pci_driver *dev ) ;
//#line  1076 "include/linux/pci.h"
__inline static void *( __attribute__((__always_inline__)) pci_get_drvdata)(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
  {
//#line  1078
  tmp = dev_get_drvdata((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
//#line  1081 "include/linux/pci.h"
__inline static void ( __attribute__((__always_inline__)) pci_set_drvdata)(struct pci_dev *pdev ,
                                                                           void *data ) 
{ 


  {
  {
//#line  1083
  dev_set_drvdata(& pdev->dev, data);
  }
//#line  1084
  return;
}
}
//#line  1089 "include/linux/pci.h"
__inline static char const   *( __attribute__((__always_inline__)) pci_name)(struct pci_dev *pdev ) 
{ 
  char const   *tmp ;

  {
  {
//#line  1091
  tmp = dev_name((struct device  const  *)(& pdev->dev));
  }
  return (tmp);
}
}
//#line  74 "include/linux/gameport.h"
static void __gameport_register_port(struct gameport *gameport , struct module *owner ) ;
//#line  75 "include/linux/gameport.h"
__inline static void ( __attribute__((__always_inline__)) gameport_register_port)(struct gameport *gameport ) 
{ 


  {
  {
//#line  77
  __gameport_register_port(gameport, & __this_module);
  }
//#line  78
  return;
}
}
//#line  80
static void gameport_unregister_port(struct gameport *gameport ) ;
//#line  82
static void ( /* format attribute */  gameport_set_phys)(struct gameport *gameport ,
                                                         char const   *fmt  , ...) ;
//#line  105 "include/linux/gameport.h"
__inline static struct gameport *( __attribute__((__always_inline__)) gameport_allocate_port)(void) 
{ 
  struct gameport *gameport ;
  void *tmp ;

  {
  {
//#line  107
  tmp = kzalloc(sizeof(struct gameport ), 208U);
  gameport = (struct gameport *)tmp;
  }
//#line  109
  return (gameport);
}
}
//#line  117 "include/linux/gameport.h"
__inline static void ( __attribute__((__always_inline__)) gameport_set_name)(struct gameport *gameport ,
                                                                             char const   *name ) 
{ 


  {
  {
//#line  119
  strlcpy(gameport->name, name, sizeof(gameport->name));
  }
//#line  120
  return;
}
}
//#line  177 "include/sound/core.h"
__inline static void ( __attribute__((__always_inline__)) snd_power_change_state)(struct snd_card *card ,
                                                                                  unsigned int state ) 
{ 


  {
  {
//#line  179
  card->power_state = state;
//#line  180
  __wake_up(& card->power_sleep, 3U, 1, (void *)0);
  }
//#line  181
  return;
}
}
//#line  299
static struct snd_card *snd_card_new(int idx , char const   *id , struct module *module ,
                                     int extra_size ) ;
//#line  301
static int snd_card_disconnect(struct snd_card *card ) ;
//#line  302
static int snd_card_free(struct snd_card *card ) ;
//#line  304
static int snd_card_register(struct snd_card *card ) ;
//#line  317
static int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                          struct snd_device_ops *ops ) ;
//#line  466
static struct snd_pci_quirk  const  *snd_pci_quirk_lookup(struct pci_dev *pci , struct snd_pci_quirk  const  *list ) ;
//#line  111 "include/sound/control.h"
static struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew ,
                                         void *private_data ) ;
//#line  113
static int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) ;
//#line  164
int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) ;
//#line  454 "include/sound/pcm.h"
static int snd_pcm_new(struct snd_card *card , char *id , int device , int playback_count ,
                       int capture_count , struct snd_pcm **rpcm ) ;
//#line  477
static int snd_pcm_suspend_all(struct snd_pcm *pcm ) ;
//#line  623 "include/sound/pcm.h"
__inline static snd_pcm_sframes_t ( __attribute__((__always_inline__)) bytes_to_frames)(struct snd_pcm_runtime *runtime ,
                                                                                        ssize_t size ) 
{ 


  {
//#line  625
  return ((size * 8L) / (ssize_t )runtime->frame_bits);
}
}
//#line  633 "include/sound/pcm.h"
__inline static ssize_t ( __attribute__((__always_inline__)) frames_to_bytes)(struct snd_pcm_runtime *runtime ,
                                                                              snd_pcm_sframes_t size ) 
{ 


  {
//#line  635
  return ((size * (snd_pcm_sframes_t )runtime->frame_bits) / 8L);
}
}
//#line  643 "include/sound/pcm.h"
__inline static size_t ( __attribute__((__always_inline__)) snd_pcm_lib_buffer_bytes)(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  ssize_t tmp ;

  {
  {
//#line  645
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  646
  tmp = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->buffer_size);
  }
  return ((size_t )tmp);
}
}
//#line  649 "include/sound/pcm.h"
__inline static size_t ( __attribute__((__always_inline__)) snd_pcm_lib_period_bytes)(struct snd_pcm_substream *substream ) 
{ 
  struct snd_pcm_runtime *runtime ;
  ssize_t tmp ;

  {
  {
//#line  651
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  652
  tmp = frames_to_bytes(runtime, (snd_pcm_sframes_t )runtime->period_size);
  }
  return ((size_t )tmp);
}
}
//#line  763 "include/sound/pcm.h"
__inline static void ( __attribute__((__always_inline__)) snd_pcm_trigger_done)(struct snd_pcm_substream *substream ,
                                                                                struct snd_pcm_substream *master ) 
{ 


  {
//#line  766
  (substream->runtime)->trigger_master = (struct snd_pcm_substream *)master;
//#line  767
  return;
}
}
//#line  787 "include/sound/pcm.h"
__inline static struct snd_interval *( __attribute__((__always_inline__)) hw_param_interval)(struct snd_pcm_hw_params *params ,
                                                                                             snd_pcm_hw_param_t var ) 
{ 


  {
//#line  790
  return (& params->intervals[var - 8]);
}
}
//#line  849
static int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                         snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_ratnums *r ) ;
//#line  853
static int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                         snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_ratdens *r ) ;
//#line  918
static int snd_pcm_format_width(snd_pcm_format_t format ) ;
//#line  925
static void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) ;
//#line  926
static void snd_pcm_set_sync(struct snd_pcm_substream *substream ) ;
//#line  928
int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) ;
//#line  936
static void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) ;
//#line  995
static int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm , int type ,
                                                 void *data , size_t size , size_t max ) ;
//#line  998
static int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream , size_t size ) ;
//#line  999
static int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream ) ;
//#line  149 "include/sound/rawmidi.h"
static int snd_rawmidi_new(struct snd_card *card , char *id , int device , int output_count ,
                           int input_count , struct snd_rawmidi **rmidi ) ;
//#line  152
static void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi , int stream , struct snd_rawmidi_ops *ops ) ;
//#line  158
static int snd_rawmidi_receive(struct snd_rawmidi_substream *substream , unsigned char const   *buffer ,
                               int count ) ;
//#line  165
static int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                                int count ) ;
//#line  114 "include/sound/info.h"
int snd_iprintf(struct snd_info_buffer *buffer , char *fmt  , ...) ;
//#line  139
static int snd_card_proc_new(struct snd_card *card , char const   *name , struct snd_info_entry **entryp ) ;
//#line  142 "include/sound/info.h"
__inline static void ( __attribute__((__always_inline__)) snd_info_set_text_ops)(struct snd_info_entry *entry ,
                                                                                 void *private_data ,
                                                                                 void (*read)(struct snd_info_entry * ,
                                                                                              struct snd_info_buffer * ) ) 
{ 


  {
//#line  146
  entry->private_data = (struct ensoniq *)private_data;
//#line  147
  entry->c.text.read = read;
//#line  148
  return;
}
}
//#line  553 "include/sound/ac97_codec.h"
static int snd_ac97_bus(struct snd_card *card , int num , struct snd_ac97_bus_ops *ops ,
                        void *private_data , struct snd_ac97_bus **rbus ) ;
//#line  556
static int snd_ac97_mixer(struct snd_ac97_bus *bus , struct snd_ac97_template *template ,
                          struct snd_ac97 **rac97 ) ;
//#line  575
static void snd_ac97_suspend(struct snd_ac97 *ac97 ) ;
//#line  576
static void snd_ac97_resume(struct snd_ac97 *ac97 ) ;
//#line  7 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__DUMMY(void *x ) 
{ 


  {
//#line  8
  return;
}
}
//#line  12 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void *MICRODRIVERS__MODIF_kmem_cache_zalloc(struct kmem_cache *a , gfp_t b ) 
{ 


  {
//#line  14
  return ((void *)0);
}
}
//#line  18 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
unsigned long MICRODRIVERS__MODIF__spin_lock_irqsave(spinlock_t *lock ) 
{ 


  {
//#line  20
  return (0UL);
}
}
//#line  24 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
//#line  26
  return;
}
}
//#line  30 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_pci_disable_device(struct pci_dev *dev ) 
{ 


  {
  {
//#line  32
  MICRODRIVERS__DUMMY((void *)dev->bus);
//#line  33
  MICRODRIVERS__DUMMY((void *)dev->devfn);
  }
//#line  34
  return;
}
}
//#line  38 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_pci_set_master(struct pci_dev *dev ) 
{ 


  {
  {
//#line  40
  MICRODRIVERS__DUMMY((void *)dev->bus);
//#line  41
  MICRODRIVERS__DUMMY((void *)dev->devfn);
//#line  42
  MICRODRIVERS__DUMMY((void *)(dev->dev.bus_id));
  }
//#line  43
  return;
}
}
//#line  47 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF___release_region(struct resource *a , resource_size_t b ,
                                          resource_size_t c ) 
{ 


  {
//#line  50
  return;
}
}
//#line  54 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF___spin_lock_init(spinlock_t *lock , char const   *name ,
                                          struct lock_class_key *key ) 
{ 


  {
//#line  56
  return;
}
}
//#line  60 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
struct resource *MICRODRIVERS__MODIF___request_region(struct resource *a , resource_size_t start ,
                                                      resource_size_t n , char const   *name ) 
{ 


  {
//#line  63
  return ((struct resource *)0);
}
}
//#line  67 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_enable_device(struct pci_dev *dev ) 
{ 


  {
//#line  70
  return (0);
}
}
//#line  74 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_pci_unregister_driver(struct pci_driver *drv ) 
{ 


  {
  {
//#line  76
  MICRODRIVERS__DUMMY((void *)(& drv->driver));
  }
//#line  77
  return;
}
}
//#line  81 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock(spinlock_t *lock ) 
{ 


  {
//#line  83
  return;
}
}
//#line  87 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock(spinlock_t *lock ) 
{ 


  {
//#line  89
  return;
}
}
//#line  92 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock_bh(spinlock_t *lock ) 
{ 


  {
//#line  94
  return;
}
}
//#line  98 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF___pci_register_driver(struct pci_driver *drv , struct module *owner ) 
{ 


  {
  {
//#line  100
  MICRODRIVERS__DUMMY((void *)drv->driver.name);
//#line  101
  MICRODRIVERS__DUMMY((void *)drv->name);
//#line  102
  MICRODRIVERS__DUMMY((void *)drv->driver.bus);
//#line  103
  MICRODRIVERS__DUMMY((void *)drv->driver.owner);
//#line  104
  MICRODRIVERS__DUMMY((void *)(& drv->dynids.lock));
//#line  105
  MICRODRIVERS__DUMMY((void *)(& drv->dynids.list));
//#line  106
  MICRODRIVERS__DUMMY((void *)(& drv->driver));
//#line  107
  MICRODRIVERS__DUMMY((void *)drv->probe);
  }
//#line  109
  return (0);
}
}
//#line  113 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_request_irq(unsigned int a , irqreturn_t (*handler)(int  ,
                                                                            void * ,
                                                                            struct pt_regs * ) ,
                                    unsigned long b , char const   *c , void *d ) 
{ 


  {
//#line  117
  return (0);
}
}
//#line  121 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
//#line  123
  return;
}
}
//#line  127 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_lock_irq(spinlock_t *lock ) 
{ 


  {
//#line  128
  return;
}
}
//#line  132 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_mutex_unlock(struct mutex *lock ) 
{ 


  {
//#line  133
  return;
}
}
//#line  137 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_mutex_lock(struct mutex *lock ) 
{ 


  {
//#line  138
  return;
}
}
//#line  142 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF__spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
//#line  143
  return;
}
}
//#line  146 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF___wake_up(wait_queue_head_t *q , unsigned int mode , int nr_exclusive ,
                                   void *key ) 
{ 


  {
//#line  148
  return;
}
}
//#line  151 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_pci_release_regions(struct pci_dev *pdev ) 
{ 


  {
//#line  152
  return;
}
}
//#line  155 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF_free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
//#line  156
  return;
}
}
//#line  159 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_set_power_state(struct pci_dev *dev , pci_power_t state ) 
{ 


  {
//#line  160
  return (0);
}
}
//#line  163 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_save_state(struct pci_dev *dev ) 
{ 


  {
//#line  164
  return (0);
}
}
//#line  167 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_restore_state(struct pci_dev *dev ) 
{ 


  {
//#line  168
  return (0);
}
}
//#line  171 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u8 *val ) 
{ 


  {
//#line  175
  return (0);
}
}
//#line  178 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
void MICRODRIVERS__MODIF___mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) 
{ 


  {
//#line  179
  return;
}
}
//#line  182 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u16 *val ) 
{ 


  {
//#line  186
  return (0);
}
}
//#line  189 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 


  {
//#line  191
  return (0);
}
}
//#line  194 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_device_create_file(struct device *dev , struct device_attribute *attr ) 
{ 


  {
  {
//#line  195
  MICRODRIVERS__DUMMY((void *)attr->attr.mode);
//#line  196
  MICRODRIVERS__DUMMY((void *)attr->attr.name);
  }
//#line  198
  return (0);
}
}
//#line  201 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_hrtimer_get_res(clockid_t which_clock , struct timespec *tp ) 
{ 


  {
  {
//#line  202
  MICRODRIVERS__DUMMY((void *)tp->tv_sec);
//#line  203
  MICRODRIVERS__DUMMY((void *)tp->tv_nsec);
  }
//#line  204
  return (0);
}
}
//#line  207 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
struct proc_dir_entry *MICRODRIVERS__MODIF_create_proc_entry(char const   *name ,
                                                             mode_t mode , struct proc_dir_entry *parent ) 
{ 


  {
  {
//#line  208
  MICRODRIVERS__DUMMY((void *)name);
//#line  209
  MICRODRIVERS__DUMMY((void *)mode);
//#line  210
  MICRODRIVERS__DUMMY((void *)parent);
//#line  211
  MICRODRIVERS__DUMMY((void *)parent->name);
  }
//#line  212
  return ((struct proc_dir_entry *)((void *)0));
}
}
//#line  215 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
struct proc_dir_entry *MICRODRIVERS__MODIF_proc_symlink(char const   *name , struct proc_dir_entry *parent ,
                                                        char const   *dest ) 
{ 


  {
  {
//#line  217
  MICRODRIVERS__DUMMY((void *)parent->name);
  }
//#line  218
  return ((struct proc_dir_entry *)((void *)0));
}
}
//#line  221 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_logWrite(void *addr , char *what , char *where , char *file ,
                                 int line ) 
{ 


  {
//#line  222
  return (0);
}
}
//#line  225 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_logRead(void *addr , char *what , char *where , char *file ,
                                int line ) 
{ 


  {
//#line  226
  return (0);
}
}
//#line  229 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_logStackFrame(char *func ) 
{ 


  {
//#line  230
  return (0);
}
}
//#line  233 "/scratch/sym/ipc_drivers/ens1371/modif_annots.h"
int MICRODRIVERS__MODIF_logAlloc(void *addr , int size , char *fn , char *file , char *allocfn ,
                                 int line ) 
{ 


  {
//#line  234
  return (0);
}
}
//#line  69 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct pci_dev *ens1371_dev  =    (struct pci_dev *)((void *)0);
static char const   __mod_author71[79]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  71
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'J', 
        (char const   )'a',      (char const   )'r',      (char const   )'o',      (char const   )'s', 
        (char const   )'l',      (char const   )'a',      (char const   )'v',      (char const   )' ', 
        (char const   )'K',      (char const   )'y',      (char const   )'s',      (char const   )'e', 
        (char const   )'l',      (char const   )'a',      (char const   )' ',      (char const   )'<', 
        (char const   )'p',      (char const   )'e',      (char const   )'r',      (char const   )'e', 
        (char const   )'x',      (char const   )'@',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'x',      (char const   )'.', 
        (char const   )'c',      (char const   )'z',      (char const   )'>',      (char const   )',', 
        (char const   )' ',      (char const   )'T',      (char const   )'h',      (char const   )'o', 
        (char const   )'m',      (char const   )'a',      (char const   )'s',      (char const   )' ', 
        (char const   )'S',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'<', 
        (char const   )'s',      (char const   )'a',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'r',      (char const   )'@',      (char const   )'i', 
        (char const   )'f',      (char const   )'e',      (char const   )'.',      (char const   )'e', 
        (char const   )'e',      (char const   )'.',      (char const   )'e',      (char const   )'t', 
        (char const   )'h',      (char const   )'z',      (char const   )'.',      (char const   )'c', 
        (char const   )'h',      (char const   )'>',      (char const   )'\000'};
static char const   __mod_license72[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  72
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
static char const   __mod_description79[46]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  79
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'E',      (char const   )'n',      (char const   )'s',      (char const   )'o', 
        (char const   )'n',      (char const   )'i',      (char const   )'q',      (char const   )'/', 
        (char const   )'C',      (char const   )'r',      (char const   )'e',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )' ',      (char const   )'A',      (char const   )'u',      (char const   )'d', 
        (char const   )'i',      (char const   )'o',      (char const   )'P',      (char const   )'C', 
        (char const   )'I',      (char const   )' ',      (char const   )'E',      (char const   )'S', 
        (char const   )'1',      (char const   )'3',      (char const   )'7',      (char const   )'1', 
        (char const   )'+',      (char const   )'\000'};
static int index[32]  = 
//#line  92
  {      -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1, 
        -1,      -1,      -1,      -1};
static char *id[32]  = 
//#line  93
  {      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0), 
        (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0),      (char *)((void *)0)};
static int enable[32]  = 
//#line  94
  {      1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1, 
        1,      1,      1,      1};
//#line  97 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int joystick_port[32]  ;
//#line  103 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int spdif[32]  ;
//#line  104 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int lineio[32]  ;
//#line  107 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_index  =    {(unsigned int )(sizeof(index) / sizeof(index[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(index[0]),
    (void *)(index)};
static char const   __param_str_index[6]  = {      (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000'};
static struct kernel_param  const  __param_index  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_index, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_index}};
static char const   __mod_indextype107[28]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_index108[55]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  108
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'n',      (char const   )'d', 
        (char const   )'e',      (char const   )'x',      (char const   )':',      (char const   )'I', 
        (char const   )'n',      (char const   )'d',      (char const   )'e',      (char const   )'x', 
        (char const   )' ',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'u',      (char const   )'e',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'E', 
        (char const   )'n',      (char const   )'s',      (char const   )'o',      (char const   )'n', 
        (char const   )'i',      (char const   )'q',      (char const   )' ',      (char const   )'A', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )'P',      (char const   )'C',      (char const   )'I',      (char const   )' ', 
        (char const   )'s',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'c',      (char const   )'a',      (char const   )'r', 
        (char const   )'d',      (char const   )'.',      (char const   )'\000'};
//#line  109 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_id  =    {(unsigned int )(sizeof(id) / sizeof(id[0]) + (sizeof(char [1]) - 1UL)), (unsigned int *)((void *)0),
    & param_set_charp, & param_get_charp, (unsigned int )sizeof(id[0]), (void *)(id)};
static char const   __param_str_id[3]  = {      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
static struct kernel_param  const  __param_id  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_id, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_id}};
static char const   __mod_idtype109[27]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'p',      (char const   )'\000'};
static char const   __mod_id110[50]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  110
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'i',      (char const   )'d',      (char const   )':', 
        (char const   )'I',      (char const   )'D',      (char const   )' ',      (char const   )'s', 
        (char const   )'t',      (char const   )'r',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'E',      (char const   )'n', 
        (char const   )'s',      (char const   )'o',      (char const   )'n',      (char const   )'i', 
        (char const   )'q',      (char const   )' ',      (char const   )'A',      (char const   )'u', 
        (char const   )'d',      (char const   )'i',      (char const   )'o',      (char const   )'P', 
        (char const   )'C',      (char const   )'I',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )'u',      (char const   )'n',      (char const   )'d', 
        (char const   )'c',      (char const   )'a',      (char const   )'r',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
//#line  111 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_enable  =    {(unsigned int )(sizeof(enable) / sizeof(enable[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_bool, & param_get_bool, (unsigned int )sizeof(enable[0]),
    (void *)(enable)};
static char const   __param_str_enable[7]  = {      (char const   )'e',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'\000'};
static struct kernel_param  const  __param_enable  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_enable, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_enable}};
static char const   __mod_enabletype111[30]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
static char const   __mod_enable112[47]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  112
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'e',      (char const   )'n',      (char const   )'a', 
        (char const   )'b',      (char const   )'l',      (char const   )'e',      (char const   )':', 
        (char const   )'E',      (char const   )'n',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'E', 
        (char const   )'n',      (char const   )'s',      (char const   )'o',      (char const   )'n', 
        (char const   )'i',      (char const   )'q',      (char const   )' ',      (char const   )'A', 
        (char const   )'u',      (char const   )'d',      (char const   )'i',      (char const   )'o', 
        (char const   )'P',      (char const   )'C',      (char const   )'I',      (char const   )' ', 
        (char const   )'s',      (char const   )'o',      (char const   )'u',      (char const   )'n', 
        (char const   )'d',      (char const   )'c',      (char const   )'a',      (char const   )'r', 
        (char const   )'d',      (char const   )'.',      (char const   )'\000'};
//#line  115 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_joystick_port  =    {(unsigned int )(sizeof(joystick_port) / sizeof(joystick_port[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(joystick_port[0]),
    (void *)(joystick_port)};
static char const   __param_str_joystick_port[14]  = 
  {      (char const   )'j',      (char const   )'o',      (char const   )'y',      (char const   )'s', 
        (char const   )'t',      (char const   )'i',      (char const   )'c',      (char const   )'k', 
        (char const   )'_',      (char const   )'p',      (char const   )'o',      (char const   )'r', 
        (char const   )'t',      (char const   )'\000'};
static struct kernel_param  const  __param_joystick_port  __attribute__((__used__,
__unused__, __section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_joystick_port, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_joystick_port}};
static char const   __mod_joystick_porttype115[36]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'j',      (char const   )'o',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'i',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_joystick_port116[42]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  116
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'j',      (char const   )'o',      (char const   )'y', 
        (char const   )'s',      (char const   )'t',      (char const   )'i',      (char const   )'c', 
        (char const   )'k',      (char const   )'_',      (char const   )'p',      (char const   )'o', 
        (char const   )'r',      (char const   )'t',      (char const   )':',      (char const   )'J', 
        (char const   )'o',      (char const   )'y',      (char const   )'s',      (char const   )'t', 
        (char const   )'i',      (char const   )'c',      (char const   )'k',      (char const   )' ', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'d',      (char const   )'d', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'.',      (char const   )'\000'};
//#line  123 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_spdif  =    {(unsigned int )(sizeof(spdif) / sizeof(spdif[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(spdif[0]),
    (void *)(spdif)};
static char const   __param_str_spdif[6]  = {      (char const   )'s',      (char const   )'p',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'\000'};
static struct kernel_param  const  __param_spdif  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_spdif, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_spdif}};
static char const   __mod_spdiftype123[28]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'s',      (char const   )'p',      (char const   )'d', 
        (char const   )'i',      (char const   )'f',      (char const   )':',      (char const   )'a', 
        (char const   )'r',      (char const   )'r',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'o',      (char const   )'f',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_spdif124[59]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  124
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'s',      (char const   )'p',      (char const   )'d', 
        (char const   )'i',      (char const   )'f',      (char const   )':',      (char const   )'S', 
        (char const   )'/',      (char const   )'P',      (char const   )'D',      (char const   )'I', 
        (char const   )'F',      (char const   )' ',      (char const   )'o',      (char const   )'u', 
        (char const   )'t',      (char const   )'p',      (char const   )'u',      (char const   )'t', 
        (char const   )' ',      (char const   )'(',      (char const   )'-',      (char const   )'1', 
        (char const   )' ',      (char const   )'=',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'n',      (char const   )'e',      (char const   )',', 
        (char const   )' ',      (char const   )'0',      (char const   )' ',      (char const   )'=', 
        (char const   )' ',      (char const   )'a',      (char const   )'u',      (char const   )'t', 
        (char const   )'o',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )' ',      (char const   )'=',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'c',      (char const   )'e', 
        (char const   )')',      (char const   )'.',      (char const   )'\000'};
//#line  125 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct kparam_array  const  __param_arr_lineio  =    {(unsigned int )(sizeof(lineio) / sizeof(lineio[0]) + (sizeof(char [1]) - 1UL)),
    (unsigned int *)((void *)0), & param_set_int, & param_get_int, (unsigned int )sizeof(lineio[0]),
    (void *)(lineio)};
static char const   __param_str_lineio[7]  = {      (char const   )'l',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )'i',      (char const   )'o',      (char const   )'\000'};
static struct kernel_param  const  __param_lineio  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_lineio, 292U, & param_array_set, & param_array_get, {.arr = & __param_arr_lineio}};
static char const   __mod_lineiotype125[29]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'i',      (char const   )'o',      (char const   )':', 
        (char const   )'a',      (char const   )'r',      (char const   )'r',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static char const   __mod_lineio126[55]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  126
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'e',      (char const   )'i',      (char const   )'o',      (char const   )':', 
        (char const   )'L',      (char const   )'i',      (char const   )'n',      (char const   )'e', 
        (char const   )' ',      (char const   )'I',      (char const   )'n',      (char const   )' ', 
        (char const   )'t',      (char const   )'o',      (char const   )' ',      (char const   )'R', 
        (char const   )'e',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'O',      (char const   )'u',      (char const   )'t',      (char const   )' ', 
        (char const   )'(',      (char const   )'0',      (char const   )' ',      (char const   )'=', 
        (char const   )' ',      (char const   )'a',      (char const   )'u',      (char const   )'t', 
        (char const   )'o',      (char const   )',',      (char const   )' ',      (char const   )'1', 
        (char const   )' ',      (char const   )'=',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )'c',      (char const   )'e', 
        (char const   )')',      (char const   )'.',      (char const   )'\000'};
//#line  452
static irqreturn_t snd_audiopci_interrupt(int irq , void *dev_id ) ;
//#line  454 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct pci_device_id snd_audiopci_ids[4]  = {      {(__u32 )4724, (__u32 )4977, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      (kernel_ulong_t )0}, 
        {(__u32 )4724, (__u32 )22656, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      (kernel_ulong_t )0}, 
        {(__u32 )4354, (__u32 )35128, (__u32 )(~ 0), (__u32 )(~ 0), (__u32 )0, (__u32 )0,
      (kernel_ulong_t )0}, 
        {(__u32 )0, 0U, 0U, 0U, 0U, 0U, 0UL}};
//#line  466
extern struct pci_device_id  const  __mod_pci_device_table  __attribute__((__unused__,
__alias__("snd_audiopci_ids"))) ;
//#line  493 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_ratden es1371_dac_clock  =    {(unsigned int )(3000 * (1 << 15)), (unsigned int )(48000 * (1 << 15)), 3000U,
    (unsigned int )(1 << 15)};
//#line  499 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_pcm_hw_constraint_ratdens snd_es1371_hw_constraints_dac_clock  =    {1,
    & es1371_dac_clock};
//#line  503 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_ratnum es1371_adc_clock  =    {(unsigned int )(48000 << 15), 32768U, 393216U, 1U};
//#line  509 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_pcm_hw_constraint_ratnums snd_es1371_hw_constraints_adc_clock  =    {1,
    & es1371_adc_clock};
//#line  514 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static unsigned int const   snd_ensoniq_sample_shift[4]  = {      (unsigned int const   )0,      (unsigned int const   )1,      (unsigned int const   )1,      (unsigned int const   )2};
//#line  523 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static unsigned int snd_es1371_wait_src_ready(struct ensoniq *ensoniq ) 
{ 
  unsigned int t ;
  unsigned int r ;

  {
//#line  525
  r = 0U;
//#line  527
  t = 0U;
  {
  {
  while (1) {


    if (! (t < 40960U)) {
      goto while_break;
    }
    {
//#line  528
    r = inl((unsigned short )(ensoniq->port + 16UL));
    }
//#line  529
    if ((r & (unsigned int )(1 << 23)) == 0U) {
//#line  530
      return (r);
    }
    {
//#line  531
    cond_resched();
//#line  527
    t ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  533
  printk(str_395763820, ensoniq->port + 16UL, r);
  }
//#line  535
  return (0U);
}
}
//#line  538 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static unsigned int snd_es1371_src_read(struct ensoniq *ensoniq , unsigned short reg ) 
{ 
  unsigned int temp ;
  unsigned int i ;
  unsigned int orig ;
  unsigned int r ;

  {
  {
//#line  543
  orig = snd_es1371_wait_src_ready(ensoniq);
  temp = orig;
//#line  546
  r = temp & (unsigned int )((((1 << 22) | (1 << 21)) | (1 << 20)) | (1 << 19));
//#line  548
  r |= (unsigned int )((((int )reg & 127) << 25) | 65536);
//#line  549
  outl(r, (unsigned short )(ensoniq->port + 16UL));
//#line  552
  temp = snd_es1371_wait_src_ready(ensoniq);
  }
//#line  554
  if ((temp & 8847360U) != 65536U) {
//#line  556
    i = 0U;
    {
    {
    while (1) {


      if (! (i < 40960U)) {
        goto while_break;
      }
      {
//#line  557
      temp = inl((unsigned short )(ensoniq->port + 16UL));
      }
//#line  558
      if ((temp & 8847360U) == 65536U) {
//#line  559
        goto while_break;
      }
//#line  556
      i ++;
    }

    }
    while_break: /* CIL Label */ ;
    }
  }
  {
//#line  564
  r = orig & (unsigned int )((((1 << 22) | (1 << 21)) | (1 << 20)) | (1 << 19));
//#line  566
  r |= (unsigned int )(((int )reg & 127) << 25);
//#line  567
  outl(r, (unsigned short )(ensoniq->port + 16UL));
  }
//#line  569
  return (temp);
}
}
//#line  572 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_src_write(struct ensoniq *ensoniq , unsigned short reg , unsigned short data ) 
{ 
  unsigned int r ;
  unsigned int tmp ;

  {
  {
//#line  577
  tmp = snd_es1371_wait_src_ready(ensoniq);
  r = tmp & (unsigned int )((((1 << 22) | (1 << 21)) | (1 << 20)) | (1 << 19));
//#line  580
  r |= (unsigned int )((((int )reg & 127) << 25) | ((int )data & 65535));
//#line  581
  outl(r | (unsigned int )(1 << 24), (unsigned short )(ensoniq->port + 16UL));
  }
//#line  582
  return;
}
}
//#line  613 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_codec_write(struct snd_ac97 *ac97 , unsigned short reg , unsigned short val ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int t ;
  unsigned int x ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
//#line  616
  ensoniq = (struct ensoniq *)ac97->private_data;
//#line  619
  mutex_lock_nested((struct mutex *)ensoniq->src_mutex, 0U);
//#line  620
  t = 0U;
  }
  {
  {
  while (1) {


    if (! (t < 40960U)) {
      goto while_break;
    }
    {
//#line  621
    tmp___1 = inl((unsigned short )(ensoniq->port + 20UL));
    }
//#line  621
    if (! (tmp___1 & (unsigned int )(1 << 30))) {
      {
//#line  623
      x = snd_es1371_wait_src_ready(ensoniq);
//#line  624
      outl((x & (unsigned int )((((1 << 22) | (1 << 21)) | (1 << 20)) | (1 << 19))) | 65536U,
           (unsigned short )(ensoniq->port + 16UL));
//#line  629
      t = 0U;
      }
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___0;
        }
        {
//#line  630
        tmp = inl((unsigned short )(ensoniq->port + 16UL));
        }
//#line  630
        if ((tmp & 8847360U) == 0U) {
//#line  632
          goto while_break___0;
        }
//#line  629
        t ++;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
//#line  635
      t = 0U;
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___1;
        }
        {
//#line  636
        tmp___0 = inl((unsigned short )(ensoniq->port + 16UL));
        }
//#line  636
        if ((tmp___0 & 8847360U) == 65536U) {
//#line  638
          goto while_break___1;
        }
//#line  635
        t ++;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
//#line  640
      outl((unsigned int )((((int )reg & 127) << 16) | ((int )val & 65535)), (unsigned short )(ensoniq->port + 20UL));
//#line  642
      snd_es1371_wait_src_ready(ensoniq);
//#line  643
      outl(x, (unsigned short )(ensoniq->port + 16UL));
//#line  644
      mutex_unlock((struct mutex *)ensoniq->src_mutex);
      }
//#line  645
      return;
    }
//#line  620
    t ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  648
  mutex_unlock((struct mutex *)ensoniq->src_mutex);
//#line  649
  tmp___2 = inl((unsigned short )(ensoniq->port + 20UL));
  printk(str_218451996, ensoniq->port + 20UL, tmp___2);
  }
//#line  651
  return;
}
}
//#line  653 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static unsigned short snd_es1371_codec_read(struct snd_ac97 *ac97 , unsigned short reg ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int t ;
  unsigned int x ;
  unsigned int fail ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
//#line  656
  ensoniq = (struct ensoniq *)ac97->private_data;
//#line  657
  fail = 0U;
  __again: 
  {
//#line  660
  mutex_lock_nested((struct mutex *)ensoniq->src_mutex, 0U);
//#line  661
  t = 0U;
  }
  {
  {
  while (1) {


    if (! (t < 40960U)) {
      goto while_break;
    }
    {
//#line  662
    tmp___3 = inl((unsigned short )(ensoniq->port + 20UL));
    }
//#line  662
    if (! (tmp___3 & (unsigned int )(1 << 30))) {
      {
//#line  664
      x = snd_es1371_wait_src_ready(ensoniq);
//#line  665
      outl((x & (unsigned int )((((1 << 22) | (1 << 21)) | (1 << 20)) | (1 << 19))) | 65536U,
           (unsigned short )(ensoniq->port + 16UL));
//#line  670
      t = 0U;
      }
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___0;
        }
        {
//#line  671
        tmp = inl((unsigned short )(ensoniq->port + 16UL));
        }
//#line  671
        if ((tmp & 8847360U) == 0U) {
//#line  673
          goto while_break___0;
        }
//#line  670
        t ++;
      }

      }
      while_break___0: /* CIL Label */ ;
      }
//#line  676
      t = 0U;
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___1;
        }
        {
//#line  677
        tmp___0 = inl((unsigned short )(ensoniq->port + 16UL));
        }
//#line  677
        if ((tmp___0 & 8847360U) == 65536U) {
//#line  679
          goto while_break___1;
        }
//#line  676
        t ++;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
      {
//#line  681
      outl((unsigned int )((((int )reg & 127) << 16) | (1 << 23)), (unsigned short )(ensoniq->port + 20UL));
//#line  683
      snd_es1371_wait_src_ready(ensoniq);
//#line  684
      outl(x, (unsigned short )(ensoniq->port + 16UL));
//#line  686
      t = 0U;
      }
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___2;
        }
        {
//#line  687
        tmp___1 = inl((unsigned short )(ensoniq->port + 20UL));
        }
//#line  687
        if (! (tmp___1 & (unsigned int )(1 << 30))) {
//#line  688
          goto while_break___2;
        }
//#line  686
        t ++;
      }

      }
      while_break___2: /* CIL Label */ ;
      }
//#line  691
      t = 0U;
      {
      {
      while (1) {


        if (! (t < 40960U)) {
          goto while_break___3;
        }
        {
//#line  692
        x = inl((unsigned short )(ensoniq->port + 20UL));
        }
//#line  692
        if (x & (unsigned int )(1 << 31)) {
          {
//#line  693
          mutex_unlock((struct mutex *)ensoniq->src_mutex);
          }
//#line  694
          return ((unsigned short )(x & 65535U));
        }
//#line  691
        t ++;
      }

      }
      while_break___3: /* CIL Label */ ;
      }
      {
//#line  697
      mutex_unlock((struct mutex *)ensoniq->src_mutex);
//#line  698
      fail ++;
      }
//#line  698
      if (fail > 10U) {
        {
//#line  699
        tmp___2 = inl((unsigned short )(ensoniq->port + 20UL));
        printk(str_294126970, ensoniq->port + 20UL, (int )reg, tmp___2);
        }
//#line  703
        return ((unsigned short)0);
      }
//#line  705
      goto __again;
    }
//#line  661
    t ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  708
  mutex_unlock((struct mutex *)ensoniq->src_mutex);
//#line  709
  tmp___4 = inl((unsigned short )(ensoniq->port + 20UL));
  printk(str_54849971, ensoniq->port + 20UL, tmp___4);
  }
//#line  711
  return ((unsigned short)0);
}
}
//#line  714 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_codec_wait(struct snd_ac97 *ac97 ) 
{ 


  {
  {
//#line  717
  __const_udelay(3221250UL);
//#line  718
  snd_es1371_codec_read(ac97, (unsigned short)0);
//#line  719
  snd_es1371_codec_read(ac97, (unsigned short)124);
//#line  720
  snd_es1371_codec_read(ac97, (unsigned short)126);
//#line  721
  __const_udelay(3221250UL);
  }
//#line  723
  return;
}
}
//#line  725 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_adc_rate(struct ensoniq *ensoniq , unsigned int rate ) 
{ 
  unsigned int n ;
  unsigned int truncm ;
  unsigned int freq ;
  unsigned int result ;
  unsigned int ret ;
  int tmp ;
  unsigned int tmp___0 ;

  {
//#line  728
  ret = 0U;
  spin: 
  {
//#line  731
  tmp = mutex_trylock((struct mutex *)ensoniq->src_mutex);
  ret = (unsigned int )tmp;
  }
//#line  732
  if (! (ret != 0U)) {
//#line  735
    goto spin;
  }
//#line  740
  n = rate / 3000U;
//#line  741
  if ((1 << n) & ((((1 << 15) | (1 << 13)) | (1 << 11)) | (1 << 9))) {
//#line  742
    n --;
  }
//#line  743
  truncm = (21U * n - 1U) | 1U;
//#line  744
  freq = (unsigned int )(((48000UL << 15) / (unsigned long )rate) * (unsigned long )n);
//#line  745
  result = (unsigned int )((48000UL << 15) / (unsigned long )(freq / n));
//#line  746
  if (rate >= 24000U) {
//#line  747
    if (truncm > 239U) {
//#line  748
      truncm = 239U;
    }
    {
//#line  749
    snd_es1371_src_write(ensoniq, (unsigned short)120, (unsigned short )((((239U - truncm) >> 1) << 9) | (n << 4)));
    }
  } else {
//#line  752
    if (truncm > 119U) {
//#line  753
      truncm = 119U;
    }
    {
//#line  754
    snd_es1371_src_write(ensoniq, (unsigned short)120, (unsigned short )((32768U | (((119U - truncm) >> 1) << 9)) | (n << 4)));
    }
  }
  {
//#line  757
  tmp___0 = snd_es1371_src_read(ensoniq, (unsigned short)121);
  snd_es1371_src_write(ensoniq, (unsigned short)121, (unsigned short )((tmp___0 & 255U) | ((freq >> 5) & 64512U)));
//#line  761
  snd_es1371_src_write(ensoniq, (unsigned short)123, (unsigned short )(freq & 32767U));
//#line  762
  snd_es1371_src_write(ensoniq, (unsigned short)108, (unsigned short )(n << 8));
//#line  763
  snd_es1371_src_write(ensoniq, (unsigned short)109, (unsigned short )(n << 8));
//#line  764
  mutex_unlock((struct mutex *)ensoniq->src_mutex);
  }
//#line  765
  return;
}
}
//#line  767 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_dac1_rate(struct ensoniq *ensoniq , unsigned int rate ) 
{ 
  unsigned int freq ;
  unsigned int r ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  771
  mutex_lock_nested((struct mutex *)ensoniq->src_mutex, 0U);
//#line  772
  freq = ((rate << 15) + 1500U) / 3000U;
//#line  773
  tmp = snd_es1371_wait_src_ready(ensoniq);
  r = (tmp & (unsigned int )(((1 << 22) | (1 << 20)) | (1 << 19))) | (unsigned int )(1 << 21);
//#line  776
  outl(r, (unsigned short )(ensoniq->port + 16UL));
//#line  777
  tmp___0 = snd_es1371_src_read(ensoniq, (unsigned short)113);
  snd_es1371_src_write(ensoniq, (unsigned short)113, (unsigned short )((tmp___0 & 255U) | ((freq >> 5) & 64512U)));
//#line  781
  snd_es1371_src_write(ensoniq, (unsigned short)115, (unsigned short )(freq & 32767U));
//#line  782
  tmp___1 = snd_es1371_wait_src_ready(ensoniq);
  r = tmp___1 & (unsigned int )(((1 << 22) | (1 << 20)) | (1 << 19));
//#line  784
  outl(r, (unsigned short )(ensoniq->port + 16UL));
//#line  785
  mutex_unlock((struct mutex *)ensoniq->src_mutex);
  }
//#line  786
  return;
}
}
//#line  788 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_es1371_dac2_rate(struct ensoniq *ensoniq , unsigned int rate ) 
{ 
  unsigned int freq ;
  unsigned int r ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  792
  mutex_lock_nested((struct mutex *)ensoniq->src_mutex, 0U);
//#line  793
  freq = ((rate << 15) + 1500U) / 3000U;
//#line  794
  tmp = snd_es1371_wait_src_ready(ensoniq);
  r = (tmp & (unsigned int )(((1 << 22) | (1 << 21)) | (1 << 19))) | (unsigned int )(1 << 20);
//#line  797
  outl(r, (unsigned short )(ensoniq->port + 16UL));
//#line  798
  tmp___0 = snd_es1371_src_read(ensoniq, (unsigned short)117);
  snd_es1371_src_write(ensoniq, (unsigned short)117, (unsigned short )((tmp___0 & 255U) | ((freq >> 5) & 64512U)));
//#line  802
  snd_es1371_src_write(ensoniq, (unsigned short)119, (unsigned short )(freq & 32767U));
//#line  804
  tmp___1 = snd_es1371_wait_src_ready(ensoniq);
  r = tmp___1 & (unsigned int )(((1 << 22) | (1 << 21)) | (1 << 19));
//#line  806
  outl(r, (unsigned short )(ensoniq->port + 16UL));
//#line  807
  mutex_unlock((struct mutex *)ensoniq->src_mutex);
  }
//#line  808
  return;
}
}
//#line  812 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_trigger(struct snd_pcm_substream *substream , int cmd ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int what ;
  struct snd_pcm_substream *s ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;
  unsigned int what___0 ;
  struct snd_pcm_substream *s___0 ;
  struct list_head  const  *__mptr___1 ;
  struct list_head  const  *__mptr___2 ;

  {
//#line  814
  ensoniq = (struct ensoniq *)substream->private_data;
  {
  if (cmd == 3) {
//#line  816
    goto case_3;
  }
  if (cmd == 4) {
//#line  817
    goto case_3;
  }
  if (cmd == 1) {
//#line  840
    goto case_1;
  }
  if (cmd == 0) {
//#line  841
    goto case_1;
  }
//#line  866
  goto switch_default;
  case_3: /* CIL Label */ 
//#line  819
  what = 0U;
//#line  821
  __mptr = (struct list_head  const  *)(substream->group)->substreams.next;
  s = (struct snd_pcm_substream *)((char *)__mptr - (unsigned int )(& ((struct snd_pcm_substream *)0)->link_list));
  {
  {
  while (1) {


    {
    __builtin_prefetch((void const   *)s->link_list.next);
    }
    if (! ((unsigned long )(& s->link_list) != (unsigned long )(& (substream->group)->substreams))) {
      goto while_break;
    }
//#line  822
    if ((unsigned long )s == (unsigned long )ensoniq->playback1_substream) {
      {
//#line  823
      what |= (unsigned int )(1 << 11);
//#line  824
      snd_pcm_trigger_done(s, substream);
      }
    } else
//#line  825
    if ((unsigned long )s == (unsigned long )ensoniq->playback2_substream) {
      {
//#line  826
      what |= (unsigned int )(1 << 12);
//#line  827
      snd_pcm_trigger_done(s, substream);
      }
    } else
//#line  828
    if ((unsigned long )s == (unsigned long )ensoniq->capture_substream) {
//#line  829
      return (-22);
    }
//#line  821
    __mptr___0 = (struct list_head  const  *)s->link_list.next;
    s = (struct snd_pcm_substream *)((char *)__mptr___0 - (unsigned int )(& ((struct snd_pcm_substream *)0)->link_list));
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  831
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  832
  if (cmd == 3) {
//#line  833
    ensoniq->sctrl |= what;
  } else {
//#line  835
    ensoniq->sctrl &= ~ what;
  }
  {
//#line  836
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  837
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  838
  goto switch_break;
  case_1: /* CIL Label */ 
//#line  843
  what___0 = 0U;
//#line  845
  __mptr___1 = (struct list_head  const  *)(substream->group)->substreams.next;
  s___0 = (struct snd_pcm_substream *)((char *)__mptr___1 - (unsigned int )(& ((struct snd_pcm_substream *)0)->link_list));
  {
  {
  while (1) {


    {
    __builtin_prefetch((void const   *)s___0->link_list.next);
    }
    if (! ((unsigned long )(& s___0->link_list) != (unsigned long )(& (substream->group)->substreams))) {
      goto while_break___0;
    }
//#line  846
    if ((unsigned long )s___0 == (unsigned long )ensoniq->playback1_substream) {
      {
//#line  847
      what___0 |= (unsigned int )(1 << 6);
//#line  848
      snd_pcm_trigger_done(s___0, substream);
      }
    } else
//#line  849
    if ((unsigned long )s___0 == (unsigned long )ensoniq->playback2_substream) {
      {
//#line  850
      what___0 |= (unsigned int )(1 << 5);
//#line  851
      snd_pcm_trigger_done(s___0, substream);
      }
    } else
//#line  852
    if ((unsigned long )s___0 == (unsigned long )ensoniq->capture_substream) {
      {
//#line  853
      what___0 |= (unsigned int )(1 << 4);
//#line  854
      snd_pcm_trigger_done(s___0, substream);
      }
    }
//#line  845
    __mptr___2 = (struct list_head  const  *)s___0->link_list.next;
    s___0 = (struct snd_pcm_substream *)((char *)__mptr___2 - (unsigned int )(& ((struct snd_pcm_substream *)0)->link_list));
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  857
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  858
  if (cmd == 1) {
//#line  859
    ensoniq->ctrl |= what___0;
  } else {
//#line  861
    ensoniq->ctrl &= ~ what___0;
  }
  {
//#line  862
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  863
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  864
  goto switch_break;
  switch_default: /* CIL Label */ 
//#line  867
  return (-22);
  switch_break: /* CIL Label */ ;
  }
//#line  869
  return (0);
}
}
//#line  876 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_hw_params(struct snd_pcm_substream *substream , struct snd_pcm_hw_params *hw_params ) 
{ 
  struct snd_interval *tmp ;
  int tmp___0 ;

  {
  {
//#line  879
  tmp = hw_param_interval(hw_params, 18);
  tmp___0 = snd_pcm_lib_malloc_pages(substream, (size_t )tmp->min);
  }
  return (tmp___0);
}
}
//#line  882 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_hw_free(struct snd_pcm_substream *substream ) 
{ 
  int tmp ;

  {
  {
//#line  884
  tmp = snd_pcm_lib_free_pages(substream);
  }
  return (tmp);
}
}
//#line  887 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_playback1_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;
  unsigned int mode ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  889
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  890
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  891
  mode = 0U;
//#line  893
  tmp = snd_pcm_lib_buffer_bytes(substream);
  ensoniq->p1_dma_size = (unsigned int )tmp;
//#line  894
  tmp___0 = snd_pcm_lib_period_bytes(substream);
  ensoniq->p1_period_size = (unsigned int )tmp___0;
//#line  895
  tmp___1 = snd_pcm_format_width(runtime->format);
  }
//#line  895
  if (tmp___1 == 16) {
//#line  896
    mode |= 2U;
  }
//#line  897
  if (runtime->channels > 1U) {
//#line  898
    mode |= 1U;
  }
  {
//#line  899
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  900
  ensoniq->ctrl &= (unsigned int )(~ (1 << 6));
  }
//#line  903
  if (runtime->rate == 48000U) {
//#line  904
    ensoniq->ctrl |= (unsigned int )(1 << 31);
  } else {
//#line  906
    ensoniq->ctrl &= (unsigned int )(~ (1 << 31));
  }
  {
//#line  908
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  909
  outl(12U, (unsigned short )(ensoniq->port + 12UL));
//#line  910
  outl((unsigned int )runtime->dma_addr, (unsigned short )(ensoniq->port + 48UL));
//#line  911
  outl((ensoniq->p1_dma_size >> 2) - 1U, (unsigned short )(ensoniq->port + 52UL));
//#line  912
  ensoniq->sctrl &= (unsigned int )(~ ((((1 << 13) | (1 << 11)) | (1 << 7)) | 3));
//#line  913
  ensoniq->sctrl |= (unsigned int )(1 << 8) | (mode & 3U);
//#line  914
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  915
  outl((ensoniq->p1_period_size >> snd_ensoniq_sample_shift[mode]) - 1U, (unsigned short )(ensoniq->port + 36UL));
//#line  927
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  928
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  930
  snd_es1371_dac1_rate(ensoniq, runtime->rate);
  }
//#line  932
  return (0);
}
}
//#line  935 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_playback2_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;
  unsigned int mode ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  937
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  938
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  939
  mode = 0U;
//#line  941
  tmp = snd_pcm_lib_buffer_bytes(substream);
  ensoniq->p2_dma_size = (unsigned int )tmp;
//#line  942
  tmp___0 = snd_pcm_lib_period_bytes(substream);
  ensoniq->p2_period_size = (unsigned int )tmp___0;
//#line  943
  tmp___1 = snd_pcm_format_width(runtime->format);
  }
//#line  943
  if (tmp___1 == 16) {
//#line  944
    mode |= 2U;
  }
//#line  945
  if (runtime->channels > 1U) {
//#line  946
    mode |= 1U;
  }
  {
//#line  947
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  948
  ensoniq->ctrl &= (unsigned int )(~ (1 << 5));
//#line  949
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  950
  outl(12U, (unsigned short )(ensoniq->port + 12UL));
//#line  951
  outl((unsigned int )runtime->dma_addr, (unsigned short )(ensoniq->port + 56UL));
//#line  952
  outl((ensoniq->p2_dma_size >> 2) - 1U, (unsigned short )(ensoniq->port + 60UL));
//#line  953
  ensoniq->sctrl &= (unsigned int )(~ ((((((1 << 14) | (1 << 12)) | (1 << 6)) | (7 << 19)) | (7 << 16)) | (3 << 2)));
  }
  if (mode & 2U) {
    tmp___2 = 2;
  } else {
//#line  955
    tmp___2 = 1;
  }
  {
  ensoniq->sctrl |= ((unsigned int )(1 << 9) | ((mode & 3U) << 2)) | (unsigned int )((tmp___2 & 7) << 19);
//#line  957
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  958
  outl((ensoniq->p2_period_size >> snd_ensoniq_sample_shift[mode]) - 1U, (unsigned short )(ensoniq->port + 40UL));
//#line  967
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  968
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  970
  snd_es1371_dac2_rate(ensoniq, runtime->rate);
  }
//#line  972
  return (0);
}
}
//#line  975 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_capture_prepare(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;
  unsigned int mode ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  977
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  978
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  979
  mode = 0U;
//#line  981
  tmp = snd_pcm_lib_buffer_bytes(substream);
  ensoniq->c_dma_size = (unsigned int )tmp;
//#line  982
  tmp___0 = snd_pcm_lib_period_bytes(substream);
  ensoniq->c_period_size = (unsigned int )tmp___0;
//#line  983
  tmp___1 = snd_pcm_format_width(runtime->format);
  }
//#line  983
  if (tmp___1 == 16) {
//#line  984
    mode |= 2U;
  }
//#line  985
  if (runtime->channels > 1U) {
//#line  986
    mode |= 1U;
  }
  {
//#line  987
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  988
  ensoniq->ctrl &= (unsigned int )(~ (1 << 4));
//#line  989
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  990
  outl(13U, (unsigned short )(ensoniq->port + 12UL));
//#line  991
  outl((unsigned int )runtime->dma_addr, (unsigned short )(ensoniq->port + 48UL));
//#line  992
  outl((ensoniq->c_dma_size >> 2) - 1U, (unsigned short )(ensoniq->port + 52UL));
//#line  993
  ensoniq->sctrl &= (unsigned int )(~ ((1 << 15) | (3 << 4)));
//#line  994
  ensoniq->sctrl |= (unsigned int )(1 << 10) | ((mode & 3U) << 4);
//#line  995
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  996
  outl((ensoniq->c_period_size >> snd_ensoniq_sample_shift[mode]) - 1U, (unsigned short )(ensoniq->port + 44UL));
//#line  1005
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  1006
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1008
  snd_es1371_adc_rate(ensoniq, runtime->rate);
  }
//#line  1010
  return (0);
}
}
//#line  1013 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static snd_pcm_uframes_t snd_ensoniq_playback1_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  size_t ptr ;
  unsigned int tmp ;
  snd_pcm_sframes_t tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  1015
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1018
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
//#line  1019
  tmp___1 = inl((unsigned short )ensoniq->port);
  }
//#line  1019
  if (tmp___1 & (unsigned int )(1 << 6)) {
    {
//#line  1020
    outl(12U, (unsigned short )(ensoniq->port + 12UL));
//#line  1021
    tmp = inl((unsigned short )(ensoniq->port + 52UL));
    ptr = (size_t )((tmp >> 14) & 262140U);
//#line  1022
    tmp___0 = bytes_to_frames((struct snd_pcm_runtime *)substream->runtime, (ssize_t )ptr);
    ptr = (size_t )tmp___0;
    }
  } else {
//#line  1024
    ptr = (size_t )0;
  }
  {
//#line  1026
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1027
  return (ptr);
}
}
//#line  1030 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static snd_pcm_uframes_t snd_ensoniq_playback2_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  size_t ptr ;
  unsigned int tmp ;
  snd_pcm_sframes_t tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  1032
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1035
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
//#line  1036
  tmp___1 = inl((unsigned short )ensoniq->port);
  }
//#line  1036
  if (tmp___1 & (unsigned int )(1 << 5)) {
    {
//#line  1037
    outl(12U, (unsigned short )(ensoniq->port + 12UL));
//#line  1038
    tmp = inl((unsigned short )(ensoniq->port + 60UL));
    ptr = (size_t )((tmp >> 14) & 262140U);
//#line  1039
    tmp___0 = bytes_to_frames((struct snd_pcm_runtime *)substream->runtime, (ssize_t )ptr);
    ptr = (size_t )tmp___0;
    }
  } else {
//#line  1041
    ptr = (size_t )0;
  }
  {
//#line  1043
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1044
  return (ptr);
}
}
//#line  1047 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static snd_pcm_uframes_t snd_ensoniq_capture_pointer(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  size_t ptr ;
  unsigned int tmp ;
  snd_pcm_sframes_t tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  1049
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1052
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
//#line  1053
  tmp___1 = inl((unsigned short )ensoniq->port);
  }
//#line  1053
  if (tmp___1 & (unsigned int )(1 << 4)) {
    {
//#line  1054
    outl(13U, (unsigned short )(ensoniq->port + 12UL));
//#line  1055
    tmp = inl((unsigned short )(ensoniq->port + 52UL));
    ptr = (size_t )((tmp >> 14) & 262140U);
//#line  1056
    tmp___0 = bytes_to_frames((struct snd_pcm_runtime *)substream->runtime, (ssize_t )ptr);
    ptr = (size_t )tmp___0;
    }
  } else {
//#line  1058
    ptr = (size_t )0;
  }
  {
//#line  1060
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1061
  return (ptr);
}
}
static struct snd_pcm_hardware snd_ensoniq_playback1  = 
//#line  1064
     {4784387U, (1ULL << 1) | (1ULL << 2), (unsigned int )((1 << 30) | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    4000U, 48000U, 1U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 1U, 1024U,
    (size_t )0};
static struct snd_pcm_hardware snd_ensoniq_playback2  = 
//#line  1091
     {4784387U, (1ULL << 1) | (1ULL << 2), (unsigned int )((1 << 30) | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    4000U, 48000U, 1U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 1U, 1024U,
    (size_t )0};
static struct snd_pcm_hardware snd_ensoniq_capture  = 
//#line  1111
     {4260099U, (1ULL << 1) | (1ULL << 2), (unsigned int )((1 << 30) | (((((((1 << 1) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 6)) | (1 << 7))),
    4000U, 48000U, 1U, 2U, (size_t )131072, (size_t )64, (size_t )131072, 1U, 1024U,
    (size_t )0};
//#line  1130 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_playback1_open(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;

  {
  {
//#line  1132
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1133
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1135
  ensoniq->mode |= 1U;
//#line  1136
  ensoniq->playback1_substream = (struct snd_pcm_substream *)substream;
//#line  1137
  runtime->hw = snd_ensoniq_playback1;
//#line  1138
  snd_pcm_set_sync(substream);
//#line  1139
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
  if (ensoniq->spdif) {
//#line  1140
    if ((unsigned long )ensoniq->playback2_substream == (unsigned long )((void *)0)) {
//#line  1141
      ensoniq->spdif_stream = ensoniq->spdif_default;
    }
  }
  {
//#line  1142
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1147
  snd_pcm_hw_constraint_ratdens(runtime, 0U, 11, & snd_es1371_hw_constraints_dac_clock);
  }
//#line  1150
  return (0);
}
}
//#line  1153 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_playback2_open(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;

  {
  {
//#line  1155
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1156
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1158
  ensoniq->mode |= 2U;
//#line  1159
  ensoniq->playback2_substream = (struct snd_pcm_substream *)substream;
//#line  1160
  runtime->hw = snd_ensoniq_playback2;
//#line  1161
  snd_pcm_set_sync(substream);
//#line  1162
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
  if (ensoniq->spdif) {
//#line  1163
    if ((unsigned long )ensoniq->playback1_substream == (unsigned long )((void *)0)) {
//#line  1164
      ensoniq->spdif_stream = ensoniq->spdif_default;
    }
  }
  {
//#line  1165
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1170
  snd_pcm_hw_constraint_ratdens(runtime, 0U, 11, & snd_es1371_hw_constraints_dac_clock);
  }
//#line  1173
  return (0);
}
}
//#line  1176 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_capture_open(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  struct snd_pcm_runtime *runtime ;

  {
  {
//#line  1178
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1179
  runtime = (struct snd_pcm_runtime *)substream->runtime;
//#line  1181
  ensoniq->mode |= 4U;
//#line  1182
  ensoniq->capture_substream = (struct snd_pcm_substream *)substream;
//#line  1183
  runtime->hw = snd_ensoniq_capture;
//#line  1184
  snd_pcm_set_sync(substream);
//#line  1189
  snd_pcm_hw_constraint_ratnums(runtime, 0U, 11, & snd_es1371_hw_constraints_adc_clock);
  }
//#line  1192
  return (0);
}
}
//#line  1195
int snd_ensoniq_playback1_close(struct snd_pcm_substream *substream )  __attribute__((__isolate__)) ;
int snd_ensoniq_playback1_close(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_298879367);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& substream);
  }
  {
//#line  1198
  __odft_error = logRead(& substream->private_data, str_297936691, str_298879367,
                         str_679919104, 1198);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1200
  __odft_error = logWrite(& ensoniq->playback1_substream, str_542964445, str_298879367,
                          str_679919104, 1200);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->playback1_substream = (struct snd_pcm_substream *)((void *)0);
//#line  1201
  __odft_error = logWrite(& ensoniq->mode, str_784540269, str_298879367, str_679919104,
                          1201);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->mode, str_784540269, str_298879367, str_679919104,
                         1201);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ensoniq->mode &= 4294967294U;
//#line  1202
  return (0);
  }
}
}
//#line  1205 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_playback2_close(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;

  {
  {
//#line  1208
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1210
  ensoniq->playback2_substream = (struct snd_pcm_substream *)((void *)0);
//#line  1211
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1215
  ensoniq->mode &= 4294967293U;
//#line  1216
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1217
  return (0);
}
}
//#line  1220 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_capture_close(struct snd_pcm_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;

  {
  {
//#line  1223
  ensoniq = (struct ensoniq *)substream->private_data;
//#line  1225
  ensoniq->capture_substream = (struct snd_pcm_substream *)((void *)0);
//#line  1226
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1230
  ensoniq->mode &= 4294967291U;
//#line  1231
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1232
  return (0);
}
}
static struct snd_pcm_ops snd_ensoniq_playback1_ops  = 
//#line  1235
     {& snd_ensoniq_playback1_open, & snd_ensoniq_playback1_close, & snd_pcm_lib_ioctl,
    & snd_ensoniq_hw_params, & snd_ensoniq_hw_free, & snd_ensoniq_playback1_prepare,
    & snd_ensoniq_trigger, & snd_ensoniq_playback1_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                     int channel ,
                                                                     snd_pcm_uframes_t pos ,
                                                                     void __attribute__((__noderef__,
                                                                     __address_space__(1)))  *buf ,
                                                                     snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops snd_ensoniq_playback2_ops  = 
//#line  1246
     {& snd_ensoniq_playback2_open, & snd_ensoniq_playback2_close, & snd_pcm_lib_ioctl,
    & snd_ensoniq_hw_params, & snd_ensoniq_hw_free, & snd_ensoniq_playback2_prepare,
    & snd_ensoniq_trigger, & snd_ensoniq_playback2_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                     int channel ,
                                                                     snd_pcm_uframes_t pos ,
                                                                     void __attribute__((__noderef__,
                                                                     __address_space__(1)))  *buf ,
                                                                     snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
static struct snd_pcm_ops snd_ensoniq_capture_ops  = 
//#line  1257
     {& snd_ensoniq_capture_open, & snd_ensoniq_capture_close, & snd_pcm_lib_ioctl,
    & snd_ensoniq_hw_params, & snd_ensoniq_hw_free, & snd_ensoniq_capture_prepare,
    & snd_ensoniq_trigger, & snd_ensoniq_capture_pointer, (int (*)(struct snd_pcm_substream *substream ,
                                                                   int channel , snd_pcm_uframes_t pos ,
                                                                   void __attribute__((__noderef__,
                                                                   __address_space__(1)))  *buf ,
                                                                   snd_pcm_uframes_t count ))0,
    (int (*)(struct snd_pcm_substream *substream , int channel , snd_pcm_uframes_t pos ,
             snd_pcm_uframes_t count ))0, (struct page *(*)(struct snd_pcm_substream *substream ,
                                                            unsigned long offset ))0,
    (int (*)(struct snd_pcm_substream *substream , struct vm_area_struct *vma ))0,
    (int (*)(struct snd_pcm_substream *substream ))0};
//#line  1268
static int __attribute__((__cold__))  snd_ensoniq_pcm(struct ensoniq *ensoniq , int device ,
                                                      struct snd_pcm **rpcm )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_pcm(struct ensoniq *ensoniq , int device ,
                                                      struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
//#line  1274
  if (rpcm) {
//#line  1275
    *rpcm = (struct snd_pcm *)((void *)0);
  }
  {
//#line  1279
  err = snd_pcm_new((struct snd_card *)ensoniq->card, (char *)str_212077948, device,
                    1, 1, & pcm);
  }
//#line  1281
  if (err < 0) {
//#line  1282
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  1287
  snd_pcm_set_ops(pcm, 0, & snd_ensoniq_playback1_ops);
//#line  1289
  snd_pcm_set_ops(pcm, 1, & snd_ensoniq_capture_ops);
//#line  1291
  pcm->private_data = (void *)ensoniq;
//#line  1292
  pcm->info_flags = 0U;
//#line  1296
  strcpy(pcm->name, str_1039574295);
//#line  1298
  ensoniq->pcm1 = (struct snd_pcm *)pcm;
//#line  1300
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (ensoniq->pci)->dev), (size_t )65536,
                                        (size_t )131072);
  }
//#line  1303
  if (rpcm) {
//#line  1304
    *rpcm = pcm;
  }
//#line  1305
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  1308
static int __attribute__((__cold__))  snd_ensoniq_pcm2(struct ensoniq *ensoniq , int device ,
                                                       struct snd_pcm **rpcm )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_pcm2(struct ensoniq *ensoniq , int device ,
                                                       struct snd_pcm **rpcm ) 
{ 
  struct snd_pcm *pcm ;
  int err ;

  {
//#line  1314
  if (rpcm) {
//#line  1315
    *rpcm = (struct snd_pcm *)((void *)0);
  }
  {
//#line  1319
  err = snd_pcm_new((struct snd_card *)ensoniq->card, (char *)str_212077949, device,
                    1, 0, & pcm);
  }
//#line  1321
  if (err < 0) {
//#line  1322
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  1327
  snd_pcm_set_ops(pcm, 0, & snd_ensoniq_playback2_ops);
//#line  1329
  pcm->private_data = (void *)ensoniq;
//#line  1330
  pcm->info_flags = 0U;
//#line  1334
  strcpy(pcm->name, str_794415929);
//#line  1336
  ensoniq->pcm2 = (struct snd_pcm *)pcm;
//#line  1338
  snd_pcm_lib_preallocate_pages_for_all(pcm, 2, (void *)(& (ensoniq->pci)->dev), (size_t )65536,
                                        (size_t )131072);
  }
//#line  1341
  if (rpcm) {
//#line  1342
    *rpcm = pcm;
  }
//#line  1343
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  1354
int snd_ens1373_spdif_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo )  __attribute__((__isolate__)) ;
int snd_ens1373_spdif_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_845284242);
  }
  {
  {
  logStackVar(& kcontrol);
  logStackVar(& uinfo);
  }
  {
//#line  1357
  __odft_error = logWrite(& uinfo->type, str_98566182, str_845284242, str_679919104,
                          1357);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  uinfo->type = 5;
//#line  1358
  __odft_error = logWrite(& uinfo->count, str_796733679, str_845284242, str_679919104,
                          1358);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  uinfo->count = 1U;
//#line  1359
  return (0);
  }
}
}
//#line  1362
int snd_ens1373_spdif_default_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_ens1373_spdif_default_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_969183744);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1366
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_969183744, str_679919104,
                         1366);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1367
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_969183744, str_679919104,
                         1367);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1368
  __odft_error = logWrite(& ucontrol->value.iec958.status[0], str_993283191, str_969183744,
                          str_679919104, 1368);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_default, str_912128440, str_969183744, str_679919104,
                         1368);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[0] = (unsigned char )(ensoniq->spdif_default & 255U);
//#line  1369
  __odft_error = logWrite(& ucontrol->value.iec958.status[1], str_993283210, str_969183744,
                          str_679919104, 1369);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_default, str_912128440, str_969183744, str_679919104,
                         1369);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[1] = (unsigned char )((ensoniq->spdif_default >> 8) & 255U);
//#line  1370
  __odft_error = logWrite(& ucontrol->value.iec958.status[2], str_993283229, str_969183744,
                          str_679919104, 1370);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_default, str_912128440, str_969183744, str_679919104,
                         1370);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[2] = (unsigned char )((ensoniq->spdif_default >> 16) & 255U);
//#line  1371
  __odft_error = logWrite(& ucontrol->value.iec958.status[3], str_993283248, str_969183744,
                          str_679919104, 1371);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_default, str_912128440, str_969183744, str_679919104,
                         1371);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[3] = (unsigned char )((ensoniq->spdif_default >> 24) & 255U);
//#line  1372
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_969183744, str_679919104,
                         1372);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1373
  return (0);
  }
}
}
//#line  1376 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ens1373_spdif_default_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int val ;
  int change ;

  {
  {
//#line  1380
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1384
  val = (((u32 )ucontrol->value.iec958.status[0] | ((u32 )ucontrol->value.iec958.status[1] << 8)) | ((u32 )ucontrol->value.iec958.status[2] << 16)) | ((u32 )ucontrol->value.iec958.status[3] << 24);
//#line  1388
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1389
  change = ensoniq->spdif_default != val;
//#line  1390
  ensoniq->spdif_default = val;
  }
  if (change) {
    if ((unsigned long )ensoniq->playback1_substream == (unsigned long )((void *)0)) {
//#line  1391
      if ((unsigned long )ensoniq->playback2_substream == (unsigned long )((void *)0)) {
        {
//#line  1393
        outl(val, (unsigned short )(ensoniq->port + 28UL));
        }
      }
    }
  }
  {
//#line  1394
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1395
  return (change);
}
}
//#line  1398
int snd_ens1373_spdif_mask_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_ens1373_spdif_mask_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_741517731);
  }
  {
  {
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1401
  __odft_error = logWrite(& ucontrol->value.iec958.status[0], str_993283191, str_741517731,
                          str_679919104, 1401);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[0] = (unsigned char)255;
//#line  1402
  __odft_error = logWrite(& ucontrol->value.iec958.status[1], str_993283210, str_741517731,
                          str_679919104, 1402);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[1] = (unsigned char)255;
//#line  1403
  __odft_error = logWrite(& ucontrol->value.iec958.status[2], str_993283229, str_741517731,
                          str_679919104, 1403);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[2] = (unsigned char)255;
//#line  1404
  __odft_error = logWrite(& ucontrol->value.iec958.status[3], str_993283248, str_741517731,
                          str_679919104, 1404);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ucontrol->value.iec958.status[3] = (unsigned char)255;
//#line  1405
  return (0);
  }
}
}
//#line  1408
int snd_ens1373_spdif_stream_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_ens1373_spdif_stream_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_964300407);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1412
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_964300407, str_679919104,
                         1412);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1413
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_964300407, str_679919104,
                         1413);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1414
  __odft_error = logWrite(& ucontrol->value.iec958.status[0], str_993283191, str_964300407,
                          str_679919104, 1414);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_stream, str_878364613, str_964300407, str_679919104,
                         1414);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[0] = (unsigned char )(ensoniq->spdif_stream & 255U);
//#line  1415
  __odft_error = logWrite(& ucontrol->value.iec958.status[1], str_993283210, str_964300407,
                          str_679919104, 1415);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_stream, str_878364613, str_964300407, str_679919104,
                         1415);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[1] = (unsigned char )((ensoniq->spdif_stream >> 8) & 255U);
//#line  1416
  __odft_error = logWrite(& ucontrol->value.iec958.status[2], str_993283229, str_964300407,
                          str_679919104, 1416);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_stream, str_878364613, str_964300407, str_679919104,
                         1416);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[2] = (unsigned char )((ensoniq->spdif_stream >> 16) & 255U);
//#line  1417
  __odft_error = logWrite(& ucontrol->value.iec958.status[3], str_993283248, str_964300407,
                          str_679919104, 1417);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->spdif_stream, str_878364613, str_964300407, str_679919104,
                         1417);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.iec958.status[3] = (unsigned char )((ensoniq->spdif_stream >> 24) & 255U);
//#line  1418
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_964300407, str_679919104,
                         1418);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1419
  return (0);
  }
}
}
//#line  1422
int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_ens1373_spdif_stream_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int val ;
  int change ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_964303960);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1426
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_964303960, str_679919104,
                         1426);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1430
  __odft_error = logRead(& ucontrol->value.iec958.status[0], str_993283191, str_964303960,
                         str_679919104, 1430);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ucontrol->value.iec958.status[1], str_993283210, str_964303960,
                         str_679919104, 1430);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ucontrol->value.iec958.status[2], str_993283229, str_964303960,
                         str_679919104, 1430);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ucontrol->value.iec958.status[3], str_993283248, str_964303960,
                         str_679919104, 1430);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  val = (((u32 )ucontrol->value.iec958.status[0] | ((u32 )ucontrol->value.iec958.status[1] << 8)) | ((u32 )ucontrol->value.iec958.status[2] << 16)) | ((u32 )ucontrol->value.iec958.status[3] << 24);
//#line  1434
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_964303960, str_679919104,
                         1434);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1435
  __odft_error = logRead(& ensoniq->spdif_stream, str_878364613, str_964303960, str_679919104,
                         1435);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  change = ensoniq->spdif_stream != val;
//#line  1436
  __odft_error = logWrite(& ensoniq->spdif_stream, str_878364613, str_964303960, str_679919104,
                          1436);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ensoniq->spdif_stream = val;
  if (change) {
    {
    {
//#line  1437
    __odft_error = logRead(& ensoniq->playback1_substream, str_542964445, str_964303960,
                           str_679919104, 1437);
    }
    if (__odft_error) {
      return (75);
    } else {

    }

//#line  1437
    if ((unsigned long )ensoniq->playback1_substream != (unsigned long )((void *)0)) {
      {
//#line  1439
      __odft_error = logRead(& ensoniq->port, str_784561127, str_964303960, str_679919104,
                             1439);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      outl(val, (unsigned short )(ensoniq->port + 28UL));
      }
    } else {
      {
      {
      __odft_error = logRead(& ensoniq->playback2_substream, str_543407206, str_964303960,
                             str_679919104, 1437);
      }
      if (__odft_error) {
        return (75);
      } else {

      }

//#line  1437
      if ((unsigned long )ensoniq->playback2_substream != (unsigned long )((void *)0)) {
        {
//#line  1439
        __odft_error = logRead(& ensoniq->port, str_784561127, str_964303960, str_679919104,
                               1439);
        }
        if (__odft_error) {
          return (75);
        } else {

        }
        {
        outl(val, (unsigned short )(ensoniq->port + 28UL));
        }
      }
      }
    }
    }
  }
  {
//#line  1440
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_964303960, str_679919104,
                         1440);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1441
  return (change);
  }
}
}
//#line  1450
int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1371_spdif_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_941290500);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1454
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_941290500, str_679919104,
                         1454);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1455
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_941290500, str_679919104,
                         1455);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
  {
  {
//#line  1456
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_941290500, str_679919104,
                         1456);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

  if (ensoniq->ctrl & (unsigned int )(1 << 26)) {
    {
    __odft_error = logWrite(& ucontrol->value.integer.value[0], str_712681085, str_941290500,
                            str_679919104, 1456);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    ucontrol->value.integer.value[0] = 1L;
  } else {
    {
    __odft_error = logWrite(& ucontrol->value.integer.value[0], str_712681085, str_941290500,
                            str_679919104, 1456);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    ucontrol->value.integer.value[0] = 0L;
  }
  }
  {
//#line  1457
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_941290500, str_679919104,
                         1457);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1458
  return (0);
  }
}
}
//#line  1461
int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1371_spdif_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int nval1 ;
  unsigned int nval2 ;
  int change ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_941294053);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1465
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_941294053, str_679919104,
                         1465);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ensoniq = (struct ensoniq *)kcontrol->private_data;
  {
  {
//#line  1470
  __odft_error = logRead(& ucontrol->value.integer.value[0], str_712681085, str_941294053,
                         str_679919104, 1470);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

  if (ucontrol->value.integer.value[0]) {
    nval1 = (unsigned int )(1 << 26);
  } else {
    nval1 = 0U;
  }
  }
  {
  {
//#line  1471
  __odft_error = logRead(& ucontrol->value.integer.value[0], str_712681085, str_941294053,
                         str_679919104, 1471);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

  if (ucontrol->value.integer.value[0]) {
    nval2 = (unsigned int )(1 << 18);
  } else {
    nval2 = 0U;
  }
  }
  {
//#line  1472
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_941294053, str_679919104,
                         1472);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1473
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                         1473);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  change = (ensoniq->ctrl & (unsigned int )(1 << 26)) != nval1;
//#line  1474
  __odft_error = logWrite(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                          1474);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                         1474);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->ctrl &= (unsigned int )(~ (1 << 26));
//#line  1475
  __odft_error = logWrite(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                          1475);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                         1475);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->ctrl |= nval1;
//#line  1476
  __odft_error = logWrite(& ensoniq->cssr, str_784473421, str_941294053, str_679919104,
                          1476);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_941294053, str_679919104,
                         1476);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->cssr &= (unsigned int )(~ (1 << 18));
//#line  1477
  __odft_error = logWrite(& ensoniq->cssr, str_784473421, str_941294053, str_679919104,
                          1477);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_941294053, str_679919104,
                         1477);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->cssr |= nval2;
//#line  1478
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_941294053, str_679919104,
                         1478);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->port, str_784561127, str_941294053, str_679919104,
                         1478);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  1479
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_941294053, str_679919104,
                         1479);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->port, str_784561127, str_941294053, str_679919104,
                         1479);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  outl(ensoniq->cssr, (unsigned short )(ensoniq->port + 4UL));
//#line  1480
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_941294053, str_679919104,
                         1480);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1481
  return (change);
  }
}
}
//#line  1486 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_kcontrol_new snd_es1371_mixer_spdif[4]  __attribute__((__section__(".devinit.data")))  = {      {2,
      0U, 0U, (unsigned char *)str_228836090, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
      & snd_es1371_spdif_get, & snd_es1371_spdif_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {3, 0U, 0U, (unsigned char *)str_375887647, 0U, 0U, 0U, & snd_ens1373_spdif_info,
      & snd_ens1373_spdif_default_get, & snd_ens1373_spdif_default_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {3, 0U, 0U, (unsigned char *)str_913711678, 0U, 1U, 0U, & snd_ens1373_spdif_info,
      & snd_ens1373_spdif_mask_get, (snd_kcontrol_put_t *)0, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}, 
        {3, 0U, 0U, (unsigned char *)str_1012473204, 0U, 0U, 0U, & snd_ens1373_spdif_info,
      & snd_ens1373_spdif_stream_get, & snd_ens1373_spdif_stream_put, {(snd_kcontrol_tlv_rw_t *)0},
      0UL}};
//#line  1514
int snd_es1373_rear_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1373_rear_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int val ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_722882140);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1518
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_722882140, str_679919104,
                         1518);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1519
  val = 0;
//#line  1521
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_722882140, str_679919104,
                         1521);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
  {
  {
//#line  1522
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_722882140, str_679919104,
                         1522);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

//#line  1522
  if ((ensoniq->cssr & (unsigned int )(((1 << 27) | (1 << 26)) | (1 << 24))) == (unsigned int )(1 << 26)) {
//#line  1524
    val = 1;
  }
  }
  {
//#line  1525
  __odft_error = logWrite(& ucontrol->value.integer.value[0], str_712681085, str_722882140,
                          str_679919104, 1525);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.integer.value[0] = (long )val;
//#line  1526
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_722882140, str_679919104,
                         1526);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1527
  return (0);
  }
}
}
//#line  1530
int snd_es1373_rear_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1373_rear_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int nval1 ;
  int change ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_722885693);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1534
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_722885693, str_679919104,
                         1534);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ensoniq = (struct ensoniq *)kcontrol->private_data;
  {
  {
//#line  1538
  __odft_error = logRead(& ucontrol->value.integer.value[0], str_712681085, str_722885693,
                         str_679919104, 1538);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

  if (ucontrol->value.integer.value[0]) {
    nval1 = (unsigned int )(1 << 26);
  } else {
    nval1 = (unsigned int )((1 << 27) | (1 << 24));
  }
  }
  {
//#line  1540
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_722885693, str_679919104,
                         1540);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1541
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                         1541);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  change = (ensoniq->cssr & (unsigned int )(((1 << 27) | (1 << 26)) | (1 << 24))) != nval1;
//#line  1543
  __odft_error = logWrite(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                          1543);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                         1543);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->cssr &= (unsigned int )(~ (((1 << 27) | (1 << 26)) | (1 << 24)));
//#line  1544
  __odft_error = logWrite(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                          1544);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                         1544);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq->cssr |= nval1;
//#line  1545
  __odft_error = logRead(& ensoniq->cssr, str_784473421, str_722885693, str_679919104,
                         1545);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& ensoniq->port, str_784561127, str_722885693, str_679919104,
                         1545);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  outl(ensoniq->cssr, (unsigned short )(ensoniq->port + 4UL));
//#line  1546
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_722885693, str_679919104,
                         1546);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1547
  return (change);
  }
}
}
static struct snd_kcontrol_new snd_ens1373_rear  __attribute__((__section__(".devinit.data")))  = 
//#line  1550
     {2, 0U, 0U, (unsigned char *)str_188578368, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_es1373_rear_get, & snd_es1373_rear_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  1561
int snd_es1373_line_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1373_line_get(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int val ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_947039464);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1565
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_947039464, str_679919104,
                         1565);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1566
  val = 0;
//#line  1568
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_947039464, str_679919104,
                         1568);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
  {
  {
//#line  1569
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947039464, str_679919104,
                         1569);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

//#line  1569
  if ((ensoniq->ctrl & (unsigned int )(15 << 16)) >= 4U) {
//#line  1570
    val = 1;
  }
  }
  {
//#line  1571
  __odft_error = logWrite(& ucontrol->value.integer.value[0], str_712681085, str_947039464,
                          str_679919104, 1571);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ucontrol->value.integer.value[0] = (long )val;
//#line  1572
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_947039464, str_679919104,
                         1572);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1573
  return (0);
  }
}
}
//#line  1576
int snd_es1373_line_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol )  __attribute__((__isolate__)) ;
int snd_es1373_line_put(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_value *ucontrol ) 
{ 
  struct ensoniq *ensoniq ;
  int changed ;
  unsigned int ctrl ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_947043017);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& kcontrol);
  logStackVar(& ucontrol);
  }
  {
//#line  1580
  __odft_error = logRead(& kcontrol->private_data, str_108773245, str_947043017, str_679919104,
                         1580);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)kcontrol->private_data;
//#line  1584
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_947043017, str_679919104,
                         1584);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  1585
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                         1585);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ctrl = ensoniq->ctrl;
  {
  {
//#line  1586
  __odft_error = logRead(& ucontrol->value.integer.value[0], str_712681085, str_947043017,
                         str_679919104, 1586);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

//#line  1586
  if (ucontrol->value.integer.value[0]) {
    {
//#line  1587
    __odft_error = logWrite(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                            1587);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                           1587);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    ensoniq->ctrl |= (unsigned int )(4 << 16);
  } else {
    {
//#line  1589
    __odft_error = logWrite(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                            1589);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                           1589);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    ensoniq->ctrl &= (unsigned int )(~ (4 << 16));
  }
  }
  {
//#line  1590
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                         1590);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  changed = ctrl != ensoniq->ctrl;
//#line  1591
  if (changed) {
    {
//#line  1592
    __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_947043017, str_679919104,
                           1592);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    __odft_error = logRead(& ensoniq->port, str_784561127, str_947043017, str_679919104,
                           1592);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
    }
  }
  {
//#line  1593
  __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_947043017, str_679919104,
                         1593);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  1594
  return (changed);
  }
}
}
static struct snd_kcontrol_new snd_ens1373_line  __attribute__((__section__(".devinit.data")))  = 
//#line  1597
     {2, 0U, 0U, (unsigned char *)str_604382372, 0U, 0U, 0U, & snd_ctl_boolean_mono_info,
    & snd_es1373_line_get, & snd_es1373_line_put, {(snd_kcontrol_tlv_rw_t *)0}, 0UL};
//#line  1606 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_ensoniq_mixer_free_ac97(struct snd_ac97 *ac97 ) 
{ 
  struct ensoniq *ensoniq ;

  {
//#line  1608
  ensoniq = (struct ensoniq *)ac97->private_data;
//#line  1609
  ensoniq->u.es1371.ac97 = (struct snd_ac97 *)((void *)0);
//#line  1610
  return;
}
}
//#line  1618 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int es1371_quirk_lookup(struct ensoniq *ensoniq , struct es1371_quirk *list ) 
{ 


  {
  {
  {
//#line  1621
  while (1) {


    if (! ((int )list->vid != 65535)) {
//#line  1621
      goto while_break;
    }
    if ((int )(ensoniq->pci)->vendor == (int )list->vid) {
      if ((int )(ensoniq->pci)->device == (int )list->did) {
//#line  1622
        if (ensoniq->rev == (unsigned int )list->rev) {
//#line  1625
          return (1);
        }
      }
    }
//#line  1626
    list ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  1628
  return (0);
}
}
//#line  1631 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct es1371_quirk es1371_spdif_present[6]  __attribute__((__section__(".devinit.data")))  = {      {(unsigned short)4724,
      (unsigned short)22656, (unsigned char)2}, 
        {(unsigned short)4724, (unsigned short)22656, (unsigned char)3}, 
        {(unsigned short)4724, (unsigned short)22656, (unsigned char)4}, 
        {(unsigned short)4724, (unsigned short)4977, (unsigned char)7}, 
        {(unsigned short)4724, (unsigned short)4977, (unsigned char)8}, 
        {(unsigned short )(~ 0), (unsigned short )(~ 0), (unsigned char)0}};
//#line  1640 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_pci_quirk ens1373_line_quirk[2]  __attribute__((__section__(".devinit.data")))  = {      {(unsigned short)4724,
      (unsigned short)8192, 0}, 
        {(unsigned short)5208, (unsigned short)40960, 0}};
//#line  1653
static int __attribute__((__cold__))  snd_ensoniq_1371_mixer(struct ensoniq *ensoniq ,
                                                             int has_spdif , int has_line )  __attribute__((__section__(".devinit.text"))) ;
static struct snd_ac97_bus_ops ops  =    {(void (*)(struct snd_ac97 *ac97 ))0, (void (*)(struct snd_ac97 *ac97 ))0, & snd_es1371_codec_write,
    & snd_es1371_codec_read, & snd_es1371_codec_wait, (void (*)(struct snd_ac97 *ac97 ))0};
//#line  1646
static int __attribute__((__cold__))  snd_ensoniq_1371_mixer(struct ensoniq *ensoniq ,
                                                             int has_spdif , int has_line )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_1371_mixer(struct ensoniq *ensoniq ,
                                                             int has_spdif , int has_line ) 
{ 
  struct snd_card *card ;
  struct snd_ac97_bus *pbus ;
  struct snd_ac97_template ac97 ;
  int err ;
  struct snd_kcontrol *kctl ;
  int i ;
  int is_spdif ;
  unsigned int tmp ;
  int tmp___0 ;
  struct snd_kcontrol *tmp___1 ;
  struct snd_kcontrol *tmp___2 ;
  struct snd_pci_quirk  const  *tmp___3 ;

  {
  {
//#line  1649
  card = (struct snd_card *)ensoniq->card;
//#line  1659
  err = snd_ac97_bus(card, 0, & ops, (void *)0, & pbus);
  }
//#line  1659
  if (err < 0) {
//#line  1660
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  1662
  memset((void *)(& ac97), 0, sizeof(ac97));
//#line  1663
  ac97.private_data = (void *)ensoniq;
//#line  1664
  ac97.private_free = & snd_ensoniq_mixer_free_ac97;
//#line  1665
  ac97.pci = ensoniq->pci;
//#line  1666
  ac97.scaps = 1U;
//#line  1667
  err = snd_ac97_mixer(pbus, & ac97, (struct snd_ac97 **)(& ensoniq->u.es1371.ac97));
  }
//#line  1667
  if (err < 0) {
//#line  1668
    return ((int __attribute__((__cold__))  )err);
  }
  if (has_spdif > 0) {
    goto _L;
  } else
  if (! has_spdif) {
    {
//#line  1669
    tmp___0 = es1371_quirk_lookup(ensoniq, es1371_spdif_present);
    }
//#line  1669
    if (tmp___0) {
      _L: /* CIL Label */ 
      {
//#line  1672
      is_spdif = 0;
//#line  1674
      tmp = (unsigned int )((((1 << 7) << 8) | (2 << 8)) | (2 << 24));
      ensoniq->spdif_stream = tmp;
      ensoniq->spdif_default = tmp;
//#line  1676
      outl(ensoniq->spdif_default, (unsigned short )(ensoniq->port + 28UL));
      }
//#line  1678
      if ((int )(ensoniq->u.es1371.ac97)->ext_id & 4) {
//#line  1679
        is_spdif ++;
      }
//#line  1681
      i = 0;
      {
      {
      while (1) {


        if (! ((unsigned long )i < sizeof(snd_es1371_mixer_spdif) / sizeof(snd_es1371_mixer_spdif[0]) + (sizeof(char [1]) - 1UL))) {
          goto while_break;
        }
        {
//#line  1682
        kctl = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_es1371_mixer_spdif[i]),
                            (void *)ensoniq);
        }
//#line  1683
        if (! kctl) {
//#line  1684
          return ((int __attribute__((__cold__))  )-12);
        }
        {
//#line  1685
        kctl->id.index = (unsigned int )is_spdif;
//#line  1686
        err = snd_ctl_add(card, kctl);
        }
//#line  1687
        if (err < 0) {
//#line  1688
          return ((int __attribute__((__cold__))  )err);
        }
//#line  1681
        i ++;
      }

      }
      while_break: /* CIL Label */ ;
      }
    }
  }
//#line  1691
  if ((int )(ensoniq->u.es1371.ac97)->ext_id & 128) {
    {
//#line  1693
    ensoniq->cssr &= (unsigned int )(~ ((1 << 27) | (1 << 24)));
//#line  1694
    ensoniq->cssr |= (unsigned int )(1 << 26);
//#line  1695
    tmp___1 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_ens1373_rear),
                           (void *)ensoniq);
    err = snd_ctl_add(card, tmp___1);
    }
//#line  1696
    if (err < 0) {
//#line  1697
      return ((int __attribute__((__cold__))  )err);
    }
  }
  if (has_line > 0) {
    goto _L___0;
  } else {
    {
//#line  1699
    tmp___3 = snd_pci_quirk_lookup(ensoniq->pci, (struct snd_pci_quirk  const  *)(ens1373_line_quirk));
    }
//#line  1699
    if (tmp___3) {
      _L___0: /* CIL Label */ 
      {
//#line  1701
      tmp___2 = snd_ctl_new1((struct snd_kcontrol_new  const  *)(& snd_ens1373_line),
                             (void *)ensoniq);
      err = snd_ctl_add(card, tmp___2);
      }
//#line  1703
      if (err < 0) {
//#line  1704
        return ((int __attribute__((__cold__))  )err);
      }
    }
  }
//#line  1707
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  1802
static int __attribute__((__cold__))  snd_ensoniq_get_joystick_port(int dev )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_get_joystick_port(int dev ) 
{ 


  {
  {
  if (joystick_port[dev] == 0) {
//#line  1805
    goto case_0;
  }
  if (joystick_port[dev] == 1) {
//#line  1806
    goto case_0;
  }
  if (joystick_port[dev] == 512) {
//#line  1807
    goto case_0;
  }
  if (joystick_port[dev] == 520) {
//#line  1808
    goto case_0;
  }
  if (joystick_port[dev] == 528) {
//#line  1809
    goto case_0;
  }
  if (joystick_port[dev] == 536) {
//#line  1810
    goto case_0;
  }
//#line  1813
  goto switch_default;
  case_0: /* CIL Label */ 
//#line  1811
  return ((int __attribute__((__cold__))  )joystick_port[dev]);
  switch_default: /* CIL Label */ 
  {
//#line  1814
  printk(str_173238353, joystick_port[dev]);
  }
//#line  1815
  return ((int __attribute__((__cold__))  )0);

  }
}
}
//#line  1825
static int __attribute__((__cold__))  snd_ensoniq_create_gameport(struct ensoniq *ensoniq ,
                                                                  int dev )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_create_gameport(struct ensoniq *ensoniq ,
                                                                  int dev ) 
{ 
  struct gameport *gp ;
  int io_port ;
  int __attribute__((__cold__))  tmp ;
  struct resource *tmp___0 ;
  struct resource *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
//#line  1830
  tmp = snd_ensoniq_get_joystick_port(dev);
  io_port = (int )tmp;
  }
  {
  if (io_port == 0) {
//#line  1833
    goto case_0;
  }
  if (io_port == 1) {
//#line  1836
    goto case_1;
  }
//#line  1846
  goto switch_default;
  case_0: /* CIL Label */ 
//#line  1834
  return ((int __attribute__((__cold__))  )-38);
  case_1: /* CIL Label */ 
//#line  1837
  io_port = 512;
  {
  {
  while (1) {


    if (! (io_port <= 536)) {
      goto while_break;
    }
    {
//#line  1838
    tmp___0 = __request_region(& ioport_resource, (resource_size_t )io_port, (resource_size_t )8,
                               str_603776742, 0);
    }
//#line  1838
    if (tmp___0) {
//#line  1839
      goto while_break;
    }
//#line  1837
    io_port += 8;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  1840
  if (io_port > 536) {
    {
//#line  1841
    printk(str_445311958);
    }
//#line  1842
    return ((int __attribute__((__cold__))  )-16);
  }
//#line  1844
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
//#line  1847
  tmp___1 = __request_region(& ioport_resource, (resource_size_t )io_port, (resource_size_t )8,
                             str_603776742, 0);
  }
//#line  1847
  if (! tmp___1) {
    {
//#line  1848
    printk(str_216941979, io_port);
    }
//#line  1850
    return ((int __attribute__((__cold__))  )-16);
  }
//#line  1852
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
//#line  1855
  gp = gameport_allocate_port();
  ensoniq->gameport = gp;
  }
//#line  1856
  if (! gp) {
    {
//#line  1857
    printk(str_738175023);
//#line  1858
    __release_region(& ioport_resource, (resource_size_t )io_port, (resource_size_t )8);
    }
//#line  1859
    return ((int __attribute__((__cold__))  )-12);
  }
  {
//#line  1862
  gameport_set_name(gp, str_182023141);
//#line  1863
  tmp___2 = pci_name(ensoniq->pci);
  gameport_set_phys(gp, str_367676234, tmp___2);
//#line  1864
  gp->dev.parent = (struct device *)(& (ensoniq->pci)->dev);
//#line  1865
  gp->io = io_port;
//#line  1867
  ensoniq->ctrl |= (unsigned int )(1 << 2);
//#line  1869
  ensoniq->ctrl &= (unsigned int )(~ (3 << 24));
//#line  1870
  ensoniq->ctrl |= (unsigned int )(((io_port - 512) / 8 & 3) << 24);
//#line  1872
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  1874
  gameport_register_port(ensoniq->gameport);
  }
//#line  1876
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  1879 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_ensoniq_free_gameport(struct ensoniq *ensoniq ) 
{ 
  int port ;

  {
//#line  1881
  if (ensoniq->gameport) {
    {
//#line  1882
    port = (ensoniq->gameport)->io;
//#line  1884
    gameport_unregister_port(ensoniq->gameport);
//#line  1885
    ensoniq->gameport = (struct gameport *)((void *)0);
//#line  1886
    ensoniq->ctrl &= (unsigned int )(~ (1 << 2));
//#line  1887
    outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  1888
    __release_region(& ioport_resource, (resource_size_t )port, (resource_size_t )8);
    }
  }
//#line  1890
  return;
}
}
//#line  1900
void snd_ensoniq_proc_read(struct snd_info_entry *entry , struct snd_info_buffer * __attribute__((__noderef__,
                           __address_space__(2))) buffer )  __attribute__((__isolate__)) ;
void snd_ensoniq_proc_read(struct snd_info_entry *entry , struct snd_info_buffer * __attribute__((__noderef__,
                           __address_space__(2))) buffer ) 
{ 
  struct ensoniq *ensoniq ;
  char const   *tmp ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_1034057403);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& tmp);
  logStackVar(& entry);
  logStackVar(& buffer);
  }
  {
//#line  1903
  __odft_error = logRead(& entry->private_data, str_417657113, str_1034057403, str_679919104,
                         1903);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  ensoniq = (struct ensoniq *)entry->private_data;
//#line  1908
  snd_iprintf((struct snd_info_buffer *)buffer, (char *)str_1035699315);
  }
  {
  {
//#line  1910
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_1034057403, str_679919104,
                         1910);
  }
  if (__odft_error) {
    return (75);
  } else {

  }

  if (ensoniq->ctrl & (unsigned int )(1 << 2)) {
    tmp = str_2219;
  } else {
    tmp = str_42111;
  }
  }
  {
  snd_iprintf((struct snd_info_buffer *)buffer, (char *)str_711075343, tmp);
//#line  1918
  __odft_error = logRead(& ensoniq->ctrl, str_784473757, str_1034057403, str_679919104,
                         1918);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  snd_iprintf((struct snd_info_buffer *)buffer, (char *)str_368086832, ((ensoniq->ctrl >> 24) & 3U) * 8U + 512U);
//#line  1921
  printk(str_810807268, buffer);
  }
//#line  1922
  return;
  }
}
}
//#line  1924
static void __attribute__((__cold__))  snd_ensoniq_proc_init(struct ensoniq *ensoniq )  __attribute__((__section__(".devinit.text"))) ;
static void __attribute__((__cold__))  snd_ensoniq_proc_init(struct ensoniq *ensoniq ) 
{ 
  struct snd_info_entry *entry ;
  int tmp ;

  {
  {
//#line  1928
  tmp = snd_card_proc_new((struct snd_card *)ensoniq->card, str_130227268, & entry);
  }
//#line  1928
  if (! tmp) {
    {
//#line  1929
    snd_info_set_text_ops(entry, (void *)ensoniq, (void (*)(struct snd_info_entry * ,
                                                            struct snd_info_buffer * ))(& snd_ensoniq_proc_read));
    }
  }
//#line  1930
  return;
}
}
//#line  1936 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_free(struct ensoniq *ensoniq ) 
{ 


  {
  {
//#line  1938
  snd_ensoniq_free_gameport(ensoniq);
  }
//#line  1939
  if (ensoniq->irq < 0) {
//#line  1940
    goto __hw_end;
  }
  {
//#line  1945
  outl(0U, (unsigned short )ensoniq->port);
//#line  1946
  outl(0U, (unsigned short )(ensoniq->port + 32UL));
  }
//#line  1948
  if (ensoniq->irq >= 0) {
    {
//#line  1949
    synchronize_irq((unsigned int )ensoniq->irq);
    }
  }
  {
//#line  1950
  pci_set_power_state(ensoniq->pci, 3);
  }
  __hw_end: 
//#line  1956
  if (ensoniq->irq >= 0) {
    {
//#line  1957
    free_irq((unsigned int )ensoniq->irq, (void *)ensoniq);
    }
  }
  {
//#line  1958
  pci_release_regions(ensoniq->pci);
//#line  1959
  pci_disable_device(ensoniq->pci);
//#line  1960
  kfree((void const   *)ensoniq);
  }
//#line  1961
  return (0);
}
}
//#line  1964 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_dev_free(struct snd_device *device ) 
{ 
  struct ensoniq *ensoniq ;
  int tmp ;

  {
  {
//#line  1966
  ensoniq = (struct ensoniq *)device->device_data;
//#line  1967
  tmp = snd_ensoniq_free(ensoniq);
  }
  return (tmp);
}
}
//#line  1971 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_pci_quirk es1371_amplifier_hack[4]  __attribute__((__section__(".devinit.data")))  = {      {(unsigned short)4219,
      (unsigned short)8528, 0}, 
        {(unsigned short)5053, (unsigned short)4108, 0}, 
        {(unsigned short)4354, (unsigned short)22840, 0}, 
        {(unsigned short)4354, (unsigned short)35128, 0}};
//#line  1979 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct es1371_quirk es1371_ac97_reset_hack[6]  = {      {(unsigned short)4724, (unsigned short)22656, (unsigned char)2}, 
        {(unsigned short)4724, (unsigned short)22656, (unsigned char)3}, 
        {(unsigned short)4724, (unsigned short)22656, (unsigned char)4}, 
        {(unsigned short)4724, (unsigned short)4977, (unsigned char)7}, 
        {(unsigned short)4724, (unsigned short)4977, (unsigned char)8}, 
        {(unsigned short )(~ 0), (unsigned short )(~ 0), (unsigned char)0}};
//#line  1989 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_ensoniq_chip_init(struct ensoniq *ensoniq ) 
{ 
  int idx ;
  int tmp ;
  unsigned int tmp___0 ;

  {
  {
//#line  2004
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  2005
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  2006
  outl(0U, (unsigned short )(ensoniq->port + 24UL));
//#line  2007
  tmp = es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack);
  }
//#line  2007
  if (tmp) {
    {
//#line  2008
    outl(ensoniq->cssr, (unsigned short )(ensoniq->port + 4UL));
//#line  2012
    __const_udelay(85900UL);
    }
  }
  {
//#line  2015
  outl(ensoniq->ctrl | (unsigned int )(1 << 14), (unsigned short )ensoniq->port);
//#line  2016
  inl((unsigned short )ensoniq->port);
//#line  2017
  __const_udelay(85900UL);
//#line  2018
  outl(ensoniq->ctrl, (unsigned short )ensoniq->port);
//#line  2020
  snd_es1371_wait_src_ready(ensoniq);
//#line  2021
  outl((unsigned int )(1 << 22), (unsigned short )(ensoniq->port + 16UL));
//#line  2022
  idx = 0;
  }
  {
  {
  while (1) {


    if (! (idx < 128)) {
      goto while_break;
    }
    {
//#line  2023
    snd_es1371_src_write(ensoniq, (unsigned short )idx, (unsigned short)0);
//#line  2022
    idx ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  2024
  snd_es1371_src_write(ensoniq, (unsigned short)112, (unsigned short )(16 << 4));
//#line  2025
  snd_es1371_src_write(ensoniq, (unsigned short)113, (unsigned short )(16 << 10));
//#line  2026
  snd_es1371_src_write(ensoniq, (unsigned short)116, (unsigned short )(16 << 4));
//#line  2027
  snd_es1371_src_write(ensoniq, (unsigned short)117, (unsigned short )(16 << 10));
//#line  2028
  snd_es1371_src_write(ensoniq, (unsigned short)108, (unsigned short )(1 << 12));
//#line  2029
  snd_es1371_src_write(ensoniq, (unsigned short)109, (unsigned short )(1 << 12));
//#line  2030
  snd_es1371_src_write(ensoniq, (unsigned short)124, (unsigned short )(1 << 12));
//#line  2031
  snd_es1371_src_write(ensoniq, (unsigned short)125, (unsigned short )(1 << 12));
//#line  2032
  snd_es1371_src_write(ensoniq, (unsigned short)126, (unsigned short )(1 << 12));
//#line  2033
  snd_es1371_src_write(ensoniq, (unsigned short)127, (unsigned short )(1 << 12));
//#line  2034
  snd_es1371_adc_rate(ensoniq, 22050U);
//#line  2035
  snd_es1371_dac1_rate(ensoniq, 22050U);
//#line  2036
  snd_es1371_dac2_rate(ensoniq, 22050U);
//#line  2043
  snd_es1371_wait_src_ready(ensoniq);
//#line  2044
  outl(0U, (unsigned short )(ensoniq->port + 16UL));
//#line  2046
  outl(0U, (unsigned short )(ensoniq->port + 20UL));
//#line  2048
  tmp___0 = 0U;
  ensoniq->uartc = tmp___0;
  outb((unsigned char )tmp___0, (unsigned short )(ensoniq->port + 9UL));
//#line  2049
  outb((unsigned char)0, (unsigned short )(ensoniq->port + 10UL));
//#line  2050
  outl(ensoniq->cssr, (unsigned short )(ensoniq->port + 4UL));
//#line  2051
  synchronize_irq((unsigned int )ensoniq->irq);
  }
//#line  2052
  return;
}
}
//#line  2083
static int ens1371_checkpoint(void) ;
//#line  2084
static int ens1371_restore(void) ;
//#line  2055 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_suspend(struct pci_dev *pci , pm_message_t state ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct ensoniq *ensoniq ;
  pci_power_t tmp___0 ;

  {
  {
//#line  2057
  tmp = pci_get_drvdata(pci);
  card = (struct snd_card *)tmp;
//#line  2058
  ensoniq = (struct ensoniq *)card->private_data;
//#line  2060
  snd_power_change_state(card, 768U);
//#line  2062
  snd_pcm_suspend_all((struct snd_pcm *)ensoniq->pcm1);
//#line  2063
  snd_pcm_suspend_all((struct snd_pcm *)ensoniq->pcm2);
//#line  2066
  snd_ac97_suspend((struct snd_ac97 *)ensoniq->u.es1371.ac97);
//#line  2078
  pci_disable_device(pci);
//#line  2079
  pci_save_state(pci);
//#line  2080
  tmp___0 = pci_choose_state(pci, state);
  pci_set_power_state(pci, tmp___0);
//#line  2083
  ens1371_checkpoint();
//#line  2084
  ens1371_restore();
  }
//#line  2087
  return (0);
}
}
//#line  2090 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int ens1371_checkpoint(void) 
{ 


  {
  {
//#line  2092
  printk(str_42459933);
  }
//#line  2094
  if ((unsigned long )ens1371_dev == (unsigned long )((void *)0)) {
//#line  2095
    return;
  }
  {
//#line  2097
  pci_save_state(ens1371_dev);
  }
//#line  2099
  return (0);
}
}
//#line  2108
static void __attribute__((__cold__))  alsa_card_ens137x_exit(void)  __attribute__((__section__(".exit.text"))) ;
//#line  2101 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int ens1371_restore(void) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct ensoniq *ensoniq ;

  {
  {
//#line  2103
  printk(str_8982834);
  }
//#line  2105
  if ((unsigned long )ens1371_dev == (unsigned long )((void *)0)) {
    {
//#line  2108
    alsa_card_ens137x_exit();
    }
  }
  {
//#line  2111
  tmp = pci_get_drvdata(ens1371_dev);
  card = (struct snd_card *)tmp;
//#line  2112
  ensoniq = (struct ensoniq *)card->private_data;
//#line  2114
  snd_pcm_suspend_all((struct snd_pcm *)ensoniq->pcm1);
//#line  2115
  snd_pcm_suspend_all((struct snd_pcm *)ensoniq->pcm2);
//#line  2117
  pci_restore_state(ens1371_dev);
//#line  2118
  snd_ensoniq_chip_init(ensoniq);
//#line  2121
  snd_ac97_resume((struct snd_ac97 *)ensoniq->u.es1371.ac97);
  }
//#line  2125
  return (0);
}
}
//#line  2127 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_resume(struct pci_dev *pci ) 
{ 
  struct snd_card *card ;
  void *tmp ;
  struct ensoniq *ensoniq ;
  int tmp___0 ;

  {
  {
//#line  2129
  tmp = pci_get_drvdata(pci);
  card = (struct snd_card *)tmp;
//#line  2130
  ensoniq = (struct ensoniq *)card->private_data;
//#line  2132
  pci_set_power_state(pci, 0);
//#line  2133
  pci_restore_state(pci);
//#line  2134
  tmp___0 = (int )pci_enable_device(pci);
  }
//#line  2134
  if (tmp___0 < 0) {
    {
//#line  2135
    printk(str_238696912);
//#line  2137
    snd_card_disconnect(card);
    }
//#line  2138
    return (-5);
  }
  {
//#line  2140
  pci_set_master(pci);
//#line  2142
  snd_ensoniq_chip_init(ensoniq);
//#line  2145
  snd_ac97_resume((struct snd_ac97 *)ensoniq->u.es1371.ac97);
//#line  2149
  snd_power_change_state(card, 0U);
  }
//#line  2150
  return (0);
}
}
//#line  2161
static int __attribute__((__cold__))  snd_ensoniq_create(struct snd_card *card , struct pci_dev *pci ,
                                                         struct ensoniq **rensoniq )  __attribute__((__section__(".devinit.text"))) ;
static struct snd_device_ops ops___0  =    {(int (* __attribute__((__noderef__, __address_space__(2))) )(struct snd_device *dev ))(& snd_ensoniq_dev_free),
    (int (* __attribute__((__noderef__, __address_space__(2))) )(struct snd_device *dev ))0,
    (int (* __attribute__((__noderef__, __address_space__(2))) )(struct snd_device *dev ))0};
//#line  2175 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct lock_class_key __key___4  ;
//#line  2176 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct lock_class_key __key___5  ;
//#line  2155
static int __attribute__((__cold__))  snd_ensoniq_create(struct snd_card *card , struct pci_dev *pci ,
                                                         struct ensoniq **rensoniq )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_create(struct snd_card *card , struct pci_dev *pci ,
                                                         struct ensoniq **rensoniq ) 
{ 
  struct ensoniq *ensoniq ;
  int err ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct snd_pci_quirk  const  *tmp___3 ;
  int tmp___4 ;

  {
  {
//#line  2165
  *rensoniq = (struct ensoniq *)((void *)0);
//#line  2166
  err = (int )pci_enable_device(pci);
  }
//#line  2166
  if (err < 0) {
//#line  2167
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2168
  tmp = kzalloc(sizeof(*ensoniq), 208U);
  ensoniq = (struct ensoniq *)tmp;
  }
//#line  2169
  if ((unsigned long )ensoniq == (unsigned long )((void *)0)) {
    {
//#line  2170
    pci_disable_device(pci);
    }
//#line  2171
    return ((int __attribute__((__cold__))  )-12);
  }
  {
//#line  2173
  tmp___0 = kmalloc(sizeof(spinlock_t ), 32U);
  ensoniq->reg_lock = (spinlock_t * __attribute__((__noderef__, __address_space__(2))) )((struct spinlock_t *)tmp___0);
//#line  2174
  tmp___1 = kmalloc(sizeof(struct mutex ), 32U);
  ensoniq->src_mutex = (struct mutex * __attribute__((__noderef__, __address_space__(2))) )((struct mutex *)tmp___1);
  }
  {
  {
  while (1) {


    {
//#line  2175
    __spin_lock_init((spinlock_t *)ensoniq->reg_lock, str_87276860, & __key___4);
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
  {
  while (1) {


    {
//#line  2176
    __mutex_init((struct mutex *)ensoniq->src_mutex, str_9379010, & __key___5);
    }
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  2177
  ensoniq->card = (struct snd_card *)card;
//#line  2178
  ensoniq->pci = pci;
//#line  2179
  ens1371_dev = pci;
//#line  2180
  ensoniq->irq = -1;
//#line  2181
  err = (int )pci_request_regions(pci, str_980588047);
  }
//#line  2181
  if (err < 0) {
    {
//#line  2182
    kfree((void const   *)ensoniq);
//#line  2183
    pci_disable_device(pci);
    }
//#line  2184
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2186
  ensoniq->port = (unsigned long )pci->resource[0].start;
//#line  2187
  tmp___2 = (int )request_irq(pci->irq, & snd_audiopci_interrupt, 128UL, str_980588047,
                              (void *)ensoniq);
  }
//#line  2187
  if (tmp___2) {
    {
//#line  2189
    printk(str_235265470, pci->irq);
//#line  2190
    snd_ensoniq_free(ensoniq);
    }
//#line  2191
    return ((int __attribute__((__cold__))  )-16);
  }
  {
//#line  2193
  ensoniq->irq = (int )pci->irq;
//#line  2202
  pci_set_master(pci);
//#line  2203
  ensoniq->rev = (unsigned int )pci->revision;
//#line  2213
  ensoniq->ctrl = 0U;
//#line  2214
  ensoniq->sctrl = 0U;
//#line  2215
  ensoniq->cssr = 0U;
//#line  2216
  tmp___3 = snd_pci_quirk_lookup(pci, (struct snd_pci_quirk  const  *)(es1371_amplifier_hack));
  }
//#line  2216
  if (tmp___3) {
//#line  2217
    ensoniq->ctrl |= (unsigned int )(1 << 16);
  }
  {
//#line  2219
  tmp___4 = es1371_quirk_lookup(ensoniq, es1371_ac97_reset_hack);
  }
//#line  2219
  if (tmp___4) {
//#line  2220
    ensoniq->cssr |= (unsigned int )(1 << 29);
  }
  {
//#line  2223
  snd_ensoniq_chip_init(ensoniq);
//#line  2225
  err = snd_device_new(card, 8192, (void *)ensoniq, & ops___0);
  }
//#line  2225
  if (err < 0) {
    {
//#line  2226
    snd_ensoniq_free(ensoniq);
    }
//#line  2227
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2230
  snd_ensoniq_proc_init(ensoniq);
//#line  2232
  card->dev = (struct device *)(& pci->dev);
//#line  2234
  *rensoniq = ensoniq;
  }
//#line  2235
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  2242 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_ensoniq_midi_interrupt(struct ensoniq *ensoniq ) 
{ 
  struct snd_rawmidi *rmidi ;
  unsigned char status ;
  unsigned char mask ;
  unsigned char byte ;
  int tmp ;
  int __shadow_tick_118 ;
  int __shadow_tick_119 ;

  {
  __shadow_tick_118 = 0;
  __shadow_tick_119 = 0;
//#line  2244
  rmidi = (struct snd_rawmidi *)ensoniq->rmidi;
//#line  2247
  if ((unsigned long )rmidi == (unsigned long )((void *)0)) {
//#line  2248
    return;
  }
  {
//#line  2250
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
  }
  if (ensoniq->uartm & 2U) {
    mask = (unsigned char)1;
  } else {
//#line  2251
    mask = (unsigned char)0;
  }
  {
  {
//#line  2252
  while (1) {


    if (! mask) {
//#line  2252
      goto while_break;
    }
    {
//#line  2253
    status = inb((unsigned short )(ensoniq->port + 9UL));
    }
//#line  2254
    if (((int )status & (int )mask) == 0) {
//#line  2255
      goto while_break;
    }
    {
//#line  2256
    byte = inb((unsigned short )(ensoniq->port + 8UL));
//#line  2257
    snd_rawmidi_receive(ensoniq->midi_input, (unsigned char const   *)(& byte), 1);
    }
    if (__shadow_tick_118 < 200) {
      __shadow_tick_118 ++;
    } else {
      {
      printk(str_270898770);
      }
      return (72);
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  2259
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
//#line  2262
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
  }
  if (ensoniq->uartm & 1U) {
    mask = (unsigned char )(1 << 1);
  } else {
//#line  2263
    mask = (unsigned char)0;
  }
  {
  {
//#line  2264
  while (1) {


    if (! mask) {
//#line  2264
      goto while_break___0;
    }
    {
//#line  2265
    status = inb((unsigned short )(ensoniq->port + 9UL));
    }
//#line  2266
    if (((int )status & (int )mask) == 0) {
//#line  2267
      goto while_break___0;
    }
    {
//#line  2268
    tmp = snd_rawmidi_transmit(ensoniq->midi_output, & byte, 1);
    }
//#line  2268
    if (tmp != 1) {
      {
//#line  2269
      ensoniq->uartc &= (unsigned int )(~ (3 << 5));
//#line  2270
      outb((unsigned char )ensoniq->uartc, (unsigned short )(ensoniq->port + 9UL));
//#line  2271
      mask = (unsigned char )((int )mask & ~ (1 << 1));
      }
    } else {
      {
//#line  2273
      outb(byte, (unsigned short )(ensoniq->port + 8UL));
      }
    }
    if (__shadow_tick_119 < 200) {
      __shadow_tick_119 ++;
    } else {
      {
      printk(str_270906351);
      }
      return (72);
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
  {
//#line  2276
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2277
  return;
}
}
//#line  2279 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_midi_input_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
//#line  2281
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
//#line  2283
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  2284
  ensoniq->uartm |= 2U;
//#line  2285
  ensoniq->midi_input = substream;
  }
//#line  2286
  if (! (ensoniq->uartm & 1U)) {
    {
//#line  2287
    outb((unsigned char)3, (unsigned short )(ensoniq->port + 9UL));
//#line  2288
    tmp = 0U;
    ensoniq->uartc = tmp;
    outb((unsigned char )tmp, (unsigned short )(ensoniq->port + 9UL));
//#line  2289
    tmp___0 = ensoniq->ctrl | (unsigned int )(1 << 3);
    ensoniq->ctrl = tmp___0;
    outl(tmp___0, (unsigned short )ensoniq->port);
    }
  }
  {
//#line  2291
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2292
  return (0);
}
}
//#line  2295 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_midi_input_close(struct snd_rawmidi_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  2297
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
//#line  2299
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2300
  if (! (ensoniq->uartm & 1U)) {
    {
//#line  2301
    tmp = 0U;
    ensoniq->uartc = tmp;
    outb((unsigned char )tmp, (unsigned short )(ensoniq->port + 9UL));
//#line  2302
    tmp___0 = ensoniq->ctrl & (unsigned int )(~ (1 << 3));
    ensoniq->ctrl = tmp___0;
    outl(tmp___0, (unsigned short )ensoniq->port);
    }
  } else {
    {
//#line  2304
    tmp___1 = ensoniq->uartc & (unsigned int )(~ (1 << 7));
    ensoniq->uartc = tmp___1;
    outb((unsigned char )tmp___1, (unsigned short )(ensoniq->port + 9UL));
    }
  }
  {
//#line  2306
  ensoniq->midi_input = (struct snd_rawmidi_substream *)((void *)0);
//#line  2307
  ensoniq->uartm &= 4294967293U;
//#line  2308
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2309
  return (0);
}
}
//#line  2312 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_midi_output_open(struct snd_rawmidi_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
  {
//#line  2314
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
//#line  2316
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
//#line  2317
  ensoniq->uartm |= 1U;
//#line  2318
  ensoniq->midi_output = substream;
  }
//#line  2319
  if (! (ensoniq->uartm & 2U)) {
    {
//#line  2320
    outb((unsigned char)3, (unsigned short )(ensoniq->port + 9UL));
//#line  2321
    tmp = 0U;
    ensoniq->uartc = tmp;
    outb((unsigned char )tmp, (unsigned short )(ensoniq->port + 9UL));
//#line  2322
    tmp___0 = ensoniq->ctrl | (unsigned int )(1 << 3);
    ensoniq->ctrl = tmp___0;
    outl(tmp___0, (unsigned short )ensoniq->port);
    }
  }
  {
//#line  2324
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2325
  return (0);
}
}
//#line  2328 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int snd_ensoniq_midi_output_close(struct snd_rawmidi_substream *substream ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  {
//#line  2330
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
//#line  2332
  _spin_lock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2333
  if (! (ensoniq->uartm & 2U)) {
    {
//#line  2334
    tmp = 0U;
    ensoniq->uartc = tmp;
    outb((unsigned char )tmp, (unsigned short )(ensoniq->port + 9UL));
//#line  2335
    tmp___0 = ensoniq->ctrl & (unsigned int )(~ (1 << 3));
    ensoniq->ctrl = tmp___0;
    outl(tmp___0, (unsigned short )ensoniq->port);
    }
  } else {
    {
//#line  2337
    tmp___1 = ensoniq->uartc & (unsigned int )(~ (3 << 5));
    ensoniq->uartc = tmp___1;
    outb((unsigned char )tmp___1, (unsigned short )(ensoniq->port + 9UL));
    }
  }
  {
//#line  2339
  ensoniq->midi_output = (struct snd_rawmidi_substream *)((void *)0);
//#line  2340
  ensoniq->uartm &= 4294967294U;
//#line  2341
  _spin_unlock_irq((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2342
  return (0);
}
}
//#line  2345 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static void snd_ensoniq_midi_input_trigger(struct snd_rawmidi_substream *substream ,
                                           int up___0 ) 
{ 
  unsigned long flags ;
  struct ensoniq *ensoniq ;
  int idx ;

  {
//#line  2348
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
  {
  {
  while (1) {


    {
//#line  2351
    flags = _spin_lock_irqsave((spinlock_t *)ensoniq->reg_lock);
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2352
  if (up___0) {
//#line  2353
    if ((ensoniq->uartc & (unsigned int )(1 << 7)) == 0U) {
//#line  2355
      idx = 0;
      {
      {
      while (1) {


        if (! (idx < 32)) {
          goto while_break___0;
        }
        {
//#line  2356
        inb((unsigned short )(ensoniq->port + 8UL));
//#line  2355
        idx ++;
        }
      }

      }
      while_break___0: /* CIL Label */ ;
      }
      {
//#line  2357
      ensoniq->uartc |= (unsigned int )(1 << 7);
//#line  2358
      outb((unsigned char )ensoniq->uartc, (unsigned short )(ensoniq->port + 9UL));
      }
    }
  } else
//#line  2361
  if (ensoniq->uartc & (unsigned int )(1 << 7)) {
    {
//#line  2362
    ensoniq->uartc &= (unsigned int )(~ (1 << 7));
//#line  2363
    outb((unsigned char )ensoniq->uartc, (unsigned short )(ensoniq->port + 9UL));
    }
  }
  {
  {
  while (1) {


    {
//#line  2366
    _spin_unlock_irqrestore((spinlock_t *)ensoniq->reg_lock, flags);
    }
    goto while_break___1;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  2367
  return;
}
}
//#line  2369
void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substream , int up___0 )  __attribute__((__isolate__)) ;
void snd_ensoniq_midi_output_trigger(struct snd_rawmidi_substream *substream , int up___0 ) 
{ 
  unsigned long flags ;
  struct ensoniq *ensoniq ;
  unsigned char byte ;
  int tmp ;
  unsigned char tmp___0 ;
  int __shadow_tick_124 ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  logStackFrame(str_1025924976);
  }
  {
  {
  logStackVar(& ensoniq);
  logStackVar(& substream);
  }
  __shadow_tick_124 = 0;
  {
//#line  2372
  __odft_error = logRead(& (substream->rmidi)->private_data, str_629286318, str_1025924976,
                         str_679919104, 2372);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  {
  __odft_error = logRead(& substream->rmidi, str_112964058, str_1025924976, str_679919104,
                         2372);
  }
  if (__odft_error) {
    return (75);
  } else {

  }
  ensoniq = (struct ensoniq *)(substream->rmidi)->private_data;
  {
  {
  while (1) {


    {
//#line  2375
    __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_1025924976, str_679919104,
                           2375);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    flags = _spin_lock_irqsave((spinlock_t *)ensoniq->reg_lock);
    }
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  2376
  if (up___0) {
    {
    {
//#line  2377
    __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                           2377);
    }
    if (__odft_error) {
      return (75);
    } else {

    }

//#line  2377
    if (((ensoniq->uartc >> 5) & 3U) == 0U) {
      {
//#line  2378
      __odft_error = logWrite(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                              2378);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                             2378);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      ensoniq->uartc |= (unsigned int )(1 << 5);
      {
      {
//#line  2380
      while (1) {


        {
        {
//#line  2380
        __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                               2380);
        }
        if (__odft_error) {
          return (75);
        } else {

        }

        if (((ensoniq->uartc >> 5) & 3U) == 1U) {
          {
          __odft_error = logRead(& ensoniq->port, str_784561127, str_1025924976, str_679919104,
                                 2380);
          }
          if (__odft_error) {
            return (75);
          } else {

          }
          {
          tmp___0 = inb((unsigned short )(ensoniq->port + 9UL));
          }
          if (! ((int )tmp___0 & (1 << 1))) {
            goto while_break___0;
          }
        } else {
          goto while_break___0;
        }
        }
        {
//#line  2382
        tmp = snd_rawmidi_transmit(substream, & byte, 1);
        }
//#line  2382
        if (tmp != 1) {
          {
//#line  2383
          __odft_error = logWrite(& ensoniq->uartc, str_948573379, str_1025924976,
                                  str_679919104, 2383);
          }
          if (__odft_error) {
            return (75);
          } else {

          }
          {
          __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976,
                                 str_679919104, 2383);
          }
          if (__odft_error) {
            return (75);
          } else {

          }
          ensoniq->uartc &= (unsigned int )(~ (3 << 5));
        } else {
          {
//#line  2385
          __odft_error = logRead(& ensoniq->port, str_784561127, str_1025924976, str_679919104,
                                 2385);
          }
          if (__odft_error) {
            return (75);
          } else {

          }
          {
          outb(byte, (unsigned short )(ensoniq->port + 8UL));
          }
        }
        if (__shadow_tick_124 < 200) {
          __shadow_tick_124 ++;
        } else {
          {
          printk(str_271048946);
          }
          return (72);
        }
      }

      }
      while_break___0: /* CIL Label */ ;
      }
      {
//#line  2388
      __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                             2388);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      __odft_error = logRead(& ensoniq->port, str_784561127, str_1025924976, str_679919104,
                             2388);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      outb((unsigned char )ensoniq->uartc, (unsigned short )(ensoniq->port + 9UL));
      }
    }
    }
  } else {
    {
    {
//#line  2391
    __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                           2391);
    }
    if (__odft_error) {
      return (75);
    } else {

    }

//#line  2391
    if (((ensoniq->uartc >> 5) & 3U) == 1U) {
      {
//#line  2392
      __odft_error = logWrite(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                              2392);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                             2392);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      ensoniq->uartc &= (unsigned int )(~ (3 << 5));
//#line  2393
      __odft_error = logRead(& ensoniq->uartc, str_948573379, str_1025924976, str_679919104,
                             2393);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      __odft_error = logRead(& ensoniq->port, str_784561127, str_1025924976, str_679919104,
                             2393);
      }
      if (__odft_error) {
        return (75);
      } else {

      }
      {
      outb((unsigned char )ensoniq->uartc, (unsigned short )(ensoniq->port + 9UL));
      }
    }
    }
  }
  {
  {
  while (1) {


    {
//#line  2396
    __odft_error = logRead(& ensoniq->reg_lock, str_87276860, str_1025924976, str_679919104,
                           2396);
    }
    if (__odft_error) {
      return (75);
    } else {

    }
    {
    _spin_unlock_irqrestore((spinlock_t *)ensoniq->reg_lock, flags);
    }
    goto while_break___1;
  }

  }
  while_break___1: /* CIL Label */ ;
  }
//#line  2397
  return;
  }
}
}
//#line  2399 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_rawmidi_ops snd_ensoniq_midi_output  =    {& snd_ensoniq_midi_output_open, & snd_ensoniq_midi_output_close, & snd_ensoniq_midi_output_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  2406 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static struct snd_rawmidi_ops snd_ensoniq_midi_input  =    {& snd_ensoniq_midi_input_open, & snd_ensoniq_midi_input_close, & snd_ensoniq_midi_input_trigger,
    (void (*)(struct snd_rawmidi_substream *substream ))0};
//#line  2413
static int __attribute__((__cold__))  snd_ensoniq_midi(struct ensoniq *ensoniq , int device ,
                                                       struct snd_rawmidi **rrawmidi )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_ensoniq_midi(struct ensoniq *ensoniq , int device ,
                                                       struct snd_rawmidi **rrawmidi ) 
{ 
  struct snd_rawmidi *rmidi ;
  int err ;

  {
//#line  2419
  if (rrawmidi) {
//#line  2420
    *rrawmidi = (struct snd_rawmidi *)((void *)0);
  }
  {
//#line  2421
  err = snd_rawmidi_new((struct snd_card *)ensoniq->card, (char *)str_212077587, device,
                        1, 1, & rmidi);
  }
//#line  2421
  if (err < 0) {
//#line  2422
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2426
  strcpy(rmidi->name, str_182023070);
//#line  2428
  snd_rawmidi_set_ops(rmidi, 0, & snd_ensoniq_midi_output);
//#line  2429
  snd_rawmidi_set_ops(rmidi, 1, & snd_ensoniq_midi_input);
//#line  2430
  rmidi->info_flags |= 7U;
//#line  2432
  rmidi->private_data = (struct ensoniq *)ensoniq;
//#line  2433
  ensoniq->rmidi = (struct snd_rawmidi *)rmidi;
  }
//#line  2434
  if (rrawmidi) {
//#line  2435
    *rrawmidi = rmidi;
  }
//#line  2436
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  2443 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static irqreturn_t snd_audiopci_interrupt(int irq , void *dev_id ) 
{ 
  struct ensoniq *ensoniq ;
  unsigned int status ;
  unsigned int sctrl ;

  {
//#line  2445
  ensoniq = (struct ensoniq *)dev_id;
//#line  2448
  if ((unsigned long )ensoniq == (unsigned long )((void *)0)) {
//#line  2449
    return (0);
  }
  {
//#line  2451
  status = inl((unsigned short )(ensoniq->port + 4UL));
  }
//#line  2452
  if (! (status & (unsigned int )(1 << 31))) {
//#line  2453
    return (0);
  }
  {
//#line  2455
  _spin_lock((spinlock_t *)ensoniq->reg_lock);
//#line  2456
  sctrl = ensoniq->sctrl;
  }
//#line  2457
  if (status & (unsigned int )(1 << 2)) {
//#line  2458
    sctrl &= (unsigned int )(~ (1 << 8));
  }
//#line  2459
  if (status & (unsigned int )(1 << 1)) {
//#line  2460
    sctrl &= (unsigned int )(~ (1 << 9));
  }
//#line  2461
  if (status & 1U) {
//#line  2462
    sctrl &= (unsigned int )(~ (1 << 10));
  }
  {
//#line  2463
  outl(sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  2464
  outl(ensoniq->sctrl, (unsigned short )(ensoniq->port + 32UL));
//#line  2465
  _spin_unlock((spinlock_t *)ensoniq->reg_lock);
  }
//#line  2467
  if (status & (unsigned int )(1 << 3)) {
    {
//#line  2468
    snd_ensoniq_midi_interrupt(ensoniq);
    }
  }
  if (status & (unsigned int )(1 << 1)) {
//#line  2469
    if (ensoniq->playback2_substream) {
      {
//#line  2470
      snd_pcm_period_elapsed((struct snd_pcm_substream *)ensoniq->playback2_substream);
      }
    }
  }
  if (status & 1U) {
//#line  2471
    if (ensoniq->capture_substream) {
      {
//#line  2472
      snd_pcm_period_elapsed((struct snd_pcm_substream *)ensoniq->capture_substream);
      }
    }
  }
  if (status & (unsigned int )(1 << 2)) {
//#line  2473
    if (ensoniq->playback1_substream) {
      {
//#line  2474
      snd_pcm_period_elapsed((struct snd_pcm_substream *)ensoniq->playback1_substream);
      }
    }
  }
//#line  2475
  return (1);
}
}
//#line  2481 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
static int dev  ;
//#line  2478
static int __attribute__((__cold__))  snd_audiopci_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id )  __attribute__((__section__(".devinit.text"))) ;
static int __attribute__((__cold__))  snd_audiopci_probe(struct pci_dev *pci , struct pci_device_id  const  *pci_id ) 
{ 
  struct snd_card *card ;
  struct ensoniq *ensoniq ;
  int err ;
  int pcm_devs[2] ;
  int __attribute__((__cold__))  tmp ;
  int __attribute__((__cold__))  tmp___0 ;
  int __attribute__((__cold__))  tmp___1 ;
  int __attribute__((__cold__))  tmp___2 ;
  int __attribute__((__cold__))  tmp___3 ;

  {
//#line  2486
  if (dev >= 32) {
//#line  2487
    return ((int __attribute__((__cold__))  )-19);
  }
//#line  2488
  if (! enable[dev]) {
//#line  2489
    dev ++;
//#line  2490
    return ((int __attribute__((__cold__))  )-2);
  }
  {
//#line  2493
  card = snd_card_new(index[dev], (char const   *)id[dev], & __this_module, 0);
  }
//#line  2494
  if ((unsigned long )card == (unsigned long )((void *)0)) {
//#line  2495
    return ((int __attribute__((__cold__))  )-12);
  }
  {
//#line  2497
  tmp = snd_ensoniq_create(card, pci, & ensoniq);
  err = (int )tmp;
  }
//#line  2497
  if (err < 0) {
    {
//#line  2498
    snd_card_free(card);
    }
//#line  2499
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2501
  card->private_data = (void *)ensoniq;
//#line  2503
  pcm_devs[0] = 0;
  pcm_devs[1] = 1;
//#line  2511
  tmp___0 = snd_ensoniq_1371_mixer(ensoniq, spdif[dev], lineio[dev]);
  err = (int )tmp___0;
  }
//#line  2511
  if (err < 0) {
    {
//#line  2512
    snd_card_free(card);
    }
//#line  2513
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2516
  tmp___1 = snd_ensoniq_pcm(ensoniq, 0, (struct snd_pcm **)((void *)0));
  err = (int )tmp___1;
  }
//#line  2516
  if (err < 0) {
    {
//#line  2517
    snd_card_free(card);
    }
//#line  2518
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2520
  tmp___2 = snd_ensoniq_pcm2(ensoniq, 1, (struct snd_pcm **)((void *)0));
  err = (int )tmp___2;
  }
//#line  2520
  if (err < 0) {
    {
//#line  2521
    snd_card_free(card);
    }
//#line  2522
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2524
  tmp___3 = snd_ensoniq_midi(ensoniq, 0, (struct snd_rawmidi **)((void *)0));
  err = (int )tmp___3;
  }
//#line  2524
  if (err < 0) {
    {
//#line  2525
    snd_card_free(card);
    }
//#line  2526
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2529
  snd_ensoniq_create_gameport(ensoniq, dev);
//#line  2531
  strcpy(card->driver, str_229248278);
//#line  2533
  strcpy(card->shortname, str_980588047);
//#line  2534
  sprintf(card->longname, str_265323660, card->shortname, card->driver, ensoniq->port,
          ensoniq->irq);
//#line  2540
  err = snd_card_register(card);
  }
//#line  2540
  if (err < 0) {
    {
//#line  2541
    snd_card_free(card);
    }
//#line  2542
    return ((int __attribute__((__cold__))  )err);
  }
  {
//#line  2545
  pci_set_drvdata(pci, (void *)card);
//#line  2546
  dev ++;
  }
//#line  2547
  return ((int __attribute__((__cold__))  )0);
}
}
//#line  2550
static void __attribute__((__cold__))  snd_audiopci_remove(struct pci_dev *pci )  __attribute__((__section__(".devexit.text"))) ;
static void __attribute__((__cold__))  snd_audiopci_remove(struct pci_dev *pci ) 
{ 
  void *tmp ;

  {
  {
//#line  2552
  tmp = pci_get_drvdata(pci);
  snd_card_free((struct snd_card *)tmp);
//#line  2553
  pci_set_drvdata(pci, (void *)0);
  }
//#line  2554
  return;
}
}
static struct pci_driver driver  = 
//#line  2556
     {{(struct list_head *)0, (struct list_head *)0}, (char *)str_229248278, (struct pci_device_id  const  *)(snd_audiopci_ids),
    (int (*)(struct pci_dev *dev , struct pci_device_id  const  *id ))(& snd_audiopci_probe),
    (void (*)(struct pci_dev *dev ))(& snd_audiopci_remove), & snd_ensoniq_suspend,
    (int (*)(struct pci_dev *dev , pm_message_t state ))0, (int (*)(struct pci_dev *dev ))0,
    & snd_ensoniq_resume, (void (*)(struct pci_dev *dev ))0, (struct pci_error_handlers *)0,
    {(char const   *)0, (struct bus_type *)0, (struct module *)0, (char const   *)0,
     (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0, (void (*)(struct device *dev ))0,
     (int (*)(struct device *dev , pm_message_t state ))0, (int (*)(struct device *dev ))0,
     (struct attribute_group **)0, (struct dev_pm_ops *)0, (struct driver_private *)0},
    {{{0U}, 0U, 0U, (void *)0, {(struct lock_class_key *)0, (struct lock_class *)0,
                                (char const   *)0}}, {(struct list_head *)0, (struct list_head *)0}}};
//#line  2572
static void __attribute__((__cold__))  alsa_card_ens137x_exit(void)  __attribute__((__section__(".exit.text"))) ;
static void __attribute__((__cold__))  alsa_card_ens137x_exit(void) 
{ 


  {
  {
//#line  2574
  pci_unregister_driver(& driver);
  }
//#line  2575
  return;
}
}
//#line  2578 "/scratch/sym/ipc_drivers/ens1371/ens1371_annotated.c"
void cleanup_module(void) 
{ 


  {
  {
  alsa_card_ens137x_exit();
  }
  return;
}
}
static void MARSH___STUB__pci_unregister_driver(struct req_args *rqarg , struct pci_driver *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_unregister_driver", & _buf_, & _off_, & dev);
  rqarg->function_id = 1146;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__pci_unregister_driver(struct req_args *rqarg , struct pci_driver *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_unregister_driver", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_driver ),
                     sizeof(struct pci_driver ));
  if (dev != 0U) {
    tmp_fld6 = & dev->driver;
    tmp_lv5 = dev;
    nooks_ot_storeoffset_user(dev, tmp_fld6 - tmp_lv5, sizeof(struct device_driver ));
  }
  return;
}
}
void pci_unregister_driver(struct pci_driver *dev ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__pci_unregister_driver(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_unregister_driver", & rqarg);

  DEMARSH_STUB__pci_unregister_driver(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_set_power_state(struct req_args *rqarg , struct pci_dev *dev ,
                                              pci_power_t state ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_set_power_state", & _buf_, & _off_, & dev);
  fill_marshbuf("pci_set_power_state", & _buf_, & _off_, (void *)(& state), sizeof(int ));
  rqarg->function_id = 1145;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__pci_set_power_state(struct req_args *rqarg , struct pci_dev *dev ,
                                             pci_power_t state ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_set_power_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_set_power_state", _buf_, & _off_, sizeof(int ), (void *)(& state));
  fetch_marshbuf("pci_set_power_state", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int pci_set_power_state(struct pci_dev *dev , pci_power_t state ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_set_power_state(& rqarg, dev, state);
  __odft_disp_error = disp_kern("pci_set_power_state", & rqarg);

  _retval_ = (int )DEMARSH_STUB__pci_set_power_state(& rqarg, dev, state);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_new(struct req_args *rqarg , int idx , char const   *id ,
                                       struct module *module , int extra_size ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& idx), sizeof(int ));
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)id, sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_new", & _buf_, & _off_, & module);
  fill_marshbuf("snd_card_new", & _buf_, & _off_, (void *)(& extra_size), sizeof(int ));
  rqarg->function_id = 1159;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_card *DEMARSH_STUB__snd_card_new(struct req_args *rqarg , int idx ,
                                                   char const   *id , struct module *module ,
                                                   int extra_size ) 
{ 
  struct snd_card *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& idx));
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& id), sizeof(char const   ),
                     sizeof(char const   ));
  if (id != 0U) {
    fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(char const   ), (void *)id);
  }
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& module), sizeof(struct module ),
                     sizeof(struct module ));
  fetch_marshbuf("snd_card_new", _buf_, & _off_, sizeof(int ), (void *)(& extra_size));
  fetch_marshbuf_ptr("snd_card_new", _buf_, & _off_, (void **)(& _retval_), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  return (_retval_);
}
}
struct snd_card *snd_card_new(int idx , char const   *id , struct module *module ,
                              int extra_size ) 
{ 
  struct req_args rqarg ;
  struct snd_card *_retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_new(& rqarg, idx, id, module, extra_size);
  __odft_disp_error = disp_kern("snd_card_new", & rqarg);

  _retval_ = 0U;
  _retval_ = (struct snd_card *)DEMARSH_STUB__snd_card_new(& rqarg, idx, id, module,
                                                           extra_size);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_set_ops(struct req_args *rqarg , struct snd_rawmidi *rmidi ,
                                              int stream , struct snd_rawmidi_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_set_ops", & _buf_, & _off_, & rmidi);
  fill_marshbuf("snd_rawmidi_set_ops", & _buf_, & _off_, (void *)(& stream), sizeof(int ));
  fill_marshbuf_ptr("snd_rawmidi_set_ops", & _buf_, & _off_, & ops);
  rqarg->function_id = 1257;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_rawmidi_set_ops(struct req_args *rqarg , struct snd_rawmidi *rmidi ,
                                              int stream , struct snd_rawmidi_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_set_ops", _buf_, & _off_, (void **)(& rmidi), sizeof(struct snd_rawmidi ),
                     sizeof(struct snd_rawmidi ));
  fetch_marshbuf("snd_rawmidi_set_ops", _buf_, & _off_, sizeof(int ), (void *)(& stream));
  fetch_marshbuf_ptr("snd_rawmidi_set_ops", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_rawmidi_ops ),
                     sizeof(struct snd_rawmidi_ops ));
  return;
}
}
void snd_rawmidi_set_ops(struct snd_rawmidi *rmidi , int stream , struct snd_rawmidi_ops *ops ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_rawmidi_set_ops(& rqarg, rmidi, stream, ops);
  __odft_disp_error = disp_kern("snd_rawmidi_set_ops", & rqarg);

  DEMARSH_STUB__snd_rawmidi_set_ops(& rqarg, rmidi, stream, ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__synchronize_irq(struct req_args *rqarg , unsigned int irq ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("synchronize_irq", & _buf_, & _off_, (void *)(& irq), sizeof(unsigned int ));
  rqarg->function_id = 1347;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__synchronize_irq(struct req_args *rqarg , unsigned int irq ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("synchronize_irq", _buf_, & _off_, sizeof(unsigned int ), (void *)(& irq));
  return;
}
}
void synchronize_irq(unsigned int irq ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__synchronize_irq(& rqarg, irq);
  __odft_disp_error = disp_kern("synchronize_irq", & rqarg);

  DEMARSH_STUB__synchronize_irq(& rqarg, irq);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB____release_region(struct req_args *rqarg , struct resource *arg1 ,
                                           resource_size_t arg2 , resource_size_t arg3 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__release_region", & _buf_, & _off_, & arg1);
  fill_marshbuf("__release_region", & _buf_, & _off_, (void *)(& arg2), sizeof(unsigned long long ));
  fill_marshbuf("__release_region", & _buf_, & _off_, (void *)(& arg3), sizeof(unsigned long long ));
  rqarg->function_id = 1059;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____release_region(struct req_args *rqarg , struct resource *arg1 ,
                                           resource_size_t arg2 , resource_size_t arg3 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__release_region", _buf_, & _off_, (void **)(& arg1), sizeof(struct resource ),
                     sizeof(struct resource ));
  fetch_marshbuf("__release_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& arg2));
  fetch_marshbuf("__release_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& arg3));
  return;
}
}
void __release_region(struct resource *arg0 , resource_size_t arg1 , resource_size_t arg2 ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____release_region(& rqarg, arg0, arg1, arg2);
  __odft_disp_error = disp_kern("__release_region", & rqarg);

  DEMARSH_STUB____release_region(& rqarg, arg0, arg1, arg2);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_release_regions(struct req_args *rqarg , struct pci_dev *arg1 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_release_regions", & _buf_, & _off_, & arg1);
  rqarg->function_id = 1139;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__pci_release_regions(struct req_args *rqarg , struct pci_dev *arg1 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_release_regions", _buf_, & _off_, (void **)(& arg1), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  return;
}
}
void pci_release_regions(struct pci_dev *arg0 ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__pci_release_regions(& rqarg, arg0);
  __odft_disp_error = disp_kern("pci_release_regions", & rqarg);

  DEMARSH_STUB__pci_release_regions(& rqarg, arg0);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_lib_malloc_pages(struct req_args *rqarg , struct snd_pcm_substream *substream ,
                                                   size_t size ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_lib_malloc_pages", & _buf_, & _off_, & substream);
  fill_marshbuf("snd_pcm_lib_malloc_pages", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  rqarg->function_id = 1245;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_lib_malloc_pages(struct req_args *rqarg , struct snd_pcm_substream *substream ,
                                                  size_t size ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_lib_malloc_pages", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  fetch_marshbuf("snd_pcm_lib_malloc_pages", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& size));
  fetch_marshbuf("snd_pcm_lib_malloc_pages", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_lib_malloc_pages(struct snd_pcm_substream *substream , size_t size ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_lib_malloc_pages(& rqarg, substream, size);
  __odft_disp_error = disp_kern("snd_pcm_lib_malloc_pages", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_lib_malloc_pages(& rqarg, substream, size);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__gameport_unregister_port(struct req_args *rqarg , struct gameport *gameport ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("gameport_unregister_port", & _buf_, & _off_, & gameport);
  rqarg->function_id = 1096;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__gameport_unregister_port(struct req_args *rqarg , struct gameport *gameport ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("gameport_unregister_port", _buf_, & _off_, (void **)(& gameport),
                     sizeof(struct gameport ), sizeof(struct gameport ));
  return;
}
}
void gameport_unregister_port(struct gameport *gameport ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__gameport_unregister_port(& rqarg, gameport);
  __odft_disp_error = disp_kern("gameport_unregister_port", & rqarg);

  DEMARSH_STUB__gameport_unregister_port(& rqarg, gameport);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_ac97_bus(struct req_args *rqarg , struct snd_card *card ,
                                       int num , struct snd_ac97_bus_ops *ops , void *private_data ,
                                       struct snd_ac97_bus **rbus ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ac97_bus", & _buf_, & _off_, & card);
  fill_marshbuf("snd_ac97_bus", & _buf_, & _off_, (void *)(& num), sizeof(int ));
  fill_marshbuf_ptr("snd_ac97_bus", & _buf_, & _off_, & ops);
  fill_marshbuf_ptr("snd_ac97_bus", & _buf_, & _off_, & private_data);
  fill_marshbuf_ptr("snd_ac97_bus", & _buf_, & _off_, & rbus);
  if (rbus != 0U) {
    fill_marshbuf_ptr("snd_ac97_bus", & _buf_, & _off_, rbus);
  }
  rqarg->function_id = 1149;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_ac97_bus(struct req_args *rqarg , struct snd_card *card ,
                                      int num , struct snd_ac97_bus_ops *ops , void *private_data ,
                                      struct snd_ac97_bus **rbus ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ac97_bus", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_ac97_bus", _buf_, & _off_, sizeof(int ), (void *)(& num));
  fetch_marshbuf_ptr("snd_ac97_bus", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_ac97_bus_ops ),
                     sizeof(struct snd_ac97_bus_ops ));
  fetch_marshbuf_ptr("snd_ac97_bus", _buf_, & _off_, & private_data, sizeof(void ),
                     sizeof(void ));
  fetch_marshbuf_ptr("snd_ac97_bus", _buf_, & _off_, (void **)(& rbus), sizeof(struct snd_ac97_bus *),
                     sizeof(struct snd_ac97_bus *));
  if (rbus != 0U) {
    fetch_marshbuf_ptr("snd_ac97_bus", _buf_, & _off_, (void **)rbus, sizeof(struct snd_ac97_bus ),
                       sizeof(struct snd_ac97_bus ));
  }
  fetch_marshbuf("snd_ac97_bus", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_ac97_bus(struct snd_card *card , int num , struct snd_ac97_bus_ops *ops ,
                 void *private_data , struct snd_ac97_bus **rbus ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ac97_bus(& rqarg, card, num, ops, private_data, rbus);
  __odft_disp_error = disp_kern("snd_ac97_bus", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_ac97_bus(& rqarg, card, num, ops, private_data,
                                              rbus);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____wake_up(struct req_args *rqarg , wait_queue_head_t *q ,
                                    unsigned int mode , int nr , void *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & q);
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& mode), sizeof(unsigned int ));
  fill_marshbuf("__wake_up", & _buf_, & _off_, (void *)(& nr), sizeof(int ));
  fill_marshbuf_ptr("__wake_up", & _buf_, & _off_, & key);
  rqarg->function_id = 1063;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____wake_up(struct req_args *rqarg , wait_queue_head_t *q ,
                                    unsigned int mode , int nr , void *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, (void **)(& q), sizeof(wait_queue_head_t ),
                     sizeof(wait_queue_head_t ));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(unsigned int ), (void *)(& mode));
  fetch_marshbuf("__wake_up", _buf_, & _off_, sizeof(int ), (void *)(& nr));
  fetch_marshbuf_ptr("__wake_up", _buf_, & _off_, & key, sizeof(void ), sizeof(void ));
  return;
}
}
void __wake_up(wait_queue_head_t *q , unsigned int mode , int nr , void *key ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____wake_up(& rqarg, q, mode, nr, key);
  __odft_disp_error = disp_kern("__wake_up", & rqarg);

  DEMARSH_STUB____wake_up(& rqarg, q, mode, nr, key);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_request_regions(struct req_args *rqarg , struct pci_dev *arg1 ,
                                              char const   *arg2 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_request_regions", & _buf_, & _off_, & arg1);
  fill_marshbuf_ptr("pci_request_regions", & _buf_, & _off_, & arg2);
  if (arg2 != 0U) {
    fill_marshbuf("pci_request_regions", & _buf_, & _off_, (void *)arg2, sizeof(char const   ));
  }
  rqarg->function_id = 1140;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int __attribute__((__warn_unused_result__))  DEMARSH_STUB__pci_request_regions(struct req_args *rqarg ,
                                                                                      struct pci_dev *arg1 ,
                                                                                      char const   *arg2 ) 
{ 
  int __attribute__((__warn_unused_result__))  _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_request_regions", _buf_, & _off_, (void **)(& arg1), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf_ptr("pci_request_regions", _buf_, & _off_, (void **)(& arg2), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg2 != 0U) {
    fetch_marshbuf("pci_request_regions", _buf_, & _off_, sizeof(char const   ), (void *)arg2);
  }
  fetch_marshbuf("pci_request_regions", _buf_, & _off_, sizeof(int __attribute__((__warn_unused_result__))  ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
int __attribute__((__warn_unused_result__))  pci_request_regions(struct pci_dev *arg0 ,
                                                                 char const   *arg1 ) 
{ 
  struct req_args rqarg ;
  int __attribute__((__warn_unused_result__))  _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_request_regions(& rqarg, arg0, arg1);
  __odft_disp_error = disp_kern("pci_request_regions", & rqarg);

  _retval_ = (int __attribute__((__warn_unused_result__))  )DEMARSH_STUB__pci_request_regions(& rqarg,
                                                                                              arg0,
                                                                                              arg1);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__pci_choose_state(struct req_args *rqarg , struct pci_dev *dev ,
                                           pm_message_t state ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_choose_state", & _buf_, & _off_, & dev);
  rqarg->function_id = 1134;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static pci_power_t DEMARSH_STUB__pci_choose_state(struct req_args *rqarg , struct pci_dev *dev ,
                                                  pm_message_t state ) 
{ 
  pci_power_t _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_choose_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_choose_state", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
pci_power_t pci_choose_state(struct pci_dev *dev , pm_message_t state ) 
{ 
  struct req_args rqarg ;
  pci_power_t _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_choose_state(& rqarg, dev, state);
  __odft_disp_error = disp_kern("pci_choose_state", & rqarg);

  _retval_ = (pci_power_t )DEMARSH_STUB__pci_choose_state(& rqarg, dev, state);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_new(struct req_args *rqarg , struct snd_card *card ,
                                      char *id , int device , int playback_count ,
                                      int capture_count , struct snd_pcm **rpcm ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)id, sizeof(char ));
  }
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& playback_count), sizeof(int ));
  fill_marshbuf("snd_pcm_new", & _buf_, & _off_, (void *)(& capture_count), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, & rpcm);
  if (rpcm != 0U) {
    fill_marshbuf_ptr("snd_pcm_new", & _buf_, & _off_, rpcm);
  }
  rqarg->function_id = 1248;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_new(struct req_args *rqarg , struct snd_card *card ,
                                     char *id , int device , int playback_count ,
                                     int capture_count , struct snd_pcm **rpcm ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& id), sizeof(char ),
                     sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& playback_count));
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& capture_count));
  fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)(& rpcm), sizeof(struct snd_pcm *),
                     sizeof(struct snd_pcm *));
  if (rpcm != 0U) {
    fetch_marshbuf_ptr("snd_pcm_new", _buf_, & _off_, (void **)rpcm, sizeof(struct snd_pcm ),
                       sizeof(struct snd_pcm ));
  }
  fetch_marshbuf("snd_pcm_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_new(struct snd_card *card , char *id , int device , int playback_count ,
                int capture_count , struct snd_pcm **rpcm ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_new(& rqarg, card, id, device, playback_count, capture_count,
                            rpcm);
  __odft_disp_error = disp_kern("snd_pcm_new", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_new(& rqarg, card, id, device, playback_count,
                                             capture_count, rpcm);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_proc_new(struct req_args *rqarg , struct snd_card *card ,
                                            char const   *name , struct snd_info_entry **entryp ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("snd_card_proc_new", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, & entryp);
  if (entryp != 0U) {
    fill_marshbuf_ptr("snd_card_proc_new", & _buf_, & _off_, entryp);
  }
  rqarg->function_id = 1160;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_proc_new(struct req_args *rqarg , struct snd_card *card ,
                                           char const   *name , struct snd_info_entry **entryp ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)(& entryp), sizeof(struct snd_info_entry *),
                     sizeof(struct snd_info_entry *));
  if (entryp != 0U) {
    fetch_marshbuf_ptr("snd_card_proc_new", _buf_, & _off_, (void **)entryp, sizeof(struct snd_info_entry ),
                       sizeof(struct snd_info_entry ));
  }
  fetch_marshbuf("snd_card_proc_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_proc_new(struct snd_card *card , char const   *name , struct snd_info_entry **entryp ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_proc_new(& rqarg, card, name, entryp);
  __odft_disp_error = disp_kern("snd_card_proc_new", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_card_proc_new(& rqarg, card, name, entryp);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_lib_free_pages(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_lib_free_pages", & _buf_, & _off_, & substream);
  rqarg->function_id = 1243;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_lib_free_pages(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_lib_free_pages", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  fetch_marshbuf("snd_pcm_lib_free_pages", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_lib_free_pages(struct snd_pcm_substream *substream ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_lib_free_pages(& rqarg, substream);
  __odft_disp_error = disp_kern("snd_pcm_lib_free_pages", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_lib_free_pages(& rqarg, substream);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_lib_preallocate_pages_for_all(struct req_args *rqarg ,
                                                                struct snd_pcm *pcm ,
                                                                int type , void *data ,
                                                                size_t size , size_t max ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& type),
                sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, & data);
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& size),
                sizeof(unsigned long ));
  fill_marshbuf("snd_pcm_lib_preallocate_pages_for_all", & _buf_, & _off_, (void *)(& max),
                sizeof(unsigned long ));
  rqarg->function_id = 1247;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_lib_preallocate_pages_for_all(struct req_args *rqarg ,
                                                               struct snd_pcm *pcm ,
                                                               int type , void *data ,
                                                               size_t size , size_t max ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, (void **)(& pcm),
                     sizeof(struct snd_pcm ), sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(int ),
                 (void *)(& type));
  fetch_marshbuf_ptr("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, & data,
                     sizeof(void ), sizeof(void ));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& size));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(unsigned long ),
                 (void *)(& max));
  fetch_marshbuf("snd_pcm_lib_preallocate_pages_for_all", _buf_, & _off_, sizeof(int ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_lib_preallocate_pages_for_all(struct snd_pcm *pcm , int type , void *data ,
                                          size_t size , size_t max ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_lib_preallocate_pages_for_all(& rqarg, pcm, type, data, size,
                                                      max);
  __odft_disp_error = disp_kern("snd_pcm_lib_preallocate_pages_for_all", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_lib_preallocate_pages_for_all(& rqarg, pcm,
                                                                       type, data,
                                                                       size, max);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____gameport_register_port(struct req_args *rqarg , struct gameport *gameport ,
                                                   struct module *owner ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__gameport_register_port", & _buf_, & _off_, & gameport);
  fill_marshbuf_ptr("__gameport_register_port", & _buf_, & _off_, & owner);
  rqarg->function_id = 1041;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____gameport_register_port(struct req_args *rqarg , struct gameport *gameport ,
                                                   struct module *owner ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__gameport_register_port", _buf_, & _off_, (void **)(& gameport),
                     sizeof(struct gameport ), sizeof(struct gameport ));
  fetch_marshbuf_ptr("__gameport_register_port", _buf_, & _off_, (void **)(& owner),
                     sizeof(struct module ), sizeof(struct module ));
  return;
}
}
void __gameport_register_port(struct gameport *gameport , struct module *owner ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____gameport_register_port(& rqarg, gameport, owner);
  __odft_disp_error = disp_kern("__gameport_register_port", & rqarg);

  DEMARSH_STUB____gameport_register_port(& rqarg, gameport, owner);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__gameport_set_phys(struct req_args *rqarg , struct gameport *gameport ,
                                            char const   *fmt  , ...) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("gameport_set_phys", & _buf_, & _off_, & gameport);
  fill_marshbuf_ptr("gameport_set_phys", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("gameport_set_phys", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  rqarg->function_id = 1095;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__gameport_set_phys(struct req_args *rqarg , struct gameport *gameport ,
                                            char const   *fmt  , ...) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("gameport_set_phys", _buf_, & _off_, (void **)(& gameport), sizeof(struct gameport ),
                     sizeof(struct gameport ));
  fetch_marshbuf_ptr("gameport_set_phys", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("gameport_set_phys", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  return;
}
}
void gameport_set_phys(struct gameport *gameport , char const   *fmt  , ...) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__gameport_set_phys(& rqarg, gameport, fmt);
  __odft_disp_error = disp_kern("gameport_set_phys", & rqarg);

  DEMARSH_STUB__gameport_set_phys(& rqarg, gameport, fmt);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_suspend_all(struct req_args *rqarg , struct snd_pcm *pcm ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_suspend_all", & _buf_, & _off_, & pcm);
  rqarg->function_id = 1252;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_suspend_all(struct req_args *rqarg , struct snd_pcm *pcm ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_suspend_all", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ),
                     sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_suspend_all", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_suspend_all(struct snd_pcm *pcm ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_suspend_all(& rqarg, pcm);
  __odft_disp_error = disp_kern("snd_pcm_suspend_all", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_suspend_all(& rqarg, pcm);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__mutex_lock_nested(struct req_args *rqarg , struct mutex *lock ,
                                            unsigned int subclass ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mutex_lock_nested", & _buf_, & _off_, & lock);
  fill_marshbuf("mutex_lock_nested", & _buf_, & _off_, (void *)(& subclass), sizeof(unsigned int ));
  rqarg->function_id = 1119;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__mutex_lock_nested(struct req_args *rqarg , struct mutex *lock ,
                                            unsigned int subclass ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mutex_lock_nested", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  fetch_marshbuf("mutex_lock_nested", _buf_, & _off_, sizeof(unsigned int ), (void *)(& subclass));
  return;
}
}
void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__mutex_lock_nested(& rqarg, lock, subclass);
  __odft_disp_error = disp_kern("mutex_lock_nested", & rqarg);

  DEMARSH_STUB__mutex_lock_nested(& rqarg, lock, subclass);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_hw_constraint_ratdens(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                        unsigned int cond , snd_pcm_hw_param_t var ,
                                                        struct snd_pcm_hw_constraint_ratdens *r ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_ratdens", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_ratdens", & _buf_, & _off_, (void *)(& cond),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_ratdens", & _buf_, & _off_, (void *)(& var),
                sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_hw_constraint_ratdens", & _buf_, & _off_, & r);
  rqarg->function_id = 1240;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_hw_constraint_ratdens(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                       unsigned int cond , snd_pcm_hw_param_t var ,
                                                       struct snd_pcm_hw_constraint_ratdens *r ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_ratdens", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ), sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_ratdens", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& cond));
  fetch_marshbuf("snd_pcm_hw_constraint_ratdens", _buf_, & _off_, sizeof(int ), (void *)(& var));
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_ratdens", _buf_, & _off_, (void **)(& r),
                     sizeof(struct snd_pcm_hw_constraint_ratdens ), sizeof(struct snd_pcm_hw_constraint_ratdens ));
  fetch_marshbuf("snd_pcm_hw_constraint_ratdens", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_hw_constraint_ratdens(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                  snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_ratdens *r ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_hw_constraint_ratdens(& rqarg, runtime, cond, var, r);
  __odft_disp_error = disp_kern("snd_pcm_hw_constraint_ratdens", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_hw_constraint_ratdens(& rqarg, runtime, cond,
                                                               var, r);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_new1(struct req_args *rqarg , struct snd_kcontrol_new  const  *kcontrolnew ,
                                       void *private_data ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & kcontrolnew);
  fill_marshbuf_ptr("snd_ctl_new1", & _buf_, & _off_, & private_data);
  rqarg->function_id = 1164;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_kcontrol *DEMARSH_STUB__snd_ctl_new1(struct req_args *rqarg , struct snd_kcontrol_new  const  *kcontrolnew ,
                                                       void *private_data ) 
{ 
  struct snd_kcontrol *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, (void **)(& kcontrolnew), sizeof(struct snd_kcontrol_new  const  ),
                     sizeof(struct snd_kcontrol_new  const  ));
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, & private_data, sizeof(void ),
                     sizeof(void ));
  fetch_marshbuf_ptr("snd_ctl_new1", _buf_, & _off_, (void **)(& _retval_), sizeof(struct snd_kcontrol ),
                     sizeof(struct snd_kcontrol ));
  return (_retval_);
}
}
struct snd_kcontrol *snd_ctl_new1(struct snd_kcontrol_new  const  *kcontrolnew , void *private_data ) 
{ 
  struct req_args rqarg ;
  struct snd_kcontrol *_retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ctl_new1(& rqarg, kcontrolnew, private_data);
  __odft_disp_error = disp_kern("snd_ctl_new1", & rqarg);

  _retval_ = 0U;
  _retval_ = (struct snd_kcontrol *)DEMARSH_STUB__snd_ctl_new1(& rqarg, kcontrolnew,
                                                               private_data);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__pci_restore_state(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_restore_state", & _buf_, & _off_, & dev);
  rqarg->function_id = 1141;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__pci_restore_state(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_restore_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_restore_state", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int pci_restore_state(struct pci_dev *dev ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_restore_state(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_restore_state", & rqarg);

  _retval_ = (int )DEMARSH_STUB__pci_restore_state(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_receive(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                              unsigned char const   *buffer , int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_receive", & _buf_, & _off_, & substream);
  fill_marshbuf_ptr("snd_rawmidi_receive", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("snd_rawmidi_receive", & _buf_, & _off_, (void *)buffer, sizeof(unsigned char const   ));
  }
  fill_marshbuf("snd_rawmidi_receive", & _buf_, & _off_, (void *)(& count), sizeof(int ));
  rqarg->function_id = 1256;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_receive(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                             unsigned char const   *buffer , int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_receive", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ), sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf_ptr("snd_rawmidi_receive", _buf_, & _off_, (void **)(& buffer), sizeof(unsigned char const   ),
                     sizeof(unsigned char const   ));
  if (buffer != 0U) {
    fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(unsigned char const   ),
                   (void *)buffer);
  }
  fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_receive", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_receive(struct snd_rawmidi_substream *substream , unsigned char const   *buffer ,
                        int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_receive(& rqarg, substream, buffer, count);
  __odft_disp_error = disp_kern("snd_rawmidi_receive", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_receive(& rqarg, substream, buffer, count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____mutex_init(struct req_args *rqarg , struct mutex *lock ,
                                       char const   *name , struct lock_class_key *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & lock);
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__mutex_init", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("__mutex_init", & _buf_, & _off_, & key);
  rqarg->function_id = 1045;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB____mutex_init(struct req_args *rqarg , struct mutex *lock ,
                                       char const   *name , struct lock_class_key *key ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__mutex_init", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  fetch_marshbuf_ptr("__mutex_init", _buf_, & _off_, (void **)(& key), sizeof(struct lock_class_key ),
                     sizeof(struct lock_class_key ));
  return;
}
}
void __mutex_init(struct mutex *lock , char const   *name , struct lock_class_key *key ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB____mutex_init(& rqarg, lock, name, key);
  __odft_disp_error = disp_kern("__mutex_init", & rqarg);

  DEMARSH_STUB____mutex_init(& rqarg, lock, name, key);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_enable_device(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_enable_device", & _buf_, & _off_, & dev);
  rqarg->function_id = 1136;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int __attribute__((__warn_unused_result__))  DEMARSH_STUB__pci_enable_device(struct req_args *rqarg ,
                                                                                    struct pci_dev *dev ) 
{ 
  int __attribute__((__warn_unused_result__))  _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_enable_device", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_enable_device", _buf_, & _off_, sizeof(int __attribute__((__warn_unused_result__))  ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
int __attribute__((__warn_unused_result__))  pci_enable_device(struct pci_dev *dev ) 
{ 
  struct req_args rqarg ;
  int __attribute__((__warn_unused_result__))  _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_enable_device(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_enable_device", & rqarg);

  _retval_ = (int __attribute__((__warn_unused_result__))  )DEMARSH_STUB__pci_enable_device(& rqarg,
                                                                                            dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_rawmidi_new(struct req_args *rqarg , struct snd_card *card ,
                                          char *id , int device , int output_count ,
                                          int input_count , struct snd_rawmidi **rmidi ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & id);
  if (id != 0U) {
    fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)id, sizeof(char ));
  }
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& device), sizeof(int ));
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& output_count), sizeof(int ));
  fill_marshbuf("snd_rawmidi_new", & _buf_, & _off_, (void *)(& input_count), sizeof(int ));
  fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, & rmidi);
  if (rmidi != 0U) {
    fill_marshbuf_ptr("snd_rawmidi_new", & _buf_, & _off_, rmidi);
  }
  rqarg->function_id = 1255;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_new(struct req_args *rqarg , struct snd_card *card ,
                                         char *id , int device , int output_count ,
                                         int input_count , struct snd_rawmidi **rmidi ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& id), sizeof(char ),
                     sizeof(char ));
  if (id != 0U) {
    fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(char ), (void *)id);
  }
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& device));
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& output_count));
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& input_count));
  fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)(& rmidi), sizeof(struct snd_rawmidi *),
                     sizeof(struct snd_rawmidi *));
  if (rmidi != 0U) {
    fetch_marshbuf_ptr("snd_rawmidi_new", _buf_, & _off_, (void **)rmidi, sizeof(struct snd_rawmidi ),
                       sizeof(struct snd_rawmidi ));
  }
  fetch_marshbuf("snd_rawmidi_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_new(struct snd_card *card , char *id , int device , int output_count ,
                    int input_count , struct snd_rawmidi **rmidi ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_new(& rqarg, card, id, device, output_count, input_count,
                                rmidi);
  __odft_disp_error = disp_kern("snd_rawmidi_new", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_new(& rqarg, card, id, device, output_count,
                                                 input_count, rmidi);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pci_quirk_lookup(struct req_args *rqarg , struct pci_dev *pci ,
                                               struct snd_pci_quirk  const  *list ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pci_quirk_lookup", & _buf_, & _off_, & pci);
  fill_marshbuf_ptr("snd_pci_quirk_lookup", & _buf_, & _off_, & list);
  rqarg->function_id = 1238;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct snd_pci_quirk  const  *DEMARSH_STUB__snd_pci_quirk_lookup(struct req_args *rqarg ,
                                                                        struct pci_dev *pci ,
                                                                        struct snd_pci_quirk  const  *list ) 
{ 
  struct snd_pci_quirk  const  *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pci_quirk_lookup", _buf_, & _off_, (void **)(& pci), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf_ptr("snd_pci_quirk_lookup", _buf_, & _off_, (void **)(& list), sizeof(struct snd_pci_quirk  const  ),
                     sizeof(struct snd_pci_quirk  const  ));
  fetch_marshbuf_ptr("snd_pci_quirk_lookup", _buf_, & _off_, (void **)(& _retval_),
                     sizeof(struct snd_pci_quirk  const  ), sizeof(struct snd_pci_quirk  const  ));
  return (_retval_);
}
}
struct snd_pci_quirk  const  *snd_pci_quirk_lookup(struct pci_dev *pci , struct snd_pci_quirk  const  *list ) 
{ 
  struct req_args rqarg ;
  struct snd_pci_quirk  const  *_retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pci_quirk_lookup(& rqarg, pci, list);
  __odft_disp_error = disp_kern("snd_pci_quirk_lookup", & rqarg);

  _retval_ = 0U;
  _retval_ = (struct snd_pci_quirk  const  *)DEMARSH_STUB__snd_pci_quirk_lookup(& rqarg,
                                                                                pci,
                                                                                list);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__free_irq(struct req_args *rqarg , unsigned int arg1 , void *arg2 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("free_irq", & _buf_, & _off_, (void *)(& arg1), sizeof(unsigned int ));
  fill_marshbuf_ptr("free_irq", & _buf_, & _off_, & arg2);
  rqarg->function_id = 1091;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__free_irq(struct req_args *rqarg , unsigned int arg1 , void *arg2 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("free_irq", _buf_, & _off_, sizeof(unsigned int ), (void *)(& arg1));
  fetch_marshbuf_ptr("free_irq", _buf_, & _off_, & arg2, sizeof(void ), sizeof(void ));
  return;
}
}
void free_irq(unsigned int arg0 , void *arg1 ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__free_irq(& rqarg, arg0, arg1);
  __odft_disp_error = disp_kern("free_irq", & rqarg);

  DEMARSH_STUB__free_irq(& rqarg, arg0, arg1);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_disable_device(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_disable_device", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    fill_marshbuf("pci_disable_device", & _buf_, & _off_, (void *)(& dev->devfn),
                  sizeof(unsigned int ));
    fill_marshbuf_ptr("pci_disable_device", & _buf_, & _off_, & dev->bus);
  }
  rqarg->function_id = 1135;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__pci_disable_device(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_disable_device", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (dev != 0U) {
    fetch_marshbuf("pci_disable_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& dev->devfn));
    fetch_marshbuf_ptr("pci_disable_device", _buf_, & _off_, (void **)(& dev->bus),
                       sizeof(struct pci_bus ), sizeof(struct pci_bus ));
  }
  return;
}
}
void pci_disable_device(struct pci_dev *dev ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__pci_disable_device(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_disable_device", & rqarg);

  DEMARSH_STUB__pci_disable_device(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__mutex_unlock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mutex_unlock", & _buf_, & _off_, & lock);
  rqarg->function_id = 1121;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__mutex_unlock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mutex_unlock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  return;
}
}
void mutex_unlock(struct mutex *lock ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__mutex_unlock(& rqarg, lock);
  __odft_disp_error = disp_kern("mutex_unlock", & rqarg);

  DEMARSH_STUB__mutex_unlock(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_set_master(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;
  struct device *STRUCTADDRXdevdev ;
  int idx_arr26 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_set_master", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    STRUCTADDRXdevdev = & dev->dev;
    idx_arr26 = 0;
    while (idx_arr26 < 20) {
      fill_marshbuf("pci_set_master", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdev->bus_id[idx_arr26]),
                    sizeof(char ));
      idx_arr26 ++;
    }
    fill_marshbuf("pci_set_master", & _buf_, & _off_, (void *)(& dev->devfn), sizeof(unsigned int ));
    fill_marshbuf_ptr("pci_set_master", & _buf_, & _off_, & dev->bus);
  }
  rqarg->function_id = 1144;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__pci_set_master(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct device *STRUCTADDRXdevdev ;
  int idx_arr28 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_set_master", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  if (dev != 0U) {
    tmp_fld6 = & dev->dev;
    tmp_lv5 = dev;
    nooks_ot_storeoffset_user(dev, tmp_fld6 - tmp_lv5, sizeof(struct device ));
    STRUCTADDRXdevdev = & dev->dev;
    idx_arr28 = 0;
    while (idx_arr28 < 20) {
      fetch_marshbuf("pci_set_master", _buf_, & _off_, sizeof(char ), (void *)(& STRUCTADDRXdevdev->bus_id[idx_arr28]));
      idx_arr28 ++;
    }
    fetch_marshbuf("pci_set_master", _buf_, & _off_, sizeof(unsigned int ), (void *)(& dev->devfn));
    fetch_marshbuf_ptr("pci_set_master", _buf_, & _off_, (void **)(& dev->bus), sizeof(struct pci_bus ),
                       sizeof(struct pci_bus ));
  }
  return;
}
}
void pci_set_master(struct pci_dev *dev ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__pci_set_master(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_set_master", & rqarg);

  DEMARSH_STUB__pci_set_master(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB___cond_resched(struct req_args *rqarg ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  rqarg->function_id = 1064;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB___cond_resched(struct req_args *rqarg ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("_cond_resched", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int _cond_resched(void) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB___cond_resched(& rqarg);
  __odft_disp_error = disp_kern("_cond_resched", & rqarg);

  _retval_ = (int )DEMARSH_STUB___cond_resched(& rqarg);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ctl_add(struct req_args *rqarg , struct snd_card *card ,
                                      struct snd_kcontrol *kcontrol ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & card);
  fill_marshbuf_ptr("snd_ctl_add", & _buf_, & _off_, & kcontrol);
  rqarg->function_id = 1162;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_ctl_add(struct req_args *rqarg , struct snd_card *card ,
                                     struct snd_kcontrol *kcontrol ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf_ptr("snd_ctl_add", _buf_, & _off_, (void **)(& kcontrol), sizeof(struct snd_kcontrol ),
                     sizeof(struct snd_kcontrol ));
  fetch_marshbuf("snd_ctl_add", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_ctl_add(struct snd_card *card , struct snd_kcontrol *kcontrol ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ctl_add(& rqarg, card, kcontrol);
  __odft_disp_error = disp_kern("snd_ctl_add", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_ctl_add(& rqarg, card, kcontrol);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__request_irq(struct req_args *rqarg , unsigned int arg1 ,
                                      irqreturn_t (*handler)(int  , void * ) , unsigned long arg3 ,
                                      char const   *arg4 , void *arg5 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("request_irq", & _buf_, & _off_, (void *)(& arg1), sizeof(unsigned int ));
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & handler);
  fill_marshbuf("request_irq", & _buf_, & _off_, (void *)(& arg3), sizeof(unsigned long ));
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & arg4);
  if (arg4 != 0U) {
    fill_marshbuf("request_irq", & _buf_, & _off_, (void *)arg4, sizeof(char const   ));
  }
  fill_marshbuf_ptr("request_irq", & _buf_, & _off_, & arg5);
  rqarg->function_id = 1148;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int __attribute__((__warn_unused_result__))  DEMARSH_STUB__request_irq(struct req_args *rqarg ,
                                                                              unsigned int arg1 ,
                                                                              irqreturn_t (*handler)(int  ,
                                                                                                     void * ) ,
                                                                              unsigned long arg3 ,
                                                                              char const   *arg4 ,
                                                                              void *arg5 ) 
{ 
  int __attribute__((__warn_unused_result__))  _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(unsigned int ), (void *)(& arg1));
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, (void **)(& handler), sizeof(irqreturn_t (int  ,
                                                                                              void * )),
                     sizeof(irqreturn_t (int  , void * )));
  fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg3));
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, (void **)(& arg4), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg4 != 0U) {
    fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(char const   ), (void *)arg4);
  }
  fetch_marshbuf_ptr("request_irq", _buf_, & _off_, & arg5, sizeof(void ), sizeof(void ));
  fetch_marshbuf("request_irq", _buf_, & _off_, sizeof(int __attribute__((__warn_unused_result__))  ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
int __attribute__((__warn_unused_result__))  request_irq(unsigned int arg0 , irqreturn_t (*handler)(int  ,
                                                                                                    void * ) ,
                                                         unsigned long arg2 , char const   *arg3 ,
                                                         void *arg4 ) 
{ 
  struct req_args rqarg ;
  int __attribute__((__warn_unused_result__))  _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__request_irq(& rqarg, arg0, handler, arg2, arg3, arg4);
  __odft_disp_error = disp_kern("request_irq", & rqarg);

  _retval_ = (int __attribute__((__warn_unused_result__))  )DEMARSH_STUB__request_irq(& rqarg,
                                                                                      arg0,
                                                                                      handler,
                                                                                      arg2,
                                                                                      arg3,
                                                                                      arg4);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB____pci_register_driver(struct req_args *rqarg , struct pci_driver *arg1 ,
                                                struct module *arg2 , char const   *mod_name ) 
{ 
  void *_buf_ ;
  int _off_ ;
  struct device_driver *STRUCTADDRXdriver ;
  int strlen10 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg1);
  if (arg1 != 0U) {
    STRUCTADDRXdriver = & arg1->driver;
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXdriver->name);
    if (STRUCTADDRXdriver->name != 0U) {
      strlen10 = (int )strlen((void *)STRUCTADDRXdriver->name);
      strlen10 ++;
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, & strlen10, sizeof(int ));
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)STRUCTADDRXdriver->name,
                    strlen10 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXdriver->bus);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & STRUCTADDRXdriver->owner);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg1->probe);
    fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg1->name);
    if (arg1->name != 0U) {
      fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)arg1->name,
                    sizeof(char ));
    }
  }
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & arg2);
  fill_marshbuf_ptr("__pci_register_driver", & _buf_, & _off_, & mod_name);
  if (mod_name != 0U) {
    fill_marshbuf("__pci_register_driver", & _buf_, & _off_, (void *)mod_name, sizeof(char const   ));
  }
  rqarg->function_id = 1058;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int __attribute__((__warn_unused_result__))  DEMARSH_STUB____pci_register_driver(struct req_args *rqarg ,
                                                                                        struct pci_driver *arg1 ,
                                                                                        struct module *arg2 ,
                                                                                        char const   *mod_name ) 
{ 
  int __attribute__((__warn_unused_result__))  _retval_ ;
  void *_buf_ ;
  int _off_ ;
  void *tmp_lv8 ;
  void *tmp_fld9 ;
  struct device_driver *STRUCTADDRXdriver ;
  int strlen13 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg1), sizeof(struct pci_driver ),
                     sizeof(struct pci_driver ));
  if (arg1 != 0U) {
    tmp_fld9 = & arg1->dynids.list;
    tmp_lv8 = & arg1->dynids;
    nooks_ot_storeoffset_user(& arg1->dynids, tmp_fld9 - tmp_lv8, sizeof(struct list_head ));
    tmp_fld9 = & arg1->dynids.lock;
    tmp_lv8 = & arg1->dynids;
    nooks_ot_storeoffset_user(& arg1->dynids, tmp_fld9 - tmp_lv8, sizeof(spinlock_t ));
    tmp_fld9 = & arg1->driver;
    tmp_lv8 = arg1;
    nooks_ot_storeoffset_user(arg1, tmp_fld9 - tmp_lv8, sizeof(struct device_driver ));
    STRUCTADDRXdriver = & arg1->driver;
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXdriver->name),
                       sizeof(char const   ), sizeof(char const   ));
    if (STRUCTADDRXdriver->name != 0U) {
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(int ), & strlen13);
      nooks_ot_alloc_arraymem_user((void *)(& STRUCTADDRXdriver->name), strlen13,
                                   sizeof(char const   ), 0);
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, strlen13 * sizeof(char const   ),
                     (void *)STRUCTADDRXdriver->name);
    }
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXdriver->bus),
                       sizeof(struct bus_type ), sizeof(struct bus_type ));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& STRUCTADDRXdriver->owner),
                       sizeof(struct module ), sizeof(struct module ));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg1->probe),
                       sizeof(int (struct pci_dev *dev , struct pci_device_id  const  *id )),
                       sizeof(int (struct pci_dev *dev , struct pci_device_id  const  *id )));
    fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg1->name),
                       sizeof(char ), sizeof(char ));
    if (arg1->name != 0U) {
      fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(char ), (void *)arg1->name);
    }
  }
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& arg2), sizeof(struct module ),
                     sizeof(struct module ));
  fetch_marshbuf_ptr("__pci_register_driver", _buf_, & _off_, (void **)(& mod_name),
                     sizeof(char const   ), sizeof(char const   ));
  if (mod_name != 0U) {
    fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(char const   ),
                   (void *)mod_name);
  }
  fetch_marshbuf("__pci_register_driver", _buf_, & _off_, sizeof(int __attribute__((__warn_unused_result__))  ),
                 (void *)(& _retval_));
  return (_retval_);
}
}
int __attribute__((__warn_unused_result__))  __pci_register_driver(struct pci_driver *arg0 ,
                                                                   struct module *arg1 ,
                                                                   char const   *mod_name ) 
{ 
  struct req_args rqarg ;
  int __attribute__((__warn_unused_result__))  _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB____pci_register_driver(& rqarg, arg0, arg1, mod_name);
  __odft_disp_error = disp_kern("__pci_register_driver", & rqarg);

  _retval_ = (int __attribute__((__warn_unused_result__))  )DEMARSH_STUB____pci_register_driver(& rqarg,
                                                                                                arg0,
                                                                                                arg1,
                                                                                                mod_name);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ac97_mixer(struct req_args *rqarg , struct snd_ac97_bus *bus ,
                                         struct snd_ac97_template *template , struct snd_ac97 **rac97 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ac97_mixer", & _buf_, & _off_, & bus);
  fill_marshbuf_ptr("snd_ac97_mixer", & _buf_, & _off_, & template);
  fill_marshbuf_ptr("snd_ac97_mixer", & _buf_, & _off_, & rac97);
  if (rac97 != 0U) {
    fill_marshbuf_ptr("snd_ac97_mixer", & _buf_, & _off_, rac97);
  }
  rqarg->function_id = 1150;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_ac97_mixer(struct req_args *rqarg , struct snd_ac97_bus *bus ,
                                        struct snd_ac97_template *template , struct snd_ac97 **rac97 ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ac97_mixer", _buf_, & _off_, (void **)(& bus), sizeof(struct snd_ac97_bus ),
                     sizeof(struct snd_ac97_bus ));
  fetch_marshbuf_ptr("snd_ac97_mixer", _buf_, & _off_, (void **)(& template), sizeof(struct snd_ac97_template ),
                     sizeof(struct snd_ac97_template ));
  fetch_marshbuf_ptr("snd_ac97_mixer", _buf_, & _off_, (void **)(& rac97), sizeof(struct snd_ac97 *),
                     sizeof(struct snd_ac97 *));
  if (rac97 != 0U) {
    fetch_marshbuf_ptr("snd_ac97_mixer", _buf_, & _off_, (void **)rac97, sizeof(struct snd_ac97 ),
                       sizeof(struct snd_ac97 ));
  }
  fetch_marshbuf("snd_ac97_mixer", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_ac97_mixer(struct snd_ac97_bus *bus , struct snd_ac97_template *template ,
                   struct snd_ac97 **rac97 ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_ac97_mixer(& rqarg, bus, template, rac97);
  __odft_disp_error = disp_kern("snd_ac97_mixer", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_ac97_mixer(& rqarg, bus, template, rac97);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ac97_resume(struct req_args *rqarg , struct snd_ac97 *ac97 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ac97_resume", & _buf_, & _off_, & ac97);
  rqarg->function_id = 1151;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_ac97_resume(struct req_args *rqarg , struct snd_ac97 *ac97 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ac97_resume", _buf_, & _off_, (void **)(& ac97), sizeof(struct snd_ac97 ),
                     sizeof(struct snd_ac97 ));
  return;
}
}
void snd_ac97_resume(struct snd_ac97 *ac97 ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_ac97_resume(& rqarg, ac97);
  __odft_disp_error = disp_kern("snd_ac97_resume", & rqarg);

  DEMARSH_STUB__snd_ac97_resume(& rqarg, ac97);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__pci_save_state(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("pci_save_state", & _buf_, & _off_, & dev);
  rqarg->function_id = 1142;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__pci_save_state(struct req_args *rqarg , struct pci_dev *dev ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("pci_save_state", _buf_, & _off_, (void **)(& dev), sizeof(struct pci_dev ),
                     sizeof(struct pci_dev ));
  fetch_marshbuf("pci_save_state", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int pci_save_state(struct pci_dev *dev ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__pci_save_state(& rqarg, dev);
  __odft_disp_error = disp_kern("pci_save_state", & rqarg);

  _retval_ = (int )DEMARSH_STUB__pci_save_state(& rqarg, dev);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_free(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_free", & _buf_, & _off_, & card);
  rqarg->function_id = 1158;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_free(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_free", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_free", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_free(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_free(& rqarg, card);
  __odft_disp_error = disp_kern("snd_card_free", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_card_free(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_format_width(struct req_args *rqarg , snd_pcm_format_t format ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf("snd_pcm_format_width", & _buf_, & _off_, (void *)(& format), sizeof(int ));
  rqarg->function_id = 1239;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_format_width(struct req_args *rqarg , snd_pcm_format_t format ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf("snd_pcm_format_width", _buf_, & _off_, sizeof(int ), (void *)(& format));
  fetch_marshbuf("snd_pcm_format_width", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_format_width(snd_pcm_format_t format ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_format_width(& rqarg, format);
  __odft_disp_error = disp_kern("snd_pcm_format_width", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_format_width(& rqarg, format);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_period_elapsed(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_period_elapsed", & _buf_, & _off_, & substream);
  rqarg->function_id = 1249;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_pcm_period_elapsed(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_period_elapsed", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  return;
}
}
void snd_pcm_period_elapsed(struct snd_pcm_substream *substream ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_pcm_period_elapsed(& rqarg, substream);
  __odft_disp_error = disp_kern("snd_pcm_period_elapsed", & rqarg);

  DEMARSH_STUB__snd_pcm_period_elapsed(& rqarg, substream);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB____request_region(struct req_args *rqarg , struct resource *arg1 ,
                                           resource_size_t start , resource_size_t n ,
                                           char const   *name , int flags ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("__request_region", & _buf_, & _off_, & arg1);
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& start), sizeof(unsigned long long ));
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& n), sizeof(unsigned long long ));
  fill_marshbuf_ptr("__request_region", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__request_region", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf("__request_region", & _buf_, & _off_, (void *)(& flags), sizeof(int ));
  rqarg->function_id = 1060;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static struct resource *DEMARSH_STUB____request_region(struct req_args *rqarg , struct resource *arg1 ,
                                                       resource_size_t start , resource_size_t n ,
                                                       char const   *name , int flags ) 
{ 
  struct resource *_retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("__request_region", _buf_, & _off_, (void **)(& arg1), sizeof(struct resource ),
                     sizeof(struct resource ));
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& start));
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(unsigned long long ),
                 (void *)(& n));
  fetch_marshbuf_ptr("__request_region", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  fetch_marshbuf("__request_region", _buf_, & _off_, sizeof(int ), (void *)(& flags));
  fetch_marshbuf_ptr("__request_region", _buf_, & _off_, (void **)(& _retval_), sizeof(struct resource ),
                     sizeof(struct resource ));
  return (_retval_);
}
}
struct resource *__request_region(struct resource *arg0 , resource_size_t start ,
                                  resource_size_t n , char const   *name , int flags ) 
{ 
  struct req_args rqarg ;
  struct resource *_retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB____request_region(& rqarg, arg0, start, n, name, flags);
  __odft_disp_error = disp_kern("__request_region", & rqarg);

  _retval_ = 0U;
  _retval_ = (struct resource *)DEMARSH_STUB____request_region(& rqarg, arg0, start,
                                                               n, name, flags);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__mutex_trylock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("mutex_trylock", & _buf_, & _off_, & lock);
  rqarg->function_id = 1120;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__mutex_trylock(struct req_args *rqarg , struct mutex *lock ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("mutex_trylock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  fetch_marshbuf("mutex_trylock", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int mutex_trylock(struct mutex *lock ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__mutex_trylock(& rqarg, lock);
  __odft_disp_error = disp_kern("mutex_trylock", & rqarg);

  _retval_ = (int )DEMARSH_STUB__mutex_trylock(& rqarg, lock);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_set_ops(struct req_args *rqarg , struct snd_pcm *pcm ,
                                          int direction , struct snd_pcm_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & pcm);
  fill_marshbuf("snd_pcm_set_ops", & _buf_, & _off_, (void *)(& direction), sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_set_ops", & _buf_, & _off_, & ops);
  rqarg->function_id = 1250;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_pcm_set_ops(struct req_args *rqarg , struct snd_pcm *pcm ,
                                          int direction , struct snd_pcm_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& pcm), sizeof(struct snd_pcm ),
                     sizeof(struct snd_pcm ));
  fetch_marshbuf("snd_pcm_set_ops", _buf_, & _off_, sizeof(int ), (void *)(& direction));
  fetch_marshbuf_ptr("snd_pcm_set_ops", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_pcm_ops ),
                     sizeof(struct snd_pcm_ops ));
  return;
}
}
void snd_pcm_set_ops(struct snd_pcm *pcm , int direction , struct snd_pcm_ops *ops ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_pcm_set_ops(& rqarg, pcm, direction, ops);
  __odft_disp_error = disp_kern("snd_pcm_set_ops", & rqarg);

  DEMARSH_STUB__snd_pcm_set_ops(& rqarg, pcm, direction, ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_card_disconnect(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_disconnect", & _buf_, & _off_, & card);
  rqarg->function_id = 1157;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_disconnect(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_disconnect", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_disconnect", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_disconnect(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_disconnect(& rqarg, card);
  __odft_disp_error = disp_kern("snd_card_disconnect", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_card_disconnect(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_device_new(struct req_args *rqarg , struct snd_card *card ,
                                         snd_device_type_t type , void *device_data ,
                                         struct snd_device_ops *ops ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & card);
  fill_marshbuf("snd_device_new", & _buf_, & _off_, (void *)(& type), sizeof(int ));
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & device_data);
  fill_marshbuf_ptr("snd_device_new", & _buf_, & _off_, & ops);
  rqarg->function_id = 1165;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_device_new(struct req_args *rqarg , struct snd_card *card ,
                                        snd_device_type_t type , void *device_data ,
                                        struct snd_device_ops *ops ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_device_new", _buf_, & _off_, sizeof(int ), (void *)(& type));
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, & device_data, sizeof(void ),
                     sizeof(void ));
  fetch_marshbuf_ptr("snd_device_new", _buf_, & _off_, (void **)(& ops), sizeof(struct snd_device_ops ),
                     sizeof(struct snd_device_ops ));
  fetch_marshbuf("snd_device_new", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_device_new(struct snd_card *card , snd_device_type_t type , void *device_data ,
                   struct snd_device_ops *ops ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_device_new(& rqarg, card, type, device_data, ops);
  __odft_disp_error = disp_kern("snd_device_new", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_device_new(& rqarg, card, type, device_data,
                                                ops);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_ac97_suspend(struct req_args *rqarg , struct snd_ac97 *ac97 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_ac97_suspend", & _buf_, & _off_, & ac97);
  rqarg->function_id = 1152;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_ac97_suspend(struct req_args *rqarg , struct snd_ac97 *ac97 ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_ac97_suspend", _buf_, & _off_, (void **)(& ac97), sizeof(struct snd_ac97 ),
                     sizeof(struct snd_ac97 ));
  return;
}
}
void snd_ac97_suspend(struct snd_ac97 *ac97 ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_ac97_suspend(& rqarg, ac97);
  __odft_disp_error = disp_kern("snd_ac97_suspend", & rqarg);

  DEMARSH_STUB__snd_ac97_suspend(& rqarg, ac97);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_rawmidi_transmit(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                               unsigned char *buffer , int count ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_rawmidi_transmit", & _buf_, & _off_, & substream);
  fill_marshbuf_ptr("snd_rawmidi_transmit", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("snd_rawmidi_transmit", & _buf_, & _off_, (void *)buffer, sizeof(unsigned char ));
  }
  fill_marshbuf("snd_rawmidi_transmit", & _buf_, & _off_, (void *)(& count), sizeof(int ));
  rqarg->function_id = 1258;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_rawmidi_transmit(struct req_args *rqarg , struct snd_rawmidi_substream *substream ,
                                              unsigned char *buffer , int count ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_rawmidi_transmit", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ), sizeof(struct snd_rawmidi_substream ));
  fetch_marshbuf_ptr("snd_rawmidi_transmit", _buf_, & _off_, (void **)(& buffer),
                     sizeof(unsigned char ), sizeof(unsigned char ));
  if (buffer != 0U) {
    fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)buffer);
  }
  fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(int ), (void *)(& count));
  fetch_marshbuf("snd_rawmidi_transmit", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream , unsigned char *buffer ,
                         int count ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_rawmidi_transmit(& rqarg, substream, buffer, count);
  __odft_disp_error = disp_kern("snd_rawmidi_transmit", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_rawmidi_transmit(& rqarg, substream, buffer,
                                                      count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_pcm_set_sync(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_set_sync", & _buf_, & _off_, & substream);
  rqarg->function_id = 1251;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__snd_pcm_set_sync(struct req_args *rqarg , struct snd_pcm_substream *substream ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_set_sync", _buf_, & _off_, (void **)(& substream), sizeof(struct snd_pcm_substream ),
                     sizeof(struct snd_pcm_substream ));
  return;
}
}
void snd_pcm_set_sync(struct snd_pcm_substream *substream ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  MARSH___STUB__snd_pcm_set_sync(& rqarg, substream);
  __odft_disp_error = disp_kern("snd_pcm_set_sync", & rqarg);

  DEMARSH_STUB__snd_pcm_set_sync(& rqarg, substream);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return;
}
}
static void MARSH___STUB__snd_pcm_hw_constraint_ratnums(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                        unsigned int cond , snd_pcm_hw_param_t var ,
                                                        struct snd_pcm_hw_constraint_ratnums *r ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_pcm_hw_constraint_ratnums", & _buf_, & _off_, & runtime);
  fill_marshbuf("snd_pcm_hw_constraint_ratnums", & _buf_, & _off_, (void *)(& cond),
                sizeof(unsigned int ));
  fill_marshbuf("snd_pcm_hw_constraint_ratnums", & _buf_, & _off_, (void *)(& var),
                sizeof(int ));
  fill_marshbuf_ptr("snd_pcm_hw_constraint_ratnums", & _buf_, & _off_, & r);
  rqarg->function_id = 1241;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_pcm_hw_constraint_ratnums(struct req_args *rqarg , struct snd_pcm_runtime *runtime ,
                                                       unsigned int cond , snd_pcm_hw_param_t var ,
                                                       struct snd_pcm_hw_constraint_ratnums *r ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_ratnums", _buf_, & _off_, (void **)(& runtime),
                     sizeof(struct snd_pcm_runtime ), sizeof(struct snd_pcm_runtime ));
  fetch_marshbuf("snd_pcm_hw_constraint_ratnums", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& cond));
  fetch_marshbuf("snd_pcm_hw_constraint_ratnums", _buf_, & _off_, sizeof(int ), (void *)(& var));
  fetch_marshbuf_ptr("snd_pcm_hw_constraint_ratnums", _buf_, & _off_, (void **)(& r),
                     sizeof(struct snd_pcm_hw_constraint_ratnums ), sizeof(struct snd_pcm_hw_constraint_ratnums ));
  fetch_marshbuf("snd_pcm_hw_constraint_ratnums", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_pcm_hw_constraint_ratnums(struct snd_pcm_runtime *runtime , unsigned int cond ,
                                  snd_pcm_hw_param_t var , struct snd_pcm_hw_constraint_ratnums *r ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_pcm_hw_constraint_ratnums(& rqarg, runtime, cond, var, r);
  __odft_disp_error = disp_kern("snd_pcm_hw_constraint_ratnums", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_pcm_hw_constraint_ratnums(& rqarg, runtime, cond,
                                                               var, r);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
static void MARSH___STUB__snd_card_register(struct req_args *rqarg , struct snd_card *card ) 
{ 
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("snd_card_register", & _buf_, & _off_, & card);
  rqarg->function_id = 1161;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__snd_card_register(struct req_args *rqarg , struct snd_card *card ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("snd_card_register", _buf_, & _off_, (void **)(& card), sizeof(struct snd_card ),
                     sizeof(struct snd_card ));
  fetch_marshbuf("snd_card_register", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int snd_card_register(struct snd_card *card ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  MARSH___STUB__snd_card_register(& rqarg, card);
  __odft_disp_error = disp_kern("snd_card_register", & rqarg);

  _retval_ = (int )DEMARSH_STUB__snd_card_register(& rqarg, card);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  return (_retval_);
}
}
void __MARSH_WRAP__snd_ensoniq_playback1_close(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_pcm_substream *substream ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXsubstreamprivate_data ;
  struct snd_pcm_substream **STRUCTADDRXSTRUCTADDRXsubstreamprivate_dataplayback1_substream ;
  int _retval_ ;

  {
  _off_ = 0;
  substream = 0U;
  fetch_marshbuf_ptr("snd_ensoniq_playback1_close", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
  if (substream != 0U) {
    tmp_fld6 = & substream->private_data;
    tmp_lv5 = substream;
    nooks_ot_storeoffset_user(substream, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXsubstreamprivate_data = & substream->private_data;
    fetch_marshbuf_ptr("snd_ensoniq_playback1_close", _buf_, & _off_, (void **)STRUCTADDRXsubstreamprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXsubstreamprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXsubstreamprivate_data)->mode;
      tmp_lv5 = *STRUCTADDRXsubstreamprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXsubstreamprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_ensoniq_playback1_close", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXsubstreamprivate_data)->mode));
      tmp_fld6 = & (*STRUCTADDRXsubstreamprivate_data)->playback1_substream;
      tmp_lv5 = *STRUCTADDRXsubstreamprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXsubstreamprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(struct snd_pcm_substream *));
      STRUCTADDRXSTRUCTADDRXsubstreamprivate_dataplayback1_substream = & (*STRUCTADDRXsubstreamprivate_data)->playback1_substream;
      fetch_marshbuf_ptr("snd_ensoniq_playback1_close", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXsubstreamprivate_dataplayback1_substream,
                         sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ensoniq_playback1_close(substream);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ensoniq_playback1_close", & _buf_, & _off_, & substream);
  if (substream != 0U) {
    STRUCTADDRXsubstreamprivate_data = & substream->private_data;
    fill_marshbuf_ptr("snd_ensoniq_playback1_close", & _buf_, & _off_, STRUCTADDRXsubstreamprivate_data);
    if (*STRUCTADDRXsubstreamprivate_data != 0U) {
      fill_marshbuf("snd_ensoniq_playback1_close", & _buf_, & _off_, (void *)(& (*STRUCTADDRXsubstreamprivate_data)->mode),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXsubstreamprivate_dataplayback1_substream = & (*STRUCTADDRXsubstreamprivate_data)->playback1_substream;
      fill_marshbuf_ptr("snd_ensoniq_playback1_close", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXsubstreamprivate_dataplayback1_substream);
    }
  }
  fill_marshbuf("snd_ensoniq_playback1_close", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ens1373_spdif_info(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  struct snd_ctl_elem_info *uinfo ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_info", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  uinfo = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_info", _buf_, & _off_, (void **)(& uinfo),
                     sizeof(struct snd_ctl_elem_info ), sizeof(struct snd_ctl_elem_info ));
  if (uinfo != 0U) {
    tmp_fld7 = & uinfo->count;
    tmp_lv6 = uinfo;
    nooks_ot_storeoffset_user(uinfo, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
    fetch_marshbuf("snd_ens1373_spdif_info", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& uinfo->count));
    tmp_fld7 = & uinfo->type;
    tmp_lv6 = uinfo;
    nooks_ot_storeoffset_user(uinfo, tmp_fld7 - tmp_lv6, sizeof(snd_ctl_elem_type_t ));
    fetch_marshbuf("snd_ens1373_spdif_info", _buf_, & _off_, sizeof(int ), (void *)(& uinfo->type));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ens1373_spdif_info(kcontrol, uinfo);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ens1373_spdif_info", & _buf_, & _off_, & kcontrol);
  fill_marshbuf_ptr("snd_ens1373_spdif_info", & _buf_, & _off_, & uinfo);
  if (uinfo != 0U) {
    fill_marshbuf("snd_ens1373_spdif_info", & _buf_, & _off_, (void *)(& uinfo->count),
                  sizeof(unsigned int ));
    fill_marshbuf("snd_ens1373_spdif_info", & _buf_, & _off_, (void *)(& uinfo->type),
                  sizeof(int ));
  }
  fill_marshbuf("snd_ens1373_spdif_info", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ens1373_spdif_default_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_default_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_ens1373_spdif_default_get", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->spdif_default;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_ens1373_spdif_default_get", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_default));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_ens1373_spdif_default_get", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_default_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 24) {
      fetch_marshbuf("snd_ens1373_spdif_default_get", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& ucontrol->value.iec958.status[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ens1373_spdif_default_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ens1373_spdif_default_get", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_ens1373_spdif_default_get", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_ens1373_spdif_default_get", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_default),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_ens1373_spdif_default_get", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_ens1373_spdif_default_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 24) {
      fill_marshbuf("snd_ens1373_spdif_default_get", & _buf_, & _off_, (void *)(& ucontrol->value.iec958.status[idx_arr310]),
                    sizeof(unsigned char ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_ens1373_spdif_default_get", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ens1373_spdif_mask_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr36 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_mask_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_mask_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr36 = 0;
    while (idx_arr36 < 24) {
      fetch_marshbuf("snd_ens1373_spdif_mask_get", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& ucontrol->value.iec958.status[idx_arr36]));
      idx_arr36 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ens1373_spdif_mask_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ens1373_spdif_mask_get", & _buf_, & _off_, & kcontrol);
  fill_marshbuf_ptr("snd_ens1373_spdif_mask_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr36 = 0;
    while (idx_arr36 < 24) {
      fill_marshbuf("snd_ens1373_spdif_mask_get", & _buf_, & _off_, (void *)(& ucontrol->value.iec958.status[idx_arr36]),
                    sizeof(unsigned char ));
      idx_arr36 ++;
    }
  }
  fill_marshbuf("snd_ens1373_spdif_mask_get", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ens1373_spdif_stream_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_stream_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_ens1373_spdif_stream_get", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->spdif_stream;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_ens1373_spdif_stream_get", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_stream));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_ens1373_spdif_stream_get", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_stream_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 24) {
      fetch_marshbuf("snd_ens1373_spdif_stream_get", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& ucontrol->value.iec958.status[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ens1373_spdif_stream_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ens1373_spdif_stream_get", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_ens1373_spdif_stream_get", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_ens1373_spdif_stream_get", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_stream),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_ens1373_spdif_stream_get", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_ens1373_spdif_stream_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 24) {
      fill_marshbuf("snd_ens1373_spdif_stream_get", & _buf_, & _off_, (void *)(& ucontrol->value.iec958.status[idx_arr310]),
                    sizeof(unsigned char ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_ens1373_spdif_stream_get", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ens1373_spdif_stream_put(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  struct snd_pcm_substream **STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback1_substream ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_pcm_substream **STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback2_substream ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr312 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->spdif_stream;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_ens1373_spdif_stream_put", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_stream));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->port;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned long ));
      fetch_marshbuf("snd_ens1373_spdif_stream_put", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->playback1_substream;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(struct snd_pcm_substream *));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback1_substream = & (*STRUCTADDRXkcontrolprivate_data)->playback1_substream;
      fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback1_substream,
                         sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->playback2_substream;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(struct snd_pcm_substream *));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback2_substream = & (*STRUCTADDRXkcontrolprivate_data)->playback2_substream;
      fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback2_substream,
                         sizeof(struct snd_pcm_substream ), sizeof(struct snd_pcm_substream ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_ens1373_spdif_stream_put", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr312 = 0;
    while (idx_arr312 < 24) {
      fetch_marshbuf("snd_ens1373_spdif_stream_put", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& ucontrol->value.iec958.status[idx_arr312]));
      idx_arr312 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_ens1373_spdif_stream_put(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_ens1373_spdif_stream_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->spdif_stream),
                    sizeof(unsigned int ));
      fill_marshbuf("snd_ens1373_spdif_stream_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback1_substream = & (*STRUCTADDRXkcontrolprivate_data)->playback1_substream;
      fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback1_substream);
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback2_substream = & (*STRUCTADDRXkcontrolprivate_data)->playback2_substream;
      fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_dataplayback2_substream);
    }
  }
  fill_marshbuf_ptr("snd_ens1373_spdif_stream_put", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr312 = 0;
    while (idx_arr312 < 24) {
      fill_marshbuf("snd_ens1373_spdif_stream_put", & _buf_, & _off_, (void *)(& ucontrol->value.iec958.status[idx_arr312]),
                    sizeof(unsigned char ));
      idx_arr312 ++;
    }
  }
  fill_marshbuf("snd_ens1373_spdif_stream_put", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1371_spdif_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1371_spdif_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1371_spdif_get", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->ctrl;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1371_spdif_get", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1371_spdif_get", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1371_spdif_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1371_spdif_get", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1371_spdif_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1371_spdif_get", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1371_spdif_get", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1371_spdif_get", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1371_spdif_get", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1371_spdif_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1371_spdif_get", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1371_spdif_get", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1371_spdif_put(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1371_spdif_put", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1371_spdif_put", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->cssr;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1371_spdif_put", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->ctrl;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1371_spdif_put", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->port;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned long ));
      fetch_marshbuf("snd_es1371_spdif_put", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1371_spdif_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1371_spdif_put", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1371_spdif_put", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1371_spdif_put(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1371_spdif_put", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1371_spdif_put", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1371_spdif_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr),
                    sizeof(unsigned int ));
      fill_marshbuf("snd_es1371_spdif_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl),
                    sizeof(unsigned int ));
      fill_marshbuf("snd_es1371_spdif_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1371_spdif_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1371_spdif_put", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1371_spdif_put", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1371_spdif_put", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1373_rear_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_rear_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1373_rear_get", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->cssr;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1373_rear_get", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1373_rear_get", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_rear_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1373_rear_get", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1373_rear_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1373_rear_get", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1373_rear_get", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1373_rear_get", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1373_rear_get", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1373_rear_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1373_rear_get", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1373_rear_get", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1373_rear_put(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_rear_put", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1373_rear_put", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->cssr;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1373_rear_put", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->port;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned long ));
      fetch_marshbuf("snd_es1373_rear_put", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1373_rear_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_rear_put", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1373_rear_put", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1373_rear_put(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1373_rear_put", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1373_rear_put", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1373_rear_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->cssr),
                    sizeof(unsigned int ));
      fill_marshbuf("snd_es1373_rear_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1373_rear_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1373_rear_put", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1373_rear_put", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1373_rear_put", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1373_line_get(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_line_get", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1373_line_get", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->ctrl;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1373_line_get", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1373_line_get", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_line_get", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1373_line_get", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1373_line_get(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1373_line_get", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1373_line_get", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1373_line_get", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl),
                    sizeof(unsigned int ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1373_line_get", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1373_line_get", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1373_line_get", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1373_line_get", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_es1373_line_put(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_kcontrol *kcontrol ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXkcontrolprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock ;
  struct snd_ctl_elem_value *ucontrol ;
  int idx_arr310 ;
  int _retval_ ;

  {
  _off_ = 0;
  kcontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_line_put", _buf_, & _off_, (void **)(& kcontrol),
                     sizeof(struct snd_kcontrol ), sizeof(struct snd_kcontrol ));
  if (kcontrol != 0U) {
    tmp_fld6 = & kcontrol->private_data;
    tmp_lv5 = kcontrol;
    nooks_ot_storeoffset_user(kcontrol, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fetch_marshbuf_ptr("snd_es1373_line_put", _buf_, & _off_, (void **)STRUCTADDRXkcontrolprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->ctrl;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_es1373_line_put", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->port;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned long ));
      fetch_marshbuf("snd_es1373_line_put", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port));
      tmp_fld6 = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      tmp_lv5 = *STRUCTADDRXkcontrolprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXkcontrolprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(spinlock_t * __attribute__((__noderef__, __address_space__(2))) ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fetch_marshbuf_ptr("snd_es1373_line_put", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock,
                         -1, sizeof(spinlock_t ));
    }
  }
  ucontrol = 0U;
  fetch_marshbuf_ptr("snd_es1373_line_put", _buf_, & _off_, (void **)(& ucontrol),
                     sizeof(struct snd_ctl_elem_value ), sizeof(struct snd_ctl_elem_value ));
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fetch_marshbuf("snd_es1373_line_put", _buf_, & _off_, sizeof(long ), (void *)(& ucontrol->value.integer.value[idx_arr310]));
      idx_arr310 ++;
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  _retval_ = (int )snd_es1373_line_put(kcontrol, ucontrol);
  _off_ = 0;
  fill_marshbuf_ptr("snd_es1373_line_put", & _buf_, & _off_, & kcontrol);
  if (kcontrol != 0U) {
    STRUCTADDRXkcontrolprivate_data = & kcontrol->private_data;
    fill_marshbuf_ptr("snd_es1373_line_put", & _buf_, & _off_, STRUCTADDRXkcontrolprivate_data);
    if (*STRUCTADDRXkcontrolprivate_data != 0U) {
      fill_marshbuf("snd_es1373_line_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->ctrl),
                    sizeof(unsigned int ));
      fill_marshbuf("snd_es1373_line_put", & _buf_, & _off_, (void *)(& (*STRUCTADDRXkcontrolprivate_data)->port),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock = & (*STRUCTADDRXkcontrolprivate_data)->reg_lock;
      fill_marshbuf_ptr("snd_es1373_line_put", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXkcontrolprivate_datareg_lock);
    }
  }
  fill_marshbuf_ptr("snd_es1373_line_put", & _buf_, & _off_, & ucontrol);
  if (ucontrol != 0U) {
    idx_arr310 = 0;
    while (idx_arr310 < 128) {
      fill_marshbuf("snd_es1373_line_put", & _buf_, & _off_, (void *)(& ucontrol->value.integer.value[idx_arr310]),
                    sizeof(long ));
      idx_arr310 ++;
    }
  }
  fill_marshbuf("snd_es1373_line_put", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ensoniq_proc_read(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_info_entry *entry ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct ensoniq **STRUCTADDRXentryprivate_data ;
  struct snd_info_buffer * __attribute__((__noderef__, __address_space__(2))) buffer ;

  {
  _off_ = 0;
  entry = 0U;
  fetch_marshbuf_ptr("snd_ensoniq_proc_read", _buf_, & _off_, (void **)(& entry),
                     sizeof(struct snd_info_entry ), sizeof(struct snd_info_entry ));
  if (entry != 0U) {
    tmp_fld6 = & entry->private_data;
    tmp_lv5 = entry;
    nooks_ot_storeoffset_user(entry, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
    STRUCTADDRXentryprivate_data = & entry->private_data;
    fetch_marshbuf_ptr("snd_ensoniq_proc_read", _buf_, & _off_, (void **)STRUCTADDRXentryprivate_data,
                       sizeof(struct ensoniq ), sizeof(struct ensoniq ));
    if (*STRUCTADDRXentryprivate_data != 0U) {
      tmp_fld6 = & (*STRUCTADDRXentryprivate_data)->ctrl;
      tmp_lv5 = *STRUCTADDRXentryprivate_data;
      nooks_ot_storeoffset_user(*STRUCTADDRXentryprivate_data, tmp_fld6 - tmp_lv5,
                                sizeof(unsigned int ));
      fetch_marshbuf("snd_ensoniq_proc_read", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (*STRUCTADDRXentryprivate_data)->ctrl));
    }
  }
  buffer = 0U;
  fetch_marshbuf_ptr("snd_ensoniq_proc_read", _buf_, & _off_, (void **)(& buffer),
                     -1, sizeof(struct snd_info_buffer ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  snd_ensoniq_proc_read(entry, buffer);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ensoniq_proc_read", & _buf_, & _off_, & entry);
  if (entry != 0U) {
    STRUCTADDRXentryprivate_data = & entry->private_data;
    fill_marshbuf_ptr("snd_ensoniq_proc_read", & _buf_, & _off_, STRUCTADDRXentryprivate_data);
    if (*STRUCTADDRXentryprivate_data != 0U) {
      fill_marshbuf("snd_ensoniq_proc_read", & _buf_, & _off_, (void *)(& (*STRUCTADDRXentryprivate_data)->ctrl),
                    sizeof(unsigned int ));
    }
  }
  fill_marshbuf_ptr("snd_ensoniq_proc_read", & _buf_, & _off_, & buffer);
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snd_ensoniq_midi_output_trigger(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct snd_rawmidi_substream *substream ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  struct snd_rawmidi **STRUCTADDRXsubstreamrmidi ;
  struct ensoniq **STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data ;
  spinlock_t * __attribute__((__noderef__, __address_space__(2))) *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_datareg_lock ;
  int up___0 ;

  {
  _off_ = 0;
  substream = 0U;
  fetch_marshbuf_ptr("snd_ensoniq_midi_output_trigger", _buf_, & _off_, (void **)(& substream),
                     sizeof(struct snd_rawmidi_substream ), sizeof(struct snd_rawmidi_substream ));
  if (substream != 0U) {
    tmp_fld6 = & substream->rmidi;
    tmp_lv5 = substream;
    nooks_ot_storeoffset_user(substream, tmp_fld6 - tmp_lv5, sizeof(struct snd_rawmidi *));
    STRUCTADDRXsubstreamrmidi = & substream->rmidi;
    fetch_marshbuf_ptr("snd_ensoniq_midi_output_trigger", _buf_, & _off_, (void **)STRUCTADDRXsubstreamrmidi,
                       sizeof(struct snd_rawmidi ), sizeof(struct snd_rawmidi ));
    if (*STRUCTADDRXsubstreamrmidi != 0U) {
      tmp_fld6 = & (*STRUCTADDRXsubstreamrmidi)->private_data;
      tmp_lv5 = *STRUCTADDRXsubstreamrmidi;
      nooks_ot_storeoffset_user(*STRUCTADDRXsubstreamrmidi, tmp_fld6 - tmp_lv5, sizeof(struct ensoniq *));
      STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data = & (*STRUCTADDRXsubstreamrmidi)->private_data;
      fetch_marshbuf_ptr("snd_ensoniq_midi_output_trigger", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data,
                         sizeof(struct ensoniq ), sizeof(struct ensoniq ));
      if (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data != 0U) {
        tmp_fld6 = & (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->uartc;
        tmp_lv5 = *STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data;
        nooks_ot_storeoffset_user(*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data,
                                  tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
        fetch_marshbuf("snd_ensoniq_midi_output_trigger", _buf_, & _off_, sizeof(unsigned int ),
                       (void *)(& (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->uartc));
        tmp_fld6 = & (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->port;
        tmp_lv5 = *STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data;
        nooks_ot_storeoffset_user(*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data,
                                  tmp_fld6 - tmp_lv5, sizeof(unsigned long ));
        fetch_marshbuf("snd_ensoniq_midi_output_trigger", _buf_, & _off_, sizeof(unsigned long ),
                       (void *)(& (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->port));
        tmp_fld6 = & (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->reg_lock;
        tmp_lv5 = *STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data;
        nooks_ot_storeoffset_user(*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data,
                                  tmp_fld6 - tmp_lv5, sizeof(spinlock_t * __attribute__((__noderef__,
                                  __address_space__(2))) ));
        STRUCTADDRXSTRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_datareg_lock = & (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->reg_lock;
        fetch_marshbuf_ptr("snd_ensoniq_midi_output_trigger", _buf_, & _off_, (void **)STRUCTADDRXSTRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_datareg_lock,
                           -1, sizeof(spinlock_t ));
      }
    }
  }
  fetch_marshbuf("snd_ensoniq_midi_output_trigger", _buf_, & _off_, sizeof(int ),
                 (void *)(& up___0));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  snd_ensoniq_midi_output_trigger(substream, up___0);
  _off_ = 0;
  fill_marshbuf_ptr("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, & substream);
  if (substream != 0U) {
    STRUCTADDRXsubstreamrmidi = & substream->rmidi;
    fill_marshbuf_ptr("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, STRUCTADDRXsubstreamrmidi);
    if (*STRUCTADDRXsubstreamrmidi != 0U) {
      STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data = & (*STRUCTADDRXsubstreamrmidi)->private_data;
      fill_marshbuf_ptr("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data);
      if (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data != 0U) {
        fill_marshbuf("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, (void *)(& (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->uartc),
                      sizeof(unsigned int ));
        fill_marshbuf("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, (void *)(& (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->port),
                      sizeof(unsigned long ));
        STRUCTADDRXSTRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_datareg_lock = & (*STRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_data)->reg_lock;
        fill_marshbuf_ptr("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, STRUCTADDRXSTRUCTADDRXSTRUCTADDRXsubstreamrmidiprivate_datareg_lock);
      }
    }
  }
  fill_marshbuf("snd_ensoniq_midi_output_trigger", & _buf_, & _off_, (void *)(& up___0),
                sizeof(int ));
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
extern int disp_user(char *function_name , struct req_args *rqargs ) 
{ 
  struct marshret_struct retval ;

  {
  retval.buf = 0U;
  if (rqargs->function_id == 1202) {
    __MARSH_WRAP__snd_ensoniq_playback1_close(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1170) {
    __MARSH_WRAP__snd_ens1373_spdif_info(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1168) {
    __MARSH_WRAP__snd_ens1373_spdif_default_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1171) {
    __MARSH_WRAP__snd_ens1373_spdif_mask_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1172) {
    __MARSH_WRAP__snd_ens1373_spdif_stream_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1173) {
    __MARSH_WRAP__snd_ens1373_spdif_stream_put(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1227) {
    __MARSH_WRAP__snd_es1371_spdif_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1228) {
    __MARSH_WRAP__snd_es1371_spdif_put(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1234) {
    __MARSH_WRAP__snd_es1373_rear_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1235) {
    __MARSH_WRAP__snd_es1373_rear_put(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1232) {
    __MARSH_WRAP__snd_es1373_line_get(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1233) {
    __MARSH_WRAP__snd_es1373_line_put(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1213) {
    __MARSH_WRAP__snd_ensoniq_proc_read(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1198) {
    __MARSH_WRAP__snd_ensoniq_midi_output_trigger(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  return (1);
}
}
void register_functions(void) 
{ 


  {
  nooks_ot_register_userfn(snd_ensoniq_playback1_close, 1202);
  nooks_ot_register_userfn(snd_ens1373_spdif_info, 1170);
  nooks_ot_register_userfn(snd_ens1373_spdif_default_get, 1168);
  nooks_ot_register_userfn(snd_ens1373_spdif_mask_get, 1171);
  nooks_ot_register_userfn(snd_ens1373_spdif_stream_get, 1172);
  nooks_ot_register_userfn(snd_ens1373_spdif_stream_put, 1173);
  nooks_ot_register_userfn(snd_es1371_spdif_get, 1227);
  nooks_ot_register_userfn(snd_es1371_spdif_put, 1228);
  nooks_ot_register_userfn(snd_es1373_rear_get, 1234);
  nooks_ot_register_userfn(snd_es1373_rear_put, 1235);
  nooks_ot_register_userfn(snd_es1373_line_get, 1232);
  nooks_ot_register_userfn(snd_es1373_line_put, 1233);
  nooks_ot_register_userfn(snd_ensoniq_proc_read, 1213);
  nooks_ot_register_userfn(snd_ensoniq_midi_output_trigger, 1198);
  nooks_ot_register_userfn(param_set_int, 1133);
  nooks_ot_register_userfn(param_get_int, 1130);
  nooks_ot_register_userfn(param_set_charp, 1132);
  nooks_ot_register_userfn(param_get_charp, 1129);
  nooks_ot_register_userfn(param_set_bool, 1131);
  nooks_ot_register_userfn(param_get_bool, 1128);
  nooks_ot_register_userfn(param_array_set, 1127);
  nooks_ot_register_userfn(param_array_get, 1126);
  nooks_ot_register_userfn(snd_ctl_boolean_mono_info, 1163);
  nooks_ot_register_userfn(snd_pcm_lib_ioctl, 1244);
}
}
int param_set_int(char const   *val , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_get_int(char *buffer , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_set_charp(char const   *val , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_get_charp(char *buffer , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_set_bool(char const   *val , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_get_bool(char *buffer , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_array_set(char const   *val , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int param_array_get(char *buffer , struct kernel_param *kp ) 
{ 


  {
  return (0U);
}
}
int snd_ctl_boolean_mono_info(struct snd_kcontrol *kcontrol , struct snd_ctl_elem_info *uinfo ) 
{ 


  {
  return (0U);
}
}
int snd_pcm_lib_ioctl(struct snd_pcm_substream *substream , unsigned int cmd , void *arg ) 
{ 


  {
  return (0U);
}
}
void register_globals(void) 
{ 


  {
  nooks_ot_register_userfn(__param_str_spdif, 1057);
  nooks_ot_register_userfn(str_238696912, 1287);
  nooks_ot_register_userfn(str_964300407, 1336);
  nooks_ot_register_userfn(index, 1102);
  nooks_ot_register_userfn(& es1371_dac_clock, 1087);
  nooks_ot_register_userfn(& driver, 1079);
  nooks_ot_register_userfn(str_1035699315, 1269);
  nooks_ot_register_userfn(str_969183744, 1338);
  nooks_ot_register_userfn(& __this_module, 1062);
  nooks_ot_register_userfn(& __key___5, 1043);
  nooks_ot_register_userfn(str_173238353, 1274);
  nooks_ot_register_userfn(str_542964445, 1303);
  nooks_ot_register_userfn(str_212077587, 1278);
  nooks_ot_register_userfn(str_375887647, 1297);
  nooks_ot_register_userfn(str_980588047, 1339);
  nooks_ot_register_userfn(str_964303960, 1337);
  nooks_ot_register_userfn(snd_ensoniq_sample_shift, 1215);
  nooks_ot_register_userfn(str_42111, 1300);
  nooks_ot_register_userfn(str_87276860, 1325);
  nooks_ot_register_userfn(str_445311958, 1302);
  nooks_ot_register_userfn(str_212077948, 1279);
  nooks_ot_register_userfn(str_229248278, 1285);
  nooks_ot_register_userfn(str_1012473204, 1266);
  nooks_ot_register_userfn(& ioport_resource, 1105);
  nooks_ot_register_userfn(str_395763820, 1298);
  nooks_ot_register_userfn(& __param_arr_joystick_port, 1049);
  nooks_ot_register_userfn(str_270898770, 1289);
  nooks_ot_register_userfn(str_543407206, 1304);
  nooks_ot_register_userfn(& snd_ensoniq_midi_output, 1195);
  nooks_ot_register_userfn(& snd_es1371_hw_constraints_dac_clock, 1225);
  nooks_ot_register_userfn(& __param_arr_id, 1047);
  nooks_ot_register_userfn(str_368086832, 1296);
  nooks_ot_register_userfn(str_912128440, 1328);
  nooks_ot_register_userfn(& snd_ensoniq_capture_ops, 1177);
  nooks_ot_register_userfn(str_738175023, 1314);
  nooks_ot_register_userfn(str_212077949, 1280);
  nooks_ot_register_userfn(str_744380086, 1316);
  nooks_ot_register_userfn(str_722885693, 1313);
  nooks_ot_register_userfn(& ops___0, 1123);
  nooks_ot_register_userfn(str_294126970, 1292);
  nooks_ot_register_userfn(str_1025924976, 1267);
  nooks_ot_register_userfn(str_784473757, 1318);
  nooks_ot_register_userfn(lineio, 1110);
  nooks_ot_register_userfn(joystick_port, 1106);
  nooks_ot_register_userfn(str_130227268, 1273);
  nooks_ot_register_userfn(str_993283229, 1343);
  nooks_ot_register_userfn(__param_str_enable, 1052);
  nooks_ot_register_userfn(__param_str_index, 1054);
  nooks_ot_register_userfn(str_367676234, 1295);
  nooks_ot_register_userfn(str_845284242, 1324);
  nooks_ot_register_userfn(& snd_ensoniq_midi_input, 1190);
  nooks_ot_register_userfn(str_947039464, 1333);
  nooks_ot_register_userfn(str_298879367, 1294);
  nooks_ot_register_userfn(& __param_arr_spdif, 1051);
  nooks_ot_register_userfn(__param_str_lineio, 1056);
  nooks_ot_register_userfn(str_112964058, 1272);
  nooks_ot_register_userfn(str_941294053, 1332);
  nooks_ot_register_userfn(& snd_ensoniq_playback2_ops, 1209);
  nooks_ot_register_userfn(es1371_ac97_reset_hack, 1084);
  nooks_ot_register_userfn(str_8982834, 1327);
  nooks_ot_register_userfn(str_741517731, 1315);
  nooks_ot_register_userfn(id, 1100);
  nooks_ot_register_userfn(str_417657113, 1299);
  nooks_ot_register_userfn(str_796733679, 1322);
  nooks_ot_register_userfn(str_604382372, 1307);
  nooks_ot_register_userfn(str_679919104, 1309);
  nooks_ot_register_userfn(str_271048946, 1291);
  nooks_ot_register_userfn(str_228836090, 1284);
  nooks_ot_register_userfn(es1371_amplifier_hack, 1086);
  nooks_ot_register_userfn(& es1371_adc_clock, 1085);
  nooks_ot_register_userfn(str_9379010, 1330);
  nooks_ot_register_userfn(str_878364613, 1326);
  nooks_ot_register_userfn(str_2219, 1283);
  nooks_ot_register_userfn(str_108773245, 1271);
  nooks_ot_register_userfn(& snd_ens1373_rear, 1167);
  nooks_ot_register_userfn(str_603776742, 1306);
  nooks_ot_register_userfn(str_784540269, 1319);
  nooks_ot_register_userfn(& snd_ensoniq_playback1_ops, 1204);
  nooks_ot_register_userfn(str_182023070, 1275);
  nooks_ot_register_userfn(str_913711678, 1329);
  nooks_ot_register_userfn(str_235265470, 1286);
  nooks_ot_register_userfn(__param_str_joystick_port, 1055);
  nooks_ot_register_userfn(str_784561127, 1320);
  nooks_ot_register_userfn(snd_audiopci_ids, 1153);
  nooks_ot_register_userfn(str_711075343, 1310);
  nooks_ot_register_userfn(str_993283191, 1341);
  nooks_ot_register_userfn(ens1373_line_quirk, 1083);
  nooks_ot_register_userfn(str_216941979, 1281);
  nooks_ot_register_userfn(str_1039574295, 1270);
  nooks_ot_register_userfn(str_265323660, 1288);
  nooks_ot_register_userfn(str_722882140, 1312);
  nooks_ot_register_userfn(str_218451996, 1282);
  nooks_ot_register_userfn(& __key___4, 1042);
  nooks_ot_register_userfn(str_270906351, 1290);
  nooks_ot_register_userfn(str_941290500, 1331);
  nooks_ot_register_userfn(& snd_ens1373_line, 1166);
  nooks_ot_register_userfn(& ops, 1122);
  nooks_ot_register_userfn(& __param_arr_index, 1048);
  nooks_ot_register_userfn(& __param_arr_enable, 1046);
  nooks_ot_register_userfn(str_810807268, 1323);
  nooks_ot_register_userfn(str_993283210, 1342);
  nooks_ot_register_userfn(& snd_es1371_hw_constraints_adc_clock, 1224);
  nooks_ot_register_userfn(snd_es1371_mixer_spdif, 1226);
  nooks_ot_register_userfn(str_182023141, 1276);
  nooks_ot_register_userfn(spdif, 1259);
  nooks_ot_register_userfn(str_794415929, 1321);
  nooks_ot_register_userfn(str_188578368, 1277);
  nooks_ot_register_userfn(& __param_arr_lineio, 1050);
  nooks_ot_register_userfn(str_54849971, 1305);
  nooks_ot_register_userfn(__param_str_id, 1053);
  nooks_ot_register_userfn(str_629286318, 1308);
  nooks_ot_register_userfn(str_712681085, 1311);
  nooks_ot_register_userfn(str_42459933, 1301);
  nooks_ot_register_userfn(enable, 1080);
  nooks_ot_register_userfn(str_993283248, 1344);
  nooks_ot_register_userfn(str_1034057403, 1268);
  nooks_ot_register_userfn(str_98566182, 1340);
  nooks_ot_register_userfn(es1371_spdif_present, 1089);
  nooks_ot_register_userfn(str_947043017, 1334);
  nooks_ot_register_userfn(str_297936691, 1293);
  nooks_ot_register_userfn(str_948573379, 1335);
  nooks_ot_register_userfn(str_784473421, 1317);
}
}
