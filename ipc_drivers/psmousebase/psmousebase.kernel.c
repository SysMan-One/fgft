/* Generated by CIL v. 1.4.0 */
/* print_CIL_Input is true */

#include "../../common/master_top.h" // Matt E1
extern int disp_user(char *function_name , struct req_args *rqargs ) ;
char function_id_map[1456][128]  = 
  {      "0", 
        "1", 
        "2", 
        "3", 
        "4", 
        "5", 
        "6", 
        "7", 
        "8", 
        "9", 
        "10", 
        "11", 
        "12", 
        "13", 
        "14", 
        "15", 
        "16", 
        "17", 
        "18", 
        "19", 
        "20", 
        "21", 
        "22", 
        "23", 
        "24", 
        "25", 
        "26", 
        "27", 
        "28", 
        "29", 
        "30", 
        "31", 
        "32", 
        "33", 
        "34", 
        "35", 
        "36", 
        "37", 
        "38", 
        "39", 
        "40", 
        "41", 
        "42", 
        "43", 
        "44", 
        "45", 
        "46", 
        "47", 
        "48", 
        "49", 
        "50", 
        "51", 
        "52", 
        "53", 
        "54", 
        "55", 
        "56", 
        "57", 
        "58", 
        "59", 
        "60", 
        "61", 
        "62", 
        "63", 
        "64", 
        "65", 
        "66", 
        "67", 
        "68", 
        "69", 
        "70", 
        "71", 
        "72", 
        "73", 
        "74", 
        "75", 
        "76", 
        "77", 
        "78", 
        "79", 
        "80", 
        "81", 
        "82", 
        "83", 
        "84", 
        "85", 
        "86", 
        "87", 
        "88", 
        "89", 
        "90", 
        "91", 
        "92", 
        "93", 
        "94", 
        "95", 
        "96", 
        "97", 
        "98", 
        "99", 
        "100", 
        "101", 
        "102", 
        "103", 
        "104", 
        "105", 
        "106", 
        "107", 
        "108", 
        "109", 
        "110", 
        "111", 
        "112", 
        "113", 
        "114", 
        "115", 
        "116", 
        "117", 
        "118", 
        "119", 
        "120", 
        "121", 
        "122", 
        "123", 
        "124", 
        "125", 
        "126", 
        "127", 
        "128", 
        "129", 
        "130", 
        "131", 
        "132", 
        "133", 
        "134", 
        "135", 
        "136", 
        "137", 
        "138", 
        "139", 
        "140", 
        "141", 
        "142", 
        "143", 
        "144", 
        "145", 
        "146", 
        "147", 
        "148", 
        "149", 
        "150", 
        "151", 
        "152", 
        "153", 
        "154", 
        "155", 
        "156", 
        "157", 
        "158", 
        "159", 
        "160", 
        "161", 
        "162", 
        "163", 
        "164", 
        "165", 
        "166", 
        "167", 
        "168", 
        "169", 
        "170", 
        "171", 
        "172", 
        "173", 
        "174", 
        "175", 
        "176", 
        "177", 
        "178", 
        "179", 
        "180", 
        "181", 
        "182", 
        "183", 
        "184", 
        "185", 
        "186", 
        "187", 
        "188", 
        "189", 
        "190", 
        "191", 
        "192", 
        "193", 
        "194", 
        "195", 
        "196", 
        "197", 
        "198", 
        "199", 
        "200", 
        "201", 
        "202", 
        "203", 
        "204", 
        "205", 
        "206", 
        "207", 
        "208", 
        "209", 
        "210", 
        "211", 
        "212", 
        "213", 
        "214", 
        "215", 
        "216", 
        "217", 
        "218", 
        "219", 
        "220", 
        "221", 
        "222", 
        "223", 
        "224", 
        "225", 
        "226", 
        "227", 
        "228", 
        "229", 
        "230", 
        "231", 
        "232", 
        "233", 
        "234", 
        "235", 
        "236", 
        "237", 
        "238", 
        "239", 
        "240", 
        "241", 
        "242", 
        "243", 
        "244", 
        "245", 
        "246", 
        "247", 
        "248", 
        "249", 
        "250", 
        "251", 
        "252", 
        "253", 
        "254", 
        "255", 
        "256", 
        "257", 
        "258", 
        "259", 
        "260", 
        "261", 
        "262", 
        "263", 
        "264", 
        "265", 
        "266", 
        "267", 
        "268", 
        "269", 
        "270", 
        "271", 
        "272", 
        "273", 
        "274", 
        "275", 
        "276", 
        "277", 
        "278", 
        "279", 
        "280", 
        "281", 
        "282", 
        "283", 
        "284", 
        "285", 
        "286", 
        "287", 
        "288", 
        "289", 
        "290", 
        "291", 
        "292", 
        "293", 
        "294", 
        "295", 
        "296", 
        "297", 
        "298", 
        "299", 
        "300", 
        "301", 
        "302", 
        "303", 
        "304", 
        "305", 
        "306", 
        "307", 
        "308", 
        "309", 
        "310", 
        "311", 
        "312", 
        "313", 
        "314", 
        "315", 
        "316", 
        "317", 
        "318", 
        "319", 
        "320", 
        "321", 
        "322", 
        "323", 
        "324", 
        "325", 
        "326", 
        "327", 
        "328", 
        "329", 
        "330", 
        "331", 
        "332", 
        "333", 
        "334", 
        "335", 
        "336", 
        "337", 
        "338", 
        "339", 
        "340", 
        "341", 
        "342", 
        "343", 
        "344", 
        "345", 
        "346", 
        "347", 
        "348", 
        "349", 
        "350", 
        "351", 
        "352", 
        "353", 
        "354", 
        "355", 
        "356", 
        "357", 
        "358", 
        "359", 
        "360", 
        "361", 
        "362", 
        "363", 
        "364", 
        "365", 
        "366", 
        "367", 
        "368", 
        "369", 
        "370", 
        "371", 
        "372", 
        "373", 
        "374", 
        "375", 
        "376", 
        "377", 
        "378", 
        "379", 
        "380", 
        "381", 
        "382", 
        "383", 
        "384", 
        "385", 
        "386", 
        "387", 
        "388", 
        "389", 
        "390", 
        "391", 
        "392", 
        "393", 
        "394", 
        "395", 
        "396", 
        "397", 
        "398", 
        "399", 
        "400", 
        "401", 
        "402", 
        "403", 
        "404", 
        "405", 
        "406", 
        "407", 
        "408", 
        "409", 
        "410", 
        "411", 
        "412", 
        "413", 
        "414", 
        "415", 
        "416", 
        "417", 
        "418", 
        "419", 
        "420", 
        "421", 
        "422", 
        "423", 
        "424", 
        "425", 
        "426", 
        "427", 
        "428", 
        "429", 
        "430", 
        "431", 
        "432", 
        "433", 
        "434", 
        "435", 
        "436", 
        "437", 
        "438", 
        "439", 
        "440", 
        "441", 
        "442", 
        "443", 
        "444", 
        "445", 
        "446", 
        "447", 
        "448", 
        "449", 
        "450", 
        "451", 
        "452", 
        "453", 
        "454", 
        "455", 
        "456", 
        "457", 
        "458", 
        "459", 
        "460", 
        "461", 
        "462", 
        "463", 
        "464", 
        "465", 
        "466", 
        "467", 
        "468", 
        "469", 
        "470", 
        "471", 
        "472", 
        "473", 
        "474", 
        "475", 
        "476", 
        "477", 
        "478", 
        "479", 
        "480", 
        "481", 
        "482", 
        "483", 
        "484", 
        "485", 
        "486", 
        "487", 
        "488", 
        "489", 
        "490", 
        "491", 
        "492", 
        "493", 
        "494", 
        "495", 
        "496", 
        "497", 
        "498", 
        "499", 
        "500", 
        "501", 
        "502", 
        "503", 
        "504", 
        "505", 
        "506", 
        "507", 
        "508", 
        "509", 
        "510", 
        "511", 
        "512", 
        "513", 
        "514", 
        "515", 
        "516", 
        "517", 
        "518", 
        "519", 
        "520", 
        "521", 
        "522", 
        "523", 
        "524", 
        "525", 
        "526", 
        "527", 
        "528", 
        "529", 
        "530", 
        "531", 
        "532", 
        "533", 
        "534", 
        "535", 
        "536", 
        "537", 
        "538", 
        "539", 
        "540", 
        "541", 
        "542", 
        "543", 
        "544", 
        "545", 
        "546", 
        "547", 
        "548", 
        "549", 
        "550", 
        "551", 
        "552", 
        "553", 
        "554", 
        "555", 
        "556", 
        "557", 
        "558", 
        "559", 
        "560", 
        "561", 
        "562", 
        "563", 
        "564", 
        "565", 
        "566", 
        "567", 
        "568", 
        "569", 
        "570", 
        "571", 
        "572", 
        "573", 
        "574", 
        "575", 
        "576", 
        "577", 
        "578", 
        "579", 
        "580", 
        "581", 
        "582", 
        "583", 
        "584", 
        "585", 
        "586", 
        "587", 
        "588", 
        "589", 
        "590", 
        "591", 
        "592", 
        "593", 
        "594", 
        "595", 
        "596", 
        "597", 
        "598", 
        "599", 
        "600", 
        "601", 
        "602", 
        "603", 
        "604", 
        "605", 
        "606", 
        "607", 
        "608", 
        "609", 
        "610", 
        "611", 
        "612", 
        "613", 
        "614", 
        "615", 
        "616", 
        "617", 
        "618", 
        "619", 
        "620", 
        "621", 
        "622", 
        "623", 
        "624", 
        "625", 
        "626", 
        "627", 
        "628", 
        "629", 
        "630", 
        "631", 
        "632", 
        "633", 
        "634", 
        "635", 
        "636", 
        "637", 
        "638", 
        "639", 
        "640", 
        "641", 
        "642", 
        "643", 
        "644", 
        "645", 
        "646", 
        "647", 
        "648", 
        "649", 
        "650", 
        "651", 
        "652", 
        "653", 
        "654", 
        "655", 
        "656", 
        "657", 
        "658", 
        "659", 
        "660", 
        "661", 
        "662", 
        "663", 
        "664", 
        "665", 
        "666", 
        "667", 
        "668", 
        "669", 
        "670", 
        "671", 
        "672", 
        "673", 
        "674", 
        "675", 
        "676", 
        "677", 
        "678", 
        "679", 
        "680", 
        "681", 
        "682", 
        "683", 
        "684", 
        "685", 
        "686", 
        "687", 
        "688", 
        "689", 
        "690", 
        "691", 
        "692", 
        "693", 
        "694", 
        "695", 
        "696", 
        "697", 
        "698", 
        "699", 
        "700", 
        "701", 
        "702", 
        "703", 
        "704", 
        "705", 
        "706", 
        "707", 
        "708", 
        "709", 
        "710", 
        "711", 
        "712", 
        "713", 
        "714", 
        "715", 
        "716", 
        "717", 
        "718", 
        "719", 
        "720", 
        "721", 
        "722", 
        "723", 
        "724", 
        "725", 
        "726", 
        "727", 
        "728", 
        "729", 
        "730", 
        "731", 
        "732", 
        "733", 
        "734", 
        "735", 
        "736", 
        "737", 
        "738", 
        "739", 
        "740", 
        "741", 
        "742", 
        "743", 
        "744", 
        "745", 
        "746", 
        "747", 
        "748", 
        "749", 
        "750", 
        "751", 
        "752", 
        "753", 
        "754", 
        "755", 
        "756", 
        "757", 
        "758", 
        "759", 
        "760", 
        "761", 
        "762", 
        "763", 
        "764", 
        "765", 
        "766", 
        "767", 
        "768", 
        "769", 
        "770", 
        "771", 
        "772", 
        "773", 
        "774", 
        "775", 
        "776", 
        "777", 
        "778", 
        "779", 
        "780", 
        "781", 
        "782", 
        "783", 
        "784", 
        "785", 
        "786", 
        "787", 
        "788", 
        "789", 
        "790", 
        "791", 
        "792", 
        "793", 
        "794", 
        "795", 
        "796", 
        "797", 
        "798", 
        "799", 
        "800", 
        "801", 
        "802", 
        "803", 
        "804", 
        "805", 
        "806", 
        "807", 
        "808", 
        "809", 
        "810", 
        "811", 
        "812", 
        "813", 
        "814", 
        "815", 
        "816", 
        "817", 
        "818", 
        "819", 
        "820", 
        "821", 
        "822", 
        "823", 
        "824", 
        "825", 
        "826", 
        "827", 
        "828", 
        "829", 
        "830", 
        "831", 
        "832", 
        "833", 
        "834", 
        "835", 
        "836", 
        "837", 
        "838", 
        "839", 
        "840", 
        "841", 
        "842", 
        "843", 
        "844", 
        "845", 
        "846", 
        "847", 
        "848", 
        "849", 
        "850", 
        "851", 
        "852", 
        "853", 
        "854", 
        "855", 
        "856", 
        "857", 
        "858", 
        "859", 
        "860", 
        "861", 
        "862", 
        "863", 
        "864", 
        "865", 
        "866", 
        "867", 
        "868", 
        "869", 
        "870", 
        "871", 
        "872", 
        "873", 
        "874", 
        "875", 
        "876", 
        "877", 
        "878", 
        "879", 
        "880", 
        "881", 
        "882", 
        "883", 
        "884", 
        "885", 
        "886", 
        "887", 
        "888", 
        "889", 
        "890", 
        "891", 
        "892", 
        "893", 
        "894", 
        "895", 
        "896", 
        "897", 
        "898", 
        "899", 
        "900", 
        "901", 
        "902", 
        "903", 
        "904", 
        "905", 
        "906", 
        "907", 
        "908", 
        "909", 
        "910", 
        "911", 
        "912", 
        "913", 
        "914", 
        "915", 
        "916", 
        "917", 
        "918", 
        "919", 
        "920", 
        "921", 
        "922", 
        "923", 
        "924", 
        "925", 
        "926", 
        "927", 
        "928", 
        "929", 
        "930", 
        "931", 
        "932", 
        "933", 
        "934", 
        "935", 
        "936", 
        "937", 
        "938", 
        "939", 
        "940", 
        "941", 
        "942", 
        "943", 
        "944", 
        "945", 
        "946", 
        "947", 
        "948", 
        "949", 
        "950", 
        "951", 
        "952", 
        "953", 
        "954", 
        "955", 
        "956", 
        "957", 
        "958", 
        "959", 
        "960", 
        "961", 
        "962", 
        "963", 
        "964", 
        "965", 
        "966", 
        "967", 
        "968", 
        "969", 
        "970", 
        "971", 
        "972", 
        "973", 
        "974", 
        "975", 
        "976", 
        "977", 
        "978", 
        "979", 
        "980", 
        "981", 
        "982", 
        "983", 
        "984", 
        "985", 
        "986", 
        "987", 
        "988", 
        "989", 
        "990", 
        "991", 
        "992", 
        "993", 
        "994", 
        "995", 
        "996", 
        "997", 
        "998", 
        "999", 
        "INIT_LIST_HEAD", 
        "MICRODRIVERS__DUMMY", 
        "MICRODRIVERS__MODIF___create_workqueue", 
        "MICRODRIVERS__MODIF___spin_lock_init", 
        "MICRODRIVERS__MODIF__spin_lock", 
        "MICRODRIVERS__MODIF__spin_lock_irq", 
        "MICRODRIVERS__MODIF__spin_lock_irqsave", 
        "MICRODRIVERS__MODIF__spin_unlock", 
        "MICRODRIVERS__MODIF__spin_unlock_irq", 
        "MICRODRIVERS__MODIF__spin_unlock_irqrestore", 
        "MICRODRIVERS__MODIF_destroy_workqueue", 
        "MICRODRIVERS__MODIF_dev_driver_string", 
        "MICRODRIVERS__MODIF_flush_workqueue", 
        "MICRODRIVERS__MODIF_free_irq", 
        "MICRODRIVERS__MODIF_init_timer", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_byte", 
        "MICRODRIVERS__MODIF_pci_bus_read_config_word", 
        "MICRODRIVERS__MODIF_pci_bus_write_config_word", 
        "MICRODRIVERS__MODIF_pci_clear_mwi", 
        "MICRODRIVERS__MODIF_ps2_cmd_aborted", 
        "MICRODRIVERS__MODIF_ps2_command", 
        "MICRODRIVERS__MODIF_ps2_drain", 
        "MICRODRIVERS__MODIF_ps2_handle_ack", 
        "MICRODRIVERS__MODIF_ps2_handle_response", 
        "MICRODRIVERS__MODIF_ps2_init", 
        "MICRODRIVERS__MODIF_ps2_sendbyte", 
        "MICRODRIVERS__MODIF_request_irq", 
        "__builtin_expect", 
        "__builtin_memcpy", 
        "__create_workqueue_key", 
        "__key___3", 
        "__key___4", 
        "__kmalloc", 
        "__memcpy", 
        "__param_str_proto", 
        "__param_str_rate", 
        "__param_str_resetafter", 
        "__param_str_resolution", 
        "__param_str_resync_time", 
        "__param_str_smartscroll", 
        "__psmouse_set_state", 
        "__serio_register_driver", 
        "__serio_register_port", 
        "__this_module", 
        "_spin_lock_irq", 
        "_spin_unlock_irq", 
        "alps_absolute_mode", 
        "alps_detect", 
        "alps_disconnect", 
        "alps_get_model", 
        "alps_get_status", 
        "alps_hw_init", 
        "alps_init", 
        "alps_model_data", 
        "alps_passthrough_mode", 
        "alps_poll", 
        "alps_process_byte", 
        "alps_process_packet", 
        "alps_reconnect", 
        "alps_tap_mode", 
        "cleanup_module", 
        "clear_bit", 
        "cortron_detect", 
        "destroy_workqueue", 
        "dev_get_drvdata", 
        "dev_set_drvdata", 
        "device_create_file", 
        "device_remove_file", 
        "dmi_check_system", 
        "elantech_init", 
        "flush_workqueue", 
        "genius_detect", 
        "get_model_info", 
        "heapifyfree", 
        "heapifymalloc", 
        "hgpk_detect", 
        "hgpk_init", 
        "im_explorer_detect", 
        "init_module", 
        "init_timer", 
        "input_allocate_device", 
        "input_event", 
        "input_free_device", 
        "input_register_device", 
        "input_report_abs", 
        "input_report_key", 
        "input_report_rel", 
        "input_set_abs_params", 
        "input_sync", 
        "input_unregister_device", 
        "intellimouse_detect", 
        "kfree", 
        "kmalloc", 
        "kzalloc", 
        "lifebook_absolute_mode", 
        "lifebook_create_relative_device", 
        "lifebook_detect", 
        "lifebook_disconnect", 
        "lifebook_dmi_table", 
        "lifebook_init", 
        "lifebook_process_byte", 
        "lifebook_relative_mode", 
        "lifebook_set_6byte_proto", 
        "lifebook_set_resolution", 
        "lifebook_set_serio_phys", 
        "lockdep_init_map", 
        "logAlloc", 
        "logFree", 
        "logRead", 
        "logSfiFrame", 
        "logStackFrame", 
        "logStackVar", 
        "logWrite", 
        "memcmp", 
        "memset", 
        "msleep", 
        "mutex_lock_interruptible_nested", 
        "mutex_lock_nested", 
        "mutex_unlock", 
        "newabs_mask", 
        "newabs_rel_mask", 
        "newabs_rslt", 
        "odft_is_self_locked", 
        "oldabs_mask", 
        "oldabs_rslt", 
        "param_get_bool", 
        "param_get_uint", 
        "param_set_bool", 
        "param_set_uint", 
        "params", 
        "params___0", 
        "printk", 
        "ps2_cmd_aborted", 
        "ps2_command", 
        "ps2_drain", 
        "ps2_handle_ack", 
        "ps2_handle_response", 
        "ps2_init", 
        "ps2_sendbyte", 
        "ps2bare_detect", 
        "ps2pp_attr_set_smartscroll", 
        "ps2pp_attr_show_smartscroll", 
        "ps2pp_cmd", 
        "ps2pp_disconnect", 
        "ps2pp_init", 
        "ps2pp_list", 
        "ps2pp_process_byte", 
        "ps2pp_set_model_properties", 
        "ps2pp_set_resolution", 
        "ps2pp_set_smartscroll", 
        "psmouse_activate", 
        "psmouse_attr_draghys", 
        "psmouse_attr_ext_dev", 
        "psmouse_attr_inertia", 
        "psmouse_attr_jenks", 
        "psmouse_attr_mindrag", 
        "psmouse_attr_press_to_select", 
        "psmouse_attr_protocol", 
        "psmouse_attr_rate", 
        "psmouse_attr_reach", 
        "psmouse_attr_resetafter", 
        "psmouse_attr_resolution", 
        "psmouse_attr_resync_time", 
        "psmouse_attr_sensitivity", 
        "psmouse_attr_set_helper", 
        "psmouse_attr_set_protocol", 
        "psmouse_attr_set_rate", 
        "psmouse_attr_set_resolution", 
        "psmouse_attr_show_helper", 
        "psmouse_attr_show_protocol", 
        "psmouse_attr_skipback", 
        "psmouse_attr_smartscroll", 
        "psmouse_attr_speed", 
        "psmouse_attr_thresh", 
        "psmouse_attr_upthresh", 
        "psmouse_attr_ztime", 
        "psmouse_attribute_group", 
        "psmouse_attributes", 
        "psmouse_cleanup", 
        "psmouse_connect", 
        "psmouse_deactivate", 
        "psmouse_disconnect", 
        "psmouse_drv", 
        "psmouse_exit", 
        "psmouse_extensions", 
        "psmouse_get_maxproto", 
        "psmouse_handle_byte", 
        "psmouse_init", 
        "psmouse_initialize", 
        "psmouse_interrupt", 
        "psmouse_max_proto", 
        "psmouse_mutex", 
        "psmouse_poll", 
        "psmouse_probe", 
        "psmouse_process_byte", 
        "psmouse_protocol_by_name", 
        "psmouse_protocol_by_type", 
        "psmouse_protocols", 
        "psmouse_queue_work", 
        "psmouse_rate", 
        "psmouse_reconnect", 
        "psmouse_reset", 
        "psmouse_resetafter", 
        "psmouse_resolution", 
        "psmouse_resync", 
        "psmouse_resync_time", 
        "psmouse_serio_ids", 
        "psmouse_set_int_attr", 
        "psmouse_set_maxproto", 
        "psmouse_set_rate", 
        "psmouse_set_resolution", 
        "psmouse_set_state", 
        "psmouse_show_int_attr", 
        "psmouse_sliced_command", 
        "psmouse_smartscroll", 
        "psmouse_switch_protocol", 
        "psmousebase_checkpoint", 
        "psmousebase_restore", 
        "queue_delayed_work", 
        "rates", 
        "rates___0", 
        "seq", 
        "serio_close", 
        "serio_continue_rx", 
        "serio_get_drvdata", 
        "serio_interrupt", 
        "serio_open", 
        "serio_pause_rx", 
        "serio_pin_driver", 
        "serio_pin_driver_uninterruptible", 
        "serio_reconnect", 
        "serio_register_driver", 
        "serio_register_port", 
        "serio_set_drvdata", 
        "serio_unpin_driver", 
        "serio_unregister_child_port", 
        "serio_unregister_driver", 
        "set_bit", 
        "set_input_params", 
        "snprintf", 
        "sprintf", 
        "stackguard_get_ra", 
        "stackguard_pop", 
        "stackguard_push", 
        "stackguard_set_ra", 
        "stackguard_stack", 
        "str_0", 
        "str_1010884528", 
        "str_1013043182", 
        "str_1017698982", 
        "str_1023639894", 
        "str_1031719054", 
        "str_1044724246", 
        "str_1050144493", 
        "str_1050151853", 
        "str_1052497969", 
        "str_10840589", 
        "str_11013887", 
        "str_110221080", 
        "str_118047708", 
        "str_119286224", 
        "str_124740196", 
        "str_128276866", 
        "str_140626898", 
        "str_142045592", 
        "str_14548643", 
        "str_15267", 
        "str_15552", 
        "str_15586355", 
        "str_15590", 
        "str_15793603", 
        "str_16734883", 
        "str_171666755", 
        "str_173267101", 
        "str_187222440", 
        "str_188112229", 
        "str_189760183", 
        "str_195539842", 
        "str_197364336", 
        "str_200191798", 
        "str_215909707", 
        "str_218997622", 
        "str_221391155", 
        "str_221608524", 
        "str_236819496", 
        "str_24323315", 
        "str_245692261", 
        "str_25550113", 
        "str_260425477", 
        "str_262748659", 
        "str_26595480", 
        "str_268995351", 
        "str_27684", 
        "str_301601544", 
        "str_307711519", 
        "str_307711520", 
        "str_320736607", 
        "str_332938523", 
        "str_34346614", 
        "str_35399249", 
        "str_358533959", 
        "str_360606437", 
        "str_36735500", 
        "str_37228", 
        "str_376268180", 
        "str_380817653", 
        "str_384033014", 
        "str_384189395", 
        "str_385727219", 
        "str_39677390", 
        "str_403177438", 
        "str_405065312", 
        "str_411456915", 
        "str_412173691", 
        "str_421260424", 
        "str_429751348", 
        "str_434472304", 
        "str_434643244", 
        "str_434738890", 
        "str_43793156", 
        "str_440620529", 
        "str_461899299", 
        "str_466443422", 
        "str_474479501", 
        "str_474874", 
        "str_48484082", 
        "str_488213612", 
        "str_488282298", 
        "str_48996679", 
        "str_490918915", 
        "str_533384369", 
        "str_53613786", 
        "str_536282345", 
        "str_540929980", 
        "str_541045427", 
        "str_543324020", 
        "str_572528806", 
        "str_579626", 
        "str_585544529", 
        "str_593046695", 
        "str_600255105", 
        "str_603215579", 
        "str_604279769", 
        "str_626734451", 
        "str_629972820", 
        "str_632067631", 
        "str_642703443", 
        "str_658966400", 
        "str_669717307", 
        "str_705283662", 
        "str_705599013", 
        "str_706554", 
        "str_707067097", 
        "str_709202683", 
        "str_709466", 
        "str_7096282", 
        "str_709875", 
        "str_722666407", 
        "str_72550417", 
        "str_730272386", 
        "str_731306984", 
        "str_731419387", 
        "str_738322", 
        "str_747748554", 
        "str_761787", 
        "str_766615943", 
        "str_767616905", 
        "str_768901977", 
        "str_769605543", 
        "str_774488393", 
        "str_791712760", 
        "str_791712761", 
        "str_797604288", 
        "str_80031588", 
        "str_812672849", 
        "str_819248", 
        "str_819620768", 
        "str_839122464", 
        "str_84203302", 
        "str_877329080", 
        "str_887671200", 
        "str_898632330", 
        "str_9228869", 
        "str_9228977", 
        "str_931209414", 
        "str_942823456", 
        "str_95278588", 
        "str_957027776", 
        "str_965002357", 
        "str_974116503", 
        "str_987425018", 
        "str_991534108", 
        "str_992268699", 
        "str_992291005", 
        "str_998105566", 
        "str_998620162", 
        "strcmp", 
        "strict_strtoul", 
        "strlcpy", 
        "strlen", 
        "strncmp", 
        "synaptics_capability", 
        "synaptics_detect", 
        "synaptics_detect_pkt_type", 
        "synaptics_disconnect", 
        "synaptics_identify", 
        "synaptics_init", 
        "synaptics_is_pt_packet", 
        "synaptics_mode_cmd", 
        "synaptics_model_id", 
        "synaptics_parse_hw_state", 
        "synaptics_pass_pt_packet", 
        "synaptics_process_byte", 
        "synaptics_process_packet", 
        "synaptics_pt_activate", 
        "synaptics_pt_create", 
        "synaptics_pt_write", 
        "synaptics_query_hardware", 
        "synaptics_reconnect", 
        "synaptics_reset", 
        "synaptics_send_cmd", 
        "synaptics_set_absolute_mode", 
        "synaptics_set_rate", 
        "synaptics_validate_byte", 
        "sysfs_create_group", 
        "sysfs_remove_group", 
        "thinking_detect", 
        "touchkit_ps2_detect", 
        "trackpoint_attr_draghys", 
        "trackpoint_attr_ext_dev", 
        "trackpoint_attr_group", 
        "trackpoint_attr_inertia", 
        "trackpoint_attr_jenks", 
        "trackpoint_attr_mindrag", 
        "trackpoint_attr_press_to_select", 
        "trackpoint_attr_reach", 
        "trackpoint_attr_sensitivity", 
        "trackpoint_attr_skipback", 
        "trackpoint_attr_speed", 
        "trackpoint_attr_thresh", 
        "trackpoint_attr_upthresh", 
        "trackpoint_attr_ztime", 
        "trackpoint_attrs", 
        "trackpoint_defaults", 
        "trackpoint_detect", 
        "trackpoint_disconnect", 
        "trackpoint_read", 
        "trackpoint_reconnect", 
        "trackpoint_set_bit_attr", 
        "trackpoint_set_int_attr", 
        "trackpoint_show_int_attr", 
        "trackpoint_start_protocol", 
        "trackpoint_sync", 
        "trackpoint_toggle_bit", 
        "trackpoint_write", 
        "warn_slowpath"};
int function_id_map_len  =    1456;
char str_490918915[12]  =    "psmousebase";
char str_540929980[9]  =    "protocol";
char str_819248[5]  =    "rate";
char str_429751348[11]  =    "resolution";
char str_1050144493[11]  =    "resetafter";
char str_1044724246[12]  =    "resync_time";
char str_707067097[24]  =    "psmouse_mutex.wait_lock";
char str_48484082[14]  =    "psmouse_mutex";
char str_626734451[45]  =    "<4>psmouse.c: %s at %s lost sync at byte %d\n";
char str_898632330[41]  =    "<5>psmouse.c: issuing reconnect request\n";
char str_262748659[44]  =    "<5>psmouse.c: %s at %s - driver resynched.\n";
char str_839122464[12]  =    " bad parity";
char str_0[1]  =    "";
char str_1050151853[9]  =    " timeout";
char str_461899299[39]  =    "<4>psmouse.c: bad data from KBC -%s%s\n";
char str_466443422[70]  =    "<6>psmouse.c: %s at %s lost synchronization, throwing %d bytes away.\n";
char str_189760183[7]  =    "Genius";
char str_10840589[6]  =    "Mouse";
char str_384189395[8]  =    "Generic";
char str_221608524[12]  =    "Wheel Mouse";
char str_731306984[15]  =    "Explorer Mouse";
char str_942823456[11]  =    "Kensington";
char str_188112229[14]  =    "ThinkingMouse";
char str_221391155[8]  =    "Cortron";
char str_957027776[15]  =    "PS/2 Trackball";
char str_579626[5]  =    "PS/2";
char str_709466[5]  =    "bare";
char str_11013887[6]  =    "PS2++";
char str_24323315[9]  =    "logitech";
char str_95278588[10]  =    "ThinkPS/2";
char str_360606437[8]  =    "thinkps";
char str_384033014[8]  =    "GenPS/2";
char str_268995351[7]  =    "genius";
char str_195539842[7]  =    "ImPS/2";
char str_761787[5]  =    "imps";
char str_774488393[9]  =    "ImExPS/2";
char str_738322[5]  =    "exps";
char str_998105566[8]  =    "SynPS/2";
char str_819620768[10]  =    "synaptics";
char str_124740196[9]  =    "AlpsPS/2";
char str_706554[5]  =    "alps";
char str_197364336[7]  =    "LBPS/2";
char str_812672849[9]  =    "lifebook";
char str_218997622[7]  =    "TPPS/2";
char str_604279769[11]  =    "trackpoint";
char str_474479501[12]  =    "CortronPS/2";
char str_260425477[7]  =    "cortps";
char str_709875[5]  =    "auto";
char str_37228[4]  =    "any";
char str_488282298[61]  =    "/scratch/sym/ipc_drivers/psmousebase/psmousebase_annotated.c";
char str_119286224[43]  =    "<4>psmouse.c: Failed to reset mouse on %s\n";
char str_1031719054[23]  =    "psmouse_set_resolution";
char str_48996679[20]  =    "psmouse->resolution";
char str_72550417[28]  =    "psmousebase.merged.kernel.c";
char str_7096282[17]  =    "psmouse_set_rate";
char str_992268699[14]  =    "psmouse->rate";
char str_1023639894[44]  =    "<4>psmouse.c: Failed to enable mouse on %s\n";
char str_965002357[48]  =    "<4>psmouse.c: Failed to deactivate mouse on %s\n";
char str_1013043182[47]  =    "<4>psmouse.c: failed to re-enable mouse on %s\n";
char str_991534108[56]  =    "<6>psmouse.c: resync failed, issuing reconnect request\n";
char str_987425018[9]  =    "%s %s %s";
char str_887671200[31]  =    "&(&psmouse->resync_work)->work";
char str_307711519[10]  =    "%s/input0";
char str_434738890[71]  =    "<7>psmouse: reconnect request, but serio is disconnected, ignoring...\n";
char str_380817653[18]  =    "PS/2 mouse driver";
char str_200191798[8]  =    "psmouse";
char str_998620162[22]  =    "psmouse_show_int_attr";
char str_142045592[40]  =    "psmouse is %p, field is %p, buf is %p.\n";
char str_118047708[7]  =    "*field";
char str_15590[4]  =    "%u\n";
char str_385727219[21]  =    "psmouse_set_int_attr";
char str_173267101[27]  =    "psmouse_attr_show_protocol";
char str_992291005[14]  =    "psmouse->type";
char str_593046695[10]  =    "tmp->name";
char str_215909707[12]  =    "Seeing %s.\n";
char str_110221080[14]  =    "tmp___0->name";
char str_15552[4]  =    "%s\n";
char str_187222440[68]  =    "<4>psmouse: failed to destroy child port, protocol change aborted.\n";
char str_140626898[21]  =    "psmouse_set_maxproto";
char str_245692261[16]  =    "proto->maxproto";
char str_722666407[46]  =    "*((unsigned int *)kp->__annonCompField15.arg)";
char str_600255105[27]  =    "kp->__annonCompField15.arg";
char str_320736607[12]  =    "proto->type";
char str_39677390[21]  =    "psmouse_get_maxproto";
char str_84203302[14]  =    "(\"kpsmoused\")";
char str_1052497969[10]  =    "kpsmoused";
char str_53613786[50]  =    "<3>psmouse: failed to create kpsmoused workqueue\n";
char str_705599013[46]  =    "<4>alps.c: Failed to enable hardware tapping\n";
char str_585544529[43]  =    "<3>alps.c: Failed to enable absolute mode\n";
char str_747748554[41]  =    "<3>alps.c: Failed to enable stream mode\n";
char str_307711520[10]  =    "%s/input1";
char str_434472304[16]  =    "DualPoint Stick";
char str_358533959[11]  =    "PS/2 Mouse";
char str_474874[5]  =    "ALPS";
char str_26595480[19]  =    "DualPoint TouchPad";
char str_709202683[11]  =    "GlidePoint";
char str_658966400[10]  =    "Synaptics";
char str_80031588[9]  =    "TouchPad";
char str_877329080[82]  =    "<3>Synaptics claims to have extended capabilities, but I\'m not able to read them.";
char str_572528806[47]  =    "<6>synaptics: failed to switch guest protocol\n";
char str_731419387[63]  =    "<3>synaptics: not enough memory to allocate pass-through port\n";
char str_25550113[23]  =    "Synaptics pass-through";
char str_488213612[20]  =    "synaptics-pt/serio0";
char str_36735500[25]  =    "<6>serio: %s port at %s\n";
char str_421260424[38]  =    "<3>synaptics: unknown packet type %d\n";
char str_629972820[47]  =    "<6>synaptics: using relaxed packet validation\n";
char str_642703443[40]  =    "<3>Unable to query Synaptics hardware.\n";
char str_35399249[45]  =    "<3>Unable to initialize Synaptics hardware.\n";
char str_543324020[75]  =    "<6>Synaptics Touchpad, model: %ld, fw: %ld.%ld, id: %#lx, caps: %#lx/%#lx\n";
char str_669717307[14]  =    "FLORA-ie 55mi";
char str_332938523[11]  =    "LifeBook B";
char str_412173691[11]  =    "Lifebook B";
char str_405065312[21]  =    "Lifebook B213x/B2150";
char str_236819496[7]  =    "Zephyr";
char str_9228869[6]  =    "CF-18";
char str_603215579[15]  =    "isa0060/serio3";
char str_791712760[16]  =    "Panasonic CF-28";
char str_791712761[16]  =    "Panasonic CF-29";
char str_9228977[6]  =    "CF-72";
char str_1010884528[14]  =    "Lifebook B142";
char str_536282345[66]  =    "<4>lifebook.c: got relative packet but no relative device set up\n";
char str_376268180[8]  =    "Fujitsu";
char str_434643244[21]  =    "Lifebook TouchScreen";
char str_128276866[14]  =    "PS/2 Touchpad";
char str_15267[4]  =    "%d\n";
char str_1017698982[12]  =    "smartscroll";
char str_403177438[56]  =    "<4>logips2pp: Detected unknown logitech mouse model %d\n";
char str_43793156[9]  =    "MX Mouse";
char str_974116503[11]  =    "TouchPad 3";
char str_171666755[9]  =    "TrackMan";
char str_411456915[9]  =    "Logitech";
char str_533384369[73]  =    "<3>logips2pp.c: failed to create smartscroll sysfs attribute, error: %d\n";
char str_766615943[12]  =    "sensitivity";
char str_15793603[6]  =    "speed";
char str_931209414[8]  =    "inertia";
char str_15586355[6]  =    "reach";
char str_705283662[8]  =    "draghys";
char str_34346614[8]  =    "mindrag";
char str_301601544[7]  =    "thresh";
char str_632067631[9]  =    "upthresh";
char str_16734883[6]  =    "ztime";
char str_14548643[6]  =    "jenks";
char str_797604288[16]  =    "press_to_select";
char str_730272386[9]  =    "skipback";
char str_769605543[8]  =    "ext_dev";
char str_541045427[53]  =    "<4>trackpoint.c: failed to get extended button data\n";
char str_27684[4]  =    "IBM";
char str_768901977[11]  =    "TrackPoint";
char str_440620529[63]  =    "<3>trackpoint.c: failed to create sysfs attributes, error: %d\n";
char str_767616905[52]  =    "<6>IBM TrackPoint firmware: 0x%02x, buttons: %d/%d\n";
int logSfiFrame(char *func ) ;
//#line  5 "psmousebase.merged.kernel.c"
typedef __builtin_va_list __gnuc_va_list;
//#line  7 "psmousebase.merged.kernel.c"
typedef __gnuc_va_list va_list;
//#line  9 "psmousebase.merged.kernel.c"
typedef unsigned int __kernel_mode_t;
//#line  11 "psmousebase.merged.kernel.c"
typedef int __kernel_pid_t;
//#line  13 "psmousebase.merged.kernel.c"
typedef unsigned int __kernel_uid_t;
//#line  15 "psmousebase.merged.kernel.c"
typedef unsigned int __kernel_gid_t;
//#line  17 "psmousebase.merged.kernel.c"
typedef unsigned long __kernel_size_t;
//#line  19 "psmousebase.merged.kernel.c"
typedef long __kernel_ssize_t;
//#line  21 "psmousebase.merged.kernel.c"
typedef long __kernel_time_t;
//#line  23 "psmousebase.merged.kernel.c"
typedef long __kernel_clock_t;
//#line  25 "psmousebase.merged.kernel.c"
typedef int __kernel_timer_t;
//#line  27 "psmousebase.merged.kernel.c"
typedef int __kernel_clockid_t;
//#line  29 "psmousebase.merged.kernel.c"
typedef long long __kernel_loff_t;
//#line  31 "psmousebase.merged.kernel.c"
typedef __kernel_uid_t __kernel_uid32_t;
//#line  33 "psmousebase.merged.kernel.c"
typedef __kernel_gid_t __kernel_gid32_t;
//#line  35 "psmousebase.merged.kernel.c"
typedef signed char __s8;
//#line  37 "psmousebase.merged.kernel.c"
typedef unsigned char __u8;
//#line  39 "psmousebase.merged.kernel.c"
typedef short __s16;
//#line  41 "psmousebase.merged.kernel.c"
typedef unsigned short __u16;
//#line  43 "psmousebase.merged.kernel.c"
typedef int __s32;
//#line  45 "psmousebase.merged.kernel.c"
typedef unsigned int __u32;
//#line  47 "psmousebase.merged.kernel.c"
typedef long long __s64;
//#line  49 "psmousebase.merged.kernel.c"
typedef unsigned long long __u64;
//#line  51 "psmousebase.merged.kernel.c"
typedef signed char s8;
//#line  53 "psmousebase.merged.kernel.c"
typedef unsigned char u8;
//#line  55 "psmousebase.merged.kernel.c"
typedef unsigned short u16;
//#line  57 "psmousebase.merged.kernel.c"
typedef unsigned int u32;
//#line  59 "psmousebase.merged.kernel.c"
typedef long long s64;
//#line  61 "psmousebase.merged.kernel.c"
typedef unsigned long long u64;
//#line  63 "psmousebase.merged.kernel.c"
typedef unsigned short umode_t;
//#line  65 "psmousebase.merged.kernel.c"
typedef __u32 __kernel_dev_t;
//#line  67 "psmousebase.merged.kernel.c"
typedef __kernel_dev_t dev_t;
//#line  69 "psmousebase.merged.kernel.c"
typedef __kernel_mode_t mode_t;
//#line  71 "psmousebase.merged.kernel.c"
typedef __kernel_pid_t pid_t;
//#line  73 "psmousebase.merged.kernel.c"
typedef __kernel_timer_t timer_t;
//#line  75 "psmousebase.merged.kernel.c"
typedef __kernel_clockid_t clockid_t;
//#line  77 "psmousebase.merged.kernel.c"
typedef __kernel_uid32_t uid_t;
//#line  79 "psmousebase.merged.kernel.c"
typedef __kernel_gid32_t gid_t;
//#line  81 "psmousebase.merged.kernel.c"
typedef __kernel_loff_t loff_t;
//#line  83 "psmousebase.merged.kernel.c"
typedef __kernel_size_t size_t;
//#line  85 "psmousebase.merged.kernel.c"
typedef __kernel_ssize_t ssize_t;
//#line  87 "psmousebase.merged.kernel.c"
typedef __kernel_time_t time_t;
//#line  89 "psmousebase.merged.kernel.c"
typedef __kernel_clock_t clock_t;
//#line  91 "psmousebase.merged.kernel.c"
typedef __s32 int32_t;
//#line  93 "psmousebase.merged.kernel.c"
typedef __u32 uint32_t;
//#line  95 "psmousebase.merged.kernel.c"
typedef unsigned long sector_t;
//#line  97 "psmousebase.merged.kernel.c"
typedef unsigned long blkcnt_t;
//#line  99 "psmousebase.merged.kernel.c"
typedef unsigned int gfp_t;
//#line  101 "psmousebase.merged.kernel.c"
typedef unsigned int fmode_t;
//#line  103 "psmousebase.merged.kernel.c"
struct __anonstruct_atomic_t_7 {
   int volatile   counter ;
};
//#line  107 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_atomic_t_7 atomic_t;
//#line  109 "psmousebase.merged.kernel.c"
struct __anonstruct_atomic64_t_8 {
   long volatile   counter ;
};
//#line  113 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_atomic64_t_8 atomic64_t;
//#line  115
struct module;
struct module;
//#line  117 "psmousebase.merged.kernel.c"
struct bug_entry {
   int bug_addr_disp ;
   int file_disp ;
   unsigned short line ;
   unsigned short flags ;
};
//#line  124
struct completion;
struct completion;
//#line  126
struct pt_regs;
struct pt_regs;
//#line  128
struct pid;
struct pid;
//#line  130
struct task_struct;
struct task_struct;
//#line  132
struct mm_struct;
struct mm_struct;
//#line  134 "psmousebase.merged.kernel.c"
struct pt_regs {
   unsigned long r15 ;
   unsigned long r14 ;
   unsigned long r13 ;
   unsigned long r12 ;
   unsigned long bp ;
   unsigned long bx ;
   unsigned long r11 ;
   unsigned long r10 ;
   unsigned long r9 ;
   unsigned long r8 ;
   unsigned long ax ;
   unsigned long cx ;
   unsigned long dx ;
   unsigned long si ;
   unsigned long di ;
   unsigned long orig_ax ;
   unsigned long ip ;
   unsigned long cs ;
   unsigned long flags ;
   unsigned long sp ;
   unsigned long ss ;
};
//#line  158 "psmousebase.merged.kernel.c"
struct kernel_vm86_regs {
   struct pt_regs pt ;
   unsigned short es ;
   unsigned short __esh ;
   unsigned short ds ;
   unsigned short __dsh ;
   unsigned short fs ;
   unsigned short __fsh ;
   unsigned short gs ;
   unsigned short __gsh ;
};
//#line  170 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_10 {
   struct pt_regs *regs ;
   struct kernel_vm86_regs *vm86 ;
};
//#line  175 "psmousebase.merged.kernel.c"
struct math_emu_info {
   long ___orig_eip ;
   union __anonunion____missing_field_name_10 __annonCompField4 ;
};
//#line  180 "psmousebase.merged.kernel.c"
typedef unsigned long pgdval_t;
//#line  182 "psmousebase.merged.kernel.c"
typedef unsigned long pgprotval_t;
//#line  184
struct page;
struct page;
//#line  186 "psmousebase.merged.kernel.c"
struct __anonstruct_pgd_t_13 {
   pgdval_t pgd ;
};
//#line  190 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_pgd_t_13 pgd_t;
//#line  192 "psmousebase.merged.kernel.c"
struct __anonstruct_pgprot_t_14 {
   pgprotval_t pgprot ;
};
//#line  196 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_pgprot_t_14 pgprot_t;
//#line  198 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_18 {
   unsigned int a ;
   unsigned int b ;
};
//#line  203 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_19 {
   u16 limit0 ;
   u16 base0 ;
   unsigned int base1 : 8 ;
   unsigned int type : 4 ;
   unsigned int s : 1 ;
   unsigned int dpl : 2 ;
   unsigned int p : 1 ;
   unsigned int limit : 4 ;
   unsigned int avl : 1 ;
   unsigned int l : 1 ;
   unsigned int d : 1 ;
   unsigned int g : 1 ;
   unsigned int base2 : 8 ;
};
//#line  219 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_17 {
   struct __anonstruct____missing_field_name_18 __annonCompField6 ;
   struct __anonstruct____missing_field_name_19 __annonCompField7 ;
};
//#line  224 "psmousebase.merged.kernel.c"
struct desc_struct {
   union __anonunion____missing_field_name_17 __annonCompField8 ;
} __attribute__((__packed__)) ;
//#line  228
struct ds_context;
struct ds_context;
//#line  230
struct bts_tracer;
struct bts_tracer;
//#line  232
struct exec_domain;
struct exec_domain;
//#line  234
struct map_segment;
struct map_segment;
//#line  236 "psmousebase.merged.kernel.c"
struct exec_domain {
   char const   *name ;
   void (*handler)(int  , struct pt_regs * ) ;
   unsigned char pers_low ;
   unsigned char pers_high ;
   unsigned long *signal_map ;
   unsigned long *signal_invmap ;
   struct map_segment *err_map ;
   struct map_segment *socktype_map ;
   struct map_segment *sockopt_map ;
   struct map_segment *af_map ;
   struct module *module ;
   struct exec_domain *next ;
};
//#line  251 "psmousebase.merged.kernel.c"
struct cpumask {
   unsigned long bits[((255UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
};
//#line  255 "psmousebase.merged.kernel.c"
typedef struct cpumask cpumask_t;
//#line  257
struct thread_struct;
struct thread_struct;
//#line  259 "psmousebase.merged.kernel.c"
struct i387_fsave_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u32 status ;
};
//#line  271 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_28 {
   u64 rip ;
   u64 rdp ;
};
//#line  276 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_29 {
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
};
//#line  283 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_27 {
   struct __anonstruct____missing_field_name_28 __annonCompField9 ;
   struct __anonstruct____missing_field_name_29 __annonCompField10 ;
};
//#line  288 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_30 {
   u32 padding1[12] ;
   u32 sw_reserved[12] ;
};
//#line  293 "psmousebase.merged.kernel.c"
struct i387_fxsave_struct {
   u16 cwd ;
   u16 swd ;
   u16 twd ;
   u16 fop ;
   union __anonunion____missing_field_name_27 __annonCompField11 ;
   u32 mxcsr ;
   u32 mxcsr_mask ;
   u32 st_space[32] ;
   u32 xmm_space[64] ;
   u32 padding[12] ;
   union __anonunion____missing_field_name_30 __annonCompField12 ;
} __attribute__((__aligned__(16))) ;
//#line  307 "psmousebase.merged.kernel.c"
struct i387_soft_struct {
   u32 cwd ;
   u32 swd ;
   u32 twd ;
   u32 fip ;
   u32 fcs ;
   u32 foo ;
   u32 fos ;
   u32 st_space[20] ;
   u8 ftop ;
   u8 changed ;
   u8 lookahead ;
   u8 no_update ;
   u8 rm ;
   u8 alimit ;
   struct math_emu_info *info ;
   u32 entry_eip ;
};
//#line  326 "psmousebase.merged.kernel.c"
struct xsave_hdr_struct {
   u64 xstate_bv ;
   u64 reserved1[2] ;
   u64 reserved2[5] ;
} __attribute__((__packed__)) ;
//#line  332 "psmousebase.merged.kernel.c"
struct xsave_struct {
   struct i387_fxsave_struct i387 ;
   struct xsave_hdr_struct xsave_hdr ;
} __attribute__((__packed__, __aligned__(64))) ;
//#line  337 "psmousebase.merged.kernel.c"
union thread_xstate {
   struct i387_fsave_struct fsave ;
   struct i387_fxsave_struct fxsave ;
   struct i387_soft_struct soft ;
   struct xsave_struct xsave ;
};
//#line  344
struct kmem_cache;
struct kmem_cache;
//#line  346 "psmousebase.merged.kernel.c"
struct thread_struct {
   struct desc_struct tls_array[3] ;
   unsigned long sp0 ;
   unsigned long sp ;
   unsigned long usersp ;
   unsigned short es ;
   unsigned short ds ;
   unsigned short fsindex ;
   unsigned short gsindex ;
   unsigned long ip ;
   unsigned long fs ;
   unsigned long gs ;
   unsigned long debugreg0 ;
   unsigned long debugreg1 ;
   unsigned long debugreg2 ;
   unsigned long debugreg3 ;
   unsigned long debugreg6 ;
   unsigned long debugreg7 ;
   unsigned long cr2 ;
   unsigned long trap_no ;
   unsigned long error_code ;
   union thread_xstate *xstate ;
   unsigned long *io_bitmap_ptr ;
   unsigned long iopl ;
   unsigned int io_bitmap_max ;
   unsigned long debugctlmsr ;
   struct ds_context *ds_ctx ;
   unsigned int bts_ovfl_signal ;
};
//#line  376 "psmousebase.merged.kernel.c"
struct __anonstruct_mm_segment_t_31 {
   unsigned long seg ;
};
//#line  380 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_mm_segment_t_31 mm_segment_t;
//#line  382 "psmousebase.merged.kernel.c"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
//#line  387
struct hlist_node;
struct hlist_node;
//#line  389 "psmousebase.merged.kernel.c"
struct hlist_head {
   struct hlist_node *first ;
};
//#line  393 "psmousebase.merged.kernel.c"
struct hlist_node {
   struct hlist_node *next ;
   struct hlist_node **pprev ;
};
//#line  398
struct timespec;
struct timespec;
//#line  400
struct compat_timespec;
struct compat_timespec;
//#line  402 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_33 {
   unsigned long arg0 ;
   unsigned long arg1 ;
   unsigned long arg2 ;
   unsigned long arg3 ;
};
//#line  409 "psmousebase.merged.kernel.c"
struct __anonstruct_futex_34 {
   u32 *uaddr ;
   u32 val ;
   u32 flags ;
   u32 bitset ;
   u64 time ;
};
//#line  417 "psmousebase.merged.kernel.c"
struct __anonstruct_nanosleep_35 {
   clockid_t index ;
   struct timespec *rmtp ;
   struct compat_timespec *compat_rmtp ;
   u64 expires ;
};
//#line  424
struct pollfd;
struct pollfd;
//#line  426 "psmousebase.merged.kernel.c"
struct __anonstruct_poll_36 {
   struct pollfd *ufds ;
   int nfds ;
   int has_timeout ;
   unsigned long tv_sec ;
   unsigned long tv_nsec ;
};
//#line  434 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_32 {
   struct __anonstruct____missing_field_name_33 __annonCompField13 ;
   struct __anonstruct_futex_34 futex ;
   struct __anonstruct_nanosleep_35 nanosleep ;
   struct __anonstruct_poll_36 poll ;
};
//#line  441 "psmousebase.merged.kernel.c"
struct restart_block {
   long (*fn)(struct restart_block * ) ;
   union __anonunion____missing_field_name_32 __annonCompField14 ;
};
//#line  446 "psmousebase.merged.kernel.c"
typedef atomic64_t atomic_long_t;
//#line  448 "psmousebase.merged.kernel.c"
struct thread_info {
   struct task_struct *task ;
   struct exec_domain *exec_domain ;
   __u32 flags ;
   __u32 status ;
   __u32 cpu ;
   int preempt_count ;
   mm_segment_t addr_limit ;
   struct restart_block restart_block ;
   void *sysenter_return ;
};
//#line  460 "psmousebase.merged.kernel.c"
struct raw_spinlock {
   unsigned int slock ;
};
//#line  464 "psmousebase.merged.kernel.c"
typedef struct raw_spinlock raw_spinlock_t;
//#line  466 "psmousebase.merged.kernel.c"
struct __anonstruct_raw_rwlock_t_37 {
   unsigned int lock ;
};
//#line  470 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_raw_rwlock_t_37 raw_rwlock_t;
//#line  472
struct lockdep_map;
struct lockdep_map;
//#line  474 "psmousebase.merged.kernel.c"
struct stack_trace {
   unsigned int nr_entries ;
   unsigned int max_entries ;
   unsigned long *entries ;
   int skip ;
};
//#line  481 "psmousebase.merged.kernel.c"
struct lockdep_subclass_key {
   char __one_byte ;
} __attribute__((__packed__)) ;
//#line  485 "psmousebase.merged.kernel.c"
struct lock_class_key {
   struct lockdep_subclass_key subkeys[8UL] ;
};
//#line  489 "psmousebase.merged.kernel.c"
struct lock_class {
   struct list_head hash_entry ;
   struct list_head lock_entry ;
   struct lockdep_subclass_key *key ;
   unsigned int subclass ;
   unsigned int dep_gen_id ;
   unsigned long usage_mask ;
   struct stack_trace usage_traces[9] ;
   struct list_head locks_after ;
   struct list_head locks_before ;
   unsigned int version ;
   unsigned long ops ;
   char const   *name ;
   int name_version ;
};
//#line  505 "psmousebase.merged.kernel.c"
struct lockdep_map {
   struct lock_class_key *key ;
   struct lock_class *class_cache ;
   char const   *name ;
};
//#line  511 "psmousebase.merged.kernel.c"
struct held_lock {
   u64 prev_chain_key ;
   unsigned long acquire_ip ;
   struct lockdep_map *instance ;
   struct lockdep_map *nest_lock ;
   unsigned int class_idx : 13 ;
   unsigned int irq_context : 2 ;
   unsigned int trylock : 1 ;
   unsigned int read : 2 ;
   unsigned int check : 2 ;
   unsigned int hardirqs_off : 1 ;
};
//#line  524 "psmousebase.merged.kernel.c"
struct __anonstruct_spinlock_t_38 {
   raw_spinlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  532 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_spinlock_t_38 spinlock_t;
//#line  534 "psmousebase.merged.kernel.c"
struct __anonstruct_rwlock_t_39 {
   raw_rwlock_t raw_lock ;
   unsigned int magic ;
   unsigned int owner_cpu ;
   void *owner ;
   struct lockdep_map dep_map ;
};
//#line  542 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_rwlock_t_39 rwlock_t;
//#line  544 "psmousebase.merged.kernel.c"
struct timespec {
   time_t tv_sec ;
   long tv_nsec ;
};
//#line  549 "psmousebase.merged.kernel.c"
struct kstat {
   u64 ino ;
   dev_t dev ;
   umode_t mode ;
   unsigned int nlink ;
   uid_t uid ;
   gid_t gid ;
   dev_t rdev ;
   loff_t size ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   unsigned long blksize ;
   unsigned long long blocks ;
};
//#line  565
struct __wait_queue;
struct __wait_queue;
//#line  567 "psmousebase.merged.kernel.c"
typedef struct __wait_queue wait_queue_t;
//#line  569 "psmousebase.merged.kernel.c"
struct __wait_queue {
   unsigned int flags ;
   void *private ;
   int (*func)(wait_queue_t *wait , unsigned int mode , int sync , void *key ) ;
   struct list_head task_list ;
};
//#line  576 "psmousebase.merged.kernel.c"
struct __wait_queue_head {
   spinlock_t lock ;
   struct list_head task_list ;
};
//#line  581 "psmousebase.merged.kernel.c"
typedef struct __wait_queue_head wait_queue_head_t;
//#line  583 "psmousebase.merged.kernel.c"
struct mutex {
   atomic_t count ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct thread_info *owner ;
   char const   *name ;
   void *magic ;
   struct lockdep_map dep_map ;
};
//#line  593 "psmousebase.merged.kernel.c"
struct mutex_waiter {
   struct list_head list ;
   struct task_struct *task ;
   struct mutex *lock ;
   void *magic ;
};
//#line  600
struct rw_semaphore;
struct rw_semaphore;
//#line  602 "psmousebase.merged.kernel.c"
struct rw_semaphore {
   __s32 activity ;
   spinlock_t wait_lock ;
   struct list_head wait_list ;
   struct lockdep_map dep_map ;
};
//#line  609
struct file;
struct file;
//#line  611
struct device;
struct device;
//#line  613 "psmousebase.merged.kernel.c"
struct pm_message {
   int event ;
};
//#line  617 "psmousebase.merged.kernel.c"
typedef struct pm_message pm_message_t;
//#line  619 "psmousebase.merged.kernel.c"
struct dev_pm_ops {
   int (*prepare)(struct device *dev ) ;
   void (*complete)(struct device *dev ) ;
   int (*suspend)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   int (*freeze)(struct device *dev ) ;
   int (*thaw)(struct device *dev ) ;
   int (*poweroff)(struct device *dev ) ;
   int (*restore)(struct device *dev ) ;
   int (*suspend_noirq)(struct device *dev ) ;
   int (*resume_noirq)(struct device *dev ) ;
   int (*freeze_noirq)(struct device *dev ) ;
   int (*thaw_noirq)(struct device *dev ) ;
   int (*poweroff_noirq)(struct device *dev ) ;
   int (*restore_noirq)(struct device *dev ) ;
};
//#line  636
enum dpm_state {
    DPM_INVALID = 0,
    DPM_ON = 1,
    DPM_PREPARING = 2,
    DPM_RESUMING = 3,
    DPM_SUSPENDING = 4,
    DPM_OFF = 5,
    DPM_OFF_IRQ = 6
} ;
//#line  646 "psmousebase.merged.kernel.c"
struct dev_pm_info {
   pm_message_t power_state ;
   unsigned int can_wakeup : 1 ;
   unsigned int should_wakeup : 1 ;
   enum dpm_state status ;
   struct list_head entry ;
};
//#line  654 "psmousebase.merged.kernel.c"
struct __anonstruct_mm_context_t_90 {
   void *ldt ;
   int size ;
   struct mutex lock ;
   void *vdso ;
};
//#line  661 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_mm_context_t_90 mm_context_t;
//#line  663
struct pci_bus;
struct pci_bus;
//#line  665
struct vm_area_struct;
struct vm_area_struct;
//#line  667
struct key;
struct key;
//#line  669 "psmousebase.merged.kernel.c"
typedef __u64 Elf64_Addr;
//#line  671 "psmousebase.merged.kernel.c"
typedef __u16 Elf64_Half;
//#line  673 "psmousebase.merged.kernel.c"
typedef __u32 Elf64_Word;
//#line  675 "psmousebase.merged.kernel.c"
typedef __u64 Elf64_Xword;
//#line  677 "psmousebase.merged.kernel.c"
struct elf64_sym {
   Elf64_Word st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   Elf64_Half st_shndx ;
   Elf64_Addr st_value ;
   Elf64_Xword st_size ;
};
//#line  686 "psmousebase.merged.kernel.c"
typedef struct elf64_sym Elf64_Sym;
//#line  688
struct kobject;
struct kobject;
//#line  690 "psmousebase.merged.kernel.c"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
//#line  696 "psmousebase.merged.kernel.c"
struct attribute_group {
   char const   *name ;
   mode_t (*is_visible)(struct kobject * , struct attribute * , int  ) ;
   struct attribute **attrs ;
};
//#line  702 "psmousebase.merged.kernel.c"
struct sysfs_ops {
   ssize_t (*show)(struct kobject * , struct attribute * , char * ) ;
   ssize_t (*store)(struct kobject * , struct attribute * , char const   * , size_t  ) ;
};
//#line  707
struct sysfs_dirent;
struct sysfs_dirent;
//#line  709 "psmousebase.merged.kernel.c"
struct kref {
   atomic_t refcount ;
};
//#line  713
struct kset;
struct kset;
//#line  715
struct kobj_type;
struct kobj_type;
//#line  717 "psmousebase.merged.kernel.c"
struct kobject {
   char const   *name ;
   struct list_head entry ;
   struct kobject *parent ;
   struct kset *kset ;
   struct kobj_type *ktype ;
   struct sysfs_dirent *sd ;
   struct kref kref ;
   unsigned int state_initialized : 1 ;
   unsigned int state_in_sysfs : 1 ;
   unsigned int state_add_uevent_sent : 1 ;
   unsigned int state_remove_uevent_sent : 1 ;
};
//#line  731 "psmousebase.merged.kernel.c"
struct kobj_type {
   void (*release)(struct kobject *kobj ) ;
   struct sysfs_ops *sysfs_ops ;
   struct attribute **default_attrs ;
};
//#line  737 "psmousebase.merged.kernel.c"
struct kobj_uevent_env {
   char *envp[32] ;
   int envp_idx ;
   char buf[2048] ;
   int buflen ;
};
//#line  744 "psmousebase.merged.kernel.c"
struct kset_uevent_ops {
   int (*filter)(struct kset *kset , struct kobject *kobj ) ;
   char const   *(*name)(struct kset *kset , struct kobject *kobj ) ;
   int (*uevent)(struct kset *kset , struct kobject *kobj , struct kobj_uevent_env *env ) ;
};
//#line  750 "psmousebase.merged.kernel.c"
struct kset {
   struct list_head list ;
   spinlock_t list_lock ;
   struct kobject kobj ;
   struct kset_uevent_ops *uevent_ops ;
};
//#line  757
struct kernel_param;
struct kernel_param;
//#line  759
struct kparam_string;
struct kparam_string;
//#line  761
struct kparam_array;
struct kparam_array;
//#line  763 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_100 {
   void *arg ;
   struct kparam_string  const  *str ;
   struct kparam_array  const  *arr ;
};
//#line  769 "psmousebase.merged.kernel.c"
struct kernel_param {
   char const   *name ;
   unsigned int perm ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   union __anonunion____missing_field_name_100 __annonCompField15 ;
};
//#line  777 "psmousebase.merged.kernel.c"
struct kparam_string {
   unsigned int maxlen ;
   char *string ;
};
//#line  782 "psmousebase.merged.kernel.c"
struct kparam_array {
   unsigned int max ;
   unsigned int *num ;
   int (*set)(char const   *val , struct kernel_param *kp ) ;
   int (*get)(char *buffer , struct kernel_param *kp ) ;
   unsigned int elemsize ;
   void *elem ;
};
//#line  791
struct marker;
struct marker;
//#line  793 "psmousebase.merged.kernel.c"
typedef void marker_probe_func(void *probe_private , void *call_private , char const   *fmt ,
                               va_list *args );
//#line  796 "psmousebase.merged.kernel.c"
struct marker_probe_closure {
   marker_probe_func *func ;
   void *probe_private ;
};
//#line  801 "psmousebase.merged.kernel.c"
struct marker {
   char const   *name ;
   char const   *format ;
   char state ;
   char ptype ;
   void (*call)(struct marker  const  *mdata , void *call_private  , ...) ;
   struct marker_probe_closure single ;
   struct marker_probe_closure *multi ;
   char const   *tp_name ;
   void *tp_cb ;
} __attribute__((__aligned__(8))) ;
//#line  813 "psmousebase.merged.kernel.c"
union ktime {
   s64 tv64 ;
};
//#line  817 "psmousebase.merged.kernel.c"
typedef union ktime ktime_t;
//#line  819 "psmousebase.merged.kernel.c"
struct tvec {
   struct list_head vec[1 << 6] ;
};
//#line  823 "psmousebase.merged.kernel.c"
struct tvec_root {
   struct list_head vec[1 << 8] ;
};
//#line  827
struct timer_list;
struct timer_list;
//#line  829 "psmousebase.merged.kernel.c"
struct tvec_base {
   spinlock_t lock ;
   struct timer_list *running_timer ;
   unsigned long timer_jiffies ;
   struct tvec_root tv1 ;
   struct tvec tv2 ;
   struct tvec tv3 ;
   struct tvec tv4 ;
   struct tvec tv5 ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
//#line  840 "psmousebase.merged.kernel.c"
struct timer_list {
   struct list_head  __attribute__((__noderef__, __address_space__(2))) entry ;
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   struct tvec_base * __attribute__((__noderef__, __address_space__(2))) base ;
};
//#line  848
struct hrtimer;
struct hrtimer;
//#line  850
enum hrtimer_restart;
enum hrtimer_restart;
//#line  852
struct workqueue_struct;
struct workqueue_struct;
//#line  854
struct work_struct;
struct work_struct;
//#line  856 "psmousebase.merged.kernel.c"
struct work_struct {
   atomic_long_t data ;
   struct list_head  __attribute__((__noderef__, __address_space__(2))) entry ;
   void (*func)(struct work_struct *work ) ;
   struct lockdep_map lockdep_map ;
};
//#line  863 "psmousebase.merged.kernel.c"
struct delayed_work {
   struct work_struct work ;
   struct timer_list timer ;
};
//#line  868 "psmousebase.merged.kernel.c"
struct kmem_cache_cpu {
   void **freelist ;
   struct page *page ;
   int node ;
   unsigned int offset ;
   unsigned int objsize ;
};
//#line  876 "psmousebase.merged.kernel.c"
struct kmem_cache_node {
   spinlock_t list_lock ;
   unsigned long nr_partial ;
   unsigned long min_partial ;
   struct list_head partial ;
   atomic_long_t nr_slabs ;
   atomic_long_t total_objects ;
   struct list_head full ;
};
//#line  886 "psmousebase.merged.kernel.c"
struct kmem_cache_order_objects {
   unsigned long x ;
};
//#line  890 "psmousebase.merged.kernel.c"
struct kmem_cache {
   unsigned long flags ;
   int size ;
   int objsize ;
   int offset ;
   struct kmem_cache_order_objects oo ;
   struct kmem_cache_node local_node ;
   struct kmem_cache_order_objects max ;
   struct kmem_cache_order_objects min ;
   gfp_t allocflags ;
   int refcount ;
   void (*ctor)(void * ) ;
   int inuse ;
   int align ;
   char const   *name ;
   struct list_head list ;
   struct kobject kobj ;
   int remote_node_defrag_ratio ;
   struct kmem_cache_node *node[1 << 6] ;
   struct kmem_cache_cpu *cpu_slab[255] ;
};
//#line  912 "psmousebase.merged.kernel.c"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
//#line  917 "psmousebase.merged.kernel.c"
struct rcu_head {
   struct rcu_head *next ;
   void (*func)(struct rcu_head *head ) ;
};
//#line  922
struct tracepoint;
struct tracepoint;
//#line  924 "psmousebase.merged.kernel.c"
struct tracepoint {
   char const   *name ;
   int state ;
   void **funcs ;
} __attribute__((__aligned__(32))) ;
//#line  930 "psmousebase.merged.kernel.c"
struct mod_arch_specific {

};
//#line  934 "psmousebase.merged.kernel.c"
struct kernel_symbol {
   unsigned long value ;
   char const   *name ;
};
//#line  939 "psmousebase.merged.kernel.c"
struct module_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct module_attribute * , struct module * , char * ) ;
   ssize_t (*store)(struct module_attribute * , struct module * , char const   * ,
                    size_t count ) ;
   void (*setup)(struct module * , char const   * ) ;
   int (*test)(struct module * ) ;
   void (*free)(struct module * ) ;
};
//#line  949
struct module_param_attrs;
struct module_param_attrs;
//#line  951 "psmousebase.merged.kernel.c"
struct module_kobject {
   struct kobject kobj ;
   struct module *mod ;
   struct kobject *drivers_dir ;
   struct module_param_attrs *mp ;
};
//#line  958
struct exception_table_entry;
struct exception_table_entry;
//#line  960
enum module_state {
    MODULE_STATE_LIVE = 0,
    MODULE_STATE_COMING = 1,
    MODULE_STATE_GOING = 2
} ;
//#line  966
struct module_sect_attrs;
struct module_sect_attrs;
//#line  968
struct module_notes_attrs;
struct module_notes_attrs;
//#line  970 "psmousebase.merged.kernel.c"
struct module {
   enum module_state state ;
   struct list_head list ;
   char name[64UL - sizeof(unsigned long )] ;
   struct module_kobject mkobj ;
   struct module_attribute *modinfo_attrs ;
   char const   *version ;
   char const   *srcversion ;
   struct kobject *holders_dir ;
   struct kernel_symbol  const  *syms ;
   unsigned long const   *crcs ;
   unsigned int num_syms ;
   unsigned int num_gpl_syms ;
   struct kernel_symbol  const  *gpl_syms ;
   unsigned long const   *gpl_crcs ;
   struct kernel_symbol  const  *gpl_future_syms ;
   unsigned long const   *gpl_future_crcs ;
   unsigned int num_gpl_future_syms ;
   unsigned int num_exentries ;
   struct exception_table_entry *extable ;
   int (*init)(void) ;
   void *module_init ;
   void *module_core ;
   unsigned int init_size ;
   unsigned int core_size ;
   unsigned int init_text_size ;
   unsigned int core_text_size ;
   struct mod_arch_specific arch ;
   unsigned int taints ;
   unsigned int num_bugs ;
   struct list_head bug_list ;
   struct bug_entry *bug_table ;
   Elf64_Sym *symtab ;
   unsigned int num_symtab ;
   char *strtab ;
   struct module_sect_attrs *sect_attrs ;
   struct module_notes_attrs *notes_attrs ;
   void *percpu ;
   char *args ;
   struct marker *markers ;
   unsigned int num_markers ;
   struct tracepoint *tracepoints ;
   unsigned int num_tracepoints ;
   struct list_head modules_which_use_me ;
   struct task_struct *waiter ;
   void (*exit)(void) ;
   char *refptr ;
};
//#line  1019
struct device_driver;
struct device_driver;
//#line  1021 "psmousebase.merged.kernel.c"
typedef int irqreturn_t;
//#line  1023 "psmousebase.merged.kernel.c"
struct kernel_cap_struct {
   __u32 cap[2] ;
};
//#line  1027 "psmousebase.merged.kernel.c"
typedef struct kernel_cap_struct kernel_cap_t;
//#line  1029
struct dentry;
struct dentry;
//#line  1031 "psmousebase.merged.kernel.c"
struct rb_node {
   unsigned long rb_parent_color ;
   struct rb_node *rb_right ;
   struct rb_node *rb_left ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  1037 "psmousebase.merged.kernel.c"
struct rb_root {
   struct rb_node *rb_node ;
};
//#line  1041
struct prio_tree_node;
struct prio_tree_node;
//#line  1043 "psmousebase.merged.kernel.c"
struct raw_prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
};
//#line  1049 "psmousebase.merged.kernel.c"
struct prio_tree_node {
   struct prio_tree_node *left ;
   struct prio_tree_node *right ;
   struct prio_tree_node *parent ;
   unsigned long start ;
   unsigned long last ;
};
//#line  1057 "psmousebase.merged.kernel.c"
struct prio_tree_root {
   struct prio_tree_node *prio_tree_node ;
   unsigned short index_bits ;
   unsigned short raw ;
};
//#line  1063
struct address_space;
struct address_space;
//#line  1065 "psmousebase.merged.kernel.c"
typedef atomic_long_t mm_counter_t;
//#line  1067 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_104 {
   u16 inuse ;
   u16 objects ;
};
//#line  1072 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_103 {
   atomic_t _mapcount ;
   struct __anonstruct____missing_field_name_104 __annonCompField16 ;
};
//#line  1077 "psmousebase.merged.kernel.c"
struct __anonstruct____missing_field_name_106 {
   unsigned long private ;
   struct address_space *mapping ;
};
//#line  1082 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_105 {
   struct __anonstruct____missing_field_name_106 __annonCompField18 ;
   spinlock_t ptl ;
   struct kmem_cache *slab ;
   struct page *first_page ;
};
//#line  1089 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_107 {
   unsigned long index ;
   void *freelist ;
};
//#line  1094 "psmousebase.merged.kernel.c"
struct page {
   unsigned long flags ;
   atomic_t _count ;
   union __anonunion____missing_field_name_103 __annonCompField17 ;
   union __anonunion____missing_field_name_105 __annonCompField19 ;
   union __anonunion____missing_field_name_107 __annonCompField20 ;
   struct list_head lru ;
};
//#line  1103 "psmousebase.merged.kernel.c"
struct __anonstruct_vm_set_109 {
   struct list_head list ;
   void *parent ;
   struct vm_area_struct *head ;
};
//#line  1109 "psmousebase.merged.kernel.c"
union __anonunion_shared_108 {
   struct __anonstruct_vm_set_109 vm_set ;
   struct raw_prio_tree_node prio_tree_node ;
};
//#line  1114
struct anon_vma;
struct anon_vma;
//#line  1116
struct vm_operations_struct;
struct vm_operations_struct;
//#line  1118
struct mempolicy;
struct mempolicy;
//#line  1120 "psmousebase.merged.kernel.c"
struct vm_area_struct {
   struct mm_struct *vm_mm ;
   unsigned long vm_start ;
   unsigned long vm_end ;
   struct vm_area_struct *vm_next ;
   pgprot_t vm_page_prot ;
   unsigned long vm_flags ;
   struct rb_node vm_rb ;
   union __anonunion_shared_108 shared ;
   struct list_head anon_vma_node ;
   struct anon_vma *anon_vma ;
   struct vm_operations_struct *vm_ops ;
   unsigned long vm_pgoff ;
   struct file *vm_file ;
   void *vm_private_data ;
   unsigned long vm_truncate_count ;
   struct mempolicy *vm_policy ;
};
//#line  1139 "psmousebase.merged.kernel.c"
struct core_thread {
   struct task_struct *task ;
   struct core_thread *next ;
};
//#line  1144 "psmousebase.merged.kernel.c"
struct core_state {
   atomic_t nr_threads ;
   struct core_thread dumper ;
   struct completion startup ;
};
//#line  1150 "psmousebase.merged.kernel.c"
struct mm_struct {
   struct vm_area_struct *mmap ;
   struct rb_root mm_rb ;
   struct vm_area_struct *mmap_cache ;
   unsigned long (*get_unmapped_area)(struct file *filp , unsigned long addr , unsigned long len ,
                                      unsigned long pgoff , unsigned long flags ) ;
   void (*unmap_area)(struct mm_struct *mm , unsigned long addr ) ;
   unsigned long mmap_base ;
   unsigned long task_size ;
   unsigned long cached_hole_size ;
   unsigned long free_area_cache ;
   pgd_t *pgd ;
   atomic_t mm_users ;
   atomic_t mm_count ;
   int map_count ;
   struct rw_semaphore mmap_sem ;
   spinlock_t page_table_lock ;
   struct list_head mmlist ;
   mm_counter_t _file_rss ;
   mm_counter_t _anon_rss ;
   unsigned long hiwater_rss ;
   unsigned long hiwater_vm ;
   unsigned long total_vm ;
   unsigned long locked_vm ;
   unsigned long shared_vm ;
   unsigned long exec_vm ;
   unsigned long stack_vm ;
   unsigned long reserved_vm ;
   unsigned long def_flags ;
   unsigned long nr_ptes ;
   unsigned long start_code ;
   unsigned long end_code ;
   unsigned long start_data ;
   unsigned long end_data ;
   unsigned long start_brk ;
   unsigned long brk ;
   unsigned long start_stack ;
   unsigned long arg_start ;
   unsigned long arg_end ;
   unsigned long env_start ;
   unsigned long env_end ;
   unsigned long saved_auxv[44] ;
   cpumask_t cpu_vm_mask ;
   mm_context_t context ;
   unsigned int faultstamp ;
   unsigned int token_priority ;
   unsigned int last_interval ;
   unsigned long flags ;
   struct core_state *core_state ;
   spinlock_t ioctx_lock ;
   struct hlist_head ioctx_list ;
   struct file *exe_file ;
   unsigned long num_exe_file_vmas ;
};
//#line  1205 "psmousebase.merged.kernel.c"
typedef unsigned long cputime_t;
//#line  1207
struct sem_undo_list;
struct sem_undo_list;
//#line  1209 "psmousebase.merged.kernel.c"
struct sem_undo_list {
   atomic_t refcnt ;
   spinlock_t lock ;
   struct list_head list_proc ;
};
//#line  1215 "psmousebase.merged.kernel.c"
struct sysv_sem {
   struct sem_undo_list *undo_list ;
};
//#line  1219
struct siginfo;
struct siginfo;
//#line  1221 "psmousebase.merged.kernel.c"
struct __anonstruct_sigset_t_110 {
   unsigned long sig[1] ;
};
//#line  1225 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_sigset_t_110 sigset_t;
//#line  1227 "psmousebase.merged.kernel.c"
typedef void __signalfn_t(int  );
//#line  1229 "psmousebase.merged.kernel.c"
typedef __signalfn_t *__sighandler_t;
//#line  1231 "psmousebase.merged.kernel.c"
typedef void __restorefn_t(void);
//#line  1233 "psmousebase.merged.kernel.c"
typedef __restorefn_t *__sigrestore_t;
//#line  1235 "psmousebase.merged.kernel.c"
struct sigaction {
   __sighandler_t sa_handler ;
   unsigned long sa_flags ;
   __sigrestore_t sa_restorer ;
   sigset_t sa_mask ;
};
//#line  1242 "psmousebase.merged.kernel.c"
struct k_sigaction {
   struct sigaction sa ;
};
//#line  1246 "psmousebase.merged.kernel.c"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
//#line  1251 "psmousebase.merged.kernel.c"
typedef union sigval sigval_t;
//#line  1253 "psmousebase.merged.kernel.c"
struct __anonstruct__kill_112 {
   pid_t _pid ;
   uid_t _uid ;
};
//#line  1258 "psmousebase.merged.kernel.c"
struct __anonstruct__timer_113 {
   timer_t _tid ;
   int _overrun ;
   char _pad[sizeof(uid_t ) - sizeof(int )] ;
   sigval_t _sigval ;
   int _sys_private ;
};
//#line  1266 "psmousebase.merged.kernel.c"
struct __anonstruct__rt_114 {
   pid_t _pid ;
   uid_t _uid ;
   sigval_t _sigval ;
};
//#line  1272 "psmousebase.merged.kernel.c"
struct __anonstruct__sigchld_115 {
   pid_t _pid ;
   uid_t _uid ;
   int _status ;
   clock_t _utime ;
   clock_t _stime ;
};
//#line  1280 "psmousebase.merged.kernel.c"
struct __anonstruct__sigfault_116 {
   void *_addr ;
};
//#line  1284 "psmousebase.merged.kernel.c"
struct __anonstruct__sigpoll_117 {
   long _band ;
   int _fd ;
};
//#line  1289 "psmousebase.merged.kernel.c"
union __anonunion__sifields_111 {
   int _pad[(128UL - 4UL * sizeof(int )) / sizeof(int )] ;
   struct __anonstruct__kill_112 _kill ;
   struct __anonstruct__timer_113 _timer ;
   struct __anonstruct__rt_114 _rt ;
   struct __anonstruct__sigchld_115 _sigchld ;
   struct __anonstruct__sigfault_116 _sigfault ;
   struct __anonstruct__sigpoll_117 _sigpoll ;
};
//#line  1299 "psmousebase.merged.kernel.c"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_111 _sifields ;
};
//#line  1306 "psmousebase.merged.kernel.c"
typedef struct siginfo siginfo_t;
//#line  1308
struct user_struct;
struct user_struct;
//#line  1310 "psmousebase.merged.kernel.c"
struct sigpending {
   struct list_head list ;
   sigset_t signal ;
};
//#line  1315
struct vfsmount;
struct vfsmount;
//#line  1317 "psmousebase.merged.kernel.c"
struct path {
   struct vfsmount *mnt ;
   struct dentry *dentry ;
};
//#line  1322 "psmousebase.merged.kernel.c"
struct fs_struct {
   atomic_t count ;
   rwlock_t lock ;
   int umask ;
   struct path root ;
   struct path pwd ;
};
//#line  1330
enum pid_type {
    PIDTYPE_PID = 0,
    PIDTYPE_PGID = 1,
    PIDTYPE_SID = 2,
    PIDTYPE_MAX = 3
} ;
//#line  1337
struct pid_namespace;
struct pid_namespace;
//#line  1339 "psmousebase.merged.kernel.c"
struct upid {
   int nr ;
   struct pid_namespace *ns ;
   struct hlist_node pid_chain ;
};
//#line  1345 "psmousebase.merged.kernel.c"
struct pid {
   atomic_t count ;
   unsigned int level ;
   struct hlist_head tasks[3] ;
   struct rcu_head rcu ;
   struct upid numbers[1] ;
};
//#line  1353 "psmousebase.merged.kernel.c"
struct pid_link {
   struct hlist_node node ;
   struct pid *pid ;
};
//#line  1358 "psmousebase.merged.kernel.c"
struct prop_local_single {
   unsigned long events ;
   unsigned long period ;
   int shift ;
   spinlock_t lock ;
};
//#line  1365 "psmousebase.merged.kernel.c"
struct __anonstruct_seccomp_t_120 {

};
//#line  1369 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_seccomp_t_120 seccomp_t;
//#line  1371 "psmousebase.merged.kernel.c"
struct plist_head {
   struct list_head prio_list ;
   struct list_head node_list ;
   spinlock_t *lock ;
};
//#line  1377
struct rt_mutex_waiter;
struct rt_mutex_waiter;
//#line  1379 "psmousebase.merged.kernel.c"
struct rlimit {
   unsigned long rlim_cur ;
   unsigned long rlim_max ;
};
//#line  1384
struct hrtimer_clock_base;
struct hrtimer_clock_base;
//#line  1386
struct hrtimer_cpu_base;
struct hrtimer_cpu_base;
//#line  1388
enum hrtimer_restart {
    HRTIMER_NORESTART = 0,
    HRTIMER_RESTART = 1
} ;
//#line  1393 "psmousebase.merged.kernel.c"
struct hrtimer {
   struct rb_node node ;
   ktime_t _expires ;
   ktime_t _softexpires ;
   enum hrtimer_restart (*function)(struct hrtimer * ) ;
   struct hrtimer_clock_base *base ;
   unsigned long state ;
   struct list_head cb_entry ;
};
//#line  1403 "psmousebase.merged.kernel.c"
struct hrtimer_clock_base {
   struct hrtimer_cpu_base *cpu_base ;
   clockid_t index ;
   struct rb_root active ;
   struct rb_node *first ;
   ktime_t resolution ;
   ktime_t (*get_time)(void) ;
   ktime_t softirq_time ;
};
//#line  1413 "psmousebase.merged.kernel.c"
struct hrtimer_cpu_base {
   spinlock_t lock ;
   struct hrtimer_clock_base clock_base[2] ;
};
//#line  1418 "psmousebase.merged.kernel.c"
struct task_io_accounting {

};
//#line  1422 "psmousebase.merged.kernel.c"
struct latency_record {
   unsigned long backtrace[12] ;
   unsigned int count ;
   unsigned long time ;
   unsigned long max ;
};
//#line  1429
struct nsproxy;
struct nsproxy;
//#line  1431 "psmousebase.merged.kernel.c"
typedef int32_t key_serial_t;
//#line  1433 "psmousebase.merged.kernel.c"
typedef uint32_t key_perm_t;
//#line  1435
struct seq_file;
struct seq_file;
//#line  1437
struct signal_struct;
struct signal_struct;
//#line  1439
struct cred;
struct cred;
//#line  1441
struct key_type;
struct key_type;
//#line  1443
struct keyring_list;
struct keyring_list;
//#line  1445
struct key_user;
struct key_user;
//#line  1447 "psmousebase.merged.kernel.c"
union __anonunion_type_data_175 {
   struct list_head link ;
   unsigned long x[2] ;
   void *p[2] ;
};
//#line  1453 "psmousebase.merged.kernel.c"
union __anonunion_payload_176 {
   unsigned long value ;
   void *data ;
   struct keyring_list *subscriptions ;
};
//#line  1459 "psmousebase.merged.kernel.c"
struct key {
   atomic_t usage ;
   key_serial_t serial ;
   struct rb_node serial_node ;
   struct key_type *type ;
   struct rw_semaphore sem ;
   struct key_user *user ;
   void *security ;
   time_t expiry ;
   uid_t uid ;
   gid_t gid ;
   key_perm_t perm ;
   unsigned short quotalen ;
   unsigned short datalen ;
   unsigned long flags ;
   char *description ;
   union __anonunion_type_data_175 type_data ;
   union __anonunion_payload_176 payload ;
};
//#line  1479
struct inode;
struct inode;
//#line  1481 "psmousebase.merged.kernel.c"
struct group_info {
   atomic_t usage ;
   int ngroups ;
   int nblocks ;
   gid_t small_block[32] ;
   gid_t *blocks[0] ;
};
//#line  1489 "psmousebase.merged.kernel.c"
struct thread_group_cred {
   atomic_t usage ;
   pid_t tgid ;
   spinlock_t lock ;
   struct key *session_keyring ;
   struct key *process_keyring ;
   struct rcu_head rcu ;
};
//#line  1498 "psmousebase.merged.kernel.c"
struct cred {
   atomic_t usage ;
   uid_t uid ;
   gid_t gid ;
   uid_t suid ;
   gid_t sgid ;
   uid_t euid ;
   gid_t egid ;
   uid_t fsuid ;
   gid_t fsgid ;
   unsigned int securebits ;
   kernel_cap_t cap_inheritable ;
   kernel_cap_t cap_permitted ;
   kernel_cap_t cap_effective ;
   kernel_cap_t cap_bset ;
   unsigned char jit_keyring ;
   struct key *thread_keyring ;
   struct key *request_key_auth ;
   struct thread_group_cred *tgcred ;
   void *security ;
   struct user_struct *user ;
   struct group_info *group_info ;
   struct rcu_head rcu ;
};
//#line  1523
struct futex_pi_state;
struct futex_pi_state;
//#line  1525
struct robust_list_head;
struct robust_list_head;
//#line  1527
struct bio;
struct bio;
//#line  1529
struct user_namespace;
struct user_namespace;
//#line  1531 "psmousebase.merged.kernel.c"
struct io_event {
   __u64 data ;
   __u64 obj ;
   __s64 res ;
   __s64 res2 ;
};
//#line  1538 "psmousebase.merged.kernel.c"
struct iovec {
   void *iov_base ;
   __kernel_size_t iov_len ;
};
//#line  1543
struct kioctx;
struct kioctx;
//#line  1545 "psmousebase.merged.kernel.c"
union __anonunion_ki_obj_178 {
   void *user ;
   struct task_struct *tsk ;
};
//#line  1550 "psmousebase.merged.kernel.c"
struct kiocb {
   struct list_head ki_run_list ;
   unsigned long ki_flags ;
   int ki_users ;
   unsigned int ki_key ;
   struct file *ki_filp ;
   struct kioctx *ki_ctx ;
   int (*ki_cancel)(struct kiocb * , struct io_event * ) ;
   ssize_t (*ki_retry)(struct kiocb * ) ;
   void (*ki_dtor)(struct kiocb * ) ;
   union __anonunion_ki_obj_178 ki_obj ;
   __u64 ki_user_data ;
   wait_queue_t ki_wait ;
   loff_t ki_pos ;
   void *private ;
   unsigned short ki_opcode ;
   size_t ki_nbytes ;
   char *ki_buf ;
   size_t ki_left ;
   struct iovec ki_inline_vec ;
   struct iovec *ki_iovec ;
   unsigned long ki_nr_segs ;
   unsigned long ki_cur_seg ;
   struct list_head ki_list ;
   struct file *ki_eventfd ;
};
//#line  1577 "psmousebase.merged.kernel.c"
struct aio_ring_info {
   unsigned long mmap_base ;
   unsigned long mmap_size ;
   struct page **ring_pages ;
   spinlock_t ring_lock ;
   long nr_pages ;
   unsigned int nr ;
   unsigned int tail ;
   struct page *internal_pages[8] ;
};
//#line  1588 "psmousebase.merged.kernel.c"
struct kioctx {
   atomic_t users ;
   int dead ;
   struct mm_struct *mm ;
   unsigned long user_id ;
   struct hlist_node list ;
   wait_queue_head_t wait ;
   spinlock_t ctx_lock ;
   int reqs_active ;
   struct list_head active_reqs ;
   struct list_head run_list ;
   unsigned int max_reqs ;
   struct aio_ring_info ring_info ;
   struct delayed_work wq ;
   struct rcu_head rcu_head ;
};
//#line  1605 "psmousebase.merged.kernel.c"
struct sighand_struct {
   atomic_t count ;
   struct k_sigaction action[64] ;
   spinlock_t siglock ;
   wait_queue_head_t signalfd_wqh ;
};
//#line  1612 "psmousebase.merged.kernel.c"
struct pacct_struct {
   int ac_flag ;
   long ac_exitcode ;
   unsigned long ac_mem ;
   cputime_t ac_utime ;
   cputime_t ac_stime ;
   unsigned long ac_minflt ;
   unsigned long ac_majflt ;
};
//#line  1622 "psmousebase.merged.kernel.c"
struct task_cputime {
   cputime_t utime ;
   cputime_t stime ;
   unsigned long long sum_exec_runtime ;
};
//#line  1628 "psmousebase.merged.kernel.c"
struct thread_group_cputimer {
   struct task_cputime cputime ;
   int running ;
   spinlock_t lock ;
};
//#line  1634 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_179 {
   pid_t pgrp  __attribute__((__deprecated__)) ;
   pid_t __pgrp ;
};
//#line  1639 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_180 {
   pid_t session  __attribute__((__deprecated__)) ;
   pid_t __session ;
};
//#line  1644
struct tty_struct;
struct tty_struct;
//#line  1646
struct taskstats;
struct taskstats;
//#line  1648
struct tty_audit_buf;
struct tty_audit_buf;
//#line  1650 "psmousebase.merged.kernel.c"
struct signal_struct {
   atomic_t count ;
   atomic_t live ;
   wait_queue_head_t wait_chldexit ;
   struct task_struct *curr_target ;
   struct sigpending shared_pending ;
   int group_exit_code ;
   int notify_count ;
   struct task_struct *group_exit_task ;
   int group_stop_count ;
   unsigned int flags ;
   struct list_head posix_timers ;
   struct hrtimer real_timer ;
   struct pid *leader_pid ;
   ktime_t it_real_incr ;
   cputime_t it_prof_expires ;
   cputime_t it_virt_expires ;
   cputime_t it_prof_incr ;
   cputime_t it_virt_incr ;
   struct thread_group_cputimer cputimer ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   union __anonunion____missing_field_name_179 __annonCompField21 ;
   struct pid *tty_old_pgrp ;
   union __anonunion____missing_field_name_180 __annonCompField22 ;
   int leader ;
   struct tty_struct *tty ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t cutime ;
   cputime_t cstime ;
   cputime_t gtime ;
   cputime_t cgtime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   unsigned long cnvcsw ;
   unsigned long cnivcsw ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   unsigned long cmin_flt ;
   unsigned long cmaj_flt ;
   unsigned long inblock ;
   unsigned long oublock ;
   unsigned long cinblock ;
   unsigned long coublock ;
   struct task_io_accounting ioac ;
   unsigned long long sum_sched_runtime ;
   struct rlimit rlim[16] ;
   struct pacct_struct pacct ;
   struct taskstats *stats ;
   unsigned int audit_tty ;
   struct tty_audit_buf *tty_audit_buf ;
};
//#line  1704 "psmousebase.merged.kernel.c"
struct user_struct {
   atomic_t __count ;
   atomic_t processes ;
   atomic_t files ;
   atomic_t sigpending ;
   atomic_t inotify_watches ;
   atomic_t inotify_devs ;
   atomic_t epoll_watches ;
   unsigned long mq_bytes ;
   unsigned long locked_shm ;
   struct key *uid_keyring ;
   struct key *session_keyring ;
   struct hlist_node uidhash_node ;
   uid_t uid ;
   struct user_namespace *user_ns ;
};
//#line  1721
struct backing_dev_info;
struct backing_dev_info;
//#line  1723
struct reclaim_state;
struct reclaim_state;
//#line  1725 "psmousebase.merged.kernel.c"
struct sched_info {
   unsigned long pcount ;
   unsigned long long run_delay ;
   unsigned long long last_arrival ;
   unsigned long long last_queued ;
   unsigned int bkl_count ;
};
//#line  1733 "psmousebase.merged.kernel.c"
struct task_delay_info {
   spinlock_t lock ;
   unsigned int flags ;
   struct timespec blkio_start ;
   struct timespec blkio_end ;
   u64 blkio_delay ;
   u64 swapin_delay ;
   u32 blkio_count ;
   u32 swapin_count ;
   struct timespec freepages_start ;
   struct timespec freepages_end ;
   u64 freepages_delay ;
   u32 freepages_count ;
};
//#line  1748
enum cpu_idle_type {
    CPU_IDLE = 0,
    CPU_NOT_IDLE = 1,
    CPU_NEWLY_IDLE = 2,
    CPU_MAX_IDLE_TYPES = 3
} ;
//#line  1755 "psmousebase.merged.kernel.c"
struct sched_group {
   struct sched_group *next ;
   unsigned int __cpu_power ;
   u32 reciprocal_cpu_power ;
   unsigned long cpumask[] ;
};
//#line  1762
enum sched_domain_level {
    SD_LV_NONE = 0,
    SD_LV_SIBLING = 1,
    SD_LV_MC = 2,
    SD_LV_CPU = 3,
    SD_LV_NODE = 4,
    SD_LV_ALLNODES = 5,
    SD_LV_MAX = 6
} ;
//#line  1772 "psmousebase.merged.kernel.c"
struct sched_domain {
   struct sched_domain *parent ;
   struct sched_domain *child ;
   struct sched_group *groups ;
   unsigned long min_interval ;
   unsigned long max_interval ;
   unsigned int busy_factor ;
   unsigned int imbalance_pct ;
   unsigned int cache_nice_tries ;
   unsigned int busy_idx ;
   unsigned int idle_idx ;
   unsigned int newidle_idx ;
   unsigned int wake_idx ;
   unsigned int forkexec_idx ;
   int flags ;
   enum sched_domain_level level ;
   unsigned long last_balance ;
   unsigned int balance_interval ;
   unsigned int nr_balance_failed ;
   u64 last_update ;
   unsigned int lb_count[3] ;
   unsigned int lb_failed[3] ;
   unsigned int lb_balanced[3] ;
   unsigned int lb_imbalance[3] ;
   unsigned int lb_gained[3] ;
   unsigned int lb_hot_gained[3] ;
   unsigned int lb_nobusyg[3] ;
   unsigned int lb_nobusyq[3] ;
   unsigned int alb_count ;
   unsigned int alb_failed ;
   unsigned int alb_pushed ;
   unsigned int sbe_count ;
   unsigned int sbe_balanced ;
   unsigned int sbe_pushed ;
   unsigned int sbf_count ;
   unsigned int sbf_balanced ;
   unsigned int sbf_pushed ;
   unsigned int ttwu_wake_remote ;
   unsigned int ttwu_move_affine ;
   unsigned int ttwu_move_balance ;
   char *name ;
   unsigned long span[] ;
};
//#line  1816
struct io_context;
struct io_context;
//#line  1818
struct audit_context;
struct audit_context;
//#line  1820
struct pipe_inode_info;
struct pipe_inode_info;
//#line  1822
struct rq;
struct rq;
//#line  1824 "psmousebase.merged.kernel.c"
struct sched_class {
   struct sched_class  const  *next ;
   void (*enqueue_task)(struct rq *rq , struct task_struct *p , int wakeup ) ;
   void (*dequeue_task)(struct rq *rq , struct task_struct *p , int sleep ) ;
   void (*yield_task)(struct rq *rq ) ;
   void (*check_preempt_curr)(struct rq *rq , struct task_struct *p , int sync ) ;
   struct task_struct *(*pick_next_task)(struct rq *rq ) ;
   void (*put_prev_task)(struct rq *rq , struct task_struct *p ) ;
   int (*select_task_rq)(struct task_struct *p , int sync ) ;
   unsigned long (*load_balance)(struct rq *this_rq , int this_cpu , struct rq *busiest ,
                                 unsigned long max_load_move , struct sched_domain *sd ,
                                 enum cpu_idle_type idle , int *all_pinned , int *this_best_prio ) ;
   int (*move_one_task)(struct rq *this_rq , int this_cpu , struct rq *busiest , struct sched_domain *sd ,
                        enum cpu_idle_type idle ) ;
   void (*pre_schedule)(struct rq *this_rq , struct task_struct *task ) ;
   void (*post_schedule)(struct rq *this_rq ) ;
   void (*task_wake_up)(struct rq *this_rq , struct task_struct *task ) ;
   void (*set_cpus_allowed)(struct task_struct *p , struct cpumask  const  *newmask ) ;
   void (*rq_online)(struct rq *rq ) ;
   void (*rq_offline)(struct rq *rq ) ;
   void (*set_curr_task)(struct rq *rq ) ;
   void (*task_tick)(struct rq *rq , struct task_struct *p , int queued ) ;
   void (*task_new)(struct rq *rq , struct task_struct *p ) ;
   void (*switched_from)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*switched_to)(struct rq *this_rq , struct task_struct *task , int running ) ;
   void (*prio_changed)(struct rq *this_rq , struct task_struct *task , int oldprio ,
                        int running ) ;
};
//#line  1853 "psmousebase.merged.kernel.c"
struct load_weight {
   unsigned long weight ;
   unsigned long inv_weight ;
};
//#line  1858 "psmousebase.merged.kernel.c"
struct sched_entity {
   struct load_weight load ;
   struct rb_node run_node ;
   struct list_head group_node ;
   unsigned int on_rq ;
   u64 exec_start ;
   u64 sum_exec_runtime ;
   u64 vruntime ;
   u64 prev_sum_exec_runtime ;
   u64 last_wakeup ;
   u64 avg_overlap ;
   u64 wait_start ;
   u64 wait_max ;
   u64 wait_count ;
   u64 wait_sum ;
   u64 sleep_start ;
   u64 sleep_max ;
   s64 sum_sleep_runtime ;
   u64 block_start ;
   u64 block_max ;
   u64 exec_max ;
   u64 slice_max ;
   u64 nr_migrations ;
   u64 nr_migrations_cold ;
   u64 nr_failed_migrations_affine ;
   u64 nr_failed_migrations_running ;
   u64 nr_failed_migrations_hot ;
   u64 nr_forced_migrations ;
   u64 nr_forced2_migrations ;
   u64 nr_wakeups ;
   u64 nr_wakeups_sync ;
   u64 nr_wakeups_migrate ;
   u64 nr_wakeups_local ;
   u64 nr_wakeups_remote ;
   u64 nr_wakeups_affine ;
   u64 nr_wakeups_affine_attempts ;
   u64 nr_wakeups_passive ;
   u64 nr_wakeups_idle ;
};
//#line  1898 "psmousebase.merged.kernel.c"
struct sched_rt_entity {
   struct list_head run_list ;
   unsigned long timeout ;
   unsigned int time_slice ;
   int nr_cpus_allowed ;
   struct sched_rt_entity *back ;
};
//#line  1906
struct linux_binfmt;
struct linux_binfmt;
//#line  1908
struct files_struct;
struct files_struct;
//#line  1910
struct compat_robust_list_head;
struct compat_robust_list_head;
//#line  1912 "psmousebase.merged.kernel.c"
struct task_struct {
   long volatile   state ;
   void *stack ;
   atomic_t usage ;
   unsigned int flags ;
   unsigned int ptrace ;
   int lock_depth ;
   int prio ;
   int static_prio ;
   int normal_prio ;
   unsigned int rt_priority ;
   struct sched_class  const  *sched_class ;
   struct sched_entity se ;
   struct sched_rt_entity rt ;
   unsigned char fpu_counter ;
   s8 oomkilladj ;
   unsigned int btrace_seq ;
   unsigned int policy ;
   cpumask_t cpus_allowed ;
   struct sched_info sched_info ;
   struct list_head tasks ;
   struct mm_struct *mm ;
   struct mm_struct *active_mm ;
   struct linux_binfmt *binfmt ;
   int exit_state ;
   int exit_code ;
   int exit_signal ;
   int pdeath_signal ;
   unsigned int personality ;
   unsigned int did_exec : 1 ;
   pid_t pid ;
   pid_t tgid ;
   struct task_struct *real_parent ;
   struct task_struct *parent ;
   struct list_head children ;
   struct list_head sibling ;
   struct task_struct *group_leader ;
   struct list_head ptraced ;
   struct list_head ptrace_entry ;
   struct bts_tracer *bts ;
   void *bts_buffer ;
   size_t bts_size ;
   struct pid_link pids[3] ;
   struct list_head thread_group ;
   struct completion *vfork_done ;
   int *set_child_tid ;
   int *clear_child_tid ;
   cputime_t utime ;
   cputime_t stime ;
   cputime_t utimescaled ;
   cputime_t stimescaled ;
   cputime_t gtime ;
   cputime_t prev_utime ;
   cputime_t prev_stime ;
   unsigned long nvcsw ;
   unsigned long nivcsw ;
   struct timespec start_time ;
   struct timespec real_start_time ;
   unsigned long min_flt ;
   unsigned long maj_flt ;
   struct task_cputime cputime_expires ;
   struct list_head cpu_timers[3] ;
   struct cred  const  *real_cred ;
   struct cred  const  *cred ;
   struct mutex cred_exec_mutex ;
   char comm[16] ;
   int link_count ;
   int total_link_count ;
   struct sysv_sem sysvsem ;
   unsigned long last_switch_timestamp ;
   unsigned long last_switch_count ;
   struct thread_struct thread ;
   struct fs_struct *fs ;
   struct files_struct *files ;
   struct nsproxy *nsproxy ;
   struct signal_struct *signal ;
   struct sighand_struct *sighand ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   sigset_t saved_sigmask ;
   struct sigpending pending ;
   unsigned long sas_ss_sp ;
   size_t sas_ss_size ;
   int (*notifier)(void *priv ) ;
   void *notifier_data ;
   sigset_t *notifier_mask ;
   struct audit_context *audit_context ;
   uid_t loginuid ;
   unsigned int sessionid ;
   seccomp_t seccomp ;
   u32 parent_exec_id ;
   u32 self_exec_id ;
   spinlock_t alloc_lock ;
   spinlock_t pi_lock ;
   struct plist_head pi_waiters ;
   struct rt_mutex_waiter *pi_blocked_on ;
   struct mutex_waiter *blocked_on ;
   u64 curr_chain_key ;
   int lockdep_depth ;
   unsigned int lockdep_recursion ;
   struct held_lock held_locks[48UL] ;
   void *journal_info ;
   struct bio *bio_list ;
   struct bio **bio_tail ;
   struct reclaim_state *reclaim_state ;
   struct backing_dev_info *backing_dev_info ;
   struct io_context *io_context ;
   unsigned long ptrace_message ;
   siginfo_t *last_siginfo ;
   struct task_io_accounting ioac ;
   struct robust_list_head *robust_list ;
   struct compat_robust_list_head *compat_robust_list ;
   struct list_head pi_state_list ;
   struct futex_pi_state *pi_state_cache ;
   struct mempolicy *mempolicy ;
   short il_next ;
   atomic_t fs_excl ;
   struct rcu_head rcu ;
   struct pipe_inode_info *splice_pipe ;
   struct task_delay_info *delays ;
   int make_it_fail ;
   struct prop_local_single dirties ;
   int latency_record_count ;
   struct latency_record latency_record[32] ;
   unsigned long timer_slack_ns ;
   unsigned long default_timer_slack_ns ;
   struct list_head *scm_work_list ;
   unsigned long trace ;
};
//#line  2042 "psmousebase.merged.kernel.c"
struct input_id {
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
};
//#line  2049 "psmousebase.merged.kernel.c"
struct ff_replay {
   __u16 length ;
   __u16 delay ;
};
//#line  2054 "psmousebase.merged.kernel.c"
struct ff_trigger {
   __u16 button ;
   __u16 interval ;
};
//#line  2059 "psmousebase.merged.kernel.c"
struct ff_envelope {
   __u16 attack_length ;
   __u16 attack_level ;
   __u16 fade_length ;
   __u16 fade_level ;
};
//#line  2066 "psmousebase.merged.kernel.c"
struct ff_constant_effect {
   __s16 level ;
   struct ff_envelope envelope ;
};
//#line  2071 "psmousebase.merged.kernel.c"
struct ff_ramp_effect {
   __s16 start_level ;
   __s16 end_level ;
   struct ff_envelope envelope ;
};
//#line  2077 "psmousebase.merged.kernel.c"
struct ff_condition_effect {
   __u16 right_saturation ;
   __u16 left_saturation ;
   __s16 right_coeff ;
   __s16 left_coeff ;
   __u16 deadband ;
   __s16 center ;
};
//#line  2086 "psmousebase.merged.kernel.c"
struct ff_periodic_effect {
   __u16 waveform ;
   __u16 period ;
   __s16 magnitude ;
   __s16 offset ;
   __u16 phase ;
   struct ff_envelope envelope ;
   __u32 custom_len ;
   __s16 *custom_data ;
};
//#line  2097 "psmousebase.merged.kernel.c"
struct ff_rumble_effect {
   __u16 strong_magnitude ;
   __u16 weak_magnitude ;
};
//#line  2102 "psmousebase.merged.kernel.c"
union __anonunion_u_183 {
   struct ff_constant_effect constant ;
   struct ff_ramp_effect ramp ;
   struct ff_periodic_effect periodic ;
   struct ff_condition_effect condition[2] ;
   struct ff_rumble_effect rumble ;
};
//#line  2110 "psmousebase.merged.kernel.c"
struct ff_effect {
   __u16 type ;
   __s16 id ;
   __u16 direction ;
   struct ff_trigger trigger ;
   struct ff_replay replay ;
   union __anonunion_u_183 u ;
};
//#line  2119
struct pci_dev;
struct pci_dev;
//#line  2121
struct klist_node;
struct klist_node;
//#line  2123 "psmousebase.merged.kernel.c"
struct klist {
   spinlock_t k_lock ;
   struct list_head k_list ;
   void (*get)(struct klist_node * ) ;
   void (*put)(struct klist_node * ) ;
} __attribute__((__aligned__(4))) ;
//#line  2130 "psmousebase.merged.kernel.c"
struct klist_node {
   void *n_klist ;
   struct list_head n_node ;
   struct kref n_ref ;
};
//#line  2136 "psmousebase.merged.kernel.c"
struct semaphore {
   spinlock_t lock ;
   unsigned int count ;
   struct list_head wait_list ;
};
//#line  2142
struct dma_mapping_ops;
struct dma_mapping_ops;
//#line  2144 "psmousebase.merged.kernel.c"
struct dev_archdata {
   void *acpi_handle ;
   struct dma_mapping_ops *dma_ops ;
   void *iommu ;
};
//#line  2150
struct driver_private;
struct driver_private;
//#line  2152
struct class;
struct class;
//#line  2154
struct class_private;
struct class_private;
//#line  2156
struct bus_type;
struct bus_type;
//#line  2158
struct bus_type_private;
struct bus_type_private;
//#line  2160 "psmousebase.merged.kernel.c"
struct bus_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct bus_type *bus , char *buf ) ;
   ssize_t (*store)(struct bus_type *bus , char const   *buf , size_t count ) ;
};
//#line  2166
struct device_attribute;
struct device_attribute;
//#line  2168
struct driver_attribute;
struct driver_attribute;
//#line  2170 "psmousebase.merged.kernel.c"
struct bus_type {
   char const   *name ;
   struct bus_attribute *bus_attrs ;
   struct device_attribute *dev_attrs ;
   struct driver_attribute *drv_attrs ;
   int (*match)(struct device *dev , struct device_driver *drv ) ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*suspend_late)(struct device *dev , pm_message_t state ) ;
   int (*resume_early)(struct device *dev ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct bus_type_private *p ;
};
//#line  2188 "psmousebase.merged.kernel.c"
struct device_driver {
   char const   *name ;
   struct bus_type *bus ;
   struct module *owner ;
   char const   *mod_name ;
   int (*probe)(struct device *dev ) ;
   int (*remove)(struct device *dev ) ;
   void (*shutdown)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct attribute_group **groups ;
   struct dev_pm_ops *pm ;
   struct driver_private *p ;
};
//#line  2203 "psmousebase.merged.kernel.c"
struct driver_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device_driver *driver , char *buf ) ;
   ssize_t (*store)(struct device_driver *driver , char const   *buf , size_t count ) ;
};
//#line  2209
struct class_attribute;
struct class_attribute;
//#line  2211 "psmousebase.merged.kernel.c"
struct class {
   char const   *name ;
   struct module *owner ;
   struct class_attribute *class_attrs ;
   struct device_attribute *dev_attrs ;
   struct kobject *dev_kobj ;
   int (*dev_uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*class_release)(struct class *class ) ;
   void (*dev_release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
   struct class_private *p ;
};
//#line  2226
struct device_type;
struct device_type;
//#line  2228 "psmousebase.merged.kernel.c"
struct class_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct class *class , char *buf ) ;
   ssize_t (*store)(struct class *class , char const   *buf , size_t count ) ;
};
//#line  2234 "psmousebase.merged.kernel.c"
struct device_type {
   char const   *name ;
   struct attribute_group **groups ;
   int (*uevent)(struct device *dev , struct kobj_uevent_env *env ) ;
   void (*release)(struct device *dev ) ;
   int (*suspend)(struct device *dev , pm_message_t state ) ;
   int (*resume)(struct device *dev ) ;
   struct dev_pm_ops *pm ;
};
//#line  2244 "psmousebase.merged.kernel.c"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
//#line  2251 "psmousebase.merged.kernel.c"
struct device_dma_parameters {
   unsigned int max_segment_size ;
   unsigned long segment_boundary_mask ;
};
//#line  2256
struct psmouse;
struct psmouse;
//#line  2258
struct dma_coherent_mem;
struct dma_coherent_mem;
//#line  2260 "psmousebase.merged.kernel.c"
struct device {
   struct klist klist_children ;
   struct klist_node knode_parent ;
   struct klist_node knode_driver ;
   struct klist_node knode_bus ;
   struct device *parent ;
   struct kobject kobj ;
   char bus_id[20] ;
   unsigned int uevent_suppress : 1 ;
   char const   *init_name ;
   struct device_type *type ;
   struct semaphore sem ;
   struct bus_type *bus ;
   struct device_driver *driver ;
   struct psmouse *driver_data ;
   void *platform_data ;
   struct dev_pm_info power ;
   int numa_node ;
   u64 *dma_mask ;
   u64 coherent_dma_mask ;
   struct device_dma_parameters *dma_parms ;
   struct list_head dma_pools ;
   struct dma_coherent_mem *dma_mem ;
   struct dev_archdata archdata ;
   dev_t devt ;
   spinlock_t devres_lock ;
   struct list_head devres_head ;
   struct klist_node knode_class ;
   struct class *class ;
   struct attribute_group **groups ;
   void (*release)(struct device *dev ) ;
};
//#line  2293
struct nameidata;
struct nameidata;
//#line  2295 "psmousebase.merged.kernel.c"
struct qstr {
   unsigned int hash ;
   unsigned int len ;
   unsigned char const   *name ;
};
//#line  2301 "psmousebase.merged.kernel.c"
union __anonunion_d_u_184 {
   struct list_head d_child ;
   struct rcu_head d_rcu ;
};
//#line  2306
struct dentry_operations;
struct dentry_operations;
//#line  2308
struct super_block;
struct super_block;
//#line  2310 "psmousebase.merged.kernel.c"
struct dentry {
   atomic_t d_count ;
   unsigned int d_flags ;
   spinlock_t d_lock ;
   int d_mounted ;
   struct inode *d_inode ;
   struct hlist_node d_hash ;
   struct dentry *d_parent ;
   struct qstr d_name ;
   struct list_head d_lru ;
   union __anonunion_d_u_184 d_u ;
   struct list_head d_subdirs ;
   struct list_head d_alias ;
   unsigned long d_time ;
   struct dentry_operations *d_op ;
   struct super_block *d_sb ;
   void *d_fsdata ;
   unsigned char d_iname[32] ;
};
//#line  2330 "psmousebase.merged.kernel.c"
struct dentry_operations {
   int (*d_revalidate)(struct dentry * , struct nameidata * ) ;
   int (*d_hash)(struct dentry * , struct qstr * ) ;
   int (*d_compare)(struct dentry * , struct qstr * , struct qstr * ) ;
   int (*d_delete)(struct dentry * ) ;
   void (*d_release)(struct dentry * ) ;
   void (*d_iput)(struct dentry * , struct inode * ) ;
   char *(*d_dname)(struct dentry * , char * , int  ) ;
};
//#line  2340
struct radix_tree_node;
struct radix_tree_node;
//#line  2342 "psmousebase.merged.kernel.c"
struct radix_tree_root {
   unsigned int height ;
   gfp_t gfp_mask ;
   struct radix_tree_node *rnode ;
};
//#line  2348 "psmousebase.merged.kernel.c"
struct fiemap_extent {
   __u64 fe_logical ;
   __u64 fe_physical ;
   __u64 fe_length ;
   __u64 fe_reserved64[2] ;
   __u32 fe_flags ;
   __u32 fe_reserved[3] ;
};
//#line  2357
struct export_operations;
struct export_operations;
//#line  2359
struct poll_table_struct;
struct poll_table_struct;
//#line  2361
struct kstatfs;
struct kstatfs;
//#line  2363 "psmousebase.merged.kernel.c"
struct iattr {
   unsigned int ia_valid ;
   umode_t ia_mode ;
   uid_t ia_uid ;
   gid_t ia_gid ;
   loff_t ia_size ;
   struct timespec ia_atime ;
   struct timespec ia_mtime ;
   struct timespec ia_ctime ;
   struct file *ia_file ;
};
//#line  2375 "psmousebase.merged.kernel.c"
struct if_dqblk {
   __u64 dqb_bhardlimit ;
   __u64 dqb_bsoftlimit ;
   __u64 dqb_curspace ;
   __u64 dqb_ihardlimit ;
   __u64 dqb_isoftlimit ;
   __u64 dqb_curinodes ;
   __u64 dqb_btime ;
   __u64 dqb_itime ;
   __u32 dqb_valid ;
};
//#line  2387 "psmousebase.merged.kernel.c"
struct if_dqinfo {
   __u64 dqi_bgrace ;
   __u64 dqi_igrace ;
   __u32 dqi_flags ;
   __u32 dqi_valid ;
};
//#line  2394 "psmousebase.merged.kernel.c"
struct fs_disk_quota {
   __s8 d_version ;
   __s8 d_flags ;
   __u16 d_fieldmask ;
   __u32 d_id ;
   __u64 d_blk_hardlimit ;
   __u64 d_blk_softlimit ;
   __u64 d_ino_hardlimit ;
   __u64 d_ino_softlimit ;
   __u64 d_bcount ;
   __u64 d_icount ;
   __s32 d_itimer ;
   __s32 d_btimer ;
   __u16 d_iwarns ;
   __u16 d_bwarns ;
   __s32 d_padding2 ;
   __u64 d_rtb_hardlimit ;
   __u64 d_rtb_softlimit ;
   __u64 d_rtbcount ;
   __s32 d_rtbtimer ;
   __u16 d_rtbwarns ;
   __s16 d_padding3 ;
   char d_padding4[8] ;
};
//#line  2419 "psmousebase.merged.kernel.c"
struct fs_qfilestat {
   __u64 qfs_ino ;
   __u64 qfs_nblks ;
   __u32 qfs_nextents ;
};
//#line  2425 "psmousebase.merged.kernel.c"
typedef struct fs_qfilestat fs_qfilestat_t;
//#line  2427 "psmousebase.merged.kernel.c"
struct fs_quota_stat {
   __s8 qs_version ;
   __u16 qs_flags ;
   __s8 qs_pad ;
   fs_qfilestat_t qs_uquota ;
   fs_qfilestat_t qs_gquota ;
   __u32 qs_incoredqs ;
   __s32 qs_btimelimit ;
   __s32 qs_itimelimit ;
   __s32 qs_rtbtimelimit ;
   __u16 qs_bwarnlimit ;
   __u16 qs_iwarnlimit ;
};
//#line  2441
struct dquot;
struct dquot;
//#line  2443 "psmousebase.merged.kernel.c"
typedef __kernel_uid32_t qid_t;
//#line  2445 "psmousebase.merged.kernel.c"
typedef long long qsize_t;
//#line  2447 "psmousebase.merged.kernel.c"
struct mem_dqblk {
   qsize_t dqb_bhardlimit ;
   qsize_t dqb_bsoftlimit ;
   qsize_t dqb_curspace ;
   qsize_t dqb_ihardlimit ;
   qsize_t dqb_isoftlimit ;
   qsize_t dqb_curinodes ;
   time_t dqb_btime ;
   time_t dqb_itime ;
};
//#line  2458
struct quota_format_type;
struct quota_format_type;
//#line  2460 "psmousebase.merged.kernel.c"
struct mem_dqinfo {
   struct quota_format_type *dqi_format ;
   int dqi_fmt_id ;
   struct list_head dqi_dirty_list ;
   unsigned long dqi_flags ;
   unsigned int dqi_bgrace ;
   unsigned int dqi_igrace ;
   qsize_t dqi_maxblimit ;
   qsize_t dqi_maxilimit ;
   void *dqi_priv ;
};
//#line  2472 "psmousebase.merged.kernel.c"
struct dquot {
   struct hlist_node dq_hash ;
   struct list_head dq_inuse ;
   struct list_head dq_free ;
   struct list_head dq_dirty ;
   struct mutex dq_lock ;
   atomic_t dq_count ;
   wait_queue_head_t dq_wait_unused ;
   struct super_block *dq_sb ;
   unsigned int dq_id ;
   loff_t dq_off ;
   unsigned long dq_flags ;
   short dq_type ;
   struct mem_dqblk dq_dqb ;
};
//#line  2488 "psmousebase.merged.kernel.c"
struct quota_format_ops {
   int (*check_quota_file)(struct super_block *sb , int type ) ;
   int (*read_file_info)(struct super_block *sb , int type ) ;
   int (*write_file_info)(struct super_block *sb , int type ) ;
   int (*free_file_info)(struct super_block *sb , int type ) ;
   int (*read_dqblk)(struct dquot *dquot ) ;
   int (*commit_dqblk)(struct dquot *dquot ) ;
   int (*release_dqblk)(struct dquot *dquot ) ;
};
//#line  2498 "psmousebase.merged.kernel.c"
struct dquot_operations {
   int (*initialize)(struct inode * , int  ) ;
   int (*drop)(struct inode * ) ;
   int (*alloc_space)(struct inode * , qsize_t  , int  ) ;
   int (*alloc_inode)(struct inode  const  * , qsize_t  ) ;
   int (*free_space)(struct inode * , qsize_t  ) ;
   int (*free_inode)(struct inode  const  * , qsize_t  ) ;
   int (*transfer)(struct inode * , struct iattr * ) ;
   int (*write_dquot)(struct dquot * ) ;
   struct dquot *(*alloc_dquot)(struct super_block * , int  ) ;
   void (*destroy_dquot)(struct dquot * ) ;
   int (*acquire_dquot)(struct dquot * ) ;
   int (*release_dquot)(struct dquot * ) ;
   int (*mark_dirty)(struct dquot * ) ;
   int (*write_info)(struct super_block * , int  ) ;
};
//#line  2515 "psmousebase.merged.kernel.c"
struct quotactl_ops {
   int (*quota_on)(struct super_block * , int  , int  , char * , int  ) ;
   int (*quota_off)(struct super_block * , int  , int  ) ;
   int (*quota_sync)(struct super_block * , int  ) ;
   int (*get_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*set_info)(struct super_block * , int  , struct if_dqinfo * ) ;
   int (*get_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*set_dqblk)(struct super_block * , int  , qid_t  , struct if_dqblk * ) ;
   int (*get_xstate)(struct super_block * , struct fs_quota_stat * ) ;
   int (*set_xstate)(struct super_block * , unsigned int  , int  ) ;
   int (*get_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
   int (*set_xquota)(struct super_block * , int  , qid_t  , struct fs_disk_quota * ) ;
};
//#line  2529 "psmousebase.merged.kernel.c"
struct quota_format_type {
   int qf_fmt_id ;
   struct quota_format_ops *qf_ops ;
   struct module *qf_owner ;
   struct quota_format_type *qf_next ;
};
//#line  2536 "psmousebase.merged.kernel.c"
struct quota_info {
   unsigned int flags ;
   struct mutex dqio_mutex ;
   struct mutex dqonoff_mutex ;
   struct rw_semaphore dqptr_sem ;
   struct inode *files[2] ;
   struct mem_dqinfo info[2] ;
   struct quota_format_ops *ops[2] ;
};
//#line  2546
struct writeback_control;
struct writeback_control;
//#line  2548 "psmousebase.merged.kernel.c"
union __anonunion_arg_190 {
   char *buf ;
   void *data ;
};
//#line  2553 "psmousebase.merged.kernel.c"
struct __anonstruct_read_descriptor_t_189 {
   size_t written ;
   size_t count ;
   union __anonunion_arg_190 arg ;
   int error ;
};
//#line  2560 "psmousebase.merged.kernel.c"
typedef struct __anonstruct_read_descriptor_t_189 read_descriptor_t;
//#line  2562 "psmousebase.merged.kernel.c"
struct address_space_operations {
   int (*writepage)(struct page *page , struct writeback_control *wbc ) ;
   int (*readpage)(struct file * , struct page * ) ;
   void (*sync_page)(struct page * ) ;
   int (*writepages)(struct address_space * , struct writeback_control * ) ;
   int (*set_page_dirty)(struct page *page ) ;
   int (*readpages)(struct file *filp , struct address_space *mapping , struct list_head *pages ,
                    unsigned int nr_pages ) ;
   int (*write_begin)(struct file * , struct address_space *mapping , loff_t pos ,
                      unsigned int len , unsigned int flags , struct page **pagep ,
                      void **fsdata ) ;
   int (*write_end)(struct file * , struct address_space *mapping , loff_t pos , unsigned int len ,
                    unsigned int copied , struct page *page , void *fsdata ) ;
   sector_t (*bmap)(struct address_space * , sector_t  ) ;
   void (*invalidatepage)(struct page * , unsigned long  ) ;
   int (*releasepage)(struct page * , gfp_t  ) ;
   ssize_t (*direct_IO)(int  , struct kiocb * , struct iovec  const  *iov , loff_t offset ,
                        unsigned long nr_segs ) ;
   int (*get_xip_mem)(struct address_space * , unsigned long  , int  , void ** , unsigned long * ) ;
   int (*migratepage)(struct address_space * , struct page * , struct page * ) ;
   int (*launder_page)(struct page * ) ;
   int (*is_partially_uptodate)(struct page * , read_descriptor_t * , unsigned long  ) ;
};
//#line  2586 "psmousebase.merged.kernel.c"
struct address_space {
   struct inode *host ;
   struct radix_tree_root page_tree ;
   spinlock_t tree_lock ;
   unsigned int i_mmap_writable ;
   struct prio_tree_root i_mmap ;
   struct list_head i_mmap_nonlinear ;
   spinlock_t i_mmap_lock ;
   unsigned int truncate_count ;
   unsigned long nrpages ;
   unsigned long writeback_index ;
   struct address_space_operations  const  *a_ops ;
   unsigned long flags ;
   struct backing_dev_info *backing_dev_info ;
   spinlock_t private_lock ;
   struct list_head private_list ;
   struct address_space *assoc_mapping ;
} __attribute__((__aligned__(sizeof(long )))) ;
//#line  2605
struct hd_struct;
struct hd_struct;
//#line  2607
struct gendisk;
struct gendisk;
//#line  2609 "psmousebase.merged.kernel.c"
struct block_device {
   dev_t bd_dev ;
   struct inode *bd_inode ;
   struct super_block *bd_super ;
   int bd_openers ;
   struct mutex bd_mutex ;
   struct semaphore bd_mount_sem ;
   struct list_head bd_inodes ;
   void *bd_holder ;
   int bd_holders ;
   struct list_head bd_holder_list ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
   struct hd_struct *bd_part ;
   unsigned int bd_part_count ;
   int bd_invalidated ;
   struct gendisk *bd_disk ;
   struct list_head bd_list ;
   struct backing_dev_info *bd_inode_backing_dev_info ;
   unsigned long bd_private ;
   int bd_fsfreeze_count ;
   struct mutex bd_fsfreeze_mutex ;
};
//#line  2633
struct inode_operations;
struct inode_operations;
//#line  2635
struct file_operations;
struct file_operations;
//#line  2637
struct file_lock;
struct file_lock;
//#line  2639
struct cdev;
struct cdev;
//#line  2641 "psmousebase.merged.kernel.c"
union __anonunion____missing_field_name_191 {
   struct pipe_inode_info *i_pipe ;
   struct block_device *i_bdev ;
   struct cdev *i_cdev ;
};
//#line  2647
struct dnotify_struct;
struct dnotify_struct;
//#line  2649 "psmousebase.merged.kernel.c"
struct inode {
   struct hlist_node i_hash ;
   struct list_head i_list ;
   struct list_head i_sb_list ;
   struct list_head i_dentry ;
   unsigned long i_ino ;
   atomic_t i_count ;
   unsigned int i_nlink ;
   uid_t i_uid ;
   gid_t i_gid ;
   dev_t i_rdev ;
   u64 i_version ;
   loff_t i_size ;
   struct timespec i_atime ;
   struct timespec i_mtime ;
   struct timespec i_ctime ;
   unsigned int i_blkbits ;
   blkcnt_t i_blocks ;
   unsigned short i_bytes ;
   umode_t i_mode ;
   spinlock_t i_lock ;
   struct mutex i_mutex ;
   struct rw_semaphore i_alloc_sem ;
   struct inode_operations  const  *i_op ;
   struct file_operations  const  *i_fop ;
   struct super_block *i_sb ;
   struct file_lock *i_flock ;
   struct address_space *i_mapping ;
   struct address_space i_data ;
   struct dquot *i_dquot[2] ;
   struct list_head i_devices ;
   union __anonunion____missing_field_name_191 __annonCompField23 ;
   int i_cindex ;
   __u32 i_generation ;
   unsigned long i_dnotify_mask ;
   struct dnotify_struct *i_dnotify ;
   struct list_head inotify_watches ;
   struct mutex inotify_mutex ;
   unsigned long i_state ;
   unsigned long dirtied_when ;
   unsigned int i_flags ;
   atomic_t i_writecount ;
   void *i_security ;
   void *i_private ;
};
//#line  2695 "psmousebase.merged.kernel.c"
struct fown_struct {
   rwlock_t lock ;
   struct pid *pid ;
   enum pid_type pid_type ;
   uid_t uid ;
   uid_t euid ;
   int signum ;
};
//#line  2704 "psmousebase.merged.kernel.c"
struct file_ra_state {
   unsigned long start ;
   unsigned int size ;
   unsigned int async_size ;
   unsigned int ra_pages ;
   int mmap_miss ;
   loff_t prev_pos ;
};
//#line  2713 "psmousebase.merged.kernel.c"
union __anonunion_f_u_192 {
   struct list_head fu_list ;
   struct rcu_head fu_rcuhead ;
};
//#line  2718 "psmousebase.merged.kernel.c"
struct file {
   union __anonunion_f_u_192 f_u ;
   struct path f_path ;
   struct file_operations  const  *f_op ;
   atomic_long_t f_count ;
   unsigned int f_flags ;
   fmode_t f_mode ;
   loff_t f_pos ;
   struct fown_struct f_owner ;
   struct cred  const  *f_cred ;
   struct file_ra_state f_ra ;
   u64 f_version ;
   void *f_security ;
   void *private_data ;
   struct list_head f_ep_links ;
   spinlock_t f_ep_lock ;
   struct address_space *f_mapping ;
};
//#line  2737 "psmousebase.merged.kernel.c"
typedef struct files_struct *fl_owner_t;
//#line  2739 "psmousebase.merged.kernel.c"
struct file_lock_operations {
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
};
//#line  2744 "psmousebase.merged.kernel.c"
struct lock_manager_operations {
   int (*fl_compare_owner)(struct file_lock * , struct file_lock * ) ;
   void (*fl_notify)(struct file_lock * ) ;
   int (*fl_grant)(struct file_lock * , struct file_lock * , int  ) ;
   void (*fl_copy_lock)(struct file_lock * , struct file_lock * ) ;
   void (*fl_release_private)(struct file_lock * ) ;
   void (*fl_break)(struct file_lock * ) ;
   int (*fl_mylease)(struct file_lock * , struct file_lock * ) ;
   int (*fl_change)(struct file_lock ** , int  ) ;
};
//#line  2755
struct nlm_lockowner;
struct nlm_lockowner;
//#line  2757 "psmousebase.merged.kernel.c"
struct nfs_lock_info {
   u32 state ;
   struct nlm_lockowner *owner ;
   struct list_head list ;
};
//#line  2763
struct nfs4_lock_state;
struct nfs4_lock_state;
//#line  2765 "psmousebase.merged.kernel.c"
struct nfs4_lock_info {
   struct nfs4_lock_state *owner ;
};
//#line  2769
struct fasync_struct;
struct fasync_struct;
//#line  2771 "psmousebase.merged.kernel.c"
struct __anonstruct_afs_194 {
   struct list_head link ;
   int state ;
};
//#line  2776 "psmousebase.merged.kernel.c"
union __anonunion_fl_u_193 {
   struct nfs_lock_info nfs_fl ;
   struct nfs4_lock_info nfs4_fl ;
   struct __anonstruct_afs_194 afs ;
};
//#line  2782 "psmousebase.merged.kernel.c"
struct file_lock {
   struct file_lock *fl_next ;
   struct list_head fl_link ;
   struct list_head fl_block ;
   fl_owner_t fl_owner ;
   unsigned char fl_flags ;
   unsigned char fl_type ;
   unsigned int fl_pid ;
   struct pid *fl_nspid ;
   wait_queue_head_t fl_wait ;
   struct file *fl_file ;
   loff_t fl_start ;
   loff_t fl_end ;
   struct fasync_struct *fl_fasync ;
   unsigned long fl_break_time ;
   struct file_lock_operations *fl_ops ;
   struct lock_manager_operations *fl_lmops ;
   union __anonunion_fl_u_193 fl_u ;
};
//#line  2802 "psmousebase.merged.kernel.c"
struct fasync_struct {
   int magic ;
   int fa_fd ;
   struct fasync_struct *fa_next ;
   struct file *fa_file ;
};
//#line  2809
struct file_system_type;
struct file_system_type;
//#line  2811
struct super_operations;
struct super_operations;
//#line  2813
struct xattr_handler;
struct xattr_handler;
//#line  2815
struct mtd_info;
struct mtd_info;
//#line  2817 "psmousebase.merged.kernel.c"
struct super_block {
   struct list_head s_list ;
   dev_t s_dev ;
   unsigned long s_blocksize ;
   unsigned char s_blocksize_bits ;
   unsigned char s_dirt ;
   unsigned long long s_maxbytes ;
   struct file_system_type *s_type ;
   struct super_operations  const  *s_op ;
   struct dquot_operations *dq_op ;
   struct quotactl_ops *s_qcop ;
   struct export_operations  const  *s_export_op ;
   unsigned long s_flags ;
   unsigned long s_magic ;
   struct dentry *s_root ;
   struct rw_semaphore s_umount ;
   struct mutex s_lock ;
   int s_count ;
   int s_need_sync_fs ;
   atomic_t s_active ;
   void *s_security ;
   struct xattr_handler **s_xattr ;
   struct list_head s_inodes ;
   struct list_head s_dirty ;
   struct list_head s_io ;
   struct list_head s_more_io ;
   struct hlist_head s_anon ;
   struct list_head s_files ;
   struct list_head s_dentry_lru ;
   int s_nr_dentry_unused ;
   struct block_device *s_bdev ;
   struct mtd_info *s_mtd ;
   struct list_head s_instances ;
   struct quota_info s_dquot ;
   int s_frozen ;
   wait_queue_head_t s_wait_unfrozen ;
   char s_id[32] ;
   void *s_fs_info ;
   fmode_t s_mode ;
   struct mutex s_vfs_rename_mutex ;
   u32 s_time_gran ;
   char *s_subtype ;
   char *s_options ;
   struct list_head s_async_list ;
};
//#line  2863 "psmousebase.merged.kernel.c"
struct fiemap_extent_info {
   unsigned int fi_flags ;
   unsigned int fi_extents_mapped ;
   unsigned int fi_extents_max ;
   struct fiemap_extent *fi_extents_start ;
};
//#line  2870 "psmousebase.merged.kernel.c"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   ssize_t (*aio_read)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                       loff_t  ) ;
   ssize_t (*aio_write)(struct kiocb * , struct iovec  const  * , unsigned long  ,
                        loff_t  ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , u64  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * , fl_owner_t id ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*aio_fsync)(struct kiocb * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*splice_write)(struct pipe_inode_info * , struct file * , loff_t * , size_t  ,
                           unsigned int  ) ;
   ssize_t (*splice_read)(struct file * , loff_t * , struct pipe_inode_info * , size_t  ,
                          unsigned int  ) ;
   int (*setlease)(struct file * , long  , struct file_lock ** ) ;
};
//#line  2906 "psmousebase.merged.kernel.c"
struct inode_operations {
   int (*create)(struct inode * , struct dentry * , int  , struct nameidata * ) ;
   struct dentry *(*lookup)(struct inode * , struct dentry * , struct nameidata * ) ;
   int (*link)(struct dentry * , struct inode * , struct dentry * ) ;
   int (*unlink)(struct inode * , struct dentry * ) ;
   int (*symlink)(struct inode * , struct dentry * , char const   * ) ;
   int (*mkdir)(struct inode * , struct dentry * , int  ) ;
   int (*rmdir)(struct inode * , struct dentry * ) ;
   int (*mknod)(struct inode * , struct dentry * , int  , dev_t  ) ;
   int (*rename)(struct inode * , struct dentry * , struct inode * , struct dentry * ) ;
   int (*readlink)(struct dentry * , char * , int  ) ;
   void *(*follow_link)(struct dentry * , struct nameidata * ) ;
   void (*put_link)(struct dentry * , struct nameidata * , void * ) ;
   void (*truncate)(struct inode * ) ;
   int (*permission)(struct inode * , int  ) ;
   int (*setattr)(struct dentry * , struct iattr * ) ;
   int (*getattr)(struct vfsmount *mnt , struct dentry * , struct kstat * ) ;
   int (*setxattr)(struct dentry * , char const   * , void const   * , size_t  , int  ) ;
   ssize_t (*getxattr)(struct dentry * , char const   * , void * , size_t  ) ;
   ssize_t (*listxattr)(struct dentry * , char * , size_t  ) ;
   int (*removexattr)(struct dentry * , char const   * ) ;
   void (*truncate_range)(struct inode * , loff_t  , loff_t  ) ;
   long (*fallocate)(struct inode *inode , int mode , loff_t offset , loff_t len ) ;
   int (*fiemap)(struct inode * , struct fiemap_extent_info * , u64 start , u64 len ) ;
};
//#line  2932 "psmousebase.merged.kernel.c"
struct super_operations {
   struct inode *(*alloc_inode)(struct super_block *sb ) ;
   void (*destroy_inode)(struct inode * ) ;
   void (*dirty_inode)(struct inode * ) ;
   int (*write_inode)(struct inode * , int  ) ;
   void (*drop_inode)(struct inode * ) ;
   void (*delete_inode)(struct inode * ) ;
   void (*put_super)(struct super_block * ) ;
   void (*write_super)(struct super_block * ) ;
   int (*sync_fs)(struct super_block *sb , int wait ) ;
   int (*freeze_fs)(struct super_block * ) ;
   int (*unfreeze_fs)(struct super_block * ) ;
   int (*statfs)(struct dentry * , struct kstatfs * ) ;
   int (*remount_fs)(struct super_block * , int * , char * ) ;
   void (*clear_inode)(struct inode * ) ;
   void (*umount_begin)(struct super_block * ) ;
   int (*show_options)(struct seq_file * , struct vfsmount * ) ;
   int (*show_stats)(struct seq_file * , struct vfsmount * ) ;
   ssize_t (*quota_read)(struct super_block * , int  , char * , size_t  , loff_t  ) ;
   ssize_t (*quota_write)(struct super_block * , int  , char const   * , size_t  ,
                          loff_t  ) ;
   int (*bdev_try_to_free_page)(struct super_block * , struct page * , gfp_t  ) ;
};
//#line  2956 "psmousebase.merged.kernel.c"
struct file_system_type {
   char const   *name ;
   int fs_flags ;
   int (*get_sb)(struct file_system_type * , int  , char const   * , void * , struct vfsmount * ) ;
   void (*kill_sb)(struct super_block * ) ;
   struct module *owner ;
   struct file_system_type *next ;
   struct list_head fs_supers ;
   struct lock_class_key s_lock_key ;
   struct lock_class_key s_umount_key ;
   struct lock_class_key i_lock_key ;
   struct lock_class_key i_mutex_key ;
   struct lock_class_key i_mutex_dir_key ;
   struct lock_class_key i_alloc_sem_key ;
};
//#line  2972 "psmousebase.merged.kernel.c"
typedef unsigned long kernel_ulong_t;
//#line  2974 "psmousebase.merged.kernel.c"
struct serio_device_id {
   __u8 type ;
   __u8 extra ;
   __u8 id ;
   __u8 proto ;
};
//#line  2981 "psmousebase.merged.kernel.c"
struct input_device_id {
   kernel_ulong_t flags ;
   __u16 bustype ;
   __u16 vendor ;
   __u16 product ;
   __u16 version ;
   kernel_ulong_t evbit[1] ;
   kernel_ulong_t keybit[12] ;
   kernel_ulong_t relbit[1] ;
   kernel_ulong_t absbit[1] ;
   kernel_ulong_t mscbit[1] ;
   kernel_ulong_t ledbit[1] ;
   kernel_ulong_t sndbit[1] ;
   kernel_ulong_t ffbit[2] ;
   kernel_ulong_t swbit[1] ;
   kernel_ulong_t driver_info ;
};
//#line  2999
struct ff_device;
struct ff_device;
//#line  3001
struct input_handle;
struct input_handle;
//#line  3003 "psmousebase.merged.kernel.c"
struct input_dev {
   char const   *name ;
   char const   *phys ;
   char const   *uniq ;
   struct input_id id ;
   unsigned long evbit[((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long keybit[((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long relbit[((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long absbit[((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long mscbit[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long ledbit[((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long sndbit[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long ffbit[((128UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long swbit[((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned int keycodemax ;
   unsigned int keycodesize ;
   void *keycode ;
   int (*setkeycode)(struct input_dev *dev , int scancode , int keycode ) ;
   int (*getkeycode)(struct input_dev *dev , int scancode , int *keycode ) ;
   struct ff_device *ff ;
   unsigned int repeat_key ;
   struct timer_list timer ;
   int sync ;
   int abs[64] ;
   int rep[2] ;
   unsigned long key[((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long led[((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long snd[((8UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   unsigned long sw[((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   int absmax[64] ;
   int absmin[64] ;
   int absfuzz[64] ;
   int absflat[64] ;
   int (*open)(struct input_dev *dev ) ;
   void (*close)(struct input_dev *dev ) ;
   int (*flush)(struct input_dev *dev , struct file *file ) ;
   int (*event)(struct input_dev *dev , unsigned int type , unsigned int code , int value ) ;
   struct input_handle *grab ;
   spinlock_t event_lock ;
   struct mutex mutex ;
   unsigned int users ;
   int going_away ;
   struct device dev ;
   struct list_head h_list ;
   struct list_head node ;
};
//#line  3050 "psmousebase.merged.kernel.c"
struct input_handler {
   void *private ;
   void (*event)(struct input_handle *handle , unsigned int type , unsigned int code ,
                 int value ) ;
   int (*connect)(struct input_handler *handler , struct input_dev *dev , struct input_device_id  const  *id ) ;
   void (*disconnect)(struct input_handle *handle ) ;
   void (*start)(struct input_handle *handle ) ;
   struct file_operations  const  *fops ;
   int minor ;
   char const   *name ;
   struct input_device_id  const  *id_table ;
   struct input_device_id  const  *blacklist ;
   struct list_head h_list ;
   struct list_head node ;
};
//#line  3066 "psmousebase.merged.kernel.c"
struct input_handle {
   void *private ;
   int open ;
   char const   *name ;
   struct input_dev *dev ;
   struct input_handler *handler ;
   struct list_head d_node ;
   struct list_head h_node ;
};
//#line  3076 "psmousebase.merged.kernel.c"
struct ff_device {
   int (*upload)(struct input_dev *dev , struct ff_effect *effect , struct ff_effect *old ) ;
   int (*erase)(struct input_dev *dev , int effect_id ) ;
   int (*playback)(struct input_dev *dev , int effect_id , int value ) ;
   void (*set_gain)(struct input_dev *dev , u16 gain ) ;
   void (*set_autocenter)(struct input_dev *dev , u16 magnitude ) ;
   void (*destroy)(struct ff_device * ) ;
   void *private ;
   unsigned long ffbit[((128UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))] ;
   struct mutex mutex ;
   int max_effects ;
   struct ff_effect *effects ;
   struct file *effect_owners[] ;
};
//#line  3091
struct serio_driver;
struct serio_driver;
//#line  3093 "psmousebase.merged.kernel.c"
struct serio {
   void *port_data ;
   char name[32] ;
   char phys[32] ;
   unsigned int manual_bind ;
   struct serio_device_id id ;
   spinlock_t lock ;
   int (*write)(struct serio * , unsigned char  ) ;
   int (*open)(struct serio * ) ;
   void (*close)(struct serio * ) ;
   int (*start)(struct serio * ) ;
   void (*stop)(struct serio * ) ;
   struct serio *parent ;
   struct serio *child ;
   unsigned int depth ;
   struct serio_driver *drv ;
   struct mutex drv_mutex ;
   struct device dev ;
   unsigned int registered ;
   struct list_head node ;
};
//#line  3115 "psmousebase.merged.kernel.c"
struct serio_driver {
   void *private ;
   char *description ;
   struct serio_device_id *id_table ;
   unsigned int manual_bind ;
   void (*write_wakeup)(struct serio * ) ;
   irqreturn_t (*interrupt)(struct serio * , unsigned char  , unsigned int  ) ;
   int (*connect)(struct serio * , struct serio_driver *drv ) ;
   int (*reconnect)(struct serio * ) ;
   void (*disconnect)(struct serio * ) ;
   void (*cleanup)(struct serio * ) ;
   struct device_driver driver ;
};
//#line  3129 "psmousebase.merged.kernel.c"
struct ps2dev {
   struct serio *serio ;
   struct mutex cmd_mutex ;
   wait_queue_head_t wait ;
   unsigned long flags ;
   unsigned char cmdbuf[6] ;
   unsigned char cmdcnt ;
   unsigned char nak ;
};
//#line  3139
struct cpu_workqueue_struct;
struct cpu_workqueue_struct;
//#line  3141 "psmousebase.merged.kernel.c"
struct workqueue_struct {
   struct cpu_workqueue_struct *cpu_wq ;
   char const   *name ;
   struct list_head list ;
};
//#line  3147
struct net_device;
struct net_device;
//#line  3149
enum psmouse_state {
    PSMOUSE_IGNORE = 0,
    PSMOUSE_INITIALIZING = 1,
    PSMOUSE_RESYNCING = 2,
    PSMOUSE_CMD_MODE = 3,
    PSMOUSE_ACTIVATED = 4
} ;
//#line  3157
enum __anonenum_psmouse_ret_t_198 {
    PSMOUSE_BAD_DATA = 0,
    PSMOUSE_GOOD_DATA = 1,
    PSMOUSE_FULL_PACKET = 2
} ;
//#line  3163 "psmousebase.merged.kernel.c"
typedef enum __anonenum_psmouse_ret_t_198 psmouse_ret_t;
//#line  3165 "psmousebase.merged.kernel.c"
struct psmouse {
   void *private ;
   struct input_dev * __attribute__((__noderef__, __address_space__(2))) dev ;
   struct ps2dev ps2dev ;
   struct delayed_work resync_work ;
   char *vendor ;
   char *name ;
   unsigned char packet[8] ;
   unsigned char badbyte ;
   unsigned char pktcnt ;
   unsigned char pktsize ;
   unsigned char type ;
   unsigned char acks_disable_command ;
   unsigned int model ;
   unsigned long last ;
   unsigned long out_of_sync ;
   unsigned long num_resyncs ;
   enum psmouse_state state ;
   char devname[64] ;
   char phys[32] ;
   unsigned int rate ;
   unsigned int resolution ;
   unsigned int resetafter ;
   unsigned int resync_time ;
   unsigned int smartscroll ;
   psmouse_ret_t (*protocol_handler)(struct psmouse *psmouse ) ;
   void (*set_rate)(struct psmouse *psmouse , unsigned int rate ) ;
   void (*set_resolution)(struct psmouse *psmouse , unsigned int resolution ) ;
   int (*reconnect)(struct psmouse *psmouse ) ;
   void (*disconnect)(struct psmouse *psmouse ) ;
   void (*cleanup)(struct psmouse *psmouse ) ;
   int (*poll)(struct psmouse *psmouse ) ;
   void (*pt_activate)(struct psmouse *psmouse ) ;
   void (*pt_deactivate)(struct psmouse *psmouse ) ;
};
//#line  3201
enum psmouse_type {
    PSMOUSE_NONE = 0,
    PSMOUSE_PS2 = 1,
    PSMOUSE_PS2PP = 2,
    PSMOUSE_THINKPS = 3,
    PSMOUSE_GENPS = 4,
    PSMOUSE_IMPS = 5,
    PSMOUSE_IMEX = 6,
    PSMOUSE_SYNAPTICS = 7,
    PSMOUSE_ALPS = 8,
    PSMOUSE_LIFEBOOK = 9,
    PSMOUSE_TRACKPOINT = 10,
    PSMOUSE_TOUCHKIT_PS2 = 11,
    PSMOUSE_CORTRON = 12,
    PSMOUSE_HGPK = 13,
    PSMOUSE_ELANTECH = 14,
    PSMOUSE_AUTO = 15
} ;
//#line  3220 "psmousebase.merged.kernel.c"
struct psmouse_attribute {
   struct device_attribute dattr ;
   void *data ;
   ssize_t (*show)(struct psmouse *psmouse , void *data , char *buf ) ;
   ssize_t (*set)(struct psmouse *psmouse , void *data , char const   *buf , size_t count ) ;
   int protect ;
};
//#line  3228 "psmousebase.merged.kernel.c"
struct workqueue_struct___0 {
   struct cpu_workqueue_struct *cpu_wq ;
   struct list_head list ;
   char const   *name ;
   int singlethread ;
   int freezeable ;
   int rt ;
   struct lockdep_map lockdep_map ;
};
//#line  3238 "psmousebase.merged.kernel.c"
struct psmouse_protocol {
   enum psmouse_type type ;
   char const   *name ;
   char const   *alias ;
   int maxproto ;
   int (*detect)(struct psmouse * , int  ) ;
   int (*init)(struct psmouse * ) ;
};
//#line  3247
enum hrtimer_restart;
//#line  3249 "psmousebase.merged.kernel.c"
struct alps_model_info {
   unsigned char signature[3] ;
   unsigned char byte0 ;
   unsigned char mask0 ;
   unsigned char flags ;
};
//#line  3256 "psmousebase.merged.kernel.c"
struct alps_data {
   struct input_dev *dev2 ;
   char phys[32] ;
   struct alps_model_info  const  *i ;
   int prev_fin ;
};
//#line  3263
enum hrtimer_restart;
//#line  3265 "psmousebase.merged.kernel.c"
struct synaptics_hw_state {
   int x ;
   int y ;
   int z ;
   int w ;
   unsigned int left : 1 ;
   unsigned int right : 1 ;
   unsigned int middle : 1 ;
   unsigned int up : 1 ;
   unsigned int down : 1 ;
   unsigned char ext_buttons ;
   signed char scroll ;
};
//#line  3279 "psmousebase.merged.kernel.c"
struct synaptics_data {
   unsigned long model_id ;
   unsigned long capabilities ;
   unsigned long ext_cap ;
   unsigned long identity ;
   unsigned char pkt_type ;
   unsigned char mode ;
   int scroll ;
};
//#line  3289
enum hrtimer_restart;
//#line  3291 "psmousebase.merged.kernel.c"
struct dmi_strmatch {
   unsigned char slot ;
   char substr[79] ;
};
//#line  3296 "psmousebase.merged.kernel.c"
struct dmi_system_id {
   int (*callback)(struct dmi_system_id  const  * ) ;
   char const   *ident ;
   struct dmi_strmatch matches[4] ;
   void *driver_data ;
};
//#line  3303 "psmousebase.merged.kernel.c"
struct lifebook_data {
   struct input_dev *dev2 ;
   char phys[32] ;
};
//#line  3308
enum hrtimer_restart;
//#line  3310 "psmousebase.merged.kernel.c"
struct ps2pp_info {
   u8 model ;
   u8 kind ;
   u16 features ;
};
//#line  3316
enum hrtimer_restart;
//#line  3318 "psmousebase.merged.kernel.c"
struct exception_table_entry {
   unsigned long insn ;
   unsigned long fixup ;
};
//#line  3323 "psmousebase.merged.kernel.c"
struct trackpoint_data {
   unsigned char sensitivity ;
   unsigned char speed ;
   unsigned char inertia ;
   unsigned char reach ;
   unsigned char draghys ;
   unsigned char mindrag ;
   unsigned char thresh ;
   unsigned char upthresh ;
   unsigned char ztime ;
   unsigned char jenks ;
   unsigned char press_to_select ;
   unsigned char skipback ;
   unsigned char ext_dev ;
};
//#line  3339 "psmousebase.merged.kernel.c"
struct trackpoint_attr_data {
   size_t field_offset ;
   unsigned char command ;
   unsigned char mask ;
   unsigned char inverted ;
};
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
//#line  3348
#pragma merger(0,"./psmousebase_annotated.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  3350 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) set_bit)(unsigned int nr ,
                                                                   unsigned long volatile   *addr ) 
{ 


  {
//#line  3357
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "bts %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr): "memory");
//#line  3370
  return;
}
}
//#line  3374
extern void warn_slowpath(char const   *file , int line , char const   *fmt  , ...) ;
//#line  3377
extern int strict_strtoul(char const   * , unsigned int  , unsigned long * ) ;
//#line  3379
extern int sprintf(char *buf , char const   *fmt  , ...) ;
//#line  3381
extern int snprintf(char *buf , size_t size , char const   *fmt  , ...) ;
//#line  3384
extern int printk(char const   *fmt  , ...) ;
//#line  3386
extern void msleep(unsigned int msecs ) ;
//#line  3388
extern unsigned long strlen(char const   *s ) ;
//#line  3390
extern int strncmp(char const   * , char const   * , __kernel_size_t  ) ;
//#line  3392 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) INIT_LIST_HEAD)(struct list_head *list ) 
{ 


  {
//#line  3398
  list->next = list;
//#line  3400
  list->prev = list;
//#line  3402
  return;
}
}
//#line  3406
extern void lockdep_init_map(struct lockdep_map *lock , char const   *name , struct lock_class_key *key ,
                             int subclass ) ;
//#line  3409
extern void _spin_lock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  3411
extern void _spin_unlock_irq(spinlock_t *lock )  __attribute__((__section__(".spinlock.text"))) ;
//#line  3413
extern void mutex_lock_nested(struct mutex *lock , unsigned int subclass ) ;
//#line  3415
extern int __attribute__((__warn_unused_result__))  mutex_lock_interruptible_nested(struct mutex *lock ,
                                                                                    unsigned int subclass ) ;
//#line  3418
extern void mutex_unlock(struct mutex *lock ) ;
//#line  3420
extern int __attribute__((__warn_unused_result__))  sysfs_create_group(struct kobject *kobj ,
                                                                       struct attribute_group  const  *grp ) ;
//#line  3423
extern void sysfs_remove_group(struct kobject *kobj , struct attribute_group  const  *grp ) ;
//#line  3425
extern int param_set_uint(char const   *val , struct kernel_param *kp ) ;
//#line  3427
extern int param_get_uint(char *buffer , struct kernel_param *kp ) ;
//#line  3429
extern int param_set_bool(char const   *val , struct kernel_param *kp ) ;
//#line  3431
extern int param_get_bool(char *buffer , struct kernel_param *kp ) ;
//#line  3433
extern void kfree(void const   * ) ;
//#line  3435
extern unsigned long volatile   jiffies  __attribute__((__section__(".data"))) ;
//#line  3437
extern void init_timer(struct timer_list *timer ) ;
//#line  3439
extern struct workqueue_struct *__create_workqueue_key(char const   *name , int singlethread ,
                                                       int freezeable , int rt , struct lock_class_key *key ,
                                                       char const   *lock_name ) ;
//#line  3443
extern void destroy_workqueue(struct workqueue_struct *wq ) ;
//#line  3445
extern int queue_delayed_work(struct workqueue_struct * __attribute__((__noderef__,
                              __address_space__(2))) wq , struct delayed_work * __attribute__((__noderef__,
                              __address_space__(2))) work , unsigned long delay ) ;
//#line  3449
extern void flush_workqueue(struct workqueue_struct *wq ) ;
//#line  3451
extern void *__kmalloc(size_t size , gfp_t flags ) ;
//#line  3453 "psmousebase.merged.kernel.c"
__inline static void *( __attribute__((__always_inline__)) kmalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp___2 ;

  {
  {
//#line  3460
  tmp___2 = __kmalloc(size, flags);
  }
//#line  3462
  return (tmp___2);
}
}
//#line  3466 "psmousebase.merged.kernel.c"
__inline static void *( __attribute__((__always_inline__)) kzalloc)(size_t size ,
                                                                    gfp_t flags ) 
{ 
  void *tmp ;

  {
  {
//#line  3473
  tmp = kmalloc(size, flags | 32768U);
  }
//#line  3475
  return (tmp);
}
}
//#line  3479
int init_module(void) ;
//#line  3481
void cleanup_module(void) ;
//#line  3483
extern struct module __this_module ;
//#line  3485 "psmousebase.merged.kernel.c"
__inline static void *( __attribute__((__always_inline__)) dev_get_drvdata)(struct device  const  *dev ) 
{ 


  {
//#line  3491
  return ((void *)dev->driver_data);
}
}
//#line  3495 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) dev_set_drvdata)(struct device *dev ,
                                                                           void *data ) 
{ 


  {
//#line  3502
  dev->driver_data = (struct psmouse *)data;
//#line  3504
  return;
}
}
//#line  3508
extern struct input_dev *input_allocate_device(void) ;
//#line  3510
extern void input_free_device(struct input_dev *dev ) ;
//#line  3512
extern int __attribute__((__warn_unused_result__))  input_register_device(struct input_dev * ) ;
//#line  3514
extern void input_unregister_device(struct input_dev * ) ;
//#line  3516
extern void input_event(struct input_dev *dev , unsigned int type , unsigned int code ,
                        int value ) ;
//#line  3519 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) input_report_key)(struct input_dev *dev ,
                                                                            unsigned int code ,
                                                                            int value ) 
{ 


  {
  {
//#line  3527
  input_event(dev, 1U, code, ! (! value));
  }
//#line  3529
  return;
}
}
//#line  3533 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) input_report_rel)(struct input_dev *dev ,
                                                                            unsigned int code ,
                                                                            int value ) 
{ 


  {
  {
//#line  3541
  input_event(dev, 2U, code, value);
  }
//#line  3543
  return;
}
}
//#line  3547 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) input_sync)(struct input_dev *dev ) 
{ 


  {
  {
//#line  3553
  input_event(dev, 0U, 0U, 0);
  }
//#line  3555
  return;
}
}
//#line  3559
extern int serio_open(struct serio *serio , struct serio_driver *drv ) ;
//#line  3561
extern void serio_close(struct serio *serio ) ;
//#line  3563
extern void serio_reconnect(struct serio *serio ) ;
//#line  3565
extern void serio_unregister_child_port(struct serio *serio ) ;
//#line  3567
extern int __serio_register_driver(struct serio_driver *drv , struct module *owner ,
                                   char const   *mod_name ) ;
//#line  3570 "psmousebase.merged.kernel.c"
__inline static int __attribute__((__warn_unused_result__))  ( __attribute__((__always_inline__)) serio_register_driver)(struct serio_driver *drv ) 
{ 
  int tmp ;

  {
  {
//#line  3576
  tmp = __serio_register_driver(drv, & __this_module, str_490918915);
  }
//#line  3578
  return (tmp);
}
}
//#line  3582
extern void serio_unregister_driver(struct serio_driver *drv ) ;
//#line  3584 "psmousebase.merged.kernel.c"
__inline static void *( __attribute__((__always_inline__)) serio_get_drvdata)(struct serio *serio ) 
{ 
  void *tmp ;

  {
  {
//#line  3590
  tmp = dev_get_drvdata((struct device  const  *)(& serio->dev));
  }
//#line  3592
  return (tmp);
}
}
//#line  3596 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_set_drvdata)(struct serio *serio ,
                                                                             void *data ) 
{ 


  {
  {
//#line  3603
  dev_set_drvdata(& serio->dev, data);
  }
//#line  3605
  return;
}
}
//#line  3609 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_pause_rx)(struct serio *serio ) 
{ 


  {
  {
//#line  3615
  _spin_lock_irq(& serio->lock);
  }
//#line  3617
  return;
}
}
//#line  3621 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_continue_rx)(struct serio *serio ) 
{ 


  {
  {
//#line  3627
  _spin_unlock_irq(& serio->lock);
  }
//#line  3629
  return;
}
}
//#line  3633 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) serio_pin_driver)(struct serio *serio ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  3639
  tmp___0 = (int )mutex_lock_interruptible_nested(& serio->drv_mutex, 0U);
  tmp = tmp___0;
  }
//#line  3641
  return (tmp);
}
}
//#line  3645 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_pin_driver_uninterruptible)(struct serio *serio ) 
{ 


  {
  {
//#line  3651
  mutex_lock_nested(& serio->drv_mutex, 0U);
  }
//#line  3653
  return;
}
}
//#line  3657 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_unpin_driver)(struct serio *serio ) 
{ 


  {
  {
//#line  3663
  mutex_unlock(& serio->drv_mutex);
  }
//#line  3665
  return;
}
}
//#line  3669
extern void ps2_init(struct ps2dev *ps2dev , struct serio *serio ) ;
//#line  3671
extern int ps2_sendbyte(struct ps2dev *ps2dev , unsigned char byte , int timeout ) ;
//#line  3673
extern int ps2_command(struct ps2dev *ps2dev , unsigned char *param , int command ) ;
//#line  3675
extern int ps2_handle_ack(struct ps2dev *ps2dev , unsigned char data ) ;
//#line  3677
extern int ps2_handle_response(struct ps2dev *ps2dev , unsigned char data ) ;
//#line  3679
extern void ps2_cmd_aborted(struct ps2dev *ps2dev ) ;
//#line  3681 "psmousebase.merged.kernel.c"
void MICRODRIVERS__DUMMY(void *x ) 
{ 


  {
//#line  3687
  return;
}
}
//#line  3691 "psmousebase.merged.kernel.c"
char const   *MICRODRIVERS__MODIF_dev_driver_string(struct device *dev ) 
{ 


  {
//#line  3697
  return ((char const   *)0);
}
}
//#line  3701 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn ,
                                                  int where , u16 val ) 
{ 


  {
//#line  3708
  return (0);
}
}
//#line  3712 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_lock(spinlock_t *lock ) 
{ 


  {
//#line  3718
  return;
}
}
//#line  3722 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF___spin_lock_init(spinlock_t *lock , char const   *name ,
                                          struct lock_class_key *key ) 
{ 


  {
//#line  3729
  return;
}
}
//#line  3733 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_lock_irq(spinlock_t *lock ) 
{ 


  {
//#line  3739
  return;
}
}
//#line  3743 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_lock_irqsave(spinlock_t *lock ) 
{ 


  {
//#line  3749
  return;
}
}
//#line  3753 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_unlock(spinlock_t *lock ) 
{ 


  {
//#line  3759
  return;
}
}
//#line  3763 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
//#line  3769
  return;
}
}
//#line  3773 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF__spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
//#line  3779
  return;
}
}
//#line  3783 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_pci_bus_read_config_byte(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u8 *val ) 
{ 


  {
  {
//#line  3790
  MICRODRIVERS__DUMMY((void *)val);
  }
//#line  3792
  return (0);
}
}
//#line  3796 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn ,
                                                 int where , u16 *val ) 
{ 


  {
  {
//#line  3803
  MICRODRIVERS__DUMMY((void *)val);
  }
//#line  3805
  return (0);
}
}
//#line  3809 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_pci_clear_mwi(struct pci_dev *dev ) 
{ 


  {
//#line  3815
  return;
}
}
//#line  3819 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_request_irq(unsigned int a , irqreturn_t (*handler)(int  ,
                                                                            void * ,
                                                                            struct pt_regs * ) ,
                                    unsigned long b , char const   *c , void *d ) 
{ 


  {
//#line  3828
  return (0);
}
}
//#line  3832 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_free_irq(unsigned int irq , struct net_device *dev ) 
{ 


  {
//#line  3838
  return;
}
}
//#line  3842 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_ps2_command(struct ps2dev *ps2dev , unsigned char *param ,
                                    int command ) 
{ 


  {
  {
//#line  3849
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
//#line  3851
  MICRODRIVERS__DUMMY((void *)ps2dev->cmdcnt);
//#line  3853
  MICRODRIVERS__DUMMY((void *)(ps2dev->cmdbuf));
//#line  3855
  MICRODRIVERS__DUMMY((void *)param);
  }
//#line  3857
  return (0);
}
}
//#line  3861 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_init_timer(struct timer_list *timer ) 
{ 


  {
//#line  3867
  return;
}
}
//#line  3871 "psmousebase.merged.kernel.c"
struct workqueue_struct *MICRODRIVERS__MODIF___create_workqueue(char const   *name ,
                                                                int singlethread ) 
{ 


  {
//#line  3878
  return ((struct workqueue_struct *)((void *)0));
}
}
//#line  3882 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_flush_workqueue(struct workqueue_struct *wq ) 
{ 


  {
//#line  3888
  return;
}
}
//#line  3892 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_destroy_workqueue(struct workqueue_struct *wq ) 
{ 


  {
//#line  3898
  return;
}
}
//#line  3902 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_ps2_cmd_aborted(struct ps2dev *ps2dev ) 
{ 


  {
  {
//#line  3908
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
  }
//#line  3910
  return;
}
}
//#line  3914 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_ps2_drain(struct ps2dev *ps2dev , int maxbytes , int timeout ) 
{ 


  {
  {
//#line  3920
  MICRODRIVERS__DUMMY((void *)(ps2dev->cmdbuf));
//#line  3922
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
//#line  3924
  MICRODRIVERS__DUMMY((void *)ps2dev->cmdcnt);
  }
//#line  3926
  return;
}
}
//#line  3930 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_ps2_handle_ack(struct ps2dev *ps2dev , unsigned char data ) 
{ 


  {
  {
//#line  3936
  MICRODRIVERS__DUMMY((void *)ps2dev->nak);
//#line  3938
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
  }
//#line  3940
  return (0);
}
}
//#line  3944 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_ps2_handle_response(struct ps2dev *ps2dev , unsigned char data ) 
{ 


  {
  {
//#line  3950
  MICRODRIVERS__DUMMY((void *)(ps2dev->cmdbuf));
//#line  3952
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
//#line  3954
  MICRODRIVERS__DUMMY((void *)ps2dev->cmdcnt);
  }
//#line  3956
  return (0);
}
}
//#line  3960 "psmousebase.merged.kernel.c"
void MICRODRIVERS__MODIF_ps2_init(struct ps2dev *ps2dev , struct serio *serio ) 
{ 


  {
  {
//#line  3966
  MICRODRIVERS__DUMMY((void *)ps2dev->serio);
  }
//#line  3968
  return;
}
}
//#line  3972 "psmousebase.merged.kernel.c"
int MICRODRIVERS__MODIF_ps2_sendbyte(struct ps2dev *ps2dev , unsigned char byte ,
                                     int timeout ) 
{ 


  {
  {
//#line  3979
  MICRODRIVERS__DUMMY((void *)ps2dev->nak);
//#line  3981
  MICRODRIVERS__DUMMY((void *)ps2dev->flags);
  }
//#line  3983
  return (0);
}
}
//#line  3987
void psmouse_queue_work(struct psmouse *psmouse , struct delayed_work *work , unsigned long delay ) ;
//#line  3989
int psmouse_sliced_command(struct psmouse *psmouse , unsigned char command ) ;
//#line  3991
int psmouse_reset(struct psmouse *psmouse ) ;
//#line  3993
void psmouse_set_state(struct psmouse *psmouse , enum psmouse_state new_state ) ;
//#line  3995
void odft_sfipsmouse_set_resolution(struct psmouse *psmouse , unsigned int resolution )  __attribute__((__isolate__)) ;
//#line  3997
ssize_t psmouse_attr_show_helper(struct device *dev , struct device_attribute *devattr ,
                                 char *buf ) ;
//#line  4000
ssize_t psmouse_attr_set_helper(struct device *dev , struct device_attribute *devattr ,
                                char const   *buf , size_t count ) ;
//#line  4003
int synaptics_detect(struct psmouse *psmouse , int set_properties ) ;
//#line  4005
int synaptics_init(struct psmouse *psmouse ) ;
//#line  4007
void synaptics_reset(struct psmouse *psmouse ) ;
//#line  4009
int ps2pp_init(struct psmouse *psmouse , int set_properties ) ;
//#line  4011
int alps_detect(struct psmouse *psmouse , int set_properties ) ;
//#line  4013
int alps_init(struct psmouse *psmouse ) ;
//#line  4015 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) hgpk_detect)(struct psmouse *psmouse ,
                                                                      int set_properties ) 
{ 


  {
//#line  4022
  return (-19);
}
}
//#line  4026 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) hgpk_init)(struct psmouse *psmouse ) 
{ 


  {
//#line  4032
  return (-19);
}
}
//#line  4036
int lifebook_detect(struct psmouse *psmouse , int set_properties ) ;
//#line  4038
int lifebook_init(struct psmouse *psmouse ) ;
//#line  4040
int trackpoint_detect(struct psmouse *psmouse , int set_properties ) ;
//#line  4042 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) touchkit_ps2_detect)(struct psmouse *psmouse ,
                                                                              int set_properties ) 
{ 


  {
//#line  4049
  return (-38);
}
}
//#line  4053 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) elantech_init)(struct psmouse *psmouse ) 
{ 


  {
//#line  4059
  return (-38);
}
}
static char const   __mod_author37[40]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4063
  {      (char const   )'a',      (char const   )'u',      (char const   )'t',      (char const   )'h', 
        (char const   )'o',      (char const   )'r',      (char const   )'=',      (char const   )'V', 
        (char const   )'o',      (char const   )'j',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'h',      (char const   )' ',      (char const   )'P', 
        (char const   )'a',      (char const   )'v',      (char const   )'l',      (char const   )'i', 
        (char const   )'k',      (char const   )' ',      (char const   )'<',      (char const   )'v', 
        (char const   )'o',      (char const   )'j',      (char const   )'t',      (char const   )'e', 
        (char const   )'c',      (char const   )'h',      (char const   )'@',      (char const   )'s', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )'.', 
        (char const   )'c',      (char const   )'z',      (char const   )'>',      (char const   )'\000'};
static char const   __mod_description38[30]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  4076
  {      (char const   )'d',      (char const   )'e',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'i',      (char const   )'p',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'=', 
        (char const   )'P',      (char const   )'S',      (char const   )'/',      (char const   )'2', 
        (char const   )' ',      (char const   )'m',      (char const   )'o',      (char const   )'u', 
        (char const   )'s',      (char const   )'e',      (char const   )' ',      (char const   )'d', 
        (char const   )'r',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'\000'};
static char const   __mod_license39[12]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4088
  {      (char const   )'l',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'e',      (char const   )'=', 
        (char const   )'G',      (char const   )'P',      (char const   )'L',      (char const   )'\000'};
//#line  4094 "psmousebase.merged.kernel.c"
static unsigned int psmouse_max_proto  =    15U;
//#line  4096
static int odft_sfipsmouse_set_maxproto(char const   *val , struct kernel_param *kp )  __attribute__((__isolate__)) ;
//#line  4098
static int odft_sfipsmouse_get_maxproto(char *buffer , struct kernel_param *kp )  __attribute__((__isolate__)) ;
//#line  4100 "psmousebase.merged.kernel.c"
static char const   __param_str_proto[6]  = {      (char const   )'p',      (char const   )'r',      (char const   )'o',      (char const   )'t', 
        (char const   )'o',      (char const   )'\000'};
//#line  4103 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_proto  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_proto, 420U, & odft_sfipsmouse_set_maxproto, & odft_sfipsmouse_get_maxproto,
    {(void *)(& psmouse_max_proto)}};
static char const   __mod_prototype47[28]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4106
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )':',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'t',      (char const   )'o', 
        (char const   )'_',      (char const   )'a',      (char const   )'b',      (char const   )'b', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'\000'};
static char const   __mod_proto48[97]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4116
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'t',      (char const   )'o',      (char const   )':',      (char const   )'H', 
        (char const   )'i',      (char const   )'g',      (char const   )'h',      (char const   )'e', 
        (char const   )'s',      (char const   )'t',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'o',      (char const   )'t',      (char const   )'o', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'t',      (char const   )'e', 
        (char const   )'n',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'p',      (char const   )'r',      (char const   )'o', 
        (char const   )'b',      (char const   )'e',      (char const   )' ',      (char const   )'(', 
        (char const   )'b',      (char const   )'a',      (char const   )'r',      (char const   )'e', 
        (char const   )',',      (char const   )' ',      (char const   )'i',      (char const   )'m', 
        (char const   )'p',      (char const   )'s',      (char const   )',',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'s', 
        (char const   )',',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )')',      (char const   )'.',      (char const   )' ', 
        (char const   )'U',      (char const   )'s',      (char const   )'e',      (char const   )'f', 
        (char const   )'u',      (char const   )'l',      (char const   )' ',      (char const   )'f', 
        (char const   )'o',      (char const   )'r',      (char const   )' ',      (char const   )'K', 
        (char const   )'V',      (char const   )'M',      (char const   )' ',      (char const   )'s', 
        (char const   )'w',      (char const   )'i',      (char const   )'t',      (char const   )'c', 
        (char const   )'h',      (char const   )'e',      (char const   )'s',      (char const   )'.', 
        (char const   )'\000'};
//#line  4144 "psmousebase.merged.kernel.c"
static struct psmouse *odft_psmouse_serio  ;
//#line  4146 "psmousebase.merged.kernel.c"
static unsigned int psmouse_resolution  =    200U;
static char const   __param_str_resolution[11]  = 
//#line  4148
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'o', 
        (char const   )'l',      (char const   )'u',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000'};
//#line  4154 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_resolution  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_resolution, 420U, & param_set_uint, & param_get_uint, {(void *)(& psmouse_resolution)}};
static char const   __mod_resolutiontype54[25]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  4157
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'o',      (char const   )'l',      (char const   )'u',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )':', 
        (char const   )'u',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static char const   __mod_resolution55[36]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4168
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'o',      (char const   )'l',      (char const   )'u',      (char const   )'t', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )':', 
        (char const   )'R',      (char const   )'e',      (char const   )'s',      (char const   )'o', 
        (char const   )'l',      (char const   )'u',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )',',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'d', 
        (char const   )'p',      (char const   )'i',      (char const   )'.',      (char const   )'\000'};
//#line  4180 "psmousebase.merged.kernel.c"
static unsigned int psmouse_rate  =    100U;
//#line  4182 "psmousebase.merged.kernel.c"
static char const   __param_str_rate[5]  = {      (char const   )'r',      (char const   )'a',      (char const   )'t',      (char const   )'e', 
        (char const   )'\000'};
//#line  4185 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_rate  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_rate, 420U, & param_set_uint, & param_get_uint, {(void *)(& psmouse_rate)}};
static char const   __mod_ratetype58[19]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  4188
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )':',      (char const   )'u',      (char const   )'i', 
        (char const   )'n',      (char const   )'t',      (char const   )'\000'};
static char const   __mod_rate59[46]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4196
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )':',      (char const   )'R',      (char const   )'e', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )' ',      (char const   )'r',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )',',      (char const   )' ',      (char const   )'i', 
        (char const   )'n',      (char const   )' ',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'o',      (char const   )'r',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'p',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'s',      (char const   )'e', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'d', 
        (char const   )'.',      (char const   )'\000'};
//#line  4211 "psmousebase.merged.kernel.c"
static unsigned int psmouse_smartscroll  =    1U;
static char const   __param_str_smartscroll[12]  = 
//#line  4213
  {      (char const   )'s',      (char const   )'m',      (char const   )'a',      (char const   )'r', 
        (char const   )'t',      (char const   )'s',      (char const   )'c',      (char const   )'r', 
        (char const   )'o',      (char const   )'l',      (char const   )'l',      (char const   )'\000'};
//#line  4219 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_smartscroll  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_smartscroll, 420U, & param_set_bool, & param_get_bool, {(void *)(& psmouse_smartscroll)}};
static char const   __mod_smartscrolltype62[26]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  4222
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'s',      (char const   )'m',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )':',      (char const   )'b',      (char const   )'o',      (char const   )'o', 
        (char const   )'l',      (char const   )'\000'};
static char const   __mod_smartscroll63[87]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  4233
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'s',      (char const   )'m',      (char const   )'a', 
        (char const   )'r',      (char const   )'t',      (char const   )'s',      (char const   )'c', 
        (char const   )'r',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )':',      (char const   )'L',      (char const   )'o',      (char const   )'g', 
        (char const   )'i',      (char const   )'t',      (char const   )'e',      (char const   )'c', 
        (char const   )'h',      (char const   )' ',      (char const   )'S',      (char const   )'m', 
        (char const   )'a',      (char const   )'r',      (char const   )'t',      (char const   )'s', 
        (char const   )'c',      (char const   )'r',      (char const   )'o',      (char const   )'l', 
        (char const   )'l',      (char const   )' ',      (char const   )'a',      (char const   )'u', 
        (char const   )'t',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )'p',      (char const   )'e',      (char const   )'a',      (char const   )'t', 
        (char const   )',',      (char const   )' ',      (char const   )'1',      (char const   )' ', 
        (char const   )'=',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'(',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'a',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )')',      (char const   )',', 
        (char const   )' ',      (char const   )'0',      (char const   )' ',      (char const   )'=', 
        (char const   )' ',      (char const   )'d',      (char const   )'i',      (char const   )'s', 
        (char const   )'a',      (char const   )'b',      (char const   )'l',      (char const   )'e', 
        (char const   )'d',      (char const   )'.',      (char const   )'\000'};
//#line  4259 "psmousebase.merged.kernel.c"
static unsigned int psmouse_resetafter  =    5U;
static char const   __param_str_resetafter[11]  = 
//#line  4261
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )'a',      (char const   )'f',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000'};
//#line  4267 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_resetafter  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_resetafter, 420U, & param_set_uint, & param_get_uint, {(void *)(& psmouse_resetafter)}};
static char const   __mod_resetaftertype66[25]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  4270
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )':', 
        (char const   )'u',      (char const   )'i',      (char const   )'n',      (char const   )'t', 
        (char const   )'\000'};
static char const   __mod_resetafter67[68]  __attribute__((__used__, __unused__, __section__(".modinfo")))  = 
//#line  4281
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )':', 
        (char const   )'R',      (char const   )'e',      (char const   )'s',      (char const   )'e', 
        (char const   )'t',      (char const   )' ',      (char const   )'d',      (char const   )'e', 
        (char const   )'v',      (char const   )'i',      (char const   )'c',      (char const   )'e', 
        (char const   )' ',      (char const   )'a',      (char const   )'f',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'s', 
        (char const   )'o',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'b', 
        (char const   )'a',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'a',      (char const   )'c',      (char const   )'k',      (char const   )'e', 
        (char const   )'t',      (char const   )'s',      (char const   )' ',      (char const   )'(', 
        (char const   )'0',      (char const   )' ',      (char const   )'=',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )')',      (char const   )'.',      (char const   )'\000'};
//#line  4301 "psmousebase.merged.kernel.c"
static unsigned int psmouse_resync_time  ;
static char const   __param_str_resync_time[12]  = 
//#line  4303
  {      (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'y', 
        (char const   )'n',      (char const   )'c',      (char const   )'_',      (char const   )'t', 
        (char const   )'i',      (char const   )'m',      (char const   )'e',      (char const   )'\000'};
//#line  4309 "psmousebase.merged.kernel.c"
static struct kernel_param  const  __param_resync_time  __attribute__((__used__, __unused__,
__section__("__param"), __aligned__(sizeof(void *))))  =    {__param_str_resync_time, 420U, & param_set_uint, & param_get_uint, {(void *)(& psmouse_resync_time)}};
static char const   __mod_resync_timetype70[26]  __attribute__((__used__,
__unused__, __section__(".modinfo")))  = 
//#line  4312
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'t',      (char const   )'y',      (char const   )'p',      (char const   )'e', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )'_', 
        (char const   )'t',      (char const   )'i',      (char const   )'m',      (char const   )'e', 
        (char const   )':',      (char const   )'u',      (char const   )'i',      (char const   )'n', 
        (char const   )'t',      (char const   )'\000'};
static char const   __mod_resync_time71[93]  __attribute__((__used__, __unused__,
__section__(".modinfo")))  = 
//#line  4323
  {      (char const   )'p',      (char const   )'a',      (char const   )'r',      (char const   )'m', 
        (char const   )'=',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )'_', 
        (char const   )'t',      (char const   )'i',      (char const   )'m',      (char const   )'e', 
        (char const   )':',      (char const   )'H',      (char const   )'o',      (char const   )'w', 
        (char const   )' ',      (char const   )'l',      (char const   )'o',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'c',      (char const   )'a', 
        (char const   )'n',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'u',      (char const   )'s',      (char const   )'e',      (char const   )' ', 
        (char const   )'s',      (char const   )'t',      (char const   )'a',      (char const   )'y', 
        (char const   )' ',      (char const   )'i',      (char const   )'d',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )'f',      (char const   )'o',      (char const   )'r',      (char const   )'e', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'r', 
        (char const   )'c',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'y',      (char const   )'n',      (char const   )'c',      (char const   )' ', 
        (char const   )'(',      (char const   )'i',      (char const   )'n',      (char const   )' ', 
        (char const   )'s',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'d',      (char const   )'s',      (char const   )',', 
        (char const   )' ',      (char const   )'0',      (char const   )' ',      (char const   )'=', 
        (char const   )' ',      (char const   )'n',      (char const   )'e',      (char const   )'v', 
        (char const   )'e',      (char const   )'r',      (char const   )')',      (char const   )'.', 
        (char const   )'\000'};
//#line  4351
static ssize_t odft_sfipsmouse_attr_show_protocol(struct psmouse *psmouse , void *data ,
                                                  char *buf )  __attribute__((__isolate__)) ;
//#line  4353
static ssize_t psmouse_attr_set_protocol(struct psmouse *psmouse , void *data , char const   *buf ,
                                         size_t count ) ;
//#line  4356 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_protocol  =    {{{str_540929980, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)0, & odft_sfipsmouse_attr_show_protocol,
    & psmouse_attr_set_protocol, 1};
//#line  4359
static ssize_t odft_sfipsmouse_show_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                             __address_space__(2))) offset , char *buf )  __attribute__((__isolate__)) ;
//#line  4362
static ssize_t psmouse_attr_set_rate(struct psmouse *psmouse , void *data , char const   *buf ,
                                     size_t count ) ;
//#line  4365 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_rate  =    {{{str_819248, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper, & psmouse_attr_set_helper},
    (void *)((unsigned int )(& ((struct psmouse *)0)->rate)), (ssize_t (*)(struct psmouse *psmouse ,
                                                                           void *data ,
                                                                           char *buf ))(& odft_sfipsmouse_show_int_attr),
    & psmouse_attr_set_rate, 1};
//#line  4369
static ssize_t psmouse_attr_set_resolution(struct psmouse *psmouse , void *data ,
                                           char const   *buf , size_t count ) ;
//#line  4372 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_resolution  =    {{{str_429751348, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)((unsigned int )(& ((struct psmouse *)0)->resolution)),
    (ssize_t (*)(struct psmouse *psmouse , void *data , char *buf ))(& odft_sfipsmouse_show_int_attr),
    & psmouse_attr_set_resolution, 1};
//#line  4376
static ssize_t odft_sfipsmouse_set_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                            __address_space__(2))) offset , char const   *buf ,
                                            size_t count )  __attribute__((__isolate__)) ;
//#line  4380 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_resetafter  =    {{{str_1050144493, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)((unsigned int )(& ((struct psmouse *)0)->resetafter)),
    (ssize_t (*)(struct psmouse *psmouse , void *data , char *buf ))(& odft_sfipsmouse_show_int_attr),
    (ssize_t (*)(struct psmouse *psmouse , void *data , char const   *buf , size_t count ))(& odft_sfipsmouse_set_int_attr),
    1};
//#line  4384 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_resync_time  =    {{{str_1044724246, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)((unsigned int )(& ((struct psmouse *)0)->resync_time)),
    (ssize_t (*)(struct psmouse *psmouse , void *data , char *buf ))(& odft_sfipsmouse_show_int_attr),
    (ssize_t (*)(struct psmouse *psmouse , void *data , char const   *buf , size_t count ))(& odft_sfipsmouse_set_int_attr),
    1};
//#line  4388 "psmousebase.merged.kernel.c"
static struct attribute *psmouse_attributes[6]  = {      & psmouse_attr_protocol.dattr.attr,      & psmouse_attr_rate.dattr.attr,      & psmouse_attr_resolution.dattr.attr,      & psmouse_attr_resetafter.dattr.attr, 
        & psmouse_attr_resync_time.dattr.attr,      (struct attribute *)((void *)0)};
//#line  4391 "psmousebase.merged.kernel.c"
static struct attribute_group psmouse_attribute_group  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    psmouse_attributes};
//#line  4394 "psmousebase.merged.kernel.c"
static struct mutex psmouse_mutex  =    {{(int volatile   )1}, {{0U}, 3735899821U, 4294967295U, (void *)-1L, {(struct lock_class_key *)0,
                                                                         (struct lock_class *)0,
                                                                         str_707067097}},
    {& psmouse_mutex.wait_list, & psmouse_mutex.wait_list}, (struct thread_info *)0,
    (char const   *)0, (void *)(& psmouse_mutex), {(struct lock_class_key *)0, (struct lock_class *)0,
                                                   str_48484082}};
//#line  4401 "psmousebase.merged.kernel.c"
static struct workqueue_struct___0 *kpsmoused_wq  ;
//#line  4403 "psmousebase.merged.kernel.c"
static psmouse_ret_t psmouse_process_byte(struct psmouse *psmouse ) 
{ 
  struct input_dev *dev ;
  unsigned char *packet ;
  int tmp ;
  int tmp___0 ;

  {
//#line  4412
  dev = (struct input_dev *)psmouse->dev;
//#line  4414
  packet = psmouse->packet;
//#line  4416
  if ((int )psmouse->pktcnt < (int )psmouse->pktsize) {
//#line  4418
    return ((psmouse_ret_t )1);
  }
//#line  4421
  if ((int )psmouse->type == 5) {
    {
//#line  4423
    input_report_rel(dev, 8U, - ((int )((signed char )*(packet + 3))));
    }
  } else
//#line  4426
  if ((int )psmouse->type == 4) {
    {
//#line  4428
    input_report_rel(dev, 8U, - ((int )((signed char )*(packet + 3))));
    }
  }
//#line  4431
  if ((int )psmouse->type == 6) {
    {
    if (((int )*(packet + 3) & 192) == 128) {
//#line  4434
      goto case_128;
    }
    if (((int )*(packet + 3) & 192) == 64) {
//#line  4439
      goto case_64;
    }
    if (((int )*(packet + 3) & 192) == 0) {
//#line  4444
      goto case_0;
    }
    if (((int )*(packet + 3) & 192) == 192) {
//#line  4445
      goto case_0;
    }
//#line  4433
    goto switch_break;
    case_128: /* CIL Label */ 
    {
//#line  4436
    input_report_rel(dev, 8U, ((int )*(packet + 3) & 32) - ((int )*(packet + 3) & 31));
    }
//#line  4438
    goto switch_break;
    case_64: /* CIL Label */ 
    {
//#line  4441
    input_report_rel(dev, 6U, ((int )*(packet + 3) & 32) - ((int )*(packet + 3) & 31));
    }
//#line  4443
    goto switch_break;
    case_0: /* CIL Label */ 
    {
//#line  4447
    input_report_rel(dev, 8U, ((int )*(packet + 3) & 8) - ((int )*(packet + 3) & 7));
//#line  4449
    input_report_key(dev, 275U, ((int )*(packet + 3) >> 4) & 1);
//#line  4451
    input_report_key(dev, 276U, ((int )*(packet + 3) >> 5) & 1);
    }
//#line  4453
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
//#line  4457
  if ((int )psmouse->type == 4) {
    {
//#line  4459
    input_report_key(dev, 275U, ((int )*(packet + 0) >> 6) & 1);
//#line  4461
    input_report_key(dev, 276U, ((int )*(packet + 0) >> 7) & 1);
    }
  }
//#line  4464
  if ((int )psmouse->type == 3) {
    {
//#line  4466
    input_report_key(dev, 276U, ((int )*(packet + 0) >> 3) & 1);
//#line  4468
    *(packet + 1) = (unsigned char )((int )*(packet + 1) | (((int )*(packet + 0) & 64) << 1));
    }
  }
//#line  4471
  if ((int )psmouse->type == 12) {
    {
//#line  4473
    input_report_key(dev, 275U, ((int )*(packet + 0) >> 3) & 1);
//#line  4475
    *(packet + 0) = (unsigned char )((int )*(packet + 0) | 8);
    }
  }
  {
//#line  4478
  input_report_key(dev, 272U, (int )*(packet + 0) & 1);
//#line  4480
  input_report_key(dev, 274U, ((int )*(packet + 0) >> 2) & 1);
//#line  4482
  input_report_key(dev, 273U, ((int )*(packet + 0) >> 1) & 1);
  }
//#line  4484
  if (*(packet + 1)) {
//#line  4486
    tmp = (int )*(packet + 1) - (((int )*(packet + 0) << 4) & 256);
  } else {
//#line  4489
    tmp = 0;
  }
  {
//#line  4492
  input_report_rel(dev, 0U, tmp);
  }
//#line  4494
  if (*(packet + 2)) {
//#line  4496
    tmp___0 = (((int )*(packet + 0) << 3) & 256) - (int )*(packet + 2);
  } else {
//#line  4499
    tmp___0 = 0;
  }
  {
//#line  4502
  input_report_rel(dev, 1U, tmp___0);
//#line  4504
  input_sync(dev);
  }
//#line  4506
  return ((psmouse_ret_t )2);
}
}
//#line  4510 "psmousebase.merged.kernel.c"
void psmouse_queue_work(struct psmouse *psmouse , struct delayed_work *work , unsigned long delay ) 
{ 


  {
  {
//#line  4516
  queue_delayed_work((struct workqueue_struct * __attribute__((__noderef__, __address_space__(2))) )kpsmoused_wq,
                     (struct delayed_work * __attribute__((__noderef__, __address_space__(2))) )work,
                     delay);
  }
//#line  4520
  return;
}
}
//#line  4524 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) __psmouse_set_state)(struct psmouse *psmouse ,
                                                                               enum psmouse_state new_state ) 
{ 
  unsigned long tmp ;

  {
//#line  4531
  psmouse->state = new_state;
//#line  4533
  tmp = 0UL;
//#line  4535
  psmouse->out_of_sync = tmp;
//#line  4537
  psmouse->pktcnt = (unsigned char )tmp;
//#line  4539
  psmouse->ps2dev.flags = 0UL;
//#line  4541
  psmouse->last = (unsigned long )jiffies;
//#line  4543
  return;
}
}
//#line  4547 "psmousebase.merged.kernel.c"
void psmouse_set_state(struct psmouse *psmouse , enum psmouse_state new_state ) 
{ 


  {
  {
//#line  4553
  serio_pause_rx(psmouse->ps2dev.serio);
//#line  4555
  __psmouse_set_state(psmouse, new_state);
//#line  4557
  serio_continue_rx(psmouse->ps2dev.serio);
  }
//#line  4559
  return;
}
}
//#line  4563 "psmousebase.merged.kernel.c"
static int psmouse_handle_byte(struct psmouse *psmouse ) 
{ 
  psmouse_ret_t rc ;
  psmouse_ret_t tmp ;

  {
  {
//#line  4570
  tmp = (*(psmouse->protocol_handler))(psmouse);
//#line  4572
  rc = tmp;
  }
  {
  if ((int )rc == 0) {
//#line  4575
    goto case_0;
  }
  if ((int )rc == 2) {
//#line  4599
    goto case_2;
  }
  if ((int )rc == 1) {
//#line  4611
    goto case_1;
  }
//#line  4574
  goto switch_break;
  case_0: /* CIL Label */ 
//#line  4577
  if ((unsigned int )psmouse->state == 4U) {
    {
//#line  4579
    printk(str_626734451, psmouse->name, psmouse->phys, (int )psmouse->pktcnt);
//#line  4582
    (psmouse->out_of_sync) ++;
    }
//#line  4584
    if (psmouse->out_of_sync == (unsigned long )psmouse->resetafter) {
      {
//#line  4586
      __psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  4588
      printk(str_898632330);
//#line  4590
      serio_reconnect(psmouse->ps2dev.serio);
      }
//#line  4592
      return (-1);
    }
  }
//#line  4596
  psmouse->pktcnt = (unsigned char)0;
//#line  4598
  goto switch_break;
  case_2: /* CIL Label */ 
//#line  4601
  psmouse->pktcnt = (unsigned char)0;
//#line  4603
  if (psmouse->out_of_sync) {
    {
//#line  4605
    psmouse->out_of_sync = 0UL;
//#line  4607
    printk(str_262748659, psmouse->name, psmouse->phys);
    }
  }
//#line  4610
  goto switch_break;
  case_1: /* CIL Label */ 
//#line  4613
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  4616
  return (0);
}
}
//#line  4620 "psmousebase.merged.kernel.c"
static irqreturn_t psmouse_interrupt(struct serio *serio , unsigned char data , unsigned int flags ) 
{ 
  struct psmouse *psmouse ;
  void *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char tmp___6 ;
  int tmp___7 ;
  unsigned char tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;

  {
  {
//#line  4638
  tmp = serio_get_drvdata(serio);
//#line  4640
  psmouse = (struct psmouse *)tmp;
  }
//#line  4642
  if ((unsigned int )psmouse->state == 0U) {
//#line  4644
    goto out;
  }
//#line  4647
  if (flags & 3U) {
//#line  4649
    if ((unsigned int )psmouse->state == 4U) {
//#line  4651
      if (flags & 2U) {
//#line  4653
        tmp___0 = str_839122464;
      } else {
//#line  4656
        tmp___0 = str_0;
      }
//#line  4659
      if (flags & 1U) {
//#line  4661
        tmp___1 = str_1050151853;
      } else {
//#line  4664
        tmp___1 = str_0;
      }
      {
//#line  4667
      printk(str_461899299, tmp___1, tmp___0);
      }
    }
    {
//#line  4670
    ps2_cmd_aborted(& psmouse->ps2dev);
    }
//#line  4672
    goto out;
  }
  {
//#line  4675
  tmp___3 = __builtin_expect((long )(! (! (psmouse->ps2dev.flags & 1UL))), 0L);
  }
//#line  4677
  if (tmp___3) {
    {
//#line  4679
    tmp___2 = ps2_handle_ack(& psmouse->ps2dev, data);
    }
//#line  4681
    if (tmp___2) {
//#line  4683
      goto out;
    }
  }
  {
//#line  4687
  tmp___5 = __builtin_expect((long )(! (! (psmouse->ps2dev.flags & 2UL))), 0L);
  }
//#line  4689
  if (tmp___5) {
    {
//#line  4691
    tmp___4 = ps2_handle_response(& psmouse->ps2dev, data);
    }
//#line  4693
    if (tmp___4) {
//#line  4695
      goto out;
    }
  }
//#line  4699
  if ((unsigned int )psmouse->state <= 2U) {
//#line  4701
    goto out;
  }
//#line  4704
  if ((unsigned int )psmouse->state == 4U) {
//#line  4706
    if (psmouse->pktcnt) {
//#line  4708
      if ((long )(psmouse->last + 500UL) - (long )jiffies < 0L) {
        {
//#line  4710
        printk(str_466443422, psmouse->name, psmouse->phys, (int )psmouse->pktcnt);
//#line  4713
        psmouse->badbyte = psmouse->packet[0];
//#line  4715
        __psmouse_set_state(psmouse, (enum psmouse_state )2);
//#line  4717
        psmouse_queue_work(psmouse, & psmouse->resync_work, 0UL);
        }
//#line  4719
        goto out;
      }
    }
  }
//#line  4724
  tmp___6 = psmouse->pktcnt;
//#line  4726
  psmouse->pktcnt = (unsigned char )((int )psmouse->pktcnt + 1);
//#line  4728
  psmouse->packet[tmp___6] = data;
//#line  4730
  if ((int )psmouse->packet[0] == 170) {
//#line  4732
    if ((int )psmouse->pktcnt <= 2) {
//#line  4734
      tmp___9 = 1;
    } else {
//#line  4737
      tmp___9 = 0;
    }
  } else {
//#line  4741
    tmp___9 = 0;
  }
  {
//#line  4744
  tmp___10 = __builtin_expect((long )tmp___9, 0L);
  }
//#line  4746
  if (tmp___10) {
//#line  4748
    if ((int )psmouse->pktcnt == 1) {
//#line  4750
      psmouse->last = (unsigned long )jiffies;
//#line  4752
      goto out;
    }
//#line  4755
    if ((int )psmouse->packet[1] == 0) {
      {
//#line  4757
      __psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  4759
      serio_reconnect(serio);
      }
//#line  4761
      goto out;
    }
    {
//#line  4764
    psmouse->pktcnt = (unsigned char)1;
//#line  4766
    tmp___7 = psmouse_handle_byte(psmouse);
    }
//#line  4768
    if (tmp___7) {
//#line  4770
      goto out;
    }
//#line  4773
    tmp___8 = psmouse->pktcnt;
//#line  4775
    psmouse->pktcnt = (unsigned char )((int )psmouse->pktcnt + 1);
//#line  4777
    psmouse->packet[tmp___8] = data;
  }
//#line  4780
  if ((unsigned int )psmouse->state == 4U) {
//#line  4782
    if ((int )psmouse->pktcnt == 1) {
//#line  4784
      if (psmouse->resync_time) {
//#line  4786
        if ((long )(psmouse->last + (unsigned long )(psmouse->resync_time * (unsigned int )1000)) - (long )jiffies < 0L) {
          {
//#line  4788
          psmouse->badbyte = psmouse->packet[0];
//#line  4790
          __psmouse_set_state(psmouse, (enum psmouse_state )2);
//#line  4792
          psmouse_queue_work(psmouse, & psmouse->resync_work, 0UL);
          }
//#line  4794
          goto out;
        }
      }
    }
  }
  {
//#line  4800
  psmouse->last = (unsigned long )jiffies;
//#line  4802
  psmouse_handle_byte(psmouse);
  }
  out: 
//#line  4805
  return (1);
}
}
//#line  4809 "psmousebase.merged.kernel.c"
int psmouse_sliced_command(struct psmouse *psmouse , unsigned char command ) 
{ 
  int i ;
  int tmp ;
  unsigned char d ;
  int tmp___0 ;

  {
  {
//#line  4818
  tmp = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 230);
  }
//#line  4820
  if (tmp) {
//#line  4822
    return (-1);
  }
//#line  4825
  i = 6;
  {
  {
//#line  4827
  while (1) {


    if (! (i >= 0)) {
//#line  4827
      goto while_break;
    }
    {
//#line  4829
    d = (unsigned char )(((int )command >> i) & 3);
//#line  4831
    tmp___0 = ps2_command(& psmouse->ps2dev, & d, 4328);
    }
//#line  4833
    if (tmp___0) {
//#line  4835
      return (-1);
    }
//#line  4838
    i -= 2;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  4841
  return (0);
}
}
//#line  4845 "psmousebase.merged.kernel.c"
int psmouse_reset(struct psmouse *psmouse ) 
{ 
  unsigned char param[2] ;
  int tmp ;

  {
  {
//#line  4852
  tmp = ps2_command(& psmouse->ps2dev, param, 767);
  }
//#line  4854
  if (tmp) {
//#line  4856
    return (-1);
  }
//#line  4859
  if ((int )param[0] != 170) {
//#line  4861
    if ((int )param[1] != 0) {
//#line  4863
      return (-1);
    }
  }
//#line  4867
  return (0);
}
}
//#line  4871 "psmousebase.merged.kernel.c"
static int genius_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[4] ;

  {
  {
//#line  4878
  ps2dev = & psmouse->ps2dev;
//#line  4880
  param[0] = (unsigned char)3;
//#line  4882
  ps2_command(ps2dev, param, 4328);
//#line  4884
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  4886
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  4888
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  4890
  ps2_command(ps2dev, param, 1001);
  }
//#line  4892
  if ((int )param[0] != 0) {
//#line  4894
    return (-1);
  } else
//#line  4897
  if ((int )param[1] != 51) {
//#line  4899
    return (-1);
  } else
//#line  4902
  if ((int )param[2] != 85) {
//#line  4904
    return (-1);
  }
//#line  4907
  if (set_properties) {
    {
//#line  4909
    set_bit(276U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  4911
    set_bit(275U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  4913
    set_bit(8U, (unsigned long volatile   *)((psmouse->dev)->relbit));
//#line  4915
    psmouse->vendor = (char *)str_189760183;
//#line  4917
    psmouse->name = (char *)str_10840589;
//#line  4919
    psmouse->pktsize = (unsigned char)4;
    }
  }
//#line  4922
  return (0);
}
}
//#line  4926 "psmousebase.merged.kernel.c"
static int intellimouse_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[2] ;

  {
  {
//#line  4933
  ps2dev = & psmouse->ps2dev;
//#line  4935
  param[0] = (unsigned char)200;
//#line  4937
  ps2_command(ps2dev, param, 4339);
//#line  4939
  param[0] = (unsigned char)100;
//#line  4941
  ps2_command(ps2dev, param, 4339);
//#line  4943
  param[0] = (unsigned char)80;
//#line  4945
  ps2_command(ps2dev, param, 4339);
//#line  4947
  ps2_command(ps2dev, param, 754);
  }
//#line  4949
  if ((int )param[0] != 3) {
//#line  4951
    return (-1);
  }
//#line  4954
  if (set_properties) {
    {
//#line  4956
    set_bit(274U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  4958
    set_bit(8U, (unsigned long volatile   *)((psmouse->dev)->relbit));
    }
//#line  4960
    if (! psmouse->vendor) {
//#line  4962
      psmouse->vendor = (char *)str_384189395;
    }
//#line  4965
    if (! psmouse->name) {
//#line  4967
      psmouse->name = (char *)str_221608524;
    }
//#line  4970
    psmouse->pktsize = (unsigned char)4;
  }
//#line  4973
  return (0);
}
}
//#line  4977 "psmousebase.merged.kernel.c"
static int im_explorer_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[2] ;

  {
  {
//#line  4984
  ps2dev = & psmouse->ps2dev;
//#line  4986
  intellimouse_detect(psmouse, 0);
//#line  4988
  param[0] = (unsigned char)200;
//#line  4990
  ps2_command(ps2dev, param, 4339);
//#line  4992
  param[0] = (unsigned char)200;
//#line  4994
  ps2_command(ps2dev, param, 4339);
//#line  4996
  param[0] = (unsigned char)80;
//#line  4998
  ps2_command(ps2dev, param, 4339);
//#line  5000
  ps2_command(ps2dev, param, 754);
  }
//#line  5002
  if ((int )param[0] != 4) {
//#line  5004
    return (-1);
  }
  {
//#line  5007
  param[0] = (unsigned char)200;
//#line  5009
  ps2_command(ps2dev, param, 4339);
//#line  5011
  param[0] = (unsigned char)80;
//#line  5013
  ps2_command(ps2dev, param, 4339);
//#line  5015
  param[0] = (unsigned char)40;
//#line  5017
  ps2_command(ps2dev, param, 4339);
  }
//#line  5019
  if (set_properties) {
    {
//#line  5021
    set_bit(274U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  5023
    set_bit(8U, (unsigned long volatile   *)((psmouse->dev)->relbit));
//#line  5025
    set_bit(6U, (unsigned long volatile   *)((psmouse->dev)->relbit));
//#line  5027
    set_bit(275U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  5029
    set_bit(276U, (unsigned long volatile   *)((psmouse->dev)->keybit));
    }
//#line  5031
    if (! psmouse->vendor) {
//#line  5033
      psmouse->vendor = (char *)str_384189395;
    }
//#line  5036
    if (! psmouse->name) {
//#line  5038
      psmouse->name = (char *)str_731306984;
    }
//#line  5041
    psmouse->pktsize = (unsigned char)4;
  }
//#line  5044
  return (0);
}
}
//#line  5048
static int thinking_detect(struct psmouse *psmouse , int set_properties ) ;
static unsigned char const   seq[9]  = 
//#line  5050
  {      (unsigned char const   )20,      (unsigned char const   )60,      (unsigned char const   )40,      (unsigned char const   )20, 
        (unsigned char const   )20,      (unsigned char const   )60,      (unsigned char const   )40,      (unsigned char const   )20, 
        (unsigned char const   )20};
//#line  5056 "psmousebase.merged.kernel.c"
static int thinking_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[2] ;
  int i ;

  {
  {
//#line  5064
  ps2dev = & psmouse->ps2dev;
//#line  5066
  param[0] = (unsigned char)10;
//#line  5068
  ps2_command(ps2dev, param, 4339);
//#line  5070
  param[0] = (unsigned char)0;
//#line  5072
  ps2_command(ps2dev, param, 4328);
//#line  5074
  i = 0;
  }
  {
  {
//#line  5076
  while (1) {


    if (! ((unsigned long )i < sizeof(seq) / sizeof(seq[0]) + (sizeof(char [1]) - 1UL))) {
//#line  5076
      goto while_break;
    }
    {
//#line  5078
    param[0] = (unsigned char )seq[i];
//#line  5080
    ps2_command(ps2dev, param, 4339);
//#line  5082
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  5085
  ps2_command(ps2dev, param, 754);
  }
//#line  5087
  if ((int )param[0] != 2) {
//#line  5089
    return (-1);
  }
//#line  5092
  if (set_properties) {
    {
//#line  5094
    set_bit(276U, (unsigned long volatile   *)((psmouse->dev)->keybit));
//#line  5096
    psmouse->vendor = (char *)str_942823456;
//#line  5098
    psmouse->name = (char *)str_188112229;
    }
  }
//#line  5101
  return (0);
}
}
//#line  5105 "psmousebase.merged.kernel.c"
static int ps2bare_detect(struct psmouse *psmouse , int set_properties ) 
{ 


  {
//#line  5111
  if (set_properties) {
//#line  5113
    if (! psmouse->vendor) {
//#line  5115
      psmouse->vendor = (char *)str_384189395;
    }
//#line  5118
    if (! psmouse->name) {
//#line  5120
      psmouse->name = (char *)str_10840589;
    }
  }
//#line  5124
  return (0);
}
}
//#line  5128 "psmousebase.merged.kernel.c"
static int cortron_detect(struct psmouse *psmouse , int set_properties ) 
{ 


  {
//#line  5134
  if (set_properties) {
    {
//#line  5136
    psmouse->vendor = (char *)str_221391155;
//#line  5138
    psmouse->name = (char *)str_957027776;
//#line  5140
    set_bit(275U, (unsigned long volatile   *)((psmouse->dev)->keybit));
    }
  }
//#line  5143
  return (0);
}
}
//#line  5147 "psmousebase.merged.kernel.c"
static int psmouse_extensions(struct psmouse *psmouse , unsigned int max_proto , int set_properties ) 
{ 
  int synaptics_hardware ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
//#line  5170
  synaptics_hardware = 0;
//#line  5172
  tmp___0 = lifebook_detect(psmouse, set_properties);
  }
//#line  5174
  if (tmp___0 == 0) {
//#line  5176
    if (max_proto > 6U) {
//#line  5178
      if (! set_properties) {
//#line  5180
        return (9);
      } else {
        {
//#line  5183
        tmp = lifebook_init(psmouse);
        }
//#line  5185
        if (tmp == 0) {
//#line  5187
          return (9);
        }
      }
    }
  }
//#line  5193
  if (max_proto > 6U) {
    {
//#line  5195
    tmp___1 = thinking_detect(psmouse, set_properties);
    }
//#line  5197
    if (tmp___1 == 0) {
//#line  5199
      return (3);
    }
  }
//#line  5203
  if (max_proto > 1U) {
    {
//#line  5205
    tmp___3 = synaptics_detect(psmouse, set_properties);
    }
//#line  5207
    if (tmp___3 == 0) {
//#line  5209
      synaptics_hardware = 1;
//#line  5211
      if (max_proto > 6U) {
//#line  5213
        if (! set_properties) {
//#line  5215
          return (7);
        } else {
          {
//#line  5218
          tmp___2 = synaptics_init(psmouse);
          }
//#line  5220
          if (tmp___2 == 0) {
//#line  5222
            return (7);
          }
        }
//#line  5226
        max_proto = 6U;
      }
      {
//#line  5229
      synaptics_reset(psmouse);
      }
    }
  }
//#line  5233
  if (max_proto > 6U) {
    {
//#line  5235
    ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 246);
//#line  5237
    tmp___5 = alps_detect(psmouse, set_properties);
    }
//#line  5239
    if (tmp___5 == 0) {
//#line  5241
      if (! set_properties) {
//#line  5243
        return (8);
      } else {
        {
//#line  5246
        tmp___4 = alps_init(psmouse);
        }
//#line  5248
        if (tmp___4 == 0) {
//#line  5250
          return (8);
        }
      }
//#line  5254
      max_proto = 6U;
    }
  }
//#line  5258
  if (max_proto > 6U) {
    {
//#line  5260
    tmp___7 = hgpk_detect(psmouse, set_properties);
    }
//#line  5262
    if (tmp___7 == 0) {
//#line  5264
      if (! set_properties) {
//#line  5266
        return (13);
      } else {
        {
//#line  5269
        tmp___6 = hgpk_init(psmouse);
        }
//#line  5271
        if (tmp___6 == 0) {
//#line  5273
          return (13);
        }
      }
//#line  5277
      max_proto = 6U;
    }
  }
//#line  5281
  if (max_proto > 6U) {
    {
//#line  5283
    tmp___9 = touchkit_ps2_detect(psmouse, set_properties);
    }
//#line  5285
    if (tmp___9 == 0) {
//#line  5287
      if (! set_properties) {
//#line  5289
        return (14);
      } else {
        {
//#line  5292
        tmp___8 = elantech_init(psmouse);
        }
//#line  5294
        if (tmp___8 == 0) {
//#line  5296
          return (14);
        }
      }
//#line  5300
      max_proto = 6U;
    }
  }
//#line  5304
  if (max_proto > 6U) {
    {
//#line  5306
    tmp___10 = genius_detect(psmouse, set_properties);
    }
//#line  5308
    if (tmp___10 == 0) {
//#line  5310
      return (4);
    }
    {
//#line  5313
    tmp___11 = ps2pp_init(psmouse, set_properties);
    }
//#line  5315
    if (tmp___11 == 0) {
//#line  5317
      return (2);
    }
    {
//#line  5320
    tmp___12 = trackpoint_detect(psmouse, set_properties);
    }
//#line  5322
    if (tmp___12 == 0) {
//#line  5324
      return (10);
    }
    {
//#line  5327
    tmp___13 = touchkit_ps2_detect(psmouse, set_properties);
    }
//#line  5329
    if (tmp___13 == 0) {
//#line  5331
      return (11);
    }
  }
  {
//#line  5335
  ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 246);
//#line  5337
  psmouse_reset(psmouse);
  }
//#line  5339
  if (max_proto >= 6U) {
    {
//#line  5341
    tmp___14 = im_explorer_detect(psmouse, set_properties);
    }
//#line  5343
    if (tmp___14 == 0) {
//#line  5345
      return (6);
    }
  }
//#line  5349
  if (max_proto >= 5U) {
    {
//#line  5351
    tmp___15 = intellimouse_detect(psmouse, set_properties);
    }
//#line  5353
    if (tmp___15 == 0) {
//#line  5355
      return (5);
    }
  }
  {
//#line  5359
  ps2bare_detect(psmouse, set_properties);
  }
//#line  5361
  if (synaptics_hardware) {
    {
//#line  5363
    psmouse_reset(psmouse);
    }
  }
//#line  5366
  return (1);
}
}
static struct psmouse_protocol  const  psmouse_protocols[12]  = 
//#line  5370
  {      {(enum psmouse_type )1, str_579626, str_709466, 1, & ps2bare_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )2,
      str_11013887, str_24323315, 0, & ps2pp_init, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )3,
      str_95278588, str_360606437, 0, & thinking_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )4,
      str_384033014, str_268995351, 0, & genius_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )5,
      str_195539842, str_761787, 1, & intellimouse_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )6,
      str_774488393, str_738322, 1, & im_explorer_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )7,
      str_998105566, str_819620768, 0, & synaptics_detect, & synaptics_init}, 
        {(enum psmouse_type )8, str_124740196, str_706554, 0, & alps_detect, & alps_init}, 
        {(enum psmouse_type )9,
      str_197364336, str_812672849, 0, (int (*)(struct psmouse * , int  ))0, & lifebook_init}, 
        {(enum psmouse_type )10,
      str_218997622, str_604279769, 0, & trackpoint_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )12,
      str_474479501, str_260425477, 0, & cortron_detect, (int (*)(struct psmouse * ))0}, 
        {(enum psmouse_type )15,
      str_709875, str_37228, 1, (int (*)(struct psmouse * , int  ))0, (int (*)(struct psmouse * ))0}};
//#line  5393 "psmousebase.merged.kernel.c"
static struct psmouse_protocol  const  *psmouse_protocol_by_type(enum psmouse_type type ) 
{ 
  int i ;
  int __ret_warn_on ;
  long tmp ;

  {
//#line  5401
  i = 0;
  {
  {
//#line  5403
  while (1) {


    if (! ((unsigned long )i < sizeof(psmouse_protocols) / sizeof(psmouse_protocols[0]) + (sizeof(char [1]) - 1UL))) {
//#line  5403
      goto while_break;
    }
//#line  5405
    if ((unsigned int const   )psmouse_protocols[i].type == (unsigned int const   )type) {
//#line  5407
      return (& psmouse_protocols[i]);
    }
//#line  5410
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  5413
  __ret_warn_on = 1;
//#line  5415
  tmp = __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
//#line  5417
  if (tmp) {
    {
//#line  5419
    warn_slowpath(str_488282298, 859, (char const   *)((void *)0));
    }
  }
  {
//#line  5423
  __builtin_expect((long )(! (! __ret_warn_on)), 0L);
  }
//#line  5425
  return (& psmouse_protocols[0]);
}
}
//#line  5429 "psmousebase.merged.kernel.c"
static struct psmouse_protocol  const  *psmouse_protocol_by_name(char const   *name ,
                                                                 size_t len ) 
{ 
  struct psmouse_protocol  const  *p ;
  int i ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;

  {
//#line  5441
  i = 0;
  {
  {
//#line  5443
  while (1) {


    if (! ((unsigned long )i < sizeof(psmouse_protocols) / sizeof(psmouse_protocols[0]) + (sizeof(char [1]) - 1UL))) {
//#line  5443
      goto while_break;
    }
    {
//#line  5445
    p = & psmouse_protocols[i];
//#line  5447
    tmp = strlen((char const   *)p->name);
    }
//#line  5449
    if (tmp == len) {
      {
//#line  5451
      tmp___0 = strncmp((char const   *)p->name, name, len);
      }
//#line  5453
      if (tmp___0) {
//#line  5455
        goto _L;
      } else {
//#line  5458
        return (& psmouse_protocols[i]);
      }
    } else {
      _L: 
      {
//#line  5463
      tmp___1 = strlen((char const   *)p->alias);
      }
//#line  5465
      if (tmp___1 == len) {
        {
//#line  5467
        tmp___2 = strncmp((char const   *)p->alias, name, len);
        }
//#line  5469
        if (! tmp___2) {
//#line  5471
          return (& psmouse_protocols[i]);
        }
      }
    }
//#line  5476
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  5479
  return ((struct psmouse_protocol  const  *)((void *)0));
}
}
//#line  5483 "psmousebase.merged.kernel.c"
static int psmouse_probe(struct psmouse *psmouse ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[2] ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  5492
  ps2dev = & psmouse->ps2dev;
//#line  5494
  param[0] = (unsigned char)165;
//#line  5496
  tmp = ps2_command(ps2dev, param, 754);
  }
//#line  5498
  if (tmp) {
//#line  5500
    return (-1);
  }
//#line  5503
  if ((int )param[0] != 0) {
//#line  5505
    if ((int )param[0] != 3) {
//#line  5507
      if ((int )param[0] != 4) {
//#line  5509
        if ((int )param[0] != 255) {
//#line  5511
          return (-1);
        }
      }
    }
  }
  {
//#line  5517
  tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 246);
  }
//#line  5519
  if (tmp___0) {
    {
//#line  5521
    printk(str_119286224, (ps2dev->serio)->phys);
    }
  }
//#line  5524
  return (0);
}
}
//#line  5528 "psmousebase.merged.kernel.c"
static unsigned char const   params[5]  = {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3};
static void MARSH___STUB__psmouse_set_resolution(struct req_args *rqarg , struct psmouse *psmouse ,
                                                 unsigned int resolution ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  struct ps2dev *STRUCTADDRXpsmouseps2dev ;
  int idx_arr28 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  idx_arr06 = 0;
  while (idx_arr06 < 5) {
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& params[idx_arr06]),
                  sizeof(unsigned char const   ));
    idx_arr06 ++;
  }
  fill_marshbuf_ptr("psmouse_set_resolution", & _buf_, & _off_, & psmouse);
  if (psmouse != 0U) {
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& psmouse->resetafter),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& psmouse->resolution),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& psmouse->resync_time),
                  sizeof(unsigned int ));
    STRUCTADDRXpsmouseps2dev = & psmouse->ps2dev;
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->cmdcnt),
                  sizeof(unsigned char ));
    idx_arr28 = 0;
    while (idx_arr28 < 6) {
      fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->cmdbuf[idx_arr28]),
                    sizeof(unsigned char ));
      idx_arr28 ++;
    }
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->flags),
                  sizeof(unsigned long ));
    fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& psmouse->rate),
                  sizeof(unsigned int ));
  }
  fill_marshbuf("psmouse_set_resolution", & _buf_, & _off_, (void *)(& resolution),
                sizeof(unsigned int ));
  rqarg->function_id = 1210;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__psmouse_set_resolution(struct req_args *rqarg , struct psmouse *psmouse ,
                                                 unsigned int resolution ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  void *tmp_lv7 ;
  void *tmp_fld8 ;
  struct ps2dev *STRUCTADDRXpsmouseps2dev ;
  int idx_arr210 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  idx_arr06 = 0;
  while (idx_arr06 < 5) {
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned char const   ),
                   (void *)(& params[idx_arr06]));
    idx_arr06 ++;
  }
  fetch_marshbuf_ptr("psmouse_set_resolution", _buf_, & _off_, (void **)(& psmouse),
                     sizeof(struct psmouse ), sizeof(struct psmouse ));
  if (psmouse != 0U) {
    tmp_fld8 = & psmouse->resetafter;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resetafter));
    tmp_fld8 = & psmouse->resolution;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resolution));
    tmp_fld8 = & psmouse->resync_time;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resync_time));
    tmp_fld8 = & psmouse->ps2dev;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(struct ps2dev ));
    STRUCTADDRXpsmouseps2dev = & psmouse->ps2dev;
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)(& STRUCTADDRXpsmouseps2dev->cmdcnt));
    idx_arr210 = 0;
    while (idx_arr210 < 6) {
      fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXpsmouseps2dev->cmdbuf[idx_arr210]));
      idx_arr210 ++;
    }
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned long ),
                   (void *)(& STRUCTADDRXpsmouseps2dev->flags));
    tmp_fld8 = & psmouse->rate;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->rate));
  }
  fetch_marshbuf("psmouse_set_resolution", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& resolution));
  return;
}
}
void psmouse_set_resolution(struct psmouse *psmouse , unsigned int resolution ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_set_resolution(& rqarg, psmouse, resolution);
  __odft_disp_error = disp_user("psmouse_set_resolution", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  DEMARSH_STUB__psmouse_set_resolution(& rqarg, psmouse, resolution);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return;
}
}
//#line  5533
void odft_sfipsmouse_set_resolution(struct psmouse *psmouse , unsigned int resolution )  __attribute__((__isolate__)) ;
void odft_sfipsmouse_set_resolution(struct psmouse *psmouse , unsigned int resolution ) 
{ 
  unsigned char p ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_1031719054);
  }
  if (__odft_error) {
    {
    psmouse_set_resolution(psmouse, resolution);
    }
    return;
  } else {

  }
  {
//#line  5539
  if (resolution == 0U) {
//#line  5541
    resolution = 200U;
  } else
//#line  5544
  if (resolution > 200U) {
//#line  5546
    resolution = 200U;
  }
  {
//#line  5549
  p = (unsigned char )params[resolution / 50U];
//#line  5551
  ps2_command(& psmouse->ps2dev, & p, 4328);
//#line  5553
  __odft_error = logWrite(& psmouse->resolution, str_48996679, str_1031719054, str_72550417,
                          5553);
  psmouse->resolution = (unsigned int )(25 << (int )p);
  }
//#line  5555
  return;
  }
}
}
//#line  5559
static void odft_sfipsmouse_set_rate(struct psmouse *psmouse , unsigned int rate )  __attribute__((__isolate__)) ;
static unsigned char const   rates[8]  = 
//#line  5561
  {      (unsigned char const   )200,      (unsigned char const   )100,      (unsigned char const   )80,      (unsigned char const   )60, 
        (unsigned char const   )40,      (unsigned char const   )20,      (unsigned char const   )10,      (unsigned char const   )0};
static void MARSH___STUB__psmouse_set_rate(struct req_args *rqarg , struct psmouse *psmouse ,
                                           unsigned int rate ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  struct ps2dev *STRUCTADDRXpsmouseps2dev ;
  int idx_arr28 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  idx_arr06 = 0;
  while (idx_arr06 < 8) {
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& rates[idx_arr06]),
                  sizeof(unsigned char const   ));
    idx_arr06 ++;
  }
  fill_marshbuf_ptr("psmouse_set_rate", & _buf_, & _off_, & psmouse);
  if (psmouse != 0U) {
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& psmouse->resetafter),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& psmouse->resolution),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& psmouse->resync_time),
                  sizeof(unsigned int ));
    STRUCTADDRXpsmouseps2dev = & psmouse->ps2dev;
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->cmdcnt),
                  sizeof(unsigned char ));
    idx_arr28 = 0;
    while (idx_arr28 < 6) {
      fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->cmdbuf[idx_arr28]),
                    sizeof(unsigned char ));
      idx_arr28 ++;
    }
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& STRUCTADDRXpsmouseps2dev->flags),
                  sizeof(unsigned long ));
    fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& psmouse->rate),
                  sizeof(unsigned int ));
  }
  fill_marshbuf("psmouse_set_rate", & _buf_, & _off_, (void *)(& rate), sizeof(unsigned int ));
  rqarg->function_id = 1209;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static void DEMARSH_STUB__psmouse_set_rate(struct req_args *rqarg , struct psmouse *psmouse ,
                                           unsigned int rate ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  void *tmp_lv7 ;
  void *tmp_fld8 ;
  struct ps2dev *STRUCTADDRXpsmouseps2dev ;
  int idx_arr210 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  idx_arr06 = 0;
  while (idx_arr06 < 8) {
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned char const   ),
                   (void *)(& rates[idx_arr06]));
    idx_arr06 ++;
  }
  fetch_marshbuf_ptr("psmouse_set_rate", _buf_, & _off_, (void **)(& psmouse), sizeof(struct psmouse ),
                     sizeof(struct psmouse ));
  if (psmouse != 0U) {
    tmp_fld8 = & psmouse->resetafter;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned int ), (void *)(& psmouse->resetafter));
    tmp_fld8 = & psmouse->resolution;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned int ), (void *)(& psmouse->resolution));
    tmp_fld8 = & psmouse->resync_time;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned int ), (void *)(& psmouse->resync_time));
    tmp_fld8 = & psmouse->ps2dev;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(struct ps2dev ));
    STRUCTADDRXpsmouseps2dev = & psmouse->ps2dev;
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXpsmouseps2dev->cmdcnt));
    idx_arr210 = 0;
    while (idx_arr210 < 6) {
      fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXpsmouseps2dev->cmdbuf[idx_arr210]));
      idx_arr210 ++;
    }
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXpsmouseps2dev->flags));
    tmp_fld8 = & psmouse->rate;
    tmp_lv7 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld8 - tmp_lv7, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned int ), (void *)(& psmouse->rate));
  }
  fetch_marshbuf("psmouse_set_rate", _buf_, & _off_, sizeof(unsigned int ), (void *)(& rate));
  return;
}
}
void psmouse_set_rate(struct psmouse *psmouse , unsigned int rate ) 
{ 
  struct req_args rqarg ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_set_rate(& rqarg, psmouse, rate);
  __odft_disp_error = disp_user("psmouse_set_rate", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  DEMARSH_STUB__psmouse_set_rate(& rqarg, psmouse, rate);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return;
}
}
//#line  5568
static void odft_sfipsmouse_set_rate(struct psmouse *psmouse , unsigned int rate )  __attribute__((__isolate__)) ;
static void odft_sfipsmouse_set_rate(struct psmouse *psmouse , unsigned int rate ) 
{ 
  unsigned char r ;
  int i ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_7096282);
  }
  if (__odft_error) {
    {
    psmouse_set_rate(psmouse, rate);
    }
    return;
  } else {

  }
  {
//#line  5575
  i = 0;
  {
  {
//#line  5577
  while (1) {


    if (! ((unsigned int )rates[i] > rate)) {
//#line  5577
      goto while_break;
    }
//#line  5579
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  5582
  r = (unsigned char )rates[i];
//#line  5584
  ps2_command(& psmouse->ps2dev, & r, 4339);
//#line  5586
  __odft_error = logWrite(& psmouse->rate, str_992268699, str_7096282, str_72550417,
                          5586);
  psmouse->rate = (unsigned int )r;
  }
//#line  5588
  return;
  }
}
}
//#line  5592 "psmousebase.merged.kernel.c"
static void psmouse_initialize(struct psmouse *psmouse ) 
{ 


  {
//#line  5598
  if (psmouse_max_proto != 1U) {
    {
//#line  5600
    (*(psmouse->set_rate))(psmouse, (unsigned int )psmouse->rate);
//#line  5602
    (*(psmouse->set_resolution))(psmouse, (unsigned int )psmouse->resolution);
//#line  5604
    ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 230);
    }
  }
//#line  5607
  return;
}
}
//#line  5611 "psmousebase.merged.kernel.c"
static void psmouse_activate(struct psmouse *psmouse ) 
{ 
  int tmp ;

  {
  {
//#line  5617
  tmp = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 244);
  }
//#line  5619
  if (tmp) {
    {
//#line  5621
    printk(str_1023639894, (psmouse->ps2dev.serio)->phys);
    }
  }
  {
//#line  5624
  psmouse_set_state(psmouse, (enum psmouse_state )4);
  }
//#line  5626
  return;
}
}
//#line  5630 "psmousebase.merged.kernel.c"
static void psmouse_deactivate(struct psmouse *psmouse ) 
{ 
  int tmp ;

  {
  {
//#line  5636
  tmp = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 245);
  }
//#line  5638
  if (tmp) {
    {
//#line  5640
    printk(str_965002357, (psmouse->ps2dev.serio)->phys);
    }
  }
  {
//#line  5643
  psmouse_set_state(psmouse, (enum psmouse_state )3);
  }
//#line  5645
  return;
}
}
//#line  5649 "psmousebase.merged.kernel.c"
static int psmouse_poll(struct psmouse *psmouse ) 
{ 
  int tmp ;

  {
  {
//#line  5655
  tmp = ps2_command(& psmouse->ps2dev, psmouse->packet, 235 | ((int )psmouse->pktsize << 8));
  }
//#line  5657
  return (tmp);
}
}
//#line  5661 "psmousebase.merged.kernel.c"
static void psmouse_resync(struct work_struct *work ) 
{ 
  struct psmouse *parent ;
  struct psmouse *psmouse ;
  struct work_struct  const  *__mptr ;
  struct serio *serio ;
  psmouse_ret_t rc ;
  int failed ;
  int enabled ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  5678
  parent = (struct psmouse *)((void *)0);
//#line  5680
  __mptr = (struct work_struct  const  *)work;
//#line  5682
  psmouse = (struct psmouse *)((char *)__mptr - (unsigned int )(& ((struct psmouse *)0)->resync_work.work));
//#line  5684
  serio = psmouse->ps2dev.serio;
//#line  5686
  rc = (psmouse_ret_t )1;
//#line  5688
  failed = 0;
//#line  5690
  enabled = 0;
//#line  5692
  mutex_lock_nested(& psmouse_mutex, 0U);
  }
//#line  5694
  if ((unsigned int )psmouse->state != 2U) {
//#line  5696
    goto out;
  }
//#line  5699
  if (serio->parent) {
//#line  5701
    if ((int )serio->id.type == 5) {
      {
//#line  5703
      tmp = serio_get_drvdata((struct serio *)serio->parent);
//#line  5705
      parent = (struct psmouse *)tmp;
//#line  5707
      psmouse_deactivate(parent);
      }
    }
  }
  {
//#line  5711
  (psmouse->num_resyncs) ++;
//#line  5713
  tmp___0 = ps2_sendbyte(& psmouse->ps2dev, (unsigned char)245, 20);
  }
//#line  5715
  if (tmp___0) {
//#line  5717
    if (psmouse->num_resyncs < 3UL) {
//#line  5719
      failed = 1;
    } else
//#line  5722
    if (psmouse->acks_disable_command) {
//#line  5724
      failed = 1;
    }
  } else {
//#line  5728
    psmouse->acks_disable_command = (unsigned char)1;
  }
//#line  5731
  if (! failed) {
    {
//#line  5733
    tmp___1 = (*(psmouse->poll))(psmouse);
    }
//#line  5735
    if (tmp___1) {
//#line  5737
      failed = 1;
    } else {
      {
//#line  5740
      psmouse_set_state(psmouse, (enum psmouse_state )3);
//#line  5742
      i = 0;
      }
      {
      {
//#line  5744
      while (1) {


        if (! (i < (int )psmouse->pktsize)) {
//#line  5744
          goto while_break;
        }
        {
//#line  5746
        psmouse->pktcnt = (unsigned char )((int )psmouse->pktcnt + 1);
//#line  5748
        rc = (*(psmouse->protocol_handler))(psmouse);
        }
//#line  5750
        if ((unsigned int )rc != 1U) {
//#line  5752
          goto while_break;
        }
//#line  5755
        i ++;
      }

      }
      while_break: /* CIL Label */ ;
      }
//#line  5758
      if ((unsigned int )rc != 2U) {
//#line  5760
        failed = 1;
      }
      {
//#line  5763
      psmouse_set_state(psmouse, (enum psmouse_state )2);
      }
    }
  }
//#line  5767
  i = 0;
  {
  {
//#line  5769
  while (1) {


    if (! (i < 5)) {
//#line  5769
      goto while_break___0;
    }
    {
//#line  5771
    tmp___2 = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 244);
    }
//#line  5773
    if (! tmp___2) {
//#line  5775
      enabled = 1;
//#line  5777
      goto while_break___0;
    }
    {
//#line  5780
    msleep(200U);
//#line  5782
    i ++;
    }
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  5785
  if (! enabled) {
    {
//#line  5787
    printk(str_1013043182, (psmouse->ps2dev.serio)->phys);
//#line  5789
    failed = 1;
    }
  }
//#line  5792
  if (failed) {
    {
//#line  5794
    psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  5796
    printk(str_991534108);
//#line  5798
    serio_reconnect(serio);
    }
  } else {
    {
//#line  5801
    psmouse_set_state(psmouse, (enum psmouse_state )4);
    }
  }
//#line  5804
  if (parent) {
    {
//#line  5806
    psmouse_activate(parent);
    }
  }
  out: 
  {
//#line  5810
  mutex_unlock(& psmouse_mutex);
  }
//#line  5812
  return;
}
}
//#line  5816
extern int odft_is_self_locked(struct mutex * ) ;
//#line  5818 "psmousebase.merged.kernel.c"
static void psmouse_cleanup(struct serio *serio ) 
{ 
  struct psmouse *psmouse ;
  void *tmp ;
  struct psmouse *parent ;
  int recovery_context ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  {
//#line  5829
  tmp = serio_get_drvdata(serio);
//#line  5831
  psmouse = (struct psmouse *)tmp;
//#line  5833
  parent = (struct psmouse *)((void *)0);
//#line  5835
  recovery_context = 0;
//#line  5837
  tmp___0 = odft_is_self_locked(& psmouse_mutex);
  }
//#line  5839
  if (tmp___0 != 0) {
    {
//#line  5841
    mutex_lock_nested(& psmouse_mutex, 0U);
    }
  } else {
//#line  5844
    recovery_context = 1;
  }
//#line  5847
  if (serio->parent) {
//#line  5849
    if ((int )serio->id.type == 5) {
      {
//#line  5851
      tmp___1 = serio_get_drvdata((struct serio *)serio->parent);
//#line  5853
      parent = (struct psmouse *)tmp___1;
//#line  5855
      psmouse_deactivate(parent);
      }
    }
  }
  {
//#line  5859
  psmouse_deactivate(psmouse);
  }
//#line  5861
  if (psmouse->cleanup) {
    {
//#line  5863
    (*(psmouse->cleanup))(psmouse);
    }
  }
  {
//#line  5866
  psmouse_reset(psmouse);
//#line  5868
  ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 244);
  }
//#line  5870
  if (parent) {
//#line  5872
    if (parent->pt_deactivate) {
      {
//#line  5874
      (*(parent->pt_deactivate))(parent);
      }
    }
    {
//#line  5877
    psmouse_activate(parent);
    }
  }
//#line  5880
  if (recovery_context == 0) {
    {
//#line  5882
    mutex_unlock(& psmouse_mutex);
    }
  }
//#line  5885
  return;
}
}
//#line  5889 "psmousebase.merged.kernel.c"
int psmousebase_checkpoint(void) 
{ 


  {
//#line  5895
  return (0);
}
}
//#line  5899 "psmousebase.merged.kernel.c"
int psmousebase_restore(void) 
{ 


  {
  {
//#line  5905
  psmouse_cleanup((struct serio *)odft_psmouse_serio);
  }
//#line  5907
  return (0);
}
}
//#line  5911 "psmousebase.merged.kernel.c"
static void psmouse_disconnect(struct serio *serio ) 
{ 
  struct psmouse *psmouse ;
  struct psmouse *parent ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
//#line  5920
  parent = (struct psmouse *)((void *)0);
//#line  5922
  tmp = serio_get_drvdata(serio);
//#line  5924
  psmouse = (struct psmouse *)tmp;
//#line  5926
  sysfs_remove_group(& serio->dev.kobj, (struct attribute_group  const  *)(& psmouse_attribute_group));
//#line  5928
  mutex_lock_nested(& psmouse_mutex, 0U);
//#line  5930
  psmouse_set_state(psmouse, (enum psmouse_state )3);
//#line  5932
  mutex_unlock(& psmouse_mutex);
//#line  5934
  flush_workqueue((struct workqueue_struct *)kpsmoused_wq);
//#line  5936
  mutex_lock_nested(& psmouse_mutex, 0U);
  }
//#line  5938
  if (serio->parent) {
//#line  5940
    if ((int )serio->id.type == 5) {
      {
//#line  5942
      tmp___0 = serio_get_drvdata((struct serio *)serio->parent);
//#line  5944
      parent = (struct psmouse *)tmp___0;
//#line  5946
      psmouse_deactivate(parent);
      }
    }
  }
//#line  5950
  if (psmouse->disconnect) {
    {
//#line  5952
    (*(psmouse->disconnect))(psmouse);
    }
  }
//#line  5955
  if (parent) {
//#line  5957
    if (parent->pt_deactivate) {
      {
//#line  5959
      (*(parent->pt_deactivate))(parent);
      }
    }
  }
  {
//#line  5963
  psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  5965
  serio_close(serio);
//#line  5967
  serio_set_drvdata(serio, (void *)0);
//#line  5969
  input_unregister_device((struct input_dev *)psmouse->dev);
//#line  5971
  kfree((void const   *)psmouse);
  }
//#line  5973
  if (parent) {
    {
//#line  5975
    psmouse_activate(parent);
    }
  }
  {
//#line  5978
  mutex_unlock(& psmouse_mutex);
  }
//#line  5980
  return;
}
}
//#line  5984 "psmousebase.merged.kernel.c"
static int psmouse_switch_protocol(struct psmouse *psmouse , struct psmouse_protocol  const  *proto ) 
{ 
  struct input_dev *input_dev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct psmouse_protocol  const  *tmp___3 ;

  {
//#line  5995
  input_dev = (struct input_dev *)psmouse->dev;
//#line  5997
  input_dev->dev.parent = (struct device *)(& (psmouse->ps2dev.serio)->dev);
//#line  5999
  input_dev->evbit[0] = (1UL << 1) | (1UL << 2);
//#line  6001
  input_dev->keybit[4] = ((1UL << 16) | (1UL << 18)) | (1UL << 17);
//#line  6003
  input_dev->relbit[0] = 1UL | (1UL << 1);
//#line  6005
  psmouse->set_rate = & odft_sfipsmouse_set_rate;
//#line  6007
  psmouse->set_resolution = & odft_sfipsmouse_set_resolution;
//#line  6009
  psmouse->poll = & psmouse_poll;
//#line  6011
  psmouse->protocol_handler = & psmouse_process_byte;
//#line  6013
  psmouse->pktsize = (unsigned char)3;
//#line  6015
  if (proto) {
//#line  6017
    if (proto->detect) {
//#line  6019
      goto _L;
    } else
//#line  6022
    if (proto->init) {
      _L: 
//#line  6025
      if (proto->detect) {
        {
//#line  6027
        tmp = (*(proto->detect))(psmouse, 1);
        }
//#line  6029
        if (tmp < 0) {
//#line  6031
          return (-1);
        }
      }
//#line  6035
      if (proto->init) {
        {
//#line  6037
        tmp___0 = (*(proto->init))(psmouse);
        }
//#line  6039
        if (tmp___0 < 0) {
//#line  6041
          return (-1);
        }
      }
//#line  6045
      psmouse->type = (unsigned char )proto->type;
    } else {
      {
//#line  6048
      tmp___1 = psmouse_extensions(psmouse, psmouse_max_proto, 1);
//#line  6050
      psmouse->type = (unsigned char )tmp___1;
      }
    }
  } else {
    {
//#line  6054
    tmp___1 = psmouse_extensions(psmouse, psmouse_max_proto, 1);
//#line  6056
    psmouse->type = (unsigned char )tmp___1;
    }
  }
//#line  6059
  if ((int )psmouse->pktsize == 3) {
//#line  6061
    psmouse->resync_time = (unsigned int )0;
  }
//#line  6064
  if (psmouse->resync_time) {
    {
//#line  6066
    tmp___2 = (*(psmouse->poll))(psmouse);
    }
//#line  6068
    if (tmp___2) {
//#line  6070
      psmouse->resync_time = (unsigned int )0;
    }
  }
  {
//#line  6074
  tmp___3 = psmouse_protocol_by_type((enum psmouse_type )psmouse->type);
//#line  6076
  snprintf(psmouse->devname, sizeof(psmouse->devname), str_987425018, tmp___3->name,
           psmouse->vendor, psmouse->name);
//#line  6079
  input_dev->name = (char const   *)(psmouse->devname);
//#line  6081
  input_dev->phys = (char const   *)(psmouse->phys);
//#line  6083
  input_dev->id.bustype = (__u16 )17;
//#line  6085
  input_dev->id.vendor = (__u16 )2;
//#line  6087
  input_dev->id.product = (__u16 )psmouse->type;
//#line  6089
  input_dev->id.version = (__u16 )psmouse->model;
  }
//#line  6091
  return (0);
}
}
//#line  6095 "psmousebase.merged.kernel.c"
static struct lock_class_key __key___3  ;
//#line  6097 "psmousebase.merged.kernel.c"
static int psmouse_connect(struct serio *serio , struct serio_driver *drv ) 
{ 
  struct psmouse *psmouse ;
  struct psmouse *parent ;
  struct input_dev *input_dev ;
  int retval ;
  int error ;
  void *tmp ;
  void *tmp___0 ;
  atomic_long_t __constr_expr_0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
//#line  6111
  parent = (struct psmouse *)((void *)0);
//#line  6113
  retval = 0;
//#line  6115
  error = -12;
//#line  6117
  mutex_lock_nested(& psmouse_mutex, 0U);
  }
//#line  6119
  if (serio->parent) {
//#line  6121
    if ((int )serio->id.type == 5) {
      {
//#line  6123
      tmp = serio_get_drvdata((struct serio *)serio->parent);
//#line  6125
      parent = (struct psmouse *)tmp;
//#line  6127
      psmouse_deactivate(parent);
      }
    }
  }
  {
//#line  6131
  tmp___0 = kzalloc(sizeof(struct psmouse ), 208U);
//#line  6133
  psmouse = (struct psmouse *)tmp___0;
//#line  6135
  input_dev = input_allocate_device();
  }
//#line  6137
  if (! psmouse) {
//#line  6139
    goto err_free;
  } else
//#line  6142
  if (! input_dev) {
//#line  6144
    goto err_free;
  }
  {
//#line  6147
  ps2_init(& psmouse->ps2dev, serio);
  }
  {
  {
//#line  6149
  while (1) {


    {
    {
//#line  6151
    while (1) {


      {
//#line  6153
      __constr_expr_0.counter = (long volatile   )0;
//#line  6155
      psmouse->resync_work.work.data = __constr_expr_0;
//#line  6157
      lockdep_init_map(& psmouse->resync_work.work.lockdep_map, str_887671200, & __key___3,
                       0);
//#line  6160
      INIT_LIST_HEAD((struct list_head *)(& psmouse->resync_work.work.entry));
      }
      {
      {
//#line  6162
      while (1) {


//#line  6164
        psmouse->resync_work.work.func = & psmouse_resync;
//#line  6166
        goto while_break___1;
      }

      }
      while_break___1: /* CIL Label */ ;
      }
//#line  6169
      goto while_break___0;
    }

    }
    while_break___0: /* CIL Label */ ;
    }
    {
//#line  6172
    init_timer(& psmouse->resync_work.timer);
    }
//#line  6174
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  6177
  psmouse->dev = (struct input_dev * __attribute__((__noderef__, __address_space__(2))) )input_dev;
//#line  6179
  snprintf(psmouse->phys, sizeof(psmouse->phys), str_307711519, serio->phys);
//#line  6181
  psmouse_set_state(psmouse, (enum psmouse_state )1);
//#line  6183
  serio_set_drvdata(serio, (void *)psmouse);
//#line  6185
  error = serio_open(serio, drv);
  }
//#line  6187
  if (error) {
//#line  6189
    goto err_clear_drvdata;
  }
  {
//#line  6192
  tmp___1 = psmouse_probe(psmouse);
  }
//#line  6194
  if (tmp___1 < 0) {
//#line  6196
    error = -19;
//#line  6198
    goto err_close_serio;
  }
//#line  6201
  psmouse->rate = (unsigned int )psmouse_rate;
//#line  6203
  psmouse->resolution = (unsigned int )psmouse_resolution;
//#line  6205
  psmouse->resetafter = (unsigned int )psmouse_resetafter;
//#line  6207
  if (parent) {
//#line  6209
    psmouse->resync_time = (unsigned int )0;
  } else {
//#line  6212
    psmouse->resync_time = (unsigned int )psmouse_resync_time;
  }
  {
//#line  6215
  psmouse->smartscroll = psmouse_smartscroll;
//#line  6217
  psmouse_switch_protocol(psmouse, (struct psmouse_protocol  const  *)((void *)0));
//#line  6219
  psmouse_set_state(psmouse, (enum psmouse_state )3);
//#line  6221
  psmouse_initialize(psmouse);
//#line  6223
  tmp___2 = (int )input_register_device((struct input_dev *)psmouse->dev);
  error = tmp___2;
  }
//#line  6225
  if (error) {
//#line  6227
    goto err_protocol_disconnect;
  }
//#line  6230
  if (parent) {
//#line  6232
    if (parent->pt_activate) {
      {
//#line  6234
      (*(parent->pt_activate))(parent);
      }
    }
  }
  {
//#line  6238
  tmp___3 = (int )sysfs_create_group(& serio->dev.kobj, (struct attribute_group  const  *)(& psmouse_attribute_group));
  error = tmp___3;
  }
//#line  6240
  if (error) {
//#line  6242
    goto err_pt_deactivate;
  }
  {
//#line  6245
  psmouse_activate(psmouse);
//#line  6247
  odft_psmouse_serio = (struct psmouse *)serio;
  }
  out: 
//#line  6250
  if (parent) {
    {
//#line  6252
    psmouse_activate(parent);
    }
  }
  {
//#line  6255
  mutex_unlock(& psmouse_mutex);
  }
//#line  6257
  return (retval);
  err_pt_deactivate: 
//#line  6260
  if (parent) {
//#line  6262
    if (parent->pt_deactivate) {
      {
//#line  6264
      (*(parent->pt_deactivate))(parent);
      }
    }
  }
  {
//#line  6268
  input_unregister_device((struct input_dev *)psmouse->dev);
//#line  6270
  input_dev = (struct input_dev *)((void *)0);
  }
  err_protocol_disconnect: 
//#line  6273
  if (psmouse->disconnect) {
    {
//#line  6275
    (*(psmouse->disconnect))(psmouse);
    }
  }
  {
//#line  6278
  psmouse_set_state(psmouse, (enum psmouse_state )0);
  }
  err_close_serio: 
  {
//#line  6281
  serio_close(serio);
  }
  err_clear_drvdata: 
  {
//#line  6284
  serio_set_drvdata(serio, (void *)0);
  }
  err_free: 
  {
//#line  6287
  input_free_device(input_dev);
//#line  6289
  kfree((void const   *)psmouse);
//#line  6291
  retval = error;
  }
//#line  6293
  goto out;
}
}
//#line  6297 "psmousebase.merged.kernel.c"
static int psmouse_reconnect(struct serio *serio ) 
{ 
  struct psmouse *psmouse ;
  void *tmp ;
  struct psmouse *parent ;
  struct serio_driver *drv ;
  int rc ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
//#line  6311
  tmp = serio_get_drvdata(serio);
//#line  6313
  psmouse = (struct psmouse *)tmp;
//#line  6315
  parent = (struct psmouse *)((void *)0);
//#line  6317
  drv = serio->drv;
//#line  6319
  rc = -1;
  }
//#line  6321
  if (! drv) {
    {
//#line  6323
    printk(str_434738890);
    }
//#line  6325
    return (-1);
  } else
//#line  6328
  if (! psmouse) {
    {
//#line  6330
    printk(str_434738890);
    }
//#line  6332
    return (-1);
  }
  {
//#line  6335
  mutex_lock_nested(& psmouse_mutex, 0U);
  }
//#line  6337
  if (serio->parent) {
//#line  6339
    if ((int )serio->id.type == 5) {
      {
//#line  6341
      tmp___0 = serio_get_drvdata((struct serio *)serio->parent);
//#line  6343
      parent = (struct psmouse *)tmp___0;
//#line  6345
      psmouse_deactivate(parent);
      }
    }
  }
  {
//#line  6349
  psmouse_set_state(psmouse, (enum psmouse_state )1);
  }
//#line  6351
  if (psmouse->reconnect) {
    {
//#line  6353
    tmp___1 = (*(psmouse->reconnect))(psmouse);
    }
//#line  6355
    if (tmp___1) {
//#line  6357
      goto out;
    }
  } else {
    {
//#line  6361
    tmp___2 = psmouse_probe(psmouse);
    }
//#line  6363
    if (tmp___2 < 0) {
//#line  6365
      goto out;
    } else {
      {
//#line  6368
      tmp___3 = psmouse_extensions(psmouse, psmouse_max_proto, 0);
      }
//#line  6370
      if ((int )psmouse->type != tmp___3) {
//#line  6372
        goto out;
      }
    }
  }
  {
//#line  6377
  psmouse_set_state(psmouse, (enum psmouse_state )3);
//#line  6379
  psmouse_initialize(psmouse);
  }
//#line  6381
  if (parent) {
//#line  6383
    if (parent->pt_activate) {
      {
//#line  6385
      (*(parent->pt_activate))(parent);
      }
    }
  }
  {
//#line  6389
  psmouse_activate(psmouse);
//#line  6391
  rc = 0;
//#line  6393
  odft_psmouse_serio = (struct psmouse *)serio;
  }
  out: 
//#line  6396
  if (parent) {
    {
//#line  6398
    psmouse_activate(parent);
    }
  }
  {
//#line  6401
  mutex_unlock(& psmouse_mutex);
  }
//#line  6403
  return (rc);
  {
//#line  6405
  psmousebase_checkpoint();
//#line  6407
  psmousebase_restore();
  }
}
}
//#line  6411 "psmousebase.merged.kernel.c"
static struct serio_device_id psmouse_serio_ids[3]  = {      {(__u8 )1, (__u8 )255, (__u8 )255, (__u8 )255}, 
        {(__u8 )5, (__u8 )255, (__u8 )255, (__u8 )255}, 
        {(__u8 )0, (unsigned char)0, (unsigned char)0, (unsigned char)0}};
static struct serio_driver psmouse_drv  = 
//#line  6415
     {(void *)0, (char *)str_380817653, psmouse_serio_ids, 0U, (void (*)(struct serio * ))0,
    & psmouse_interrupt, & psmouse_connect, & psmouse_reconnect, & psmouse_disconnect,
    & psmouse_cleanup, {(char const   *)str_200191798, (struct bus_type *)0, (struct module *)0,
                        (char const   *)0, (int (*)(struct device *dev ))0, (int (*)(struct device *dev ))0,
                        (void (*)(struct device *dev ))0, (int (*)(struct device *dev ,
                                                                   pm_message_t state ))0,
                        (int (*)(struct device *dev ))0, (struct attribute_group **)0,
                        (struct dev_pm_ops *)0, (struct driver_private *)0}};
//#line  6427 "psmousebase.merged.kernel.c"
ssize_t psmouse_attr_show_helper(struct device *dev , struct device_attribute *devattr ,
                                 char *buf ) 
{ 
  struct serio *serio ;
  struct device  const  *__mptr ;
  struct psmouse_attribute *attr ;
  struct device_attribute  const  *__mptr___0 ;
  struct psmouse *psmouse ;
  int retval ;
  void *tmp ;
  ssize_t tmp___0 ;

  {
  {
//#line  6441
  __mptr = (struct device  const  *)dev;
//#line  6443
  serio = (struct serio *)((char *)__mptr - (unsigned int )(& ((struct serio *)0)->dev));
//#line  6445
  __mptr___0 = (struct device_attribute  const  *)devattr;
//#line  6447
  attr = (struct psmouse_attribute *)((char *)__mptr___0 - (unsigned int )(& ((struct psmouse_attribute *)0)->dattr));
//#line  6449
  retval = serio_pin_driver(serio);
  }
//#line  6451
  if (retval) {
//#line  6453
    return ((ssize_t )retval);
  }
//#line  6456
  if ((unsigned long )serio->drv != (unsigned long )(& psmouse_drv)) {
//#line  6458
    retval = -19;
//#line  6460
    goto out;
  }
  {
//#line  6463
  tmp = serio_get_drvdata(serio);
//#line  6465
  psmouse = (struct psmouse *)tmp;
//#line  6467
  tmp___0 = (*(attr->show))(psmouse, attr->data, buf);
//#line  6469
  retval = (int )tmp___0;
  }
  out: 
  {
//#line  6472
  serio_unpin_driver(serio);
  }
//#line  6474
  return ((ssize_t )retval);
}
}
//#line  6478 "psmousebase.merged.kernel.c"
ssize_t psmouse_attr_set_helper(struct device *dev , struct device_attribute *devattr ,
                                char const   *buf , size_t count ) 
{ 
  struct serio *serio ;
  struct device  const  *__mptr ;
  struct psmouse_attribute *attr ;
  struct device_attribute  const  *__mptr___0 ;
  struct psmouse *psmouse ;
  struct psmouse *parent ;
  int retval ;
  void *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  6494
  __mptr = (struct device  const  *)dev;
//#line  6496
  serio = (struct serio *)((char *)__mptr - (unsigned int )(& ((struct serio *)0)->dev));
//#line  6498
  __mptr___0 = (struct device_attribute  const  *)devattr;
//#line  6500
  attr = (struct psmouse_attribute *)((char *)__mptr___0 - (unsigned int )(& ((struct psmouse_attribute *)0)->dattr));
//#line  6502
  parent = (struct psmouse *)((void *)0);
//#line  6504
  retval = serio_pin_driver(serio);
  }
//#line  6506
  if (retval) {
//#line  6508
    return ((ssize_t )retval);
  }
//#line  6511
  if ((unsigned long )serio->drv != (unsigned long )(& psmouse_drv)) {
//#line  6513
    retval = -19;
//#line  6515
    goto out_unpin;
  }
  {
//#line  6518
  tmp___2 = (int )mutex_lock_interruptible_nested(& psmouse_mutex, 0U);
  retval = tmp___2;
  }
//#line  6520
  if (retval) {
//#line  6522
    goto out_unpin;
  }
  {
//#line  6525
  tmp = serio_get_drvdata(serio);
//#line  6527
  psmouse = (struct psmouse *)tmp;
  }
//#line  6529
  if (attr->protect) {
//#line  6531
    if ((unsigned int )psmouse->state == 0U) {
//#line  6533
      retval = -19;
//#line  6535
      goto out_unlock;
    }
//#line  6538
    if (serio->parent) {
//#line  6540
      if ((int )serio->id.type == 5) {
        {
//#line  6542
        tmp___0 = serio_get_drvdata((struct serio *)serio->parent);
//#line  6544
        parent = (struct psmouse *)tmp___0;
//#line  6546
        psmouse_deactivate(parent);
        }
      }
    }
    {
//#line  6550
    psmouse_deactivate(psmouse);
    }
  }
  {
//#line  6553
  tmp___1 = (*(attr->set))(psmouse, attr->data, buf, count);
//#line  6555
  retval = (int )tmp___1;
  }
//#line  6557
  if (attr->protect) {
//#line  6559
    if (retval != -19) {
      {
//#line  6561
      psmouse_activate(psmouse);
      }
    }
//#line  6564
    if (parent) {
      {
//#line  6566
      psmouse_activate(parent);
      }
    }
  }
  out_unlock: 
  {
//#line  6571
  mutex_unlock(& psmouse_mutex);
  }
  out_unpin: 
  {
//#line  6574
  serio_unpin_driver(serio);
  }
//#line  6576
  return ((ssize_t )retval);
}
}
static void MARSH___STUB__psmouse_show_int_attr(struct req_args *rqarg , struct psmouse *psmouse ,
                                                void * __attribute__((__noderef__,
                                                __address_space__(2))) offset , char *buf ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int arraylen_MARSH___STUB__psmouse_show_int_attrbuf7 ;
  int idx08 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("psmouse_show_int_attr", & _buf_, & _off_, & psmouse);
  if (psmouse != 0U) {
    fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(& psmouse->resetafter),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(& psmouse->resolution),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(& psmouse->resync_time),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(& psmouse->rate),
                  sizeof(unsigned int ));
  }
  fill_marshbuf_ptr("psmouse_show_int_attr", & _buf_, & _off_, & offset);
  fill_marshbuf_ptr("psmouse_show_int_attr", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    arraylen_MARSH___STUB__psmouse_show_int_attrbuf7 = 4;
    fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(& arraylen_MARSH___STUB__psmouse_show_int_attrbuf7),
                  sizeof(int ));
    idx08 = 0;
    while (idx08 < arraylen_MARSH___STUB__psmouse_show_int_attrbuf7) {
      fill_marshbuf("psmouse_show_int_attr", & _buf_, & _off_, (void *)(buf + idx08),
                    sizeof(char ));
      idx08 ++;
    }
  }
  rqarg->function_id = 1212;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static ssize_t DEMARSH_STUB__psmouse_show_int_attr(struct req_args *rqarg , struct psmouse *psmouse ,
                                                   void * __attribute__((__noderef__,
                                                   __address_space__(2))) offset ,
                                                   char *buf ) 
{ 
  ssize_t _retval_ ;
  void *_buf_ ;
  int _off_ ;
  void *tmp_lv8 ;
  void *tmp_fld9 ;
  int arraylen_DEMARSH_STUB__psmouse_show_int_attrbuf10 ;
  int idx011 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("psmouse_show_int_attr", _buf_, & _off_, (void **)(& psmouse),
                     sizeof(struct psmouse ), sizeof(struct psmouse ));
  if (psmouse != 0U) {
    tmp_fld9 = & psmouse->resetafter;
    tmp_lv8 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld9 - tmp_lv8, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resetafter));
    tmp_fld9 = & psmouse->resolution;
    tmp_lv8 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld9 - tmp_lv8, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resolution));
    tmp_fld9 = & psmouse->resync_time;
    tmp_lv8 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld9 - tmp_lv8, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resync_time));
    tmp_fld9 = & psmouse->rate;
    tmp_lv8 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld9 - tmp_lv8, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->rate));
  }
  fetch_marshbuf_ptr("psmouse_show_int_attr", _buf_, & _off_, (void **)(& offset),
                     -1, sizeof(void ));
  fetch_marshbuf_ptr("psmouse_show_int_attr", _buf_, & _off_, (void **)(& buf), sizeof(char ),
                     sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(int ), (void *)(& arraylen_DEMARSH_STUB__psmouse_show_int_attrbuf10));
    nooks_ot_alloc_arraymem_kern_w((void *)(& buf), arraylen_DEMARSH_STUB__psmouse_show_int_attrbuf10,
                                   sizeof(char ), 0);
    idx011 = 0;
    while (idx011 < arraylen_DEMARSH_STUB__psmouse_show_int_attrbuf10) {
      fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(char ), (void *)(buf + idx011));
      idx011 ++;
    }
  }
  fetch_marshbuf("psmouse_show_int_attr", _buf_, & _off_, sizeof(long ), (void *)(& _retval_));
  return (_retval_);
}
}
ssize_t psmouse_show_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                              __address_space__(2))) offset , char *buf ) 
{ 
  struct req_args rqarg ;
  ssize_t _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_show_int_attr(& rqarg, psmouse, offset, buf);
  __odft_disp_error = disp_user("psmouse_show_int_attr", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  _retval_ = (ssize_t )DEMARSH_STUB__psmouse_show_int_attr(& rqarg, psmouse, offset,
                                                           buf);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return (_retval_);
}
}
//#line  6583
static ssize_t odft_sfipsmouse_show_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                             __address_space__(2))) offset , char *buf )  __attribute__((__isolate__)) ;
static ssize_t odft_sfipsmouse_show_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                             __address_space__(2))) offset , char *buf ) 
{ 
  unsigned int *field ;
  int tmp ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_998620162);
  }
  if (__odft_error) {
    {
    __odft_error = (int )psmouse_show_int_attr(psmouse, offset, buf);
    }
    return (__odft_error);
  } else {

  }
  {
  {
//#line  6591
  field = (unsigned int *)((char *)psmouse + (size_t )offset);
//#line  6593
  printk(str_142045592, psmouse, field, buf);
//#line  6595
  __odft_error = logRead(field, str_118047708, str_998620162, str_72550417, 6595);
  tmp = sprintf((char *)buf, str_15590, *field);
  }
//#line  6597
  return ((ssize_t )tmp);
  }
}
}
static void MARSH___STUB__psmouse_set_int_attr(struct req_args *rqarg , struct psmouse *psmouse ,
                                               void * __attribute__((__noderef__,
                                               __address_space__(2))) offset , char const   *buf ,
                                               size_t count ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int arraylen_MARSH___STUB__psmouse_set_int_attrbuf8 ;
  int idx09 ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  fill_marshbuf_ptr("psmouse_set_int_attr", & _buf_, & _off_, & psmouse);
  if (psmouse != 0U) {
    fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& psmouse->resetafter),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& psmouse->resolution),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& psmouse->resync_time),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& psmouse->rate),
                  sizeof(unsigned int ));
  }
  fill_marshbuf_ptr("psmouse_set_int_attr", & _buf_, & _off_, & offset);
  fill_marshbuf_ptr("psmouse_set_int_attr", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    arraylen_MARSH___STUB__psmouse_set_int_attrbuf8 = 4;
    fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& arraylen_MARSH___STUB__psmouse_set_int_attrbuf8),
                  sizeof(int ));
    idx09 = 0;
    while (idx09 < arraylen_MARSH___STUB__psmouse_set_int_attrbuf8) {
      fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(buf + idx09),
                    sizeof(char const   ));
      idx09 ++;
    }
  }
  fill_marshbuf("psmouse_set_int_attr", & _buf_, & _off_, (void *)(& count), sizeof(unsigned long ));
  rqarg->function_id = 1207;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static ssize_t DEMARSH_STUB__psmouse_set_int_attr(struct req_args *rqarg , struct psmouse *psmouse ,
                                                  void * __attribute__((__noderef__,
                                                  __address_space__(2))) offset ,
                                                  char const   *buf , size_t count ) 
{ 
  ssize_t _retval_ ;
  void *_buf_ ;
  int _off_ ;
  void *tmp_lv9 ;
  void *tmp_fld10 ;
  int arraylen_DEMARSH_STUB__psmouse_set_int_attrbuf11 ;
  int idx012 ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  fetch_marshbuf_ptr("psmouse_set_int_attr", _buf_, & _off_, (void **)(& psmouse),
                     sizeof(struct psmouse ), sizeof(struct psmouse ));
  if (psmouse != 0U) {
    tmp_fld10 = & psmouse->resetafter;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resetafter));
    tmp_fld10 = & psmouse->resolution;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resolution));
    tmp_fld10 = & psmouse->resync_time;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resync_time));
    tmp_fld10 = & psmouse->rate;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->rate));
  }
  fetch_marshbuf_ptr("psmouse_set_int_attr", _buf_, & _off_, (void **)(& offset),
                     -1, sizeof(void ));
  fetch_marshbuf_ptr("psmouse_set_int_attr", _buf_, & _off_, (void **)(& buf), sizeof(char const   ),
                     sizeof(char const   ));
  if (buf != 0U) {
    fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(int ), (void *)(& arraylen_DEMARSH_STUB__psmouse_set_int_attrbuf11));
    nooks_ot_alloc_arraymem_kern_w((void *)(& buf), arraylen_DEMARSH_STUB__psmouse_set_int_attrbuf11,
                                   sizeof(char const   ), 0);
    idx012 = 0;
    while (idx012 < arraylen_DEMARSH_STUB__psmouse_set_int_attrbuf11) {
      fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(char const   ),
                     (void *)(buf + idx012));
      idx012 ++;
    }
  }
  fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(unsigned long ), (void *)(& count));
  fetch_marshbuf("psmouse_set_int_attr", _buf_, & _off_, sizeof(long ), (void *)(& _retval_));
  return (_retval_);
}
}
ssize_t psmouse_set_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                             __address_space__(2))) offset , char const   *buf , size_t count ) 
{ 
  struct req_args rqarg ;
  ssize_t _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_set_int_attr(& rqarg, psmouse, offset, buf, count);
  __odft_disp_error = disp_user("psmouse_set_int_attr", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  _retval_ = (ssize_t )DEMARSH_STUB__psmouse_set_int_attr(& rqarg, psmouse, offset,
                                                          buf, count);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return (_retval_);
}
}
//#line  6605
static ssize_t odft_sfipsmouse_set_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                            __address_space__(2))) offset , char const   *buf ,
                                            size_t count )  __attribute__((__isolate__)) ;
static ssize_t odft_sfipsmouse_set_int_attr(struct psmouse *psmouse , void * __attribute__((__noderef__,
                                            __address_space__(2))) offset , char const   *buf ,
                                            size_t count ) 
{ 
  unsigned int *field ;
  unsigned long value ;
  int tmp ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_385727219);
  }
  if (__odft_error) {
    {
    __odft_error = (int )psmouse_set_int_attr(psmouse, offset, buf, count);
    }
    return (__odft_error);
  } else {

  }
  {
  {
//#line  6615
  field = (unsigned int *)((char *)psmouse + (size_t )offset);
//#line  6617
  tmp = strict_strtoul((char const   *)buf, 10U, & value);
  }
//#line  6619
  if (tmp) {
//#line  6621
    return ((ssize_t )-22);
  }
//#line  6624
  if ((unsigned long )((unsigned int )value) != value) {
//#line  6626
    return ((ssize_t )-22);
  }
  {
//#line  6629
  __odft_error = logWrite(field, str_118047708, str_385727219, str_72550417, 6629);
  *field = (unsigned int )value;
  }
//#line  6631
  return ((ssize_t )count);
  }
}
}
static void MARSH___STUB__psmouse_attr_show_protocol(struct req_args *rqarg , struct psmouse *psmouse ,
                                                     void *data , char *buf ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr07 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr07name ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  idx_arr07 = 0;
  while (idx_arr07 < 12) {
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse_protocols[idx_arr07].type),
                  sizeof(int ));
    STRUCTADDRXpsmouse_protocolsidx_arr07name = & psmouse_protocols[idx_arr07].name;
    fill_marshbuf_ptr("psmouse_attr_show_protocol", & _buf_, & _off_, STRUCTADDRXpsmouse_protocolsidx_arr07name);
    if (*STRUCTADDRXpsmouse_protocolsidx_arr07name != 0U) {
      fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)*STRUCTADDRXpsmouse_protocolsidx_arr07name,
                    sizeof(char const   ));
    }
    idx_arr07 ++;
  }
  fill_marshbuf_ptr("psmouse_attr_show_protocol", & _buf_, & _off_, & psmouse);
  if (psmouse != 0U) {
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse->resetafter),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse->resolution),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse->resync_time),
                  sizeof(unsigned int ));
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse->type),
                  sizeof(unsigned char ));
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)(& psmouse->rate),
                  sizeof(unsigned int ));
  }
  fill_marshbuf_ptr("psmouse_attr_show_protocol", & _buf_, & _off_, & data);
  fill_marshbuf_ptr("psmouse_attr_show_protocol", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    fill_marshbuf("psmouse_attr_show_protocol", & _buf_, & _off_, (void *)buf, sizeof(char ));
  }
  rqarg->function_id = 1169;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static ssize_t DEMARSH_STUB__psmouse_attr_show_protocol(struct req_args *rqarg , struct psmouse *psmouse ,
                                                        void *data , char *buf ) 
{ 
  ssize_t _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int idx_arr08 ;
  void *tmp_lv9 ;
  void *tmp_fld10 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr08name ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  idx_arr08 = 0;
  while (idx_arr08 < 12) {
    tmp_fld10 = & psmouse_protocols[idx_arr08].name;
    tmp_lv9 = & psmouse_protocols[idx_arr08];
    nooks_ot_storeoffset_kern_w(& psmouse_protocols[idx_arr08], tmp_fld10 - tmp_lv9,
                                sizeof(char const   *));
    STRUCTADDRXpsmouse_protocolsidx_arr08name = & psmouse_protocols[idx_arr08].name;
    fetch_marshbuf_ptr("psmouse_attr_show_protocol", _buf_, & _off_, (void **)STRUCTADDRXpsmouse_protocolsidx_arr08name,
                       sizeof(char const   ), sizeof(char const   ));
    if (*STRUCTADDRXpsmouse_protocolsidx_arr08name != 0U) {
      fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(char const   ),
                     (void *)*STRUCTADDRXpsmouse_protocolsidx_arr08name);
    }
    idx_arr08 ++;
  }
  fetch_marshbuf_ptr("psmouse_attr_show_protocol", _buf_, & _off_, (void **)(& psmouse),
                     sizeof(struct psmouse ), sizeof(struct psmouse ));
  if (psmouse != 0U) {
    tmp_fld10 = & psmouse->resetafter;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resetafter));
    tmp_fld10 = & psmouse->resolution;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resolution));
    tmp_fld10 = & psmouse->resync_time;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->resync_time));
    tmp_fld10 = & psmouse->type;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned char ));
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)(& psmouse->type));
    tmp_fld10 = & psmouse->rate;
    tmp_lv9 = psmouse;
    nooks_ot_storeoffset_kern_w(psmouse, tmp_fld10 - tmp_lv9, sizeof(unsigned int ));
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(unsigned int ),
                   (void *)(& psmouse->rate));
  }
  fetch_marshbuf_ptr("psmouse_attr_show_protocol", _buf_, & _off_, & data, sizeof(void ),
                     sizeof(void ));
  fetch_marshbuf_ptr("psmouse_attr_show_protocol", _buf_, & _off_, (void **)(& buf),
                     sizeof(char ), sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(char ), (void *)buf);
  }
  fetch_marshbuf("psmouse_attr_show_protocol", _buf_, & _off_, sizeof(long ), (void *)(& _retval_));
  return (_retval_);
}
}
ssize_t psmouse_attr_show_protocol(struct psmouse *psmouse , void *data , char *buf ) 
{ 
  struct req_args rqarg ;
  ssize_t _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_attr_show_protocol(& rqarg, psmouse, data, buf);
  __odft_disp_error = disp_user("psmouse_attr_show_protocol", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  _retval_ = (ssize_t )DEMARSH_STUB__psmouse_attr_show_protocol(& rqarg, psmouse,
                                                                data, buf);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return (_retval_);
}
}
//#line  6637
static ssize_t odft_sfipsmouse_attr_show_protocol(struct psmouse *psmouse , void *data ,
                                                  char *buf )  __attribute__((__isolate__)) ;
static ssize_t odft_sfipsmouse_attr_show_protocol(struct psmouse *psmouse , void *data ,
                                                  char *buf ) 
{ 
  struct psmouse_protocol  const  *tmp ;
  struct psmouse_protocol  const  *tmp___0 ;
  int tmp___1 ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_173267101);
  }
  if (__odft_error) {
    {
    __odft_error = (int )psmouse_attr_show_protocol(psmouse, data, buf);
    }
    return (__odft_error);
  } else {

  }
  {
  {
//#line  6645
  __odft_error = logRead(& psmouse->type, str_992291005, str_173267101, str_72550417,
                         6645);
  tmp = psmouse_protocol_by_type((enum psmouse_type )psmouse->type);
//#line  6647
  __odft_error = logRead(& tmp->name, str_593046695, str_173267101, str_72550417,
                         6647);
  printk(str_215909707, tmp->name);
//#line  6649
  __odft_error = logRead(& psmouse->type, str_992291005, str_173267101, str_72550417,
                         6649);
  tmp___0 = psmouse_protocol_by_type((enum psmouse_type )psmouse->type);
//#line  6651
  __odft_error = logRead(& tmp___0->name, str_110221080, str_173267101, str_72550417,
                         6651);
  tmp___1 = sprintf(buf, str_15552, tmp___0->name);
  }
//#line  6653
  return ((ssize_t )tmp___1);
  }
}
}
//#line  6657 "psmousebase.merged.kernel.c"
static ssize_t psmouse_attr_set_protocol(struct psmouse *psmouse , void *data , char const   *buf ,
                                         size_t count ) 
{ 
  struct serio *serio ;
  struct psmouse *parent ;
  struct input_dev *old_dev ;
  struct input_dev *new_dev ;
  struct psmouse_protocol  const  *proto ;
  struct psmouse_protocol  const  *old_proto ;
  int error ;
  int retry ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  6673
  serio = psmouse->ps2dev.serio;
//#line  6675
  parent = (struct psmouse *)((void *)0);
//#line  6677
  retry = 0;
//#line  6679
  proto = psmouse_protocol_by_name(buf, count);
  }
//#line  6681
  if (! proto) {
//#line  6683
    return ((ssize_t )-22);
  }
//#line  6686
  if ((unsigned int const   )psmouse->type == (unsigned int const   )proto->type) {
//#line  6688
    return ((ssize_t )count);
  }
  {
//#line  6691
  new_dev = input_allocate_device();
  }
//#line  6693
  if (! new_dev) {
//#line  6695
    return ((ssize_t )-12);
  }
  {
  {
//#line  6698
  while (1) {


    if (! serio->child) {
//#line  6698
      goto while_break;
    }
//#line  6700
    retry ++;
//#line  6702
    if (retry > 3) {
      {
//#line  6704
      printk(str_187222440);
//#line  6706
      input_free_device(new_dev);
      }
//#line  6708
      return ((ssize_t )-5);
    }
    {
//#line  6711
    mutex_unlock(& psmouse_mutex);
//#line  6713
    serio_unpin_driver(serio);
//#line  6715
    serio_unregister_child_port(serio);
//#line  6717
    serio_pin_driver_uninterruptible(serio);
//#line  6719
    mutex_lock_nested(& psmouse_mutex, 0U);
    }
//#line  6721
    if ((unsigned long )serio->drv != (unsigned long )(& psmouse_drv)) {
      {
//#line  6723
      input_free_device(new_dev);
      }
//#line  6725
      return ((ssize_t )-19);
    }
//#line  6728
    if ((unsigned int const   )psmouse->type == (unsigned int const   )proto->type) {
      {
//#line  6730
      input_free_device(new_dev);
      }
//#line  6732
      return ((ssize_t )count);
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  6736
  if (serio->parent) {
//#line  6738
    if ((int )serio->id.type == 5) {
      {
//#line  6740
      tmp = serio_get_drvdata((struct serio *)serio->parent);
//#line  6742
      parent = (struct psmouse *)tmp;
      }
//#line  6744
      if (parent->pt_deactivate) {
        {
//#line  6746
        (*(parent->pt_deactivate))(parent);
        }
      }
    }
  }
  {
//#line  6751
  old_dev = (struct input_dev *)psmouse->dev;
//#line  6753
  old_proto = psmouse_protocol_by_type((enum psmouse_type )psmouse->type);
  }
//#line  6755
  if (psmouse->disconnect) {
    {
//#line  6757
    (*(psmouse->disconnect))(psmouse);
    }
  }
  {
//#line  6760
  psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  6762
  psmouse->dev = (struct input_dev * __attribute__((__noderef__, __address_space__(2))) )new_dev;
//#line  6764
  psmouse_set_state(psmouse, (enum psmouse_state )1);
//#line  6766
  tmp___0 = psmouse_switch_protocol(psmouse, proto);
  }
//#line  6768
  if (tmp___0 < 0) {
    {
//#line  6770
    psmouse_reset(psmouse);
//#line  6772
    psmouse_switch_protocol(psmouse, & psmouse_protocols[0]);
    }
  }
  {
//#line  6775
  psmouse_initialize(psmouse);
//#line  6777
  psmouse_set_state(psmouse, (enum psmouse_state )3);
//#line  6779
  tmp___1 = (int )input_register_device((struct input_dev *)psmouse->dev);
  error = tmp___1;
  }
//#line  6781
  if (error) {
//#line  6783
    if (psmouse->disconnect) {
      {
//#line  6785
      (*(psmouse->disconnect))(psmouse);
      }
    }
    {
//#line  6788
    psmouse_set_state(psmouse, (enum psmouse_state )0);
//#line  6790
    input_free_device(new_dev);
//#line  6792
    psmouse->dev = (struct input_dev * __attribute__((__noderef__, __address_space__(2))) )old_dev;
//#line  6794
    psmouse_set_state(psmouse, (enum psmouse_state )1);
//#line  6796
    psmouse_switch_protocol(psmouse, old_proto);
//#line  6798
    psmouse_initialize(psmouse);
//#line  6800
    psmouse_set_state(psmouse, (enum psmouse_state )3);
    }
//#line  6802
    return ((ssize_t )error);
  }
  {
//#line  6805
  input_unregister_device(old_dev);
  }
//#line  6807
  if (parent) {
//#line  6809
    if (parent->pt_activate) {
      {
//#line  6811
      (*(parent->pt_activate))(parent);
      }
    }
  }
//#line  6815
  return ((ssize_t )count);
}
}
//#line  6819 "psmousebase.merged.kernel.c"
static ssize_t psmouse_attr_set_rate(struct psmouse *psmouse , void *data , char const   *buf ,
                                     size_t count ) 
{ 
  unsigned long value ;
  int tmp ;

  {
  {
//#line  6827
  tmp = strict_strtoul(buf, 10U, & value);
  }
//#line  6829
  if (tmp) {
//#line  6831
    return ((ssize_t )-22);
  }
  {
//#line  6834
  (*(psmouse->set_rate))(psmouse, (unsigned int )value);
  }
//#line  6836
  return ((ssize_t )count);
}
}
//#line  6840 "psmousebase.merged.kernel.c"
static ssize_t psmouse_attr_set_resolution(struct psmouse *psmouse , void *data ,
                                           char const   *buf , size_t count ) 
{ 
  unsigned long value ;
  int tmp ;

  {
  {
//#line  6848
  tmp = strict_strtoul(buf, 10U, & value);
  }
//#line  6850
  if (tmp) {
//#line  6852
    return ((ssize_t )-22);
  }
  {
//#line  6855
  (*(psmouse->set_resolution))(psmouse, (unsigned int )value);
  }
//#line  6857
  return ((ssize_t )count);
}
}
static void MARSH___STUB__psmouse_set_maxproto(struct req_args *rqarg , char const   *val ,
                                               struct kernel_param *kp ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr06name ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  idx_arr06 = 0;
  while (idx_arr06 < 12) {
    fill_marshbuf("psmouse_set_maxproto", & _buf_, & _off_, (void *)(& psmouse_protocols[idx_arr06].type),
                  sizeof(int ));
    fill_marshbuf("psmouse_set_maxproto", & _buf_, & _off_, (void *)(& psmouse_protocols[idx_arr06].maxproto),
                  sizeof(int ));
    fill_marshbuf_ptr("psmouse_set_maxproto", & _buf_, & _off_, & psmouse_protocols[idx_arr06].alias);
    if (psmouse_protocols[idx_arr06].alias != 0U) {
      fill_marshbuf("psmouse_set_maxproto", & _buf_, & _off_, (void *)psmouse_protocols[idx_arr06].alias,
                    sizeof(char const   ));
    }
    STRUCTADDRXpsmouse_protocolsidx_arr06name = & psmouse_protocols[idx_arr06].name;
    fill_marshbuf_ptr("psmouse_set_maxproto", & _buf_, & _off_, STRUCTADDRXpsmouse_protocolsidx_arr06name);
    if (*STRUCTADDRXpsmouse_protocolsidx_arr06name != 0U) {
      fill_marshbuf("psmouse_set_maxproto", & _buf_, & _off_, (void *)*STRUCTADDRXpsmouse_protocolsidx_arr06name,
                    sizeof(char const   ));
    }
    idx_arr06 ++;
  }
  fill_marshbuf_ptr("psmouse_set_maxproto", & _buf_, & _off_, & val);
  if (val != 0U) {
    fill_marshbuf("psmouse_set_maxproto", & _buf_, & _off_, (void *)val, sizeof(char const   ));
  }
  fill_marshbuf_ptr("psmouse_set_maxproto", & _buf_, & _off_, & kp);
  rqarg->function_id = 1208;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__psmouse_set_maxproto(struct req_args *rqarg , char const   *val ,
                                              struct kernel_param *kp ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int idx_arr07 ;
  void *tmp_lv8 ;
  void *tmp_fld9 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr07name ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  idx_arr07 = 0;
  while (idx_arr07 < 12) {
    tmp_fld9 = & psmouse_protocols[idx_arr07].type;
    tmp_lv8 = & psmouse_protocols[idx_arr07];
    nooks_ot_storeoffset_kern_w(& psmouse_protocols[idx_arr07], tmp_fld9 - tmp_lv8,
                                sizeof(enum psmouse_type ));
    fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(int ), (void *)(& psmouse_protocols[idx_arr07].type));
    tmp_fld9 = & psmouse_protocols[idx_arr07].maxproto;
    tmp_lv8 = & psmouse_protocols[idx_arr07];
    nooks_ot_storeoffset_kern_w(& psmouse_protocols[idx_arr07], tmp_fld9 - tmp_lv8,
                                sizeof(int ));
    fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(int ), (void *)(& psmouse_protocols[idx_arr07].maxproto));
    fetch_marshbuf_ptr("psmouse_set_maxproto", _buf_, & _off_, (void **)(& psmouse_protocols[idx_arr07].alias),
                       sizeof(char const   ), sizeof(char const   ));
    if (psmouse_protocols[idx_arr07].alias != 0U) {
      fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(char const   ),
                     (void *)psmouse_protocols[idx_arr07].alias);
    }
    tmp_fld9 = & psmouse_protocols[idx_arr07].name;
    tmp_lv8 = & psmouse_protocols[idx_arr07];
    nooks_ot_storeoffset_kern_w(& psmouse_protocols[idx_arr07], tmp_fld9 - tmp_lv8,
                                sizeof(char const   *));
    STRUCTADDRXpsmouse_protocolsidx_arr07name = & psmouse_protocols[idx_arr07].name;
    fetch_marshbuf_ptr("psmouse_set_maxproto", _buf_, & _off_, (void **)STRUCTADDRXpsmouse_protocolsidx_arr07name,
                       sizeof(char const   ), sizeof(char const   ));
    if (*STRUCTADDRXpsmouse_protocolsidx_arr07name != 0U) {
      fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(char const   ),
                     (void *)*STRUCTADDRXpsmouse_protocolsidx_arr07name);
    }
    idx_arr07 ++;
  }
  fetch_marshbuf_ptr("psmouse_set_maxproto", _buf_, & _off_, (void **)(& val), sizeof(char const   ),
                     sizeof(char const   ));
  if (val != 0U) {
    fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(char const   ),
                   (void *)val);
  }
  fetch_marshbuf_ptr("psmouse_set_maxproto", _buf_, & _off_, (void **)(& kp), sizeof(struct kernel_param ),
                     sizeof(struct kernel_param ));
  if (kp != 0U) {
    tmp_fld9 = & kp->__annonCompField15.arg;
    tmp_lv8 = & kp->__annonCompField15;
    nooks_ot_storeoffset_kern_w(& kp->__annonCompField15, tmp_fld9 - tmp_lv8, sizeof(void *));
  }
  fetch_marshbuf("psmouse_set_maxproto", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int psmouse_set_maxproto(char const   *val , struct kernel_param *kp ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_set_maxproto(& rqarg, val, kp);
  __odft_disp_error = disp_user("psmouse_set_maxproto", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  _retval_ = (int )DEMARSH_STUB__psmouse_set_maxproto(& rqarg, val, kp);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return (_retval_);
}
}
//#line  6863
static int odft_sfipsmouse_set_maxproto(char const   *val , struct kernel_param *kp )  __attribute__((__isolate__)) ;
static int odft_sfipsmouse_set_maxproto(char const   *val , struct kernel_param *kp ) 
{ 
  struct psmouse_protocol  const  *proto ;
  unsigned long tmp ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_140626898);
  }
  if (__odft_error) {
    {
    __odft_error = (int )psmouse_set_maxproto(val, kp);
    }
    return (__odft_error);
  } else {

  }
  {
//#line  6870
  if (! val) {
//#line  6872
    return (-22);
  }
  {
//#line  6875
  tmp = strlen(val);
//#line  6877
  proto = psmouse_protocol_by_name(val, tmp);
  }
//#line  6879
  if (! proto) {
//#line  6881
    return (-22);
  } else {
    {
    {
//#line  6884
    __odft_error = logRead(& proto->maxproto, str_245692261, str_140626898, str_72550417,
                           6884);
    }
//#line  6884
    if (! proto->maxproto) {
//#line  6886
      return (-22);
    }
    }
  }
  {
//#line  6889
  __odft_error = logWrite((unsigned int *)kp->__annonCompField15.arg, str_722666407,
                          str_140626898, str_72550417, 6889);
  __odft_error = logRead(& kp->__annonCompField15.arg, str_600255105, str_140626898,
                         str_72550417, 6889);
  __odft_error = logRead(& proto->type, str_320736607, str_140626898, str_72550417,
                         6889);
  *((unsigned int *)kp->__annonCompField15.arg) = (unsigned int )proto->type;
  }
//#line  6891
  return (0);
  }
}
}
static void MARSH___STUB__psmouse_get_maxproto(struct req_args *rqarg , char *buffer ,
                                               struct kernel_param *kp ) 
{ 
  void *_buf_ ;
  int _off_ ;
  int idx_arr06 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr06name ;

  {
  _off_ = 0U;
  _buf_ = 0U;
  idx_arr06 = 0;
  while (idx_arr06 < 12) {
    fill_marshbuf("psmouse_get_maxproto", & _buf_, & _off_, (void *)(& psmouse_protocols[idx_arr06].type),
                  sizeof(int ));
    STRUCTADDRXpsmouse_protocolsidx_arr06name = & psmouse_protocols[idx_arr06].name;
    fill_marshbuf_ptr("psmouse_get_maxproto", & _buf_, & _off_, STRUCTADDRXpsmouse_protocolsidx_arr06name);
    if (*STRUCTADDRXpsmouse_protocolsidx_arr06name != 0U) {
      fill_marshbuf("psmouse_get_maxproto", & _buf_, & _off_, (void *)*STRUCTADDRXpsmouse_protocolsidx_arr06name,
                    sizeof(char const   ));
    }
    idx_arr06 ++;
  }
  fill_marshbuf_ptr("psmouse_get_maxproto", & _buf_, & _off_, & buffer);
  if (buffer != 0U) {
    fill_marshbuf("psmouse_get_maxproto", & _buf_, & _off_, (void *)buffer, sizeof(char ));
  }
  fill_marshbuf_ptr("psmouse_get_maxproto", & _buf_, & _off_, & kp);
  rqarg->function_id = 1185;
  rqarg->data = _buf_;
  rqarg->length = _off_;
}
}
static int DEMARSH_STUB__psmouse_get_maxproto(struct req_args *rqarg , char *buffer ,
                                              struct kernel_param *kp ) 
{ 
  int _retval_ ;
  void *_buf_ ;
  int _off_ ;
  int idx_arr07 ;
  void *tmp_lv8 ;
  void *tmp_fld9 ;
  char const   **STRUCTADDRXpsmouse_protocolsidx_arr07name ;

  {
  _off_ = 0U;
  _buf_ = rqarg->data;
  idx_arr07 = 0;
  while (idx_arr07 < 12) {
    tmp_fld9 = & psmouse_protocols[idx_arr07].name;
    tmp_lv8 = & psmouse_protocols[idx_arr07];
    nooks_ot_storeoffset_kern_w(& psmouse_protocols[idx_arr07], tmp_fld9 - tmp_lv8,
                                sizeof(char const   *));
    STRUCTADDRXpsmouse_protocolsidx_arr07name = & psmouse_protocols[idx_arr07].name;
    fetch_marshbuf_ptr("psmouse_get_maxproto", _buf_, & _off_, (void **)STRUCTADDRXpsmouse_protocolsidx_arr07name,
                       sizeof(char const   ), sizeof(char const   ));
    if (*STRUCTADDRXpsmouse_protocolsidx_arr07name != 0U) {
      fetch_marshbuf("psmouse_get_maxproto", _buf_, & _off_, sizeof(char const   ),
                     (void *)*STRUCTADDRXpsmouse_protocolsidx_arr07name);
    }
    idx_arr07 ++;
  }
  fetch_marshbuf_ptr("psmouse_get_maxproto", _buf_, & _off_, (void **)(& buffer),
                     sizeof(char ), sizeof(char ));
  if (buffer != 0U) {
    fetch_marshbuf("psmouse_get_maxproto", _buf_, & _off_, sizeof(char ), (void *)buffer);
  }
  fetch_marshbuf_ptr("psmouse_get_maxproto", _buf_, & _off_, (void **)(& kp), sizeof(struct kernel_param ),
                     sizeof(struct kernel_param ));
  if (kp != 0U) {
    tmp_fld9 = & kp->__annonCompField15.arg;
    tmp_lv8 = & kp->__annonCompField15;
    nooks_ot_storeoffset_kern_w(& kp->__annonCompField15, tmp_fld9 - tmp_lv8, sizeof(void *));
  }
  fetch_marshbuf("psmouse_get_maxproto", _buf_, & _off_, sizeof(int ), (void *)(& _retval_));
  return (_retval_);
}
}
int psmouse_get_maxproto(char *buffer , struct kernel_param *kp ) 
{ 
  struct req_args rqarg ;
  int _retval_ ;
  int __odft_disp_error ;

  {
  rqarg.function_id = 0;
  rqarg.data = 0;
  rqarg.length = 0;
  _retval_ = 0;
  STUB_LOC1();
  MARSH___STUB__psmouse_get_maxproto(& rqarg, buffer, kp);
  __odft_disp_error = disp_user("psmouse_get_maxproto", & rqarg);
  if (__odft_disp_error) {
    return (75);
  } else {

  }
  _retval_ = (int )DEMARSH_STUB__psmouse_get_maxproto(& rqarg, buffer, kp);
  if (rqarg.data != 0U) {
    DEMARSHBUF_FREE(rqarg.data);
  }
  STUB_LOC2();
  return (_retval_);
}
}
//#line  6897
static int odft_sfipsmouse_get_maxproto(char *buffer , struct kernel_param *kp )  __attribute__((__isolate__)) ;
static int odft_sfipsmouse_get_maxproto(char *buffer , struct kernel_param *kp ) 
{ 
  int type ;
  struct psmouse_protocol  const  *tmp ;
  int tmp___0 ;
  int __odft_error ;

  {
  __odft_error = 0;
  {
  __odft_error = logSfiFrame(str_39677390);
  }
  if (__odft_error) {
    {
    __odft_error = (int )psmouse_get_maxproto(buffer, kp);
    }
    return (__odft_error);
  } else {

  }
  {
  {
//#line  6905
  __odft_error = logRead((unsigned int *)kp->__annonCompField15.arg, str_722666407,
                         str_39677390, str_72550417, 6905);
  __odft_error = logRead(& kp->__annonCompField15.arg, str_600255105, str_39677390,
                         str_72550417, 6905);
  type = (int )*((unsigned int *)kp->__annonCompField15.arg);
//#line  6907
  tmp = psmouse_protocol_by_type((enum psmouse_type )type);
//#line  6909
  __odft_error = logRead(& tmp->name, str_593046695, str_39677390, str_72550417, 6909);
  tmp___0 = sprintf(buffer, str_15552, tmp->name);
  }
//#line  6911
  return (tmp___0);
  }
}
}
//#line  6915 "psmousebase.merged.kernel.c"
static struct lock_class_key __key___4  ;
//#line  6917
static int psmouse_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
//#line  6919
static int psmouse_init(void)  __attribute__((__section__(".init.text"), __no_instrument_function__)) ;
static int psmouse_init(void) 
{ 
  int err ;
  char const   *__lock_name ;
  struct workqueue_struct *tmp ;
  int tmp___0 ;

  {
  {
//#line  6927
  __lock_name = str_84203302;
//#line  6929
  tmp = __create_workqueue_key(str_1052497969, 1, 0, 0, & __key___4, __lock_name);
//#line  6931
  kpsmoused_wq = (struct workqueue_struct___0 *)tmp;
  }
//#line  6933
  if (! kpsmoused_wq) {
    {
//#line  6935
    printk(str_53613786);
    }
//#line  6937
    return (-12);
  }
  {
//#line  6940
  tmp___0 = (int )serio_register_driver(& psmouse_drv);
  err = tmp___0;
  }
//#line  6942
  if (err) {
    {
//#line  6944
    destroy_workqueue((struct workqueue_struct *)kpsmoused_wq);
    }
  }
//#line  6947
  return (err);
}
}
//#line  6951
static void psmouse_exit(void)  __attribute__((__section__(".exit.text"))) ;
//#line  6953
static void psmouse_exit(void)  __attribute__((__section__(".exit.text"))) ;
static void psmouse_exit(void) 
{ 


  {
  {
//#line  6959
  serio_unregister_driver(& psmouse_drv);
//#line  6961
  destroy_workqueue((struct workqueue_struct *)kpsmoused_wq);
  }
//#line  6963
  return;
}
}
//#line  6967 "psmousebase.merged.kernel.c"
int init_module(void) 
{  
#include "../../common/master_init_module.h" //Matt E3 
 
  int tmp ;

  {
  {
//#line  6973
  tmp = psmouse_init();
  }
//#line  6975
  return (tmp);
}
}
//#line  6979 "psmousebase.merged.kernel.c"
void cleanup_module(void) 
{ 


  {
  {
//#line  6985
  psmouse_exit();
  }
//#line  6987
  return;
}
}
//#line  6993
#pragma merger(0,"./alps.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  6995
extern void *__memcpy(void *to , void const   *from , size_t len ) ;
//#line  6997
extern int memcmp(void const   *cs , void const   *ct , unsigned long count ) ;
//#line  6999 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) input_report_abs)(struct input_dev *dev ,
                                                                            unsigned int code ,
                                                                            int value ) 
{ 


  {
  {
//#line  7007
  input_event(dev, 3U, code, value);
  }
//#line  7009
  return;
}
}
//#line  7013 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) input_set_abs_params)(struct input_dev *dev ,
                                                                                int axis ,
                                                                                int min ,
                                                                                int max ,
                                                                                int fuzz ,
                                                                                int flat ) 
{ 


  {
//#line  7024
  dev->absmin[axis] = min;
//#line  7026
  dev->absmax[axis] = max;
//#line  7028
  dev->absfuzz[axis] = fuzz;
//#line  7030
  dev->absflat[axis] = flat;
//#line  7032
  dev->absbit[axis / 64] |= 1UL << axis % 64;
//#line  7034
  return;
}
}
//#line  7038
extern void ps2_drain(struct ps2dev *ps2dev , int maxbytes , int timeout ) ;
static struct alps_model_info  const  alps_model_data[19]  = 
//#line  7040
  {      {{(unsigned char)51, (unsigned char)2, (unsigned char)10}, (unsigned char)136,
      (unsigned char)248, (unsigned char)16}, 
        {{(unsigned char)83, (unsigned char)2, (unsigned char)10}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)83, (unsigned char)2, (unsigned char)20}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)96, (unsigned char)3, (unsigned char)200}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)10}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)20}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)40}, (unsigned char)248,
      (unsigned char)248, (unsigned char)64}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)60}, (unsigned char)143,
      (unsigned char)143, (unsigned char)2}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)80}, (unsigned char)239,
      (unsigned char)239, (unsigned char)4}, 
        {{(unsigned char)99, (unsigned char)2, (unsigned char)100}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)99, (unsigned char)3, (unsigned char)200}, (unsigned char)248,
      (unsigned char)248, (unsigned char)32}, 
        {{(unsigned char)115, (unsigned char)0, (unsigned char)10}, (unsigned char)248,
      (unsigned char)248, (unsigned char)1}, 
        {{(unsigned char)115, (unsigned char)2, (unsigned char)10}, (unsigned char)248,
      (unsigned char)248, (unsigned char)0}, 
        {{(unsigned char)115, (unsigned char)2, (unsigned char)20}, (unsigned char)248,
      (unsigned char)248, (unsigned char)64}, 
        {{(unsigned char)32, (unsigned char)2, (unsigned char)14}, (unsigned char)248,
      (unsigned char)248, (unsigned char)33}, 
        {{(unsigned char)34, (unsigned char)2, (unsigned char)10}, (unsigned char)248,
      (unsigned char)248, (unsigned char)33}, 
        {{(unsigned char)34, (unsigned char)2, (unsigned char)20}, (unsigned char)255,
      (unsigned char)255, (unsigned char)33}, 
        {{(unsigned char)98, (unsigned char)2, (unsigned char)20}, (unsigned char)207,
      (unsigned char)207, (unsigned char)33}, 
        {{(unsigned char)115, (unsigned char)2, (unsigned char)80}, (unsigned char)207,
      (unsigned char)207, (unsigned char)4}};
//#line  7081 "psmousebase.merged.kernel.c"
static void alps_process_packet(struct psmouse *psmouse ) 
{ 
  struct alps_data *priv ;
  unsigned char *packet ;
  struct input_dev *dev ;
  struct input_dev *dev2 ;
  int x ;
  int y ;
  int z ;
  int ges ;
  int fin ;
  int left ;
  int right ;
  int middle ;
  int back ;
  int forward ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
//#line  7105
  priv = (struct alps_data *)psmouse->private;
//#line  7107
  packet = psmouse->packet;
//#line  7109
  dev = (struct input_dev *)psmouse->dev;
//#line  7111
  dev2 = priv->dev2;
//#line  7113
  back = 0;
//#line  7115
  forward = 0;
//#line  7117
  if (((int )*(packet + 0) & 200) == 8) {
    {
//#line  7119
    input_report_key(dev2, 272U, (int )*(packet + 0) & 1);
//#line  7121
    input_report_key(dev2, 273U, (int )*(packet + 0) & 2);
//#line  7123
    input_report_key(dev2, 274U, (int )*(packet + 0) & 4);
    }
//#line  7125
    if (*(packet + 1)) {
//#line  7127
      tmp = (int )*(packet + 1) - (((int )*(packet + 0) << 4) & 256);
    } else {
//#line  7130
      tmp = 0;
    }
    {
//#line  7133
    input_report_rel(dev2, 0U, tmp);
    }
//#line  7135
    if (*(packet + 2)) {
//#line  7137
      tmp___0 = (((int )*(packet + 0) << 3) & 256) - (int )*(packet + 2);
    } else {
//#line  7140
      tmp___0 = 0;
    }
    {
//#line  7143
    input_report_rel(dev2, 1U, tmp___0);
//#line  7145
    input_sync(dev2);
    }
//#line  7147
    return;
  }
//#line  7150
  if ((int const   )(priv->i)->flags & 16) {
//#line  7152
    left = (int )*(packet + 2) & 16;
//#line  7154
    right = (int )*(packet + 2) & 8;
//#line  7156
    middle = 0;
//#line  7158
    x = (int )*(packet + 1) | (((int )*(packet + 0) & 7) << 7);
//#line  7160
    y = (int )*(packet + 4) | (((int )*(packet + 3) & 7) << 7);
//#line  7162
    z = (int )*(packet + 5);
  } else {
//#line  7165
    left = (int )*(packet + 3) & 1;
//#line  7167
    right = (int )*(packet + 3) & 2;
//#line  7169
    middle = (int )*(packet + 3) & 4;
//#line  7171
    x = (int )*(packet + 1) | (((int )*(packet + 2) & 120) << 4);
//#line  7173
    y = (int )*(packet + 4) | (((int )*(packet + 3) & 112) << 3);
//#line  7175
    z = (int )*(packet + 5);
  }
//#line  7178
  if ((int const   )(priv->i)->flags & 4) {
//#line  7180
    back = (int )*(packet + 0) & 16;
//#line  7182
    forward = (int )*(packet + 2) & 4;
  }
//#line  7185
  if ((int const   )(priv->i)->flags & 64) {
//#line  7187
    back = (int )*(packet + 3) & 4;
//#line  7189
    forward = (int )*(packet + 2) & 4;
//#line  7191
    if (forward) {
//#line  7193
      if (back) {
//#line  7195
        tmp___1 = 1;
      } else {
//#line  7198
        tmp___1 = 0;
      }
    } else {
//#line  7202
      tmp___1 = 0;
    }
//#line  7205
    middle = tmp___1;
//#line  7207
    if (middle) {
//#line  7209
      back = 0;
//#line  7211
      forward = back;
    }
  }
  {
//#line  7215
  ges = (int )*(packet + 2) & 1;
//#line  7217
  fin = (int )*(packet + 2) & 2;
//#line  7219
  input_report_key(dev, 272U, left);
//#line  7221
  input_report_key(dev, 273U, right);
//#line  7223
  input_report_key(dev, 274U, middle);
  }
//#line  7225
  if ((int const   )(priv->i)->flags & 1) {
//#line  7227
    if (z == 127) {
//#line  7229
      if (x > 383) {
//#line  7231
        tmp___2 = x - 768;
      } else {
//#line  7234
        tmp___2 = x;
      }
      {
//#line  7237
      input_report_rel(dev2, 0U, tmp___2);
      }
//#line  7239
      if (y > 255) {
//#line  7241
        tmp___3 = y - 512;
      } else {
//#line  7244
        tmp___3 = y;
      }
      {
//#line  7247
      input_report_rel(dev2, 1U, - tmp___3);
//#line  7249
      input_sync(dev);
//#line  7251
      input_sync(dev2);
      }
//#line  7253
      return;
    }
  }
//#line  7257
  if (ges) {
//#line  7259
    if (! fin) {
//#line  7261
      z = 40;
    }
  }
//#line  7265
  if (ges) {
//#line  7267
    if (fin) {
//#line  7269
      if (! priv->prev_fin) {
        {
//#line  7271
        input_report_abs(dev, 0U, x);
//#line  7273
        input_report_abs(dev, 1U, y);
//#line  7275
        input_report_abs(dev, 24U, 0);
//#line  7277
        input_report_key(dev, 325U, 0);
//#line  7279
        input_sync(dev);
        }
      }
    }
  }
//#line  7284
  priv->prev_fin = fin;
//#line  7286
  if (z > 30) {
    {
//#line  7288
    input_report_key(dev, 330U, 1);
    }
  }
//#line  7291
  if (z < 25) {
    {
//#line  7293
    input_report_key(dev, 330U, 0);
    }
  }
//#line  7296
  if (z > 0) {
    {
//#line  7298
    input_report_abs(dev, 0U, x);
//#line  7300
    input_report_abs(dev, 1U, y);
    }
  }
  {
//#line  7303
  input_report_abs(dev, 24U, z);
//#line  7305
  input_report_key(dev, 325U, z > 0);
  }
//#line  7307
  if ((int const   )(priv->i)->flags & 2) {
    {
//#line  7309
    input_report_rel(dev, 8U, (((int )*(packet + 2) << 1) & 8) - (((int )*(packet + 0) >> 4) & 7));
    }
  }
//#line  7312
  if ((int const   )(priv->i)->flags & 68) {
    {
//#line  7314
    input_report_key(dev, 277U, forward);
//#line  7316
    input_report_key(dev, 278U, back);
    }
  }
  {
//#line  7319
  input_sync(dev);
  }
//#line  7321
  return;
}
}
//#line  7325 "psmousebase.merged.kernel.c"
static psmouse_ret_t alps_process_byte(struct psmouse *psmouse ) 
{ 
  struct alps_data *priv ;

  {
//#line  7331
  priv = (struct alps_data *)psmouse->private;
//#line  7333
  if (((int )psmouse->packet[0] & 200) == 8) {
//#line  7335
    if ((int )psmouse->pktcnt == 3) {
      {
//#line  7337
      alps_process_packet(psmouse);
      }
//#line  7339
      return ((psmouse_ret_t )2);
    }
//#line  7342
    return ((psmouse_ret_t )1);
  }
//#line  7345
  if (((int )psmouse->packet[0] & (int )(priv->i)->mask0) != (int )(priv->i)->byte0) {
//#line  7347
    return ((psmouse_ret_t )0);
  }
//#line  7350
  if ((int )psmouse->pktcnt >= 2) {
//#line  7352
    if ((int )psmouse->pktcnt <= 6) {
//#line  7354
      if ((int )psmouse->packet[(int )psmouse->pktcnt - 1] & 128) {
//#line  7356
        return ((psmouse_ret_t )0);
      }
    }
  }
//#line  7361
  if ((int )psmouse->pktcnt == 6) {
    {
//#line  7363
    alps_process_packet(psmouse);
    }
//#line  7365
    return ((psmouse_ret_t )2);
  }
//#line  7368
  return ((psmouse_ret_t )1);
}
}
//#line  7372
static struct alps_model_info  const  *alps_get_model(struct psmouse *psmouse , int *version ) ;
static unsigned char const   rates___0[8]  = 
//#line  7374
  {      (unsigned char const   )0,      (unsigned char const   )10,      (unsigned char const   )20,      (unsigned char const   )40, 
        (unsigned char const   )60,      (unsigned char const   )80,      (unsigned char const   )100,      (unsigned char const   )200};
//#line  7379 "psmousebase.merged.kernel.c"
static struct alps_model_info  const  *alps_get_model(struct psmouse *psmouse , int *version ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[4] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
//#line  7398
  ps2dev = & psmouse->ps2dev;
//#line  7400
  param[0] = (unsigned char)0;
//#line  7402
  tmp = ps2_command(ps2dev, param, 4328);
  }
//#line  7404
  if (tmp) {
//#line  7406
    return ((struct alps_model_info  const  *)((void *)0));
  } else {
    {
//#line  7409
    tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
    }
//#line  7411
    if (tmp___0) {
//#line  7413
      return ((struct alps_model_info  const  *)((void *)0));
    } else {
      {
//#line  7416
      tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
      }
//#line  7418
      if (tmp___1) {
//#line  7420
        return ((struct alps_model_info  const  *)((void *)0));
      } else {
        {
//#line  7423
        tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
        }
//#line  7425
        if (tmp___2) {
//#line  7427
          return ((struct alps_model_info  const  *)((void *)0));
        }
      }
    }
  }
  {
//#line  7433
  param[2] = (unsigned char)255;
//#line  7435
  param[1] = param[2];
//#line  7437
  param[0] = param[1];
//#line  7439
  tmp___3 = ps2_command(ps2dev, param, 1001);
  }
//#line  7441
  if (tmp___3) {
//#line  7443
    return ((struct alps_model_info  const  *)((void *)0));
  }
  {
  {
//#line  7446
  while (1) {


//#line  7448
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  7451
  if ((int )param[0] != 0) {
//#line  7453
    return ((struct alps_model_info  const  *)((void *)0));
  } else
//#line  7456
  if ((int )param[1] != 0) {
//#line  7458
    return ((struct alps_model_info  const  *)((void *)0));
  } else
//#line  7461
  if ((int )param[2] != 10) {
//#line  7463
    if ((int )param[2] != 100) {
//#line  7465
      return ((struct alps_model_info  const  *)((void *)0));
    }
  }
  {
//#line  7469
  param[0] = (unsigned char)0;
//#line  7471
  tmp___4 = ps2_command(ps2dev, param, 4328);
  }
//#line  7473
  if (tmp___4) {
//#line  7475
    return ((struct alps_model_info  const  *)((void *)0));
  } else {
    {
//#line  7478
    tmp___5 = ps2_command(ps2dev, (unsigned char *)((void *)0), 231);
    }
//#line  7480
    if (tmp___5) {
//#line  7482
      return ((struct alps_model_info  const  *)((void *)0));
    } else {
      {
//#line  7485
      tmp___6 = ps2_command(ps2dev, (unsigned char *)((void *)0), 231);
      }
//#line  7487
      if (tmp___6) {
//#line  7489
        return ((struct alps_model_info  const  *)((void *)0));
      } else {
        {
//#line  7492
        tmp___7 = ps2_command(ps2dev, (unsigned char *)((void *)0), 231);
        }
//#line  7494
        if (tmp___7) {
//#line  7496
          return ((struct alps_model_info  const  *)((void *)0));
        }
      }
    }
  }
  {
//#line  7502
  param[2] = (unsigned char)255;
//#line  7504
  param[1] = param[2];
//#line  7506
  param[0] = param[1];
//#line  7508
  tmp___8 = ps2_command(ps2dev, param, 1001);
  }
//#line  7510
  if (tmp___8) {
//#line  7512
    return ((struct alps_model_info  const  *)((void *)0));
  }
  {
  {
//#line  7515
  while (1) {


//#line  7517
    goto while_break___0;
  }

  }
  while_break___0: /* CIL Label */ ;
  }
//#line  7520
  if (version) {
//#line  7522
    i = 0;
    {
    {
//#line  7524
    while (1) {


//#line  7526
      if ((unsigned long )i < sizeof(rates___0) / sizeof(rates___0[0]) + (sizeof(char [1]) - 1UL)) {
//#line  7528
        if (! ((int )param[2] != (int )rates___0[i])) {
//#line  7530
          goto while_break___1;
        }
      } else {
//#line  7534
        goto while_break___1;
      }
//#line  7537
      i ++;
    }

    }
    while_break___1: /* CIL Label */ ;
    }
//#line  7540
    *version = (((int )param[0] << 8) | ((int )param[1] << 4)) | i;
  }
//#line  7543
  i = 0;
  {
  {
//#line  7545
  while (1) {


    if (! ((unsigned long )i < sizeof(alps_model_data) / sizeof(alps_model_data[0]) + (sizeof(char [1]) - 1UL))) {
//#line  7545
      goto while_break___2;
    }
    {
//#line  7547
    tmp___9 = memcmp((void const   *)(param), (void const   *)(alps_model_data[i].signature),
                     sizeof(alps_model_data[i].signature));
    }
//#line  7550
    if (! tmp___9) {
//#line  7552
      return (alps_model_data + i);
    }
//#line  7555
    i ++;
  }

  }
  while_break___2: /* CIL Label */ ;
  }
//#line  7558
  return ((struct alps_model_info  const  *)((void *)0));
}
}
//#line  7562 "psmousebase.merged.kernel.c"
static int alps_passthrough_mode(struct psmouse *psmouse , int enable ) 
{ 
  struct ps2dev *ps2dev ;
  int cmd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
//#line  7574
  ps2dev = & psmouse->ps2dev;
//#line  7576
  if (enable) {
//#line  7578
    tmp = 231;
  } else {
//#line  7581
    tmp = 230;
  }
  {
//#line  7584
  cmd = tmp;
//#line  7586
  tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), cmd);
  }
//#line  7588
  if (tmp___0) {
//#line  7590
    return (-1);
  } else {
    {
//#line  7593
    tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), cmd);
    }
//#line  7595
    if (tmp___1) {
//#line  7597
      return (-1);
    } else {
      {
//#line  7600
      tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), cmd);
      }
//#line  7602
      if (tmp___2) {
//#line  7604
        return (-1);
      } else {
        {
//#line  7607
        tmp___3 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
        }
//#line  7609
        if (tmp___3) {
//#line  7611
          return (-1);
        }
      }
    }
  }
  {
//#line  7617
  ps2_drain(ps2dev, 3, 100);
  }
//#line  7619
  return (0);
}
}
//#line  7623 "psmousebase.merged.kernel.c"
static int alps_absolute_mode(struct psmouse *psmouse ) 
{ 
  struct ps2dev *ps2dev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
//#line  7635
  ps2dev = & psmouse->ps2dev;
//#line  7637
  tmp = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
  }
//#line  7639
  if (tmp) {
//#line  7641
    return (-1);
  } else {
    {
//#line  7644
    tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
    }
//#line  7646
    if (tmp___0) {
//#line  7648
      return (-1);
    } else {
      {
//#line  7651
      tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
      }
//#line  7653
      if (tmp___1) {
//#line  7655
        return (-1);
      } else {
        {
//#line  7658
        tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
        }
//#line  7660
        if (tmp___2) {
//#line  7662
          return (-1);
        } else {
          {
//#line  7665
          tmp___3 = ps2_command(ps2dev, (unsigned char *)((void *)0), 244);
          }
//#line  7667
          if (tmp___3) {
//#line  7669
            return (-1);
          }
        }
      }
    }
  }
  {
//#line  7676
  tmp___4 = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 240);
  }
//#line  7678
  return (tmp___4);
}
}
//#line  7682 "psmousebase.merged.kernel.c"
static int alps_get_status(struct psmouse *psmouse , char *param ) 
{ 
  struct ps2dev *ps2dev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  7692
  ps2dev = & psmouse->ps2dev;
//#line  7694
  tmp = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
  }
//#line  7696
  if (tmp) {
//#line  7698
    return (-1);
  } else {
    {
//#line  7701
    tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
    }
//#line  7703
    if (tmp___0) {
//#line  7705
      return (-1);
    } else {
      {
//#line  7708
      tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
      }
//#line  7710
      if (tmp___1) {
//#line  7712
        return (-1);
      } else {
        {
//#line  7715
        tmp___2 = ps2_command(ps2dev, (unsigned char *)param, 1001);
        }
//#line  7717
        if (tmp___2) {
//#line  7719
          return (-1);
        }
      }
    }
  }
  {
  {
//#line  7725
  while (1) {


//#line  7727
    goto while_break;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  7730
  return (0);
}
}
//#line  7734 "psmousebase.merged.kernel.c"
static int alps_tap_mode(struct psmouse *psmouse , int enable ) 
{ 
  struct ps2dev *ps2dev ;
  int cmd ;
  int tmp ;
  unsigned char tap_arg ;
  int tmp___0 ;
  unsigned char param[4] ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  7750
  ps2dev = & psmouse->ps2dev;
//#line  7752
  if (enable) {
//#line  7754
    tmp = 4339;
  } else {
//#line  7757
    tmp = 4328;
  }
//#line  7760
  cmd = tmp;
//#line  7762
  if (enable) {
//#line  7764
    tmp___0 = 10;
  } else {
//#line  7767
    tmp___0 = 0;
  }
  {
//#line  7770
  tap_arg = (unsigned char )tmp___0;
//#line  7772
  tmp___1 = ps2_command(ps2dev, param, 1001);
  }
//#line  7774
  if (tmp___1) {
//#line  7776
    return (-1);
  } else {
    {
//#line  7779
    tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
    }
//#line  7781
    if (tmp___2) {
//#line  7783
      return (-1);
    } else {
      {
//#line  7786
      tmp___3 = ps2_command(ps2dev, (unsigned char *)((void *)0), 245);
      }
//#line  7788
      if (tmp___3) {
//#line  7790
        return (-1);
      } else {
        {
//#line  7793
        tmp___4 = ps2_command(ps2dev, & tap_arg, cmd);
        }
//#line  7795
        if (tmp___4) {
//#line  7797
          return (-1);
        }
      }
    }
  }
  {
//#line  7803
  tmp___5 = alps_get_status(psmouse, (char *)(param));
  }
//#line  7805
  if (tmp___5) {
//#line  7807
    return (-1);
  }
//#line  7810
  return (0);
}
}
//#line  7814 "psmousebase.merged.kernel.c"
static int alps_poll(struct psmouse *psmouse ) 
{ 
  struct alps_data *priv ;
  unsigned char buf[6] ;
  int poll_failed ;
  int tmp ;
  int tmp___0 ;
  size_t __len ;
  void *__ret ;

  {
//#line  7826
  priv = (struct alps_data *)psmouse->private;
//#line  7828
  if ((int const   )(priv->i)->flags & 32) {
    {
//#line  7830
    alps_passthrough_mode(psmouse, 1);
    }
  }
  {
//#line  7833
  tmp = ps2_command(& psmouse->ps2dev, buf, 235 | ((int )psmouse->pktsize << 8));
//#line  7835
  poll_failed = tmp < 0;
  }
//#line  7837
  if ((int const   )(priv->i)->flags & 32) {
    {
//#line  7839
    alps_passthrough_mode(psmouse, 0);
    }
  }
//#line  7842
  if (poll_failed) {
//#line  7844
    return (-1);
  } else
//#line  7847
  if (((int )buf[0] & (int )(priv->i)->mask0) != (int )(priv->i)->byte0) {
//#line  7849
    return (-1);
  }
//#line  7852
  if (((int )psmouse->badbyte & 200) == 8) {
    {
//#line  7854
    tmp___0 = ps2_command(& psmouse->ps2dev, buf, 235 | (3 << 8));
    }
//#line  7856
    if (tmp___0) {
//#line  7858
      return (-1);
    }
  }
//#line  7862
  __len = sizeof(buf);
//#line  7864
  if (__len >= 64UL) {
    {
//#line  7866
    __ret = __memcpy((void *)(psmouse->packet), (void const   *)(buf), __len);
    }
  } else {
    {
//#line  7869
    __ret = __builtin_memcpy((void *)(psmouse->packet), (void const   *)(buf), __len);
    }
  }
//#line  7872
  return (0);
}
}
//#line  7876 "psmousebase.merged.kernel.c"
static int alps_hw_init(struct psmouse *psmouse , int *version ) 
{ 
  struct alps_data *priv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
//#line  7887
  priv = (struct alps_data *)psmouse->private;
//#line  7889
  priv->i = alps_get_model(psmouse, version);
  }
//#line  7891
  if (! priv->i) {
//#line  7893
    return (-1);
  }
//#line  7896
  if ((int const   )(priv->i)->flags & 32) {
    {
//#line  7898
    tmp = alps_passthrough_mode(psmouse, 1);
    }
//#line  7900
    if (tmp) {
//#line  7902
      return (-1);
    }
  }
  {
//#line  7906
  tmp___0 = alps_tap_mode(psmouse, 1);
  }
//#line  7908
  if (tmp___0) {
    {
//#line  7910
    printk(str_705599013);
    }
//#line  7912
    return (-1);
  }
  {
//#line  7915
  tmp___1 = alps_absolute_mode(psmouse);
  }
//#line  7917
  if (tmp___1) {
    {
//#line  7919
    printk(str_585544529);
    }
//#line  7921
    return (-1);
  }
//#line  7924
  if ((int const   )(priv->i)->flags & 32) {
    {
//#line  7926
    tmp___2 = alps_passthrough_mode(psmouse, 0);
    }
//#line  7928
    if (tmp___2) {
//#line  7930
      return (-1);
    }
  }
  {
//#line  7934
  tmp___3 = ps2_command(& psmouse->ps2dev, (unsigned char *)((void *)0), 234);
  }
//#line  7936
  if (tmp___3) {
    {
//#line  7938
    printk(str_747748554);
    }
//#line  7940
    return (-1);
  }
//#line  7943
  return (0);
}
}
//#line  7947 "psmousebase.merged.kernel.c"
static int alps_reconnect(struct psmouse *psmouse ) 
{ 
  int tmp ;

  {
  {
//#line  7953
  psmouse_reset(psmouse);
//#line  7955
  tmp = alps_hw_init(psmouse, (int *)((void *)0));
  }
//#line  7957
  if (tmp) {
//#line  7959
    return (-1);
  }
//#line  7962
  return (0);
}
}
//#line  7966 "psmousebase.merged.kernel.c"
static void alps_disconnect(struct psmouse *psmouse ) 
{ 
  struct alps_data *priv ;

  {
  {
//#line  7972
  priv = (struct alps_data *)psmouse->private;
//#line  7974
  psmouse_reset(psmouse);
//#line  7976
  input_unregister_device(priv->dev2);
//#line  7978
  kfree((void const   *)priv);
  }
//#line  7980
  return;
}
}
//#line  7984 "psmousebase.merged.kernel.c"
int alps_init(struct psmouse *psmouse ) 
{ 
  struct alps_data *priv ;
  struct input_dev *dev1 ;
  struct input_dev *dev2 ;
  int version ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  7996
  dev1 = (struct input_dev *)psmouse->dev;
//#line  7998
  tmp = kzalloc(sizeof(struct alps_data ), 208U);
//#line  8000
  priv = (struct alps_data *)tmp;
//#line  8002
  dev2 = input_allocate_device();
  }
//#line  8004
  if (! priv) {
//#line  8006
    goto init_fail;
  } else
//#line  8009
  if (! dev2) {
//#line  8011
    goto init_fail;
  }
  {
//#line  8014
  priv->dev2 = dev2;
//#line  8016
  psmouse->private = (void *)priv;
//#line  8018
  tmp___0 = alps_hw_init(psmouse, & version);
  }
//#line  8020
  if (tmp___0) {
//#line  8022
    goto init_fail;
  }
  {
//#line  8025
  dev1->evbit[0] |= 1UL << 1;
//#line  8027
  dev1->keybit[5] |= 1UL << 10;
//#line  8029
  dev1->keybit[5] |= 1UL << 5;
//#line  8031
  dev1->keybit[4] |= ((1UL << 16) | (1UL << 18)) | (1UL << 17);
//#line  8033
  dev1->evbit[0] |= 1UL << 3;
//#line  8035
  input_set_abs_params(dev1, 0, 0, 1023, 0, 0);
//#line  8037
  input_set_abs_params(dev1, 1, 0, 767, 0, 0);
//#line  8039
  input_set_abs_params(dev1, 24, 0, 127, 0, 0);
  }
//#line  8041
  if ((int const   )(priv->i)->flags & 2) {
//#line  8043
    dev1->evbit[0] |= 1UL << 2;
//#line  8045
    dev1->relbit[0] |= 1UL << 8;
  }
//#line  8048
  if ((int const   )(priv->i)->flags & 68) {
//#line  8050
    dev1->keybit[4] |= 1UL << 21;
//#line  8052
    dev1->keybit[4] |= 1UL << 22;
  }
  {
//#line  8055
  snprintf(priv->phys, sizeof(priv->phys), str_307711520, (psmouse->ps2dev.serio)->phys);
//#line  8057
  dev2->phys = (char const   *)(priv->phys);
  }
//#line  8059
  if ((int const   )(priv->i)->flags & 1) {
//#line  8061
    dev2->name = (char const   *)str_434472304;
  } else {
//#line  8064
    dev2->name = (char const   *)str_358533959;
  }
  {
//#line  8067
  dev2->id.bustype = (__u16 )17;
//#line  8069
  dev2->id.vendor = (__u16 )2;
//#line  8071
  dev2->id.product = (__u16 )8;
//#line  8073
  dev2->id.version = (__u16 )0;
//#line  8075
  dev2->dev.parent = (struct device *)(& (psmouse->ps2dev.serio)->dev);
//#line  8077
  dev2->evbit[0] = (1UL << 1) | (1UL << 2);
//#line  8079
  dev2->relbit[0] |= 1UL | (1UL << 1);
//#line  8081
  dev2->keybit[4] |= ((1UL << 16) | (1UL << 18)) | (1UL << 17);
//#line  8083
  tmp___2 = (int )input_register_device(priv->dev2);
  tmp___1 = tmp___2;
  }
//#line  8085
  if (tmp___1) {
//#line  8087
    goto init_fail;
  }
//#line  8090
  psmouse->protocol_handler = & alps_process_byte;
//#line  8092
  psmouse->poll = & alps_poll;
//#line  8094
  psmouse->disconnect = & alps_disconnect;
//#line  8096
  psmouse->reconnect = & alps_reconnect;
//#line  8098
  psmouse->pktsize = (unsigned char)6;
//#line  8100
  psmouse->resync_time = (unsigned int )0;
//#line  8102
  return (0);
  init_fail: 
  {
//#line  8105
  psmouse_reset(psmouse);
//#line  8107
  input_free_device(dev2);
//#line  8109
  kfree((void const   *)priv);
//#line  8111
  psmouse->private = (void *)0;
  }
//#line  8113
  return (-1);
}
}
//#line  8117 "psmousebase.merged.kernel.c"
int alps_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  int version ;
  struct alps_model_info  const  *model ;

  {
  {
//#line  8124
  model = alps_get_model(psmouse, & version);
  }
//#line  8126
  if (! model) {
//#line  8128
    return (-1);
  }
//#line  8131
  if (set_properties) {
//#line  8133
    psmouse->vendor = (char *)str_474874;
//#line  8135
    if ((int const   )model->flags & 1) {
//#line  8137
      psmouse->name = (char *)str_26595480;
    } else {
//#line  8140
      psmouse->name = (char *)str_709202683;
    }
//#line  8143
    psmouse->model = (unsigned int )version;
  }
//#line  8146
  return (0);
}
}
//#line  8150
#pragma merger(0,"./synaptics.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  8152 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) clear_bit)(int nr , unsigned long volatile   *addr ) 
{ 


  {
//#line  8158
  __asm__  volatile   (".section .smp_locks,\"a\"\n"
                       " "
                       ".balign 8"
                       " "
                       "\n"
                       " "
                       ".quad"
                       " "
                       "661f\n"
                       ".previous\n"
                       "661:\n\tlock; "
                       "btr %1,%0": "+m" (*((long volatile   *)addr)): "Ir" (nr));
//#line  8171
  return;
}
}
//#line  8175
extern void *memset(void *s , int c , size_t n ) ;
//#line  8177
extern size_t strlcpy(char * , char const   * , size_t  ) ;
//#line  8179
extern irqreturn_t serio_interrupt(struct serio *serio , unsigned char data , unsigned int flags ) ;
//#line  8181
extern void __serio_register_port(struct serio *serio , struct module *owner ) ;
//#line  8183 "psmousebase.merged.kernel.c"
__inline static void ( __attribute__((__always_inline__)) serio_register_port)(struct serio *serio ) 
{ 


  {
  {
//#line  8189
  __serio_register_port(serio, & __this_module);
  }
//#line  8191
  return;
}
}
//#line  8195 "psmousebase.merged.kernel.c"
static int synaptics_mode_cmd(struct psmouse *psmouse , unsigned char mode ) 
{ 
  unsigned char param[1] ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  8203
  tmp = psmouse_sliced_command(psmouse, mode);
  }
//#line  8205
  if (tmp) {
//#line  8207
    return (-1);
  }
  {
//#line  8210
  param[0] = (unsigned char)20;
//#line  8212
  tmp___0 = ps2_command(& psmouse->ps2dev, param, 4339);
  }
//#line  8214
  if (tmp___0) {
//#line  8216
    return (-1);
  }
//#line  8219
  return (0);
}
}
//#line  8223 "psmousebase.merged.kernel.c"
int synaptics_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[4] ;

  {
  {
//#line  8230
  ps2dev = & psmouse->ps2dev;
//#line  8232
  param[0] = (unsigned char)0;
//#line  8234
  ps2_command(ps2dev, param, 4328);
//#line  8236
  ps2_command(ps2dev, param, 4328);
//#line  8238
  ps2_command(ps2dev, param, 4328);
//#line  8240
  ps2_command(ps2dev, param, 4328);
//#line  8242
  ps2_command(ps2dev, param, 1001);
  }
//#line  8244
  if ((int )param[1] != 71) {
//#line  8246
    return (-19);
  }
//#line  8249
  if (set_properties) {
//#line  8251
    psmouse->vendor = (char *)str_658966400;
//#line  8253
    psmouse->name = (char *)str_80031588;
  }
//#line  8256
  return (0);
}
}
//#line  8260 "psmousebase.merged.kernel.c"
void synaptics_reset(struct psmouse *psmouse ) 
{ 


  {
  {
//#line  8266
  synaptics_mode_cmd(psmouse, (unsigned char)0);
  }
//#line  8268
  return;
}
}
//#line  8272 "psmousebase.merged.kernel.c"
static int synaptics_send_cmd(struct psmouse *psmouse , unsigned char c , unsigned char *param ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  8279
  tmp = psmouse_sliced_command(psmouse, c);
  }
//#line  8281
  if (tmp) {
//#line  8283
    return (-1);
  }
  {
//#line  8286
  tmp___0 = ps2_command(& psmouse->ps2dev, param, 1001);
  }
//#line  8288
  if (tmp___0) {
//#line  8290
    return (-1);
  }
//#line  8293
  return (0);
}
}
//#line  8297 "psmousebase.merged.kernel.c"
static int synaptics_model_id(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  unsigned char mi[3] ;
  int tmp ;

  {
  {
//#line  8305
  priv = (struct synaptics_data *)psmouse->private;
//#line  8307
  tmp = synaptics_send_cmd(psmouse, (unsigned char)3, mi);
  }
//#line  8309
  if (tmp) {
//#line  8311
    return (-1);
  }
//#line  8314
  priv->model_id = (unsigned long )((((int )mi[0] << 16) | ((int )mi[1] << 8)) | (int )mi[2]);
//#line  8316
  return (0);
}
}
//#line  8320 "psmousebase.merged.kernel.c"
static int synaptics_capability(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  unsigned char cap[3] ;
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  8329
  priv = (struct synaptics_data *)psmouse->private;
//#line  8331
  tmp = synaptics_send_cmd(psmouse, (unsigned char)2, cap);
  }
//#line  8333
  if (tmp) {
//#line  8335
    return (-1);
  }
//#line  8338
  priv->capabilities = (unsigned long )((((int )cap[0] << 16) | ((int )cap[1] << 8)) | (int )cap[2]);
//#line  8340
  priv->ext_cap = 0UL;
//#line  8342
  if (! ((priv->capabilities & 65280UL) >> 8 == 71UL)) {
//#line  8344
    return (-1);
  }
//#line  8347
  if (! (priv->capabilities & (unsigned long )(1 << 23))) {
//#line  8349
    priv->capabilities = 0UL;
  }
//#line  8352
  if ((priv->capabilities & 7340032UL) >> 20 >= 1UL) {
    {
//#line  8354
    tmp___0 = synaptics_send_cmd(psmouse, (unsigned char)9, cap);
    }
//#line  8356
    if (tmp___0) {
      {
//#line  8358
      printk(str_877329080);
      }
    } else {
//#line  8361
      priv->ext_cap = (unsigned long )((((int )cap[0] << 16) | ((int )cap[1] << 8)) | (int )cap[2]);
//#line  8363
      if ((priv->ext_cap & 61440UL) >> 12 > 8UL) {
//#line  8365
        priv->ext_cap &= 16715775UL;
      }
    }
  }
//#line  8370
  return (0);
}
}
//#line  8374 "psmousebase.merged.kernel.c"
static int synaptics_identify(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  unsigned char id[3] ;
  int tmp ;

  {
  {
//#line  8382
  priv = (struct synaptics_data *)psmouse->private;
//#line  8384
  tmp = synaptics_send_cmd(psmouse, (unsigned char)0, id);
  }
//#line  8386
  if (tmp) {
//#line  8388
    return (-1);
  }
//#line  8391
  priv->identity = (unsigned long )((((int )id[0] << 16) | ((int )id[1] << 8)) | (int )id[2]);
//#line  8393
  if (((priv->identity >> 8) & 255UL) == 71UL) {
//#line  8395
    return (0);
  }
//#line  8398
  return (-1);
}
}
//#line  8402 "psmousebase.merged.kernel.c"
static int synaptics_query_hardware(struct psmouse *psmouse ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  8410
  tmp = synaptics_identify(psmouse);
  }
//#line  8412
  if (tmp) {
//#line  8414
    return (-1);
  }
  {
//#line  8417
  tmp___0 = synaptics_model_id(psmouse);
  }
//#line  8419
  if (tmp___0) {
//#line  8421
    return (-1);
  }
  {
//#line  8424
  tmp___1 = synaptics_capability(psmouse);
  }
//#line  8426
  if (tmp___1) {
//#line  8428
    return (-1);
  }
//#line  8431
  return (0);
}
}
//#line  8435 "psmousebase.merged.kernel.c"
static int synaptics_set_absolute_mode(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  int tmp ;

  {
//#line  8442
  priv = (struct synaptics_data *)psmouse->private;
//#line  8444
  priv->mode = (unsigned char )(1 << 7);
//#line  8446
  if ((priv->identity & 15UL) >= 4UL) {
//#line  8448
    priv->mode = (unsigned char )((int )priv->mode | (1 << 2));
  }
//#line  8451
  if (priv->capabilities & (unsigned long )(1 << 23)) {
//#line  8453
    priv->mode = (unsigned char )((int )priv->mode | 1);
  }
  {
//#line  8456
  tmp = synaptics_mode_cmd(psmouse, priv->mode);
  }
//#line  8458
  if (tmp) {
//#line  8460
    return (-1);
  }
//#line  8463
  return (0);
}
}
//#line  8467 "psmousebase.merged.kernel.c"
static void synaptics_set_rate(struct psmouse *psmouse , unsigned int rate ) 
{ 
  struct synaptics_data *priv ;

  {
//#line  8473
  priv = (struct synaptics_data *)psmouse->private;
//#line  8475
  if (rate >= 80U) {
//#line  8477
    priv->mode = (unsigned char )((int )priv->mode | (1 << 6));
//#line  8479
    psmouse->rate = (unsigned int )80;
  } else {
//#line  8482
    priv->mode = (unsigned char )((int )priv->mode & ~ (1 << 6));
//#line  8484
    psmouse->rate = (unsigned int )40;
  }
  {
//#line  8487
  synaptics_mode_cmd(psmouse, priv->mode);
  }
//#line  8489
  return;
}
}
//#line  8493 "psmousebase.merged.kernel.c"
static int synaptics_pt_write(struct serio *serio , unsigned char c ) 
{ 
  struct psmouse *parent ;
  void *tmp ;
  char rate_param ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  8503
  tmp = serio_get_drvdata((struct serio *)serio->parent);
//#line  8505
  parent = (struct psmouse *)tmp;
//#line  8507
  rate_param = (char)40;
//#line  8509
  tmp___0 = psmouse_sliced_command(parent, c);
  }
//#line  8511
  if (tmp___0) {
//#line  8513
    return (-1);
  }
  {
//#line  8516
  tmp___1 = ps2_command(& parent->ps2dev, (unsigned char *)(& rate_param), 4339);
  }
//#line  8518
  if (tmp___1) {
//#line  8520
    return (-1);
  }
//#line  8523
  return (0);
}
}
//#line  8527 "psmousebase.merged.kernel.c"
__inline static int ( __attribute__((__always_inline__)) synaptics_is_pt_packet)(unsigned char *buf ) 
{ 
  int tmp ;

  {
//#line  8533
  if (((int )*(buf + 0) & 252) == 132) {
//#line  8535
    if (((int )*(buf + 3) & 204) == 196) {
//#line  8537
      tmp = 1;
    } else {
//#line  8540
      tmp = 0;
    }
  } else {
//#line  8544
    tmp = 0;
  }
//#line  8547
  return (tmp);
}
}
//#line  8551 "psmousebase.merged.kernel.c"
static void synaptics_pass_pt_packet(struct serio *ptport , unsigned char *packet ) 
{ 
  struct psmouse *child ;
  void *tmp ;

  {
  {
//#line  8558
  tmp = serio_get_drvdata(ptport);
//#line  8560
  child = (struct psmouse *)tmp;
  }
//#line  8562
  if (child) {
//#line  8564
    if ((unsigned int )child->state == 4U) {
      {
//#line  8566
      serio_interrupt(ptport, *(packet + 1), 0U);
//#line  8568
      serio_interrupt(ptport, *(packet + 4), 0U);
//#line  8570
      serio_interrupt(ptport, *(packet + 5), 0U);
      }
//#line  8572
      if ((int )child->pktsize == 4) {
        {
//#line  8574
        serio_interrupt(ptport, *(packet + 2), 0U);
        }
      }
    } else {
      {
//#line  8578
      serio_interrupt(ptport, *(packet + 1), 0U);
      }
    }
  } else {
    {
//#line  8582
    serio_interrupt(ptport, *(packet + 1), 0U);
    }
  }
//#line  8585
  return;
}
}
//#line  8589 "psmousebase.merged.kernel.c"
static void synaptics_pt_activate(struct psmouse *psmouse ) 
{ 
  struct serio *ptport ;
  struct psmouse *child ;
  void *tmp ;
  struct synaptics_data *priv ;
  int tmp___0 ;

  {
  {
//#line  8599
  ptport = (struct serio *)(psmouse->ps2dev.serio)->child;
//#line  8601
  tmp = serio_get_drvdata(ptport);
//#line  8603
  child = (struct psmouse *)tmp;
//#line  8605
  priv = (struct synaptics_data *)psmouse->private;
  }
//#line  8607
  if (child) {
//#line  8609
    if ((int )child->pktsize == 4) {
//#line  8611
      priv->mode = (unsigned char )((int )priv->mode | (1 << 1));
    } else {
//#line  8614
      priv->mode = (unsigned char )((int )priv->mode & ~ (1 << 1));
    }
    {
//#line  8617
    tmp___0 = synaptics_mode_cmd(psmouse, priv->mode);
    }
//#line  8619
    if (tmp___0) {
      {
//#line  8621
      printk(str_572528806);
      }
    }
  }
//#line  8625
  return;
}
}
//#line  8629 "psmousebase.merged.kernel.c"
static void synaptics_pt_create(struct psmouse *psmouse ) 
{ 
  struct serio *serio ;
  void *tmp ;

  {
  {
//#line  8636
  tmp = kzalloc(sizeof(struct serio ), 208U);
//#line  8638
  serio = (struct serio *)tmp;
  }
//#line  8640
  if (! serio) {
    {
//#line  8642
    printk(str_731419387);
    }
//#line  8644
    return;
  }
  {
//#line  8647
  serio->id.type = (__u8 )5;
//#line  8649
  strlcpy(serio->name, str_25550113, sizeof(serio->name));
//#line  8651
  strlcpy(serio->phys, str_488213612, sizeof(serio->name));
//#line  8653
  serio->write = & synaptics_pt_write;
//#line  8655
  serio->parent = (struct serio *)psmouse->ps2dev.serio;
//#line  8657
  psmouse->pt_activate = & synaptics_pt_activate;
//#line  8659
  printk(str_36735500, serio->name, psmouse->phys);
//#line  8661
  serio_register_port(serio);
  }
//#line  8663
  return;
}
}
//#line  8667 "psmousebase.merged.kernel.c"
static void synaptics_parse_hw_state(unsigned char *buf , struct synaptics_data *priv ,
                                     struct synaptics_hw_state *hw ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
//#line  8681
  memset((void *)hw, 0, sizeof(struct synaptics_hw_state ));
  }
//#line  8683
  if (priv->model_id & (unsigned long )(1 << 7)) {
//#line  8685
    hw->x = ((((int )*(buf + 3) & 16) << 8) | (((int )*(buf + 1) & 15) << 8)) | (int )*(buf + 4);
//#line  8687
    hw->y = ((((int )*(buf + 3) & 32) << 7) | (((int )*(buf + 1) & 240) << 4)) | (int )*(buf + 5);
//#line  8689
    hw->z = (int )*(buf + 2);
//#line  8691
    hw->w = ((((int )*(buf + 0) & 48) >> 2) | (((int )*(buf + 0) & 4) >> 1)) | (((int )*(buf + 3) & 4) >> 2);
//#line  8693
    if ((int )*(buf + 0) & 1) {
//#line  8695
      hw->left = 1U;
    } else {
//#line  8698
      hw->left = 0U;
    }
//#line  8701
    if ((int )*(buf + 0) & 2) {
//#line  8703
      hw->right = 1U;
    } else {
//#line  8706
      hw->right = 0U;
    }
//#line  8709
    if (priv->capabilities & (unsigned long )(1 << 18)) {
//#line  8711
      if (((int )*(buf + 0) ^ (int )*(buf + 3)) & 1) {
//#line  8713
        hw->middle = 1U;
      } else {
//#line  8716
        hw->middle = 0U;
      }
//#line  8719
      if (hw->w == 2) {
//#line  8721
        hw->scroll = (signed char )*(buf + 1);
      }
    }
//#line  8725
    if (priv->capabilities & (unsigned long )(1 << 3)) {
//#line  8727
      if (((int )*(buf + 0) ^ (int )*(buf + 3)) & 1) {
//#line  8729
        hw->up = 1U;
      } else {
//#line  8732
        hw->up = 0U;
      }
//#line  8735
      if (((int )*(buf + 0) ^ (int )*(buf + 3)) & 2) {
//#line  8737
        hw->down = 1U;
      } else {
//#line  8740
        hw->down = 0U;
      }
    }
//#line  8744
    if ((priv->ext_cap & 61440UL) >> 12) {
//#line  8746
      if (((int )*(buf + 0) ^ (int )*(buf + 3)) & 2) {
        {
        if ((int )(((priv->ext_cap & 61440UL) >> 12) & 0xfffffffffffffffeUL) == 8) {
//#line  8752
          goto case_8;
        }
        if ((int )(((priv->ext_cap & 61440UL) >> 12) & 0xfffffffffffffffeUL) == 6) {
//#line  8773
          goto case_6;
        }
        if ((int )(((priv->ext_cap & 61440UL) >> 12) & 0xfffffffffffffffeUL) == 4) {
//#line  8794
          goto case_4;
        }
        if ((int )(((priv->ext_cap & 61440UL) >> 12) & 0xfffffffffffffffeUL) == 2) {
//#line  8815
          goto case_2;
        }
//#line  8749
        goto switch_default;
        switch_default: /* CIL Label */ 
//#line  8751
        goto switch_break;
        case_8: /* CIL Label */ 
//#line  8754
        if ((int )*(buf + 5) & 8) {
//#line  8756
          tmp = 128;
        } else {
//#line  8759
          tmp = 0;
        }
//#line  8762
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp);
//#line  8764
        if ((int )*(buf + 4) & 8) {
//#line  8766
          tmp___0 = 64;
        } else {
//#line  8769
          tmp___0 = 0;
        }
//#line  8772
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___0);
        case_6: /* CIL Label */ 
//#line  8775
        if ((int )*(buf + 5) & 4) {
//#line  8777
          tmp___1 = 32;
        } else {
//#line  8780
          tmp___1 = 0;
        }
//#line  8783
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___1);
//#line  8785
        if ((int )*(buf + 4) & 4) {
//#line  8787
          tmp___2 = 16;
        } else {
//#line  8790
          tmp___2 = 0;
        }
//#line  8793
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___2);
        case_4: /* CIL Label */ 
//#line  8796
        if ((int )*(buf + 5) & 2) {
//#line  8798
          tmp___3 = 8;
        } else {
//#line  8801
          tmp___3 = 0;
        }
//#line  8804
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___3);
//#line  8806
        if ((int )*(buf + 4) & 2) {
//#line  8808
          tmp___4 = 4;
        } else {
//#line  8811
          tmp___4 = 0;
        }
//#line  8814
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___4);
        case_2: /* CIL Label */ 
//#line  8817
        if ((int )*(buf + 5) & 1) {
//#line  8819
          tmp___5 = 2;
        } else {
//#line  8822
          tmp___5 = 0;
        }
//#line  8825
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___5);
//#line  8827
        if ((int )*(buf + 4) & 1) {
//#line  8829
          tmp___6 = 1;
        } else {
//#line  8832
          tmp___6 = 0;
        }
//#line  8835
        hw->ext_buttons = (unsigned char )((int )hw->ext_buttons | tmp___6);
        switch_break: /* CIL Label */ ;
        }
      }
    }
  } else {
//#line  8841
    hw->x = (((int )*(buf + 1) & 31) << 8) | (int )*(buf + 2);
//#line  8843
    hw->y = (((int )*(buf + 4) & 31) << 8) | (int )*(buf + 5);
//#line  8845
    hw->z = (((int )*(buf + 0) & 48) << 2) | ((int )*(buf + 3) & 63);
//#line  8847
    hw->w = (((int )*(buf + 1) & 128) >> 4) | (((int )*(buf + 0) & 4) >> 1);
//#line  8849
    if ((int )*(buf + 0) & 1) {
//#line  8851
      hw->left = 1U;
    } else {
//#line  8854
      hw->left = 0U;
    }
//#line  8857
    if ((int )*(buf + 0) & 2) {
//#line  8859
      hw->right = 1U;
    } else {
//#line  8862
      hw->right = 0U;
    }
  }
//#line  8866
  return;
}
}
//#line  8870 "psmousebase.merged.kernel.c"
static void synaptics_process_packet(struct psmouse *psmouse ) 
{ 
  struct input_dev *dev ;
  struct synaptics_data *priv ;
  struct synaptics_hw_state hw ;
  int num_fingers ;
  int finger_width ;
  int i ;

  {
  {
//#line  8881
  dev = (struct input_dev *)psmouse->dev;
//#line  8883
  priv = (struct synaptics_data *)psmouse->private;
//#line  8885
  synaptics_parse_hw_state(psmouse->packet, priv, & hw);
  }
//#line  8887
  if (hw.scroll) {
//#line  8889
    priv->scroll += (int )hw.scroll;
    {
    {
//#line  8891
    while (1) {


      if (! (priv->scroll >= 4)) {
//#line  8891
        goto while_break;
      }
      {
//#line  8893
      input_report_key(dev, 278U, ! hw.down);
//#line  8895
      input_sync(dev);
//#line  8897
      input_report_key(dev, 278U, (int )hw.down);
//#line  8899
      input_sync(dev);
//#line  8901
      priv->scroll -= 4;
      }
    }

    }
    while_break: /* CIL Label */ ;
    }
    {
    {
//#line  8904
    while (1) {


      if (! (priv->scroll <= -4)) {
//#line  8904
        goto while_break___0;
      }
      {
//#line  8906
      input_report_key(dev, 277U, ! hw.up);
//#line  8908
      input_sync(dev);
//#line  8910
      input_report_key(dev, 277U, (int )hw.up);
//#line  8912
      input_sync(dev);
//#line  8914
      priv->scroll += 4;
      }
    }

    }
    while_break___0: /* CIL Label */ ;
    }
//#line  8917
    return;
  }
//#line  8920
  if (hw.z > 0) {
//#line  8922
    num_fingers = 1;
//#line  8924
    finger_width = 5;
//#line  8926
    if (priv->capabilities & (unsigned long )(1 << 23)) {
      {
      if (hw.w == 0) {
//#line  8929
        goto case_0;
      }
      if (hw.w == 1) {
//#line  8930
        goto case_0;
      }
      if (hw.w == 2) {
//#line  8938
        goto case_2;
      }
      if (hw.w == 4) {
//#line  8941
        goto case_4;
      }
      if (hw.w == 5) {
//#line  8942
        goto case_4;
      }
      if (hw.w == 6) {
//#line  8943
        goto case_4;
      }
      if (hw.w == 7) {
//#line  8944
        goto case_4;
      }
      if (hw.w == 8) {
//#line  8945
        goto case_4;
      }
      if (hw.w == 9) {
//#line  8946
        goto case_4;
      }
      if (hw.w == 10) {
//#line  8947
        goto case_4;
      }
      if (hw.w == 11) {
//#line  8948
        goto case_4;
      }
      if (hw.w == 12) {
//#line  8949
        goto case_4;
      }
      if (hw.w == 13) {
//#line  8950
        goto case_4;
      }
      if (hw.w == 14) {
//#line  8951
        goto case_4;
      }
      if (hw.w == 15) {
//#line  8952
        goto case_4;
      }
//#line  8928
      goto switch_break;
      case_0: /* CIL Label */ 
//#line  8932
      if (priv->capabilities & (unsigned long )(1 << 1)) {
//#line  8934
        num_fingers = hw.w + 2;
      }
//#line  8937
      goto switch_break;
      case_2: /* CIL Label */ ;
//#line  8940
      goto switch_break;
      case_4: /* CIL Label */ 
//#line  8954
      if (priv->capabilities & 1UL) {
//#line  8956
        finger_width = hw.w;
      }
//#line  8959
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
  } else {
//#line  8964
    num_fingers = 0;
//#line  8966
    finger_width = 0;
  }
//#line  8969
  if (hw.z > 30) {
    {
//#line  8971
    input_report_key(dev, 330U, 1);
    }
  }
//#line  8974
  if (hw.z < 25) {
    {
//#line  8976
    input_report_key(dev, 330U, 0);
    }
  }
//#line  8979
  if (hw.z > 0) {
    {
//#line  8981
    input_report_abs(dev, 0U, hw.x);
//#line  8983
    input_report_abs(dev, 1U, 5856 - hw.y);
    }
  }
  {
//#line  8986
  input_report_abs(dev, 24U, hw.z);
//#line  8988
  input_report_abs(dev, 28U, finger_width);
//#line  8990
  input_report_key(dev, 325U, num_fingers == 1);
//#line  8992
  input_report_key(dev, 272U, (int )hw.left);
//#line  8994
  input_report_key(dev, 273U, (int )hw.right);
  }
//#line  8996
  if (priv->capabilities & (unsigned long )(1 << 1)) {
    {
//#line  8998
    input_report_key(dev, 333U, num_fingers == 2);
//#line  9000
    input_report_key(dev, 334U, num_fingers == 3);
    }
  }
//#line  9003
  if (priv->capabilities & (unsigned long )(1 << 18)) {
    {
//#line  9005
    input_report_key(dev, 274U, (int )hw.middle);
    }
  }
//#line  9008
  if (priv->capabilities & (unsigned long )(1 << 3)) {
    {
//#line  9010
    input_report_key(dev, 277U, (int )hw.up);
//#line  9012
    input_report_key(dev, 278U, (int )hw.down);
    }
  }
//#line  9015
  i = 0;
  {
  {
//#line  9017
  while (1) {


    if (! ((unsigned long )i < (priv->ext_cap & 61440UL) >> 12)) {
//#line  9017
      goto while_break___1;
    }
    {
//#line  9019
    input_report_key(dev, (unsigned int )(256 + i), (int )hw.ext_buttons & (1 << i));
//#line  9021
    i ++;
    }
  }

  }
  while_break___1: /* CIL Label */ ;
  }
  {
//#line  9024
  input_sync(dev);
  }
//#line  9026
  return;
}
}
//#line  9030
static int synaptics_validate_byte(unsigned char *packet , int idx , unsigned char pkt_type ) ;
//#line  9032 "psmousebase.merged.kernel.c"
static unsigned char const   newabs_mask[5]  = {      (unsigned char const   )200,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200, 
        (unsigned char const   )0};
//#line  9035 "psmousebase.merged.kernel.c"
static unsigned char const   newabs_rel_mask[5]  = {      (unsigned char const   )192,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0};
//#line  9038 "psmousebase.merged.kernel.c"
static unsigned char const   newabs_rslt[5]  = {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0};
//#line  9041 "psmousebase.merged.kernel.c"
static unsigned char const   oldabs_mask[5]  = {      (unsigned char const   )192,      (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )96};
//#line  9044 "psmousebase.merged.kernel.c"
static unsigned char const   oldabs_rslt[5]  = {      (unsigned char const   )192,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0};
//#line  9047 "psmousebase.merged.kernel.c"
static int synaptics_validate_byte(unsigned char *packet , int idx , unsigned char pkt_type ) 
{ 


  {
//#line  9053
  if (idx < 0) {
//#line  9055
    return (0);
  } else
//#line  9058
  if (idx > 4) {
//#line  9060
    return (0);
  }
  {
  if ((int )pkt_type == 0) {
//#line  9064
    goto case_0;
  }
  if ((int )pkt_type == 2) {
//#line  9065
    goto case_0;
  }
  if ((int )pkt_type == 1) {
//#line  9068
    goto case_1;
  }
  if ((int )pkt_type == 3) {
//#line  9071
    goto case_3;
  }
//#line  9074
  goto switch_default;
  case_0: /* CIL Label */ 
//#line  9067
  return (((int )*(packet + idx) & (int )newabs_rel_mask[idx]) == (int )newabs_rslt[idx]);
  case_1: /* CIL Label */ 
//#line  9070
  return (((int )*(packet + idx) & (int )newabs_mask[idx]) == (int )newabs_rslt[idx]);
  case_3: /* CIL Label */ 
//#line  9073
  return (((int )*(packet + idx) & (int )oldabs_mask[idx]) == (int )oldabs_rslt[idx]);
  switch_default: /* CIL Label */ 
  {
//#line  9076
  printk(str_421260424, (int )pkt_type);
  }
//#line  9078
  return (0);

  }
}
}
//#line  9083 "psmousebase.merged.kernel.c"
static unsigned char synaptics_detect_pkt_type(struct psmouse *psmouse ) 
{ 
  int i ;
  int tmp ;

  {
//#line  9090
  i = 0;
  {
  {
//#line  9092
  while (1) {


    if (! (i < 5)) {
//#line  9092
      goto while_break;
    }
    {
//#line  9094
    tmp = synaptics_validate_byte(psmouse->packet, i, (unsigned char)1);
    }
//#line  9096
    if (! tmp) {
      {
//#line  9098
      printk(str_629972820);
      }
//#line  9100
      return ((unsigned char)2);
    }
//#line  9103
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
//#line  9106
  return ((unsigned char)1);
}
}
//#line  9110 "psmousebase.merged.kernel.c"
static psmouse_ret_t synaptics_process_byte(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  long tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
//#line  9120
  priv = (struct synaptics_data *)psmouse->private;
//#line  9122
  if ((int )psmouse->pktcnt >= 6) {
    {
//#line  9124
    tmp = __builtin_expect((long )(! (! ((int )priv->pkt_type == 0))), 0L);
    }
//#line  9126
    if (tmp) {
      {
//#line  9128
      priv->pkt_type = synaptics_detect_pkt_type(psmouse);
      }
    }
//#line  9131
    if (priv->capabilities & (unsigned long )(1 << 7)) {
      {
//#line  9133
      tmp___0 = synaptics_is_pt_packet(psmouse->packet);
      }
//#line  9135
      if (tmp___0) {
//#line  9137
        if ((psmouse->ps2dev.serio)->child) {
          {
//#line  9139
          synaptics_pass_pt_packet((struct serio *)(psmouse->ps2dev.serio)->child,
                                   psmouse->packet);
          }
        }
      } else {
        {
//#line  9144
        synaptics_process_packet(psmouse);
        }
      }
    } else {
      {
//#line  9148
      synaptics_process_packet(psmouse);
      }
    }
//#line  9151
    return ((psmouse_ret_t )2);
  }
  {
//#line  9154
  tmp___3 = synaptics_validate_byte(psmouse->packet, (int )psmouse->pktcnt - 1, priv->pkt_type);
  }
//#line  9156
  if (tmp___3) {
//#line  9158
    tmp___2 = 1;
  } else {
//#line  9161
    tmp___2 = 0;
  }
//#line  9164
  return ((psmouse_ret_t )tmp___2);
}
}
//#line  9168 "psmousebase.merged.kernel.c"
static void set_input_params(struct input_dev *dev , struct synaptics_data *priv ) 
{ 
  int i ;

  {
  {
//#line  9174
  set_bit(3U, (unsigned long volatile   *)(dev->evbit));
//#line  9176
  input_set_abs_params(dev, 0, 1472, 5472, 0, 0);
//#line  9178
  input_set_abs_params(dev, 1, 1408, 4448, 0, 0);
//#line  9180
  input_set_abs_params(dev, 24, 0, 255, 0, 0);
//#line  9182
  set_bit(28U, (unsigned long volatile   *)(dev->absbit));
//#line  9184
  set_bit(1U, (unsigned long volatile   *)(dev->evbit));
//#line  9186
  set_bit(330U, (unsigned long volatile   *)(dev->keybit));
//#line  9188
  set_bit(325U, (unsigned long volatile   *)(dev->keybit));
//#line  9190
  set_bit(272U, (unsigned long volatile   *)(dev->keybit));
//#line  9192
  set_bit(273U, (unsigned long volatile   *)(dev->keybit));
  }
//#line  9194
  if (priv->capabilities & (unsigned long )(1 << 1)) {
    {
//#line  9196
    set_bit(333U, (unsigned long volatile   *)(dev->keybit));
//#line  9198
    set_bit(334U, (unsigned long volatile   *)(dev->keybit));
    }
  }
//#line  9201
  if (priv->capabilities & (unsigned long )(1 << 18)) {
    {
//#line  9203
    set_bit(274U, (unsigned long volatile   *)(dev->keybit));
    }
  }
//#line  9206
  if (priv->capabilities & (unsigned long )(1 << 3)) {
    {
//#line  9208
    set_bit(277U, (unsigned long volatile   *)(dev->keybit));
//#line  9210
    set_bit(278U, (unsigned long volatile   *)(dev->keybit));
    }
  } else
//#line  9213
  if (priv->capabilities & (unsigned long )(1 << 18)) {
    {
//#line  9215
    set_bit(277U, (unsigned long volatile   *)(dev->keybit));
//#line  9217
    set_bit(278U, (unsigned long volatile   *)(dev->keybit));
    }
  }
//#line  9220
  i = 0;
  {
  {
//#line  9222
  while (1) {


    if (! ((unsigned long )i < (priv->ext_cap & 61440UL) >> 12)) {
//#line  9222
      goto while_break;
    }
    {
//#line  9224
    set_bit((unsigned int )(256 + i), (unsigned long volatile   *)(dev->keybit));
//#line  9226
    i ++;
    }
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  9229
  clear_bit(2, (unsigned long volatile   *)(dev->evbit));
//#line  9231
  clear_bit(0, (unsigned long volatile   *)(dev->relbit));
//#line  9233
  clear_bit(1, (unsigned long volatile   *)(dev->relbit));
  }
//#line  9235
  return;
}
}
//#line  9239 "psmousebase.merged.kernel.c"
static void synaptics_disconnect(struct psmouse *psmouse ) 
{ 


  {
  {
//#line  9245
  synaptics_reset(psmouse);
//#line  9247
  kfree((void const   *)psmouse->private);
//#line  9249
  psmouse->private = (void *)0;
  }
//#line  9251
  return;
}
}
//#line  9255 "psmousebase.merged.kernel.c"
static int synaptics_reconnect(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  struct synaptics_data old_priv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  9265
  priv = (struct synaptics_data *)psmouse->private;
//#line  9267
  old_priv = *priv;
//#line  9269
  psmouse_reset(psmouse);
//#line  9271
  tmp = synaptics_detect(psmouse, 0);
  }
//#line  9273
  if (tmp) {
//#line  9275
    return (-1);
  }
  {
//#line  9278
  tmp___0 = synaptics_query_hardware(psmouse);
  }
//#line  9280
  if (tmp___0) {
    {
//#line  9282
    printk(str_642703443);
    }
//#line  9284
    return (-1);
  }
//#line  9287
  if (old_priv.identity != priv->identity) {
//#line  9289
    return (-1);
  } else
//#line  9292
  if (old_priv.model_id != priv->model_id) {
//#line  9294
    return (-1);
  } else
//#line  9297
  if (old_priv.capabilities != priv->capabilities) {
//#line  9299
    return (-1);
  } else
//#line  9302
  if (old_priv.ext_cap != priv->ext_cap) {
//#line  9304
    return (-1);
  }
  {
//#line  9307
  tmp___1 = synaptics_set_absolute_mode(psmouse);
  }
//#line  9309
  if (tmp___1) {
    {
//#line  9311
    printk(str_35399249);
    }
//#line  9313
    return (-1);
  }
//#line  9316
  return (0);
}
}
//#line  9320 "psmousebase.merged.kernel.c"
int synaptics_init(struct psmouse *psmouse ) 
{ 
  struct synaptics_data *priv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  9329
  tmp = kzalloc(sizeof(struct synaptics_data ), 208U);
//#line  9331
  priv = (struct synaptics_data *)tmp;
//#line  9333
  psmouse->private = (void *)priv;
  }
//#line  9335
  if (! priv) {
//#line  9337
    return (-1);
  }
  {
//#line  9340
  psmouse_reset(psmouse);
//#line  9342
  tmp___0 = synaptics_query_hardware(psmouse);
  }
//#line  9344
  if (tmp___0) {
    {
//#line  9346
    printk(str_642703443);
    }
//#line  9348
    goto init_fail;
  }
  {
//#line  9351
  tmp___1 = synaptics_set_absolute_mode(psmouse);
  }
//#line  9353
  if (tmp___1) {
    {
//#line  9355
    printk(str_35399249);
    }
//#line  9357
    goto init_fail;
  }
//#line  9360
  if (priv->model_id & (unsigned long )(1 << 7)) {
//#line  9362
    priv->pkt_type = (unsigned char)0;
  } else {
//#line  9365
    priv->pkt_type = (unsigned char)3;
  }
  {
//#line  9368
  printk(str_543324020, (priv->identity >> 4) & 15UL, priv->identity & 15UL, (priv->identity >> 16) & 255UL,
         priv->model_id, priv->capabilities, priv->ext_cap);
//#line  9372
  set_input_params((struct input_dev *)psmouse->dev, priv);
//#line  9374
  psmouse->model = (unsigned int )(((priv->model_id & 16711680UL) >> 8) | (priv->model_id & 255UL));
//#line  9376
  psmouse->protocol_handler = & synaptics_process_byte;
//#line  9378
  psmouse->set_rate = & synaptics_set_rate;
//#line  9380
  psmouse->disconnect = & synaptics_disconnect;
//#line  9382
  psmouse->reconnect = & synaptics_reconnect;
//#line  9384
  psmouse->cleanup = & synaptics_reset;
//#line  9386
  psmouse->pktsize = (unsigned char)6;
//#line  9388
  psmouse->resync_time = (unsigned int )0;
  }
//#line  9390
  if (priv->capabilities & (unsigned long )(1 << 7)) {
    {
//#line  9392
    synaptics_pt_create(psmouse);
    }
  }
//#line  9395
  return (0);
  init_fail: 
  {
//#line  9398
  kfree((void const   *)priv);
  }
//#line  9400
  return (-1);
}
}
//#line  9404
#pragma merger(0,"./lifebook.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  9406
extern int strcmp(char const   *cs , char const   *ct ) ;
//#line  9408
extern int dmi_check_system(struct dmi_system_id  const  *list ) ;
//#line  9410 "psmousebase.merged.kernel.c"
static char const   *desired_serio_phys  ;
//#line  9412 "psmousebase.merged.kernel.c"
static int lifebook_set_serio_phys(struct dmi_system_id  const  *d ) 
{ 


  {
//#line  9418
  desired_serio_phys = (char const   *)d->driver_data;
//#line  9420
  return (0);
}
}
//#line  9424 "psmousebase.merged.kernel.c"
static unsigned char lifebook_use_6byte_proto  ;
//#line  9426 "psmousebase.merged.kernel.c"
static int lifebook_set_6byte_proto(struct dmi_system_id  const  *d ) 
{ 


  {
//#line  9432
  lifebook_use_6byte_proto = (unsigned char)1;
//#line  9434
  return (0);
}
}
static struct dmi_system_id  const  lifebook_dmi_table[10]  = 
//#line  9438
  {      {(int (*)(struct dmi_system_id  const  * ))0, str_669717307, {{(unsigned char)5,
                                                                    {(char )'F', (char )'L',
                                                                     (char )'O', (char )'R',
                                                                     (char )'A', (char )'-',
                                                                     (char )'i', (char )'e',
                                                                     (char )' ', (char )'5',
                                                                     (char )'5', (char )'m',
                                                                     (char )'i', (char )'\000'}},
                                                                   {(unsigned char)0,
                                                                    {(char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0}}, {(unsigned char)0,
                                                                                 {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}},
                                                                   {(unsigned char)0,
                                                                    {(char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0}}}, (void *)0}, 
        {(int (*)(struct dmi_system_id  const  * ))0,
      str_332938523, {{(unsigned char)5, {(char )'L', (char )'i', (char )'f', (char )'e',
                                          (char )'B', (char )'o', (char )'o', (char )'k',
                                          (char )' ', (char )'B', (char )' ', (char )'S',
                                          (char )'e', (char )'r', (char )'i', (char )'e',
                                          (char )'s', (char )'\000'}}, {(unsigned char)0,
                                                                        {(char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0,
                                                                         (char)0}},
                      {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0}}, {(unsigned char)0,
                                                                                 {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}}},
      (void *)0}, 
        {(int (*)(struct dmi_system_id  const  * ))0, str_412173691, {{(unsigned char)5,
                                                                    {(char )'L', (char )'I',
                                                                     (char )'F', (char )'E',
                                                                     (char )'B', (char )'O',
                                                                     (char )'O', (char )'K',
                                                                     (char )' ', (char )'B',
                                                                     (char )' ', (char )'S',
                                                                     (char )'e', (char )'r',
                                                                     (char )'i', (char )'e',
                                                                     (char )'s', (char )'\000'}},
                                                                   {(unsigned char)0,
                                                                    {(char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0}}, {(unsigned char)0,
                                                                                 {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}},
                                                                   {(unsigned char)0,
                                                                    {(char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0, (char)0,
                                                                     (char)0}}}, (void *)0}, 
        {(int (*)(struct dmi_system_id  const  * ))0,
      str_405065312, {{(unsigned char)5, {(char )'L', (char )'i', (char )'f', (char )'e',
                                          (char )'B', (char )'o', (char )'o', (char )'k',
                                          (char )' ', (char )'B', (char )'2', (char )'1',
                                          (char )'3', (char )'1', (char )'/', (char )'B',
                                          (char )'2', (char )'1', (char )'3', (char )'3',
                                          (char )'/', (char )'B', (char )'2', (char )'1',
                                          (char )'5', (char )'0', (char )'\000'}},
                      {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0}}, {(unsigned char)0,
                                                                                 {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}},
                      {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0}}}, (void *)0}, 
        {(int (*)(struct dmi_system_id  const  * ))0,
      str_236819496, {{(unsigned char)5, {(char )'Z', (char )'E', (char )'P', (char )'H',
                                          (char )'Y', (char )'R', (char )'\000'}},
                      {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0}}, {(unsigned char)0,
                                                                                 {(char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0,
                                                                                  (char)0}},
                      {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0, (char)0,
                                          (char)0, (char)0, (char)0, (char)0}}}, (void *)0}, 
        {& lifebook_set_serio_phys,
      str_9228869, {{(unsigned char)5, {(char )'C', (char )'F', (char )'-', (char )'1',
                                        (char )'8', (char )'\000'}}, {(unsigned char)0,
                                                                      {(char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0, (char)0,
                                                                       (char)0}},
                    {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0, (char)0,
                                        (char)0, (char)0, (char)0, (char)0}}, {(unsigned char)0,
                                                                               {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0}}},
      (void *)str_603215579}, 
        {& lifebook_set_6byte_proto, str_791712760, {{(unsigned char)4, {(char )'M',
                                                                      (char )'a',
                                                                      (char )'t',
                                                                      (char )'s',
                                                                      (char )'u',
                                                                      (char )'s',
                                                                      (char )'h',
                                                                      (char )'i',
                                                                      (char )'t',
                                                                      (char )'a',
                                                                      (char )'\000'}},
                                                  {(unsigned char)5, {(char )'C',
                                                                      (char )'F',
                                                                      (char )'-',
                                                                      (char )'2',
                                                                      (char )'8',
                                                                      (char )'\000'}},
                                                  {(unsigned char)0, {(char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0}}, {(unsigned char)0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0}}},
      (void *)0}, 
        {& lifebook_set_6byte_proto, str_791712761, {{(unsigned char)4, {(char )'M',
                                                                      (char )'a',
                                                                      (char )'t',
                                                                      (char )'s',
                                                                      (char )'u',
                                                                      (char )'s',
                                                                      (char )'h',
                                                                      (char )'i',
                                                                      (char )'t',
                                                                      (char )'a',
                                                                      (char )'\000'}},
                                                  {(unsigned char)5, {(char )'C',
                                                                      (char )'F',
                                                                      (char )'-',
                                                                      (char )'2',
                                                                      (char )'9',
                                                                      (char )'\000'}},
                                                  {(unsigned char)0, {(char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0, (char)0,
                                                                      (char)0}}, {(unsigned char)0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0}}},
      (void *)0}, 
        {& lifebook_set_serio_phys, str_9228977, {{(unsigned char)5, {(char )'C', (char )'F',
                                                                   (char )'-', (char )'7',
                                                                   (char )'2', (char )'\000'}},
                                               {(unsigned char)0, {(char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0}}, {(unsigned char)0,
                                                                               {(char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0,
                                                                                (char)0}},
                                               {(unsigned char)0, {(char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0, (char)0,
                                                                   (char)0}}}, (void *)str_603215579}, 
        {(int (*)(struct dmi_system_id  const  * ))0,
      str_1010884528, {{(unsigned char)5, {(char )'L', (char )'i', (char )'f', (char )'e',
                                           (char )'B', (char )'o', (char )'o', (char )'k',
                                           (char )' ', (char )'B', (char )'1', (char )'4',
                                           (char )'2', (char )'\000'}}, {(unsigned char)0,
                                                                         {(char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0,
                                                                          (char)0}},
                       {(unsigned char)0, {(char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0, (char)0,
                                           (char)0, (char)0, (char)0, (char)0}}, {(unsigned char)0,
                                                                                  {(char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0,
                                                                                   (char)0}}},
      (void *)0}};
//#line  11083 "psmousebase.merged.kernel.c"
static psmouse_ret_t lifebook_process_byte(struct psmouse *psmouse ) 
{ 
  struct lifebook_data *priv ;
  struct input_dev *dev1 ;
  struct input_dev *dev2 ;
  struct input_dev *tmp ;
  unsigned char *packet ;
  int relative_packet ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
//#line  11100
  priv = (struct lifebook_data *)psmouse->private;
//#line  11102
  dev1 = (struct input_dev *)psmouse->dev;
//#line  11104
  if (priv) {
//#line  11106
    tmp = priv->dev2;
  } else {
//#line  11109
    tmp = (struct input_dev *)((void *)0);
  }
//#line  11112
  dev2 = tmp;
//#line  11114
  packet = psmouse->packet;
//#line  11116
  relative_packet = (int )*(packet + 0) & 8;
//#line  11118
  if (relative_packet) {
//#line  11120
    goto _L;
  } else
//#line  11123
  if (! lifebook_use_6byte_proto) {
    _L: 
//#line  11126
    if ((int )psmouse->pktcnt != 3) {
//#line  11128
      return ((psmouse_ret_t )1);
    }
  } else {
    {
    if ((int )psmouse->pktcnt == 1) {
//#line  11133
      goto case_1;
    }
    if ((int )psmouse->pktcnt == 2) {
//#line  11144
      goto case_2;
    }
    if ((int )psmouse->pktcnt == 3) {
//#line  11147
      goto case_3;
    }
    if ((int )psmouse->pktcnt == 4) {
//#line  11158
      goto case_4;
    }
    if ((int )psmouse->pktcnt == 5) {
//#line  11169
      goto case_5;
    }
    if ((int )psmouse->pktcnt == 6) {
//#line  11180
      goto case_6;
    }
//#line  11132
    goto switch_break;
    case_1: /* CIL Label */ 
//#line  11135
    if (((int )*(packet + 0) & 248) == 0) {
//#line  11137
      tmp___0 = 1;
    } else {
//#line  11140
      tmp___0 = 0;
    }
//#line  11143
    return ((psmouse_ret_t )tmp___0);
    case_2: /* CIL Label */ 
//#line  11146
    return ((psmouse_ret_t )1);
    case_3: /* CIL Label */ 
//#line  11149
    if (((int )*(packet + 2) & 48) << 2 == ((int )*(packet + 2) & 192)) {
//#line  11151
      tmp___1 = 1;
    } else {
//#line  11154
      tmp___1 = 0;
    }
//#line  11157
    return ((psmouse_ret_t )tmp___1);
    case_4: /* CIL Label */ 
//#line  11160
    if (((int )*(packet + 3) & 248) == 192) {
//#line  11162
      tmp___2 = 1;
    } else {
//#line  11165
      tmp___2 = 0;
    }
//#line  11168
    return ((psmouse_ret_t )tmp___2);
    case_5: /* CIL Label */ 
//#line  11171
    if (((int )*(packet + 4) & 192) == ((int )*(packet + 2) & 192)) {
//#line  11173
      tmp___3 = 1;
    } else {
//#line  11176
      tmp___3 = 0;
    }
//#line  11179
    return ((psmouse_ret_t )tmp___3);
    case_6: /* CIL Label */ 
//#line  11182
    if (((int )*(packet + 5) & 48) << 2 != ((int )*(packet + 5) & 192)) {
//#line  11184
      return ((psmouse_ret_t )0);
    }
//#line  11187
    if (((int )*(packet + 5) & 192) != ((int )*(packet + 1) & 192)) {
//#line  11189
      return ((psmouse_ret_t )0);
    }
//#line  11192
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
//#line  11196
  if (relative_packet) {
//#line  11198
    if (! dev2) {
      {
//#line  11200
      printk(str_536282345);
      }
    }
  } else
//#line  11204
  if (lifebook_use_6byte_proto) {
    {
//#line  11206
    input_report_abs(dev1, 0U, (((int )*(packet + 1) & 63) << 6) | ((int )*(packet + 2) & 63));
//#line  11208
    input_report_abs(dev1, 1U, 4096 - ((((int )*(packet + 4) & 63) << 6) | ((int )*(packet + 5) & 63)));
    }
  } else {
    {
//#line  11211
    input_report_abs(dev1, 0U, (int )*(packet + 1) | (((int )*(packet + 0) & 48) << 4));
//#line  11213
    input_report_abs(dev1, 1U, 1024 - ((int )*(packet + 2) | (((int )*(packet + 0) & 192) << 2)));
    }
  }
  {
//#line  11216
  input_report_key(dev1, 330U, (int )*(packet + 0) & 4);
//#line  11218
  input_sync(dev1);
  }
//#line  11220
  if (dev2) {
//#line  11222
    if (relative_packet) {
//#line  11224
      if ((int )*(packet + 0) & 16) {
//#line  11226
        tmp___4 = (int )*(packet + 1) - 256;
      } else {
//#line  11229
        tmp___4 = (int )*(packet + 1);
      }
      {
//#line  11232
      input_report_rel(dev2, 0U, tmp___4);
      }
//#line  11234
      if ((int )*(packet + 0) & 32) {
//#line  11236
        tmp___5 = (int )*(packet + 2) - 256;
      } else {
//#line  11239
        tmp___5 = (int )*(packet + 2);
      }
      {
//#line  11242
      input_report_rel(dev2, 1U, - tmp___5);
      }
    }
    {
//#line  11245
    input_report_key(dev2, 272U, (int )*(packet + 0) & 1);
//#line  11247
    input_report_key(dev2, 273U, (int )*(packet + 0) & 2);
//#line  11249
    input_sync(dev2);
    }
  }
//#line  11252
  return ((psmouse_ret_t )2);
}
}
//#line  11256 "psmousebase.merged.kernel.c"
static int lifebook_absolute_mode(struct psmouse *psmouse ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param ;
  int tmp ;

  {
  {
//#line  11264
  ps2dev = & psmouse->ps2dev;
//#line  11266
  tmp = psmouse_reset(psmouse);
  }
//#line  11268
  if (tmp) {
//#line  11270
    return (-1);
  }
//#line  11273
  if (lifebook_use_6byte_proto) {
//#line  11275
    param = (unsigned char)8;
  } else {
//#line  11278
    param = (unsigned char)7;
  }
  {
//#line  11281
  ps2_command(ps2dev, & param, 4328);
  }
//#line  11283
  return (0);
}
}
//#line  11287 "psmousebase.merged.kernel.c"
static void lifebook_relative_mode(struct psmouse *psmouse ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param ;

  {
  {
//#line  11294
  ps2dev = & psmouse->ps2dev;
//#line  11296
  param = (unsigned char)6;
//#line  11298
  ps2_command(ps2dev, & param, 4328);
  }
//#line  11300
  return;
}
}
//#line  11304
static void lifebook_set_resolution(struct psmouse *psmouse , unsigned int resolution ) ;
//#line  11306 "psmousebase.merged.kernel.c"
static unsigned char const   params___0[5]  = {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )2, 
        (unsigned char const   )3};
//#line  11309 "psmousebase.merged.kernel.c"
static void lifebook_set_resolution(struct psmouse *psmouse , unsigned int resolution ) 
{ 
  unsigned char p ;

  {
//#line  11315
  if (resolution == 0U) {
//#line  11317
    resolution = 400U;
  } else
//#line  11320
  if (resolution > 400U) {
//#line  11322
    resolution = 400U;
  }
  {
//#line  11325
  p = (unsigned char )params___0[resolution / 100U];
//#line  11327
  ps2_command(& psmouse->ps2dev, & p, 4328);
//#line  11329
  psmouse->resolution = (unsigned int )(50 << (int )p);
  }
//#line  11331
  return;
}
}
//#line  11335 "psmousebase.merged.kernel.c"
static void lifebook_disconnect(struct psmouse *psmouse ) 
{ 
  struct lifebook_data *priv ;

  {
  {
//#line  11341
  priv = (struct lifebook_data *)psmouse->private;
//#line  11343
  psmouse_reset(psmouse);
  }
//#line  11345
  if (priv) {
    {
//#line  11347
    input_unregister_device(priv->dev2);
//#line  11349
    kfree((void const   *)priv);
    }
  }
//#line  11352
  psmouse->private = (void *)0;
//#line  11354
  return;
}
}
//#line  11358 "psmousebase.merged.kernel.c"
int lifebook_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  11365
  tmp = dmi_check_system(lifebook_dmi_table);
  }
//#line  11367
  if (! tmp) {
//#line  11369
    return (-1);
  }
//#line  11372
  if (desired_serio_phys) {
    {
//#line  11374
    tmp___0 = strcmp((char const   *)((psmouse->ps2dev.serio)->phys), desired_serio_phys);
    }
//#line  11376
    if (tmp___0) {
//#line  11378
      return (-1);
    }
  }
//#line  11382
  if (set_properties) {
//#line  11384
    psmouse->vendor = (char *)str_376268180;
//#line  11386
    psmouse->name = (char *)str_434643244;
  }
//#line  11389
  return (0);
}
}
//#line  11393 "psmousebase.merged.kernel.c"
static int lifebook_create_relative_device(struct psmouse *psmouse ) 
{ 
  struct input_dev *dev2 ;
  struct lifebook_data *priv ;
  int error ;
  void *tmp ;
  int tmp___0 ;

  {
  {
//#line  11402
  error = -12;
//#line  11404
  tmp = kzalloc(sizeof(struct lifebook_data ), 208U);
//#line  11406
  priv = (struct lifebook_data *)tmp;
//#line  11408
  dev2 = input_allocate_device();
  }
//#line  11410
  if (! priv) {
//#line  11412
    goto err_out;
  } else
//#line  11415
  if (! dev2) {
//#line  11417
    goto err_out;
  }
  {
//#line  11420
  priv->dev2 = dev2;
//#line  11422
  snprintf(priv->phys, sizeof(priv->phys), str_307711520, (psmouse->ps2dev.serio)->phys);
//#line  11424
  dev2->phys = (char const   *)(priv->phys);
//#line  11426
  dev2->name = (char const   *)str_128276866;
//#line  11428
  dev2->id.bustype = (__u16 )17;
//#line  11430
  dev2->id.vendor = (__u16 )2;
//#line  11432
  dev2->id.product = (__u16 )9;
//#line  11434
  dev2->id.version = (__u16 )0;
//#line  11436
  dev2->dev.parent = (struct device *)(& (psmouse->ps2dev.serio)->dev);
//#line  11438
  dev2->evbit[0] = (1UL << 1) | (1UL << 2);
//#line  11440
  dev2->relbit[0] = 1UL | (1UL << 1);
//#line  11442
  dev2->keybit[4] = (1UL << 16) | (1UL << 17);
//#line  11444
  tmp___0 = (int )input_register_device(priv->dev2);
  error = tmp___0;
  }
//#line  11446
  if (error) {
//#line  11448
    goto err_out;
  }
//#line  11451
  psmouse->private = (void *)priv;
//#line  11453
  return (0);
  err_out: 
  {
//#line  11456
  input_free_device(dev2);
//#line  11458
  kfree((void const   *)priv);
  }
//#line  11460
  return (error);
}
}
//#line  11464 "psmousebase.merged.kernel.c"
int lifebook_init(struct psmouse *psmouse ) 
{ 
  struct input_dev *dev1 ;
  int max_coord ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
//#line  11474
  dev1 = (struct input_dev *)psmouse->dev;
//#line  11476
  if (lifebook_use_6byte_proto) {
//#line  11478
    tmp = 4096;
  } else {
//#line  11481
    tmp = 1024;
  }
  {
//#line  11484
  max_coord = tmp;
//#line  11486
  tmp___0 = lifebook_absolute_mode(psmouse);
  }
//#line  11488
  if (tmp___0) {
//#line  11490
    return (-1);
  }
  {
//#line  11493
  dev1->evbit[0] = (1UL << 3) | (1UL << 1);
//#line  11495
  dev1->relbit[0] = 0UL;
//#line  11497
  dev1->keybit[5] = 1UL << 10;
//#line  11499
  input_set_abs_params(dev1, 0, 0, max_coord, 0, 0);
//#line  11501
  input_set_abs_params(dev1, 1, 0, max_coord, 0, 0);
  }
//#line  11503
  if (! desired_serio_phys) {
    {
//#line  11505
    tmp___1 = lifebook_create_relative_device(psmouse);
    }
//#line  11507
    if (tmp___1) {
      {
//#line  11509
      lifebook_relative_mode(psmouse);
      }
//#line  11511
      return (-1);
    }
  }
//#line  11515
  psmouse->protocol_handler = & lifebook_process_byte;
//#line  11517
  psmouse->set_resolution = & lifebook_set_resolution;
//#line  11519
  psmouse->disconnect = & lifebook_disconnect;
//#line  11521
  psmouse->reconnect = & lifebook_absolute_mode;
//#line  11523
  if (lifebook_use_6byte_proto) {
//#line  11525
    psmouse->model = 6U;
  } else {
//#line  11528
    psmouse->model = 3U;
  }
//#line  11531
  psmouse->pktsize = (unsigned char)3;
//#line  11533
  return (0);
}
}
//#line  11537
#pragma merger(0,"./logips2pp.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  11539
extern int __attribute__((__warn_unused_result__))  device_create_file(struct device *device ,
                                                                       struct device_attribute *entry ) ;
//#line  11542
extern void device_remove_file(struct device *dev , struct device_attribute *attr ) ;
//#line  11544 "psmousebase.merged.kernel.c"
static psmouse_ret_t ps2pp_process_byte(struct psmouse *psmouse ) 
{ 
  struct input_dev *dev ;
  unsigned char *packet ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
//#line  11555
  dev = (struct input_dev *)psmouse->dev;
//#line  11557
  packet = psmouse->packet;
//#line  11559
  if ((int )psmouse->pktcnt < 3) {
//#line  11561
    return ((psmouse_ret_t )1);
  }
//#line  11564
  if (((int )*(packet + 0) & 72) == 72) {
//#line  11566
    if (((int )*(packet + 1) & 2) == 2) {
      {
      if ((((int )*(packet + 1) >> 4) | ((int )*(packet + 0) & 48)) == 13) {
//#line  11569
        goto case_13;
      }
      if ((((int )*(packet + 1) >> 4) | ((int )*(packet + 0) & 48)) == 14) {
//#line  11586
        goto case_14;
      }
      if ((((int )*(packet + 1) >> 4) | ((int )*(packet + 0) & 48)) == 15) {
//#line  11599
        goto case_15;
      }
//#line  11568
      goto switch_break;
      case_13: /* CIL Label */ 
//#line  11571
      if ((int )*(packet + 2) & 128) {
//#line  11573
        tmp = 6;
      } else {
//#line  11576
        tmp = 8;
      }
      {
//#line  11579
      input_report_rel(dev, (unsigned int )tmp, ((int )*(packet + 2) & 8) - ((int )*(packet + 2) & 7));
//#line  11581
      input_report_key(dev, 275U, ((int )*(packet + 2) >> 4) & 1);
//#line  11583
      input_report_key(dev, 276U, ((int )*(packet + 2) >> 5) & 1);
      }
//#line  11585
      goto switch_break;
      case_14: /* CIL Label */ 
      {
//#line  11588
      input_report_key(dev, 275U, (int )*(packet + 2) & 1);
//#line  11590
      input_report_key(dev, 276U, ((int )*(packet + 2) >> 1) & 1);
//#line  11592
      input_report_key(dev, 278U, ((int )*(packet + 2) >> 3) & 1);
//#line  11594
      input_report_key(dev, 277U, ((int )*(packet + 2) >> 4) & 1);
//#line  11596
      input_report_key(dev, 279U, ((int )*(packet + 2) >> 2) & 1);
      }
//#line  11598
      goto switch_break;
      case_15: /* CIL Label */ 
//#line  11601
      if ((int )*(packet + 2) & 8) {
//#line  11603
        tmp___0 = 6;
      } else {
//#line  11606
        tmp___0 = 8;
      }
      {
//#line  11609
      input_report_rel(dev, (unsigned int )tmp___0, (((int )*(packet + 2) >> 4) & 8) - (((int )*(packet + 2) >> 4) & 7));
//#line  11611
      *(packet + 0) = (unsigned char )((int )*(packet + 2) | 8);
      }
//#line  11613
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
//#line  11617
      goto _L;
    }
  } else {
    _L: 
//#line  11622
    if (*(packet + 1)) {
//#line  11624
      tmp___1 = (int )*(packet + 1) - (((int )*(packet + 0) << 4) & 256);
    } else {
//#line  11627
      tmp___1 = 0;
    }
    {
//#line  11630
    input_report_rel(dev, 0U, tmp___1);
    }
//#line  11632
    if (*(packet + 2)) {
//#line  11634
      tmp___2 = (((int )*(packet + 0) << 3) & 256) - (int )*(packet + 2);
    } else {
//#line  11637
      tmp___2 = 0;
    }
    {
//#line  11640
    input_report_rel(dev, 1U, tmp___2);
    }
  }
  {
//#line  11643
  input_report_key(dev, 272U, (int )*(packet + 0) & 1);
//#line  11645
  input_report_key(dev, 274U, ((int )*(packet + 0) >> 2) & 1);
//#line  11647
  input_report_key(dev, 273U, ((int )*(packet + 0) >> 1) & 1);
//#line  11649
  input_sync(dev);
  }
//#line  11651
  return ((psmouse_ret_t )2);
}
}
//#line  11655 "psmousebase.merged.kernel.c"
static int ps2pp_cmd(struct psmouse *psmouse , unsigned char *param , unsigned char command ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  11662
  tmp = psmouse_sliced_command(psmouse, command);
  }
//#line  11664
  if (tmp) {
//#line  11666
    return (-1);
  }
  {
//#line  11669
  tmp___0 = ps2_command(& psmouse->ps2dev, param, 1003);
  }
//#line  11671
  if (tmp___0) {
//#line  11673
    return (-1);
  }
//#line  11676
  return (0);
}
}
//#line  11680 "psmousebase.merged.kernel.c"
static void ps2pp_set_smartscroll(struct psmouse *psmouse , unsigned int smartscroll ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[4] ;

  {
//#line  11687
  ps2dev = & psmouse->ps2dev;
//#line  11689
  if (smartscroll > 1U) {
//#line  11691
    smartscroll = 1U;
  }
  {
//#line  11694
  ps2pp_cmd(psmouse, param, (unsigned char)50);
//#line  11696
  param[0] = (unsigned char)0;
//#line  11698
  ps2_command(ps2dev, param, 4328);
//#line  11700
  ps2_command(ps2dev, param, 4328);
//#line  11702
  ps2_command(ps2dev, param, 4328);
//#line  11704
  param[0] = (unsigned char )smartscroll;
//#line  11706
  ps2_command(ps2dev, param, 4328);
  }
//#line  11708
  return;
}
}
//#line  11712 "psmousebase.merged.kernel.c"
static ssize_t ps2pp_attr_show_smartscroll(struct psmouse *psmouse , void *data ,
                                           char *buf ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
//#line  11720
  if (psmouse->smartscroll) {
//#line  11722
    tmp = 1;
  } else {
//#line  11725
    tmp = 0;
  }
  {
//#line  11728
  tmp___0 = sprintf(buf, str_15267, tmp);
  }
//#line  11730
  return ((ssize_t )tmp___0);
}
}
//#line  11734 "psmousebase.merged.kernel.c"
static ssize_t ps2pp_attr_set_smartscroll(struct psmouse *psmouse , void *data , char const   *buf ,
                                          size_t count ) 
{ 
  unsigned long value ;
  int tmp ;

  {
  {
//#line  11742
  tmp = strict_strtoul(buf, 10U, & value);
  }
//#line  11744
  if (tmp) {
//#line  11746
    return ((ssize_t )-22);
  } else
//#line  11749
  if (value > 1UL) {
//#line  11751
    return ((ssize_t )-22);
  }
  {
//#line  11754
  ps2pp_set_smartscroll(psmouse, (unsigned int )value);
//#line  11756
  psmouse->smartscroll = (unsigned int )value;
  }
//#line  11758
  return ((ssize_t )count);
}
}
//#line  11762 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_smartscroll  =    {{{str_1017698982, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)0, & ps2pp_attr_show_smartscroll, & ps2pp_attr_set_smartscroll,
    1};
//#line  11766 "psmousebase.merged.kernel.c"
static void ps2pp_set_resolution(struct psmouse *psmouse , unsigned int resolution ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param ;

  {
//#line  11773
  if (resolution > 400U) {
    {
//#line  11775
    ps2dev = & psmouse->ps2dev;
//#line  11777
    param = (unsigned char)3;
//#line  11779
    ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11781
    ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11783
    ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11785
    ps2_command(ps2dev, & param, 4328);
//#line  11787
    psmouse->resolution = (unsigned int )800;
    }
  } else {
    {
//#line  11790
    odft_sfipsmouse_set_resolution(psmouse, resolution);
    }
  }
//#line  11793
  return;
}
}
//#line  11797 "psmousebase.merged.kernel.c"
static void ps2pp_disconnect(struct psmouse *psmouse ) 
{ 


  {
  {
//#line  11803
  device_remove_file(& (psmouse->ps2dev.serio)->dev, & psmouse_attr_smartscroll.dattr);
  }
//#line  11805
  return;
}
}
//#line  11809
static struct ps2pp_info  const  *get_model_info(unsigned char model ) ;
static struct ps2pp_info  const  ps2pp_list[34]  = 
//#line  11811
  {      {(u8 )1, (u8 )0, (u16 )0}, 
        {(u8 )12, (u8 )0, (u16 )4}, 
        {(u8 )13, (u8 )0, (u16 )0}, 
        {(u8 )15, (u8 )2, (u16 )63}, 
        {(u8 )40, (u8 )0, (u16 )4}, 
        {(u8 )41, (u8 )0, (u16 )4}, 
        {(u8 )42, (u8 )0, (u16 )4}, 
        {(u8 )43, (u8 )0, (u16 )4}, 
        {(u8 )50, (u8 )0, (u16 )0}, 
        {(u8 )51, (u8 )0, (u16 )0}, 
        {(u8 )52, (u8 )1, (u16 )5}, 
        {(u8 )53, (u8 )1, (u16 )1}, 
        {(u8 )56, (u8 )1, (u16 )5}, 
        {(u8 )61, (u8 )2, (u16 )61}, 
        {(u8 )66, (u8 )2, (u16 )63}, 
        {(u8 )72, (u8 )4, (u16 )0}, 
        {(u8 )73, (u8 )0, (u16 )4}, 
        {(u8 )75, (u8 )1, (u16 )1}, 
        {(u8 )76, (u8 )1, (u16 )1}, 
        {(u8 )79, (u8 )4, (u16 )1}, 
        {(u8 )80, (u8 )1, (u16 )5}, 
        {(u8 )81, (u8 )1, (u16 )1}, 
        {(u8 )83, (u8 )1, (u16 )1}, 
        {(u8 )85, (u8 )1, (u16 )1}, 
        {(u8 )86, (u8 )1, (u16 )1}, 
        {(u8 )87, (u8 )1, (u16 )1}, 
        {(u8 )88, (u8 )1, (u16 )1}, 
        {(u8 )96, (u8 )0, (u16 )0}, 
        {(u8 )97, (u8 )3, (u16 )3}, 
        {(u8 )99, (u8 )1, (u16 )1}, 
        {(u8 )100, (u8 )2, (u16 )61}, 
        {(u8 )111, (u8 )2, (u16 )5}, 
        {(u8 )112, (u8 )2, (u16 )61}, 
        {(u8 )114, (u8 )2, (u16 )29}};
//#line  11848 "psmousebase.merged.kernel.c"
static struct ps2pp_info  const  *get_model_info(unsigned char model ) 
{ 
  int i ;

  {
//#line  11854
  i = 0;
  {
  {
//#line  11856
  while (1) {


    if (! ((unsigned long )i < sizeof(ps2pp_list) / sizeof(ps2pp_list[0]) + (sizeof(char [1]) - 1UL))) {
//#line  11856
      goto while_break;
    }
//#line  11858
    if ((int )model == (int )ps2pp_list[i].model) {
//#line  11860
      return (& ps2pp_list[i]);
    }
//#line  11863
    i ++;
  }

  }
  while_break: /* CIL Label */ ;
  }
  {
//#line  11866
  printk(str_403177438, (int )model);
  }
//#line  11868
  return ((struct ps2pp_info  const  *)((void *)0));
}
}
//#line  11872 "psmousebase.merged.kernel.c"
static void ps2pp_set_model_properties(struct psmouse *psmouse , struct ps2pp_info  const  *model_info ,
                                       int using_ps2pp ) 
{ 
  struct input_dev *input_dev ;

  {
//#line  11879
  input_dev = (struct input_dev *)psmouse->dev;
//#line  11881
  if ((int const   )model_info->features & 4) {
    {
//#line  11883
    set_bit(275U, (unsigned long volatile   *)(input_dev->keybit));
    }
  }
//#line  11886
  if ((int const   )model_info->features & 8) {
    {
//#line  11888
    set_bit(276U, (unsigned long volatile   *)(input_dev->keybit));
    }
  }
//#line  11891
  if ((int const   )model_info->features & 16) {
    {
//#line  11893
    set_bit(279U, (unsigned long volatile   *)(input_dev->keybit));
    }
  }
//#line  11896
  if ((int const   )model_info->features & 32) {
    {
//#line  11898
    set_bit(277U, (unsigned long volatile   *)(input_dev->keybit));
//#line  11900
    set_bit(278U, (unsigned long volatile   *)(input_dev->keybit));
    }
  }
//#line  11903
  if ((int const   )model_info->features & 1) {
    {
//#line  11905
    set_bit(8U, (unsigned long volatile   *)(input_dev->relbit));
    }
  }
//#line  11908
  if ((int const   )model_info->features & 2) {
    {
//#line  11910
    set_bit(6U, (unsigned long volatile   *)(input_dev->relbit));
    }
  }
  {
  if ((int )model_info->kind == 1) {
//#line  11914
    goto case_1;
  }
  if ((int )model_info->kind == 2) {
//#line  11919
    goto case_2;
  }
  if ((int )model_info->kind == 3) {
//#line  11924
    goto case_3;
  }
  if ((int )model_info->kind == 4) {
//#line  11929
    goto case_4;
  }
//#line  11934
  goto switch_default;
  case_1: /* CIL Label */ 
//#line  11916
  psmouse->name = (char *)str_221608524;
//#line  11918
  goto switch_break;
  case_2: /* CIL Label */ 
//#line  11921
  psmouse->name = (char *)str_43793156;
//#line  11923
  goto switch_break;
  case_3: /* CIL Label */ 
//#line  11926
  psmouse->name = (char *)str_974116503;
//#line  11928
  goto switch_break;
  case_4: /* CIL Label */ 
//#line  11931
  psmouse->name = (char *)str_171666755;
//#line  11933
  goto switch_break;
  switch_default: /* CIL Label */ 
//#line  11936
  if (using_ps2pp) {
//#line  11938
    psmouse->name = (char *)str_10840589;
  }
//#line  11941
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
//#line  11944
  return;
}
}
//#line  11948 "psmousebase.merged.kernel.c"
int ps2pp_init(struct psmouse *psmouse , int set_properties ) 
{ 
  struct ps2dev *ps2dev ;
  unsigned char param[4] ;
  unsigned char model ;
  unsigned char buttons ;
  struct ps2pp_info  const  *model_info ;
  int use_ps2pp ;
  int error ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
//#line  11962
  ps2dev = & psmouse->ps2dev;
//#line  11964
  use_ps2pp = 0;
//#line  11966
  param[0] = (unsigned char)0;
//#line  11968
  ps2_command(ps2dev, param, 4328);
//#line  11970
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11972
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11974
  ps2_command(ps2dev, (unsigned char *)((void *)0), 230);
//#line  11976
  param[1] = (unsigned char)0;
//#line  11978
  ps2_command(ps2dev, param, 1001);
//#line  11980
  model = (unsigned char )((((int )param[0] >> 4) & 7) | (((int )param[0] << 3) & 120));
//#line  11982
  buttons = param[1];
  }
//#line  11984
  if (! model) {
//#line  11986
    return (-1);
  } else
//#line  11989
  if (! buttons) {
//#line  11991
    return (-1);
  }
  {
//#line  11994
  model_info = get_model_info(model);
  }
//#line  11996
  if ((unsigned long )model_info != (unsigned long )((void *)0)) {
//#line  11998
    if ((int const   )model_info->kind == 3) {
      {
//#line  12000
      param[0] = (unsigned char)17;
//#line  12002
      param[1] = (unsigned char)4;
//#line  12004
      param[2] = (unsigned char)104;
//#line  12006
      ps2_command(ps2dev, param, 12497);
//#line  12008
      param[0] = (unsigned char)17;
//#line  12010
      param[1] = (unsigned char)5;
//#line  12012
      param[2] = (unsigned char)11;
//#line  12014
      ps2_command(ps2dev, param, 12497);
//#line  12016
      param[0] = (unsigned char)17;
//#line  12018
      param[1] = (unsigned char)9;
//#line  12020
      param[2] = (unsigned char)195;
//#line  12022
      ps2_command(ps2dev, param, 12497);
//#line  12024
      param[0] = (unsigned char)0;
//#line  12026
      tmp = ps2_command(ps2dev, param, 5073);
      }
//#line  12028
      if (! tmp) {
//#line  12030
        if ((int )param[0] == 6) {
//#line  12032
          if ((int )param[1] == 0) {
//#line  12034
            if ((int )param[2] == 20) {
//#line  12036
              use_ps2pp = 1;
            }
          }
        }
      }
    } else {
      {
//#line  12043
      param[2] = (unsigned char)0;
//#line  12045
      param[1] = param[2];
//#line  12047
      param[0] = param[1];
//#line  12049
      ps2pp_cmd(psmouse, param, (unsigned char)57);
//#line  12051
      ps2pp_cmd(psmouse, param, (unsigned char)219);
      }
//#line  12053
      if (((int )param[0] & 120) == 72) {
//#line  12055
        if (((int )param[1] & 243) == 194) {
//#line  12057
          if (((int )param[2] & 3) == (((int )param[1] >> 2) & 3)) {
            {
//#line  12059
            ps2pp_set_smartscroll(psmouse, psmouse->smartscroll);
//#line  12061
            use_ps2pp = 1;
            }
          }
        }
      }
    }
  }
//#line  12068
  if (set_properties) {
//#line  12070
    psmouse->vendor = (char *)str_411456915;
//#line  12072
    psmouse->model = (unsigned int )model;
//#line  12074
    if (use_ps2pp) {
//#line  12076
      psmouse->protocol_handler = & ps2pp_process_byte;
//#line  12078
      psmouse->pktsize = (unsigned char)3;
//#line  12080
      if ((int const   )model_info->kind != 3) {
        {
//#line  12082
        psmouse->set_resolution = & ps2pp_set_resolution;
//#line  12084
        psmouse->disconnect = & ps2pp_disconnect;
//#line  12086
        tmp___1 = (int )device_create_file(& (psmouse->ps2dev.serio)->dev, & psmouse_attr_smartscroll.dattr);
        error = tmp___1;
        }
//#line  12088
        if (error) {
          {
//#line  12090
          printk(str_533384369, error);
          }
//#line  12093
          return (-1);
        }
      }
    }
//#line  12098
    if ((int )buttons < 3) {
      {
//#line  12100
      clear_bit(274, (unsigned long volatile   *)((psmouse->dev)->keybit));
      }
    }
//#line  12103
    if (model_info) {
      {
//#line  12105
      ps2pp_set_model_properties(psmouse, model_info, use_ps2pp);
      }
    }
  }
//#line  12109
  if (use_ps2pp) {
//#line  12111
    tmp___0 = 0;
  } else {
//#line  12114
    tmp___0 = -1;
  }
//#line  12117
  return (tmp___0);
}
}
//#line  12121
#pragma merger(0,"./trackpoint.i","-Wall,-Wundef,-Wstrict-prototypes,-Wno-trigraphs,-fno-strict-aliasing,-fno-common,-Werror-implicit-function-declaration,-Os,-m64,-mtune=generic,-mno-red-zone,-mcmodel=kernel,-funit-at-a-time,-maccumulate-outgoing-args,-pipe,-Wno-sign-compare,-fno-asynchronous-unwind-tables,-mno-sse,-mno-mmx,-mno-sse2,-mno-3dnow,-Wframe-larger-than=2048,-fno-stack-protector,-fno-omit-frame-pointer,-fno-optimize-sibling-calls,-g,-Wdeclaration-after-statement,-Wno-pointer-sign,-fwrapv,-fno-dwarf2-cfi-asm,-g,-Wall,-Wno-attributes,-Wno-unknown-pragmas")
//#line  12123 "psmousebase.merged.kernel.c"
static int trackpoint_read(struct ps2dev *ps2dev , unsigned char loc , unsigned char *results ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  12130
  tmp = ps2_command(ps2dev, (unsigned char *)((void *)0), 226);
  }
//#line  12132
  if (tmp) {
//#line  12134
    return (-1);
  } else {
    {
//#line  12137
    tmp___0 = ps2_command(ps2dev, results, (1 << 8) | (int )loc);
    }
//#line  12139
    if (tmp___0) {
//#line  12141
      return (-1);
    }
  }
//#line  12145
  return (0);
}
}
//#line  12149 "psmousebase.merged.kernel.c"
static int trackpoint_write(struct ps2dev *ps2dev , unsigned char loc , unsigned char val ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  12158
  tmp = ps2_command(ps2dev, (unsigned char *)((void *)0), 226);
  }
//#line  12160
  if (tmp) {
//#line  12162
    return (-1);
  } else {
    {
//#line  12165
    tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 129);
    }
//#line  12167
    if (tmp___0) {
//#line  12169
      return (-1);
    } else {
      {
//#line  12172
      tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), (int )loc);
      }
//#line  12174
      if (tmp___1) {
//#line  12176
        return (-1);
      } else {
        {
//#line  12179
        tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), (int )val);
        }
//#line  12181
        if (tmp___2) {
//#line  12183
          return (-1);
        }
      }
    }
  }
//#line  12189
  return (0);
}
}
//#line  12193 "psmousebase.merged.kernel.c"
static int trackpoint_toggle_bit(struct ps2dev *ps2dev , unsigned char loc , unsigned char mask ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
//#line  12202
  if ((int )loc < 32) {
//#line  12204
    return (-1);
  } else
//#line  12207
  if ((int )loc >= 47) {
//#line  12209
    return (-1);
  }
  {
//#line  12212
  tmp = ps2_command(ps2dev, (unsigned char *)((void *)0), 226);
  }
//#line  12214
  if (tmp) {
//#line  12216
    return (-1);
  } else {
    {
//#line  12219
    tmp___0 = ps2_command(ps2dev, (unsigned char *)((void *)0), 71);
    }
//#line  12221
    if (tmp___0) {
//#line  12223
      return (-1);
    } else {
      {
//#line  12226
      tmp___1 = ps2_command(ps2dev, (unsigned char *)((void *)0), (int )loc);
      }
//#line  12228
      if (tmp___1) {
//#line  12230
        return (-1);
      } else {
        {
//#line  12233
        tmp___2 = ps2_command(ps2dev, (unsigned char *)((void *)0), (int )mask);
        }
//#line  12235
        if (tmp___2) {
//#line  12237
          return (-1);
        }
      }
    }
  }
//#line  12243
  return (0);
}
}
//#line  12247 "psmousebase.merged.kernel.c"
static ssize_t trackpoint_show_int_attr(struct psmouse *psmouse , void *data , char *buf ) 
{ 
  struct trackpoint_data *tp ;
  struct trackpoint_attr_data *attr ;
  unsigned char value ;
  int tmp ;

  {
//#line  12256
  tp = (struct trackpoint_data *)psmouse->private;
//#line  12258
  attr = (struct trackpoint_attr_data *)data;
//#line  12260
  value = *((unsigned char *)((char *)tp + attr->field_offset));
//#line  12262
  if (attr->inverted) {
//#line  12264
    value = (unsigned char )(! value);
  }
  {
//#line  12267
  tmp = sprintf(buf, str_15590, (int )value);
  }
//#line  12269
  return ((ssize_t )tmp);
}
}
//#line  12273 "psmousebase.merged.kernel.c"
static ssize_t trackpoint_set_int_attr(struct psmouse *psmouse , void *data , char const   *buf ,
                                       size_t count ) 
{ 
  struct trackpoint_data *tp ;
  struct trackpoint_attr_data *attr ;
  unsigned char *field ;
  unsigned long value ;
  int tmp ;

  {
  {
//#line  12284
  tp = (struct trackpoint_data *)psmouse->private;
//#line  12286
  attr = (struct trackpoint_attr_data *)data;
//#line  12288
  field = (unsigned char *)((char *)tp + attr->field_offset);
//#line  12290
  tmp = strict_strtoul(buf, 10U, & value);
  }
//#line  12292
  if (tmp) {
//#line  12294
    return ((ssize_t )-22);
  } else
//#line  12297
  if (value > 255UL) {
//#line  12299
    return ((ssize_t )-22);
  }
  {
//#line  12302
  *field = (unsigned char )value;
//#line  12304
  trackpoint_write(& psmouse->ps2dev, attr->command, (unsigned char )value);
  }
//#line  12306
  return ((ssize_t )count);
}
}
//#line  12310 "psmousebase.merged.kernel.c"
static ssize_t trackpoint_set_bit_attr(struct psmouse *psmouse , void *data , char const   *buf ,
                                       size_t count ) 
{ 
  struct trackpoint_data *tp ;
  struct trackpoint_attr_data *attr ;
  unsigned char *field ;
  unsigned long value ;
  int tmp ;

  {
  {
//#line  12321
  tp = (struct trackpoint_data *)psmouse->private;
//#line  12323
  attr = (struct trackpoint_attr_data *)data;
//#line  12325
  field = (unsigned char *)((char *)tp + attr->field_offset);
//#line  12327
  tmp = strict_strtoul(buf, 10U, & value);
  }
//#line  12329
  if (tmp) {
//#line  12331
    return ((ssize_t )-22);
  } else
//#line  12334
  if (value > 1UL) {
//#line  12336
    return ((ssize_t )-22);
  }
//#line  12339
  if (attr->inverted) {
//#line  12341
    value = (unsigned long )(! value);
  }
//#line  12344
  if ((unsigned long )*field != value) {
    {
//#line  12346
    *field = (unsigned char )value;
//#line  12348
    trackpoint_toggle_bit(& psmouse->ps2dev, attr->command, attr->mask);
    }
  }
//#line  12351
  return ((ssize_t )count);
}
}
//#line  12355 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_sensitivity  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->sensitivity)), (unsigned char)74,
    (unsigned char)0, (unsigned char)0};
//#line  12358 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_sensitivity  =    {{{str_766615943, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_sensitivity), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12362 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_speed  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->speed)), (unsigned char)96,
    (unsigned char)0, (unsigned char)0};
//#line  12365 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_speed  =    {{{str_15793603, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_speed), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12369 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_inertia  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->inertia)), (unsigned char)77,
    (unsigned char)0, (unsigned char)0};
//#line  12372 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_inertia  =    {{{str_931209414, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_inertia), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12376 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_reach  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->reach)), (unsigned char)87,
    (unsigned char)0, (unsigned char)0};
//#line  12379 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_reach  =    {{{str_15586355, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_reach), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12383 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_draghys  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->draghys)), (unsigned char)88,
    (unsigned char)0, (unsigned char)0};
//#line  12386 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_draghys  =    {{{str_705283662, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_draghys), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12390 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_mindrag  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->mindrag)), (unsigned char)89,
    (unsigned char)0, (unsigned char)0};
//#line  12393 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_mindrag  =    {{{str_34346614, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_mindrag), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12397 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_thresh  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->thresh)), (unsigned char)92,
    (unsigned char)0, (unsigned char)0};
//#line  12400 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_thresh  =    {{{str_301601544, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_thresh), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12404 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_upthresh  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->upthresh)), (unsigned char)90,
    (unsigned char)0, (unsigned char)0};
//#line  12407 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_upthresh  =    {{{str_632067631, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_upthresh), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12411 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_ztime  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->ztime)), (unsigned char)94,
    (unsigned char)0, (unsigned char)0};
//#line  12414 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_ztime  =    {{{str_16734883, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_ztime), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12418 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_jenks  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->jenks)), (unsigned char)93,
    (unsigned char)0, (unsigned char)0};
//#line  12421 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_jenks  =    {{{str_14548643, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_jenks), & trackpoint_show_int_attr,
    & trackpoint_set_int_attr, 1};
//#line  12425 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_press_to_select  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->press_to_select)),
    (unsigned char)44, (unsigned char)1, (unsigned char)0};
//#line  12428 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_press_to_select  =    {{{str_797604288, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_press_to_select), & trackpoint_show_int_attr,
    & trackpoint_set_bit_attr, 1};
//#line  12432 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_skipback  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->skipback)), (unsigned char)45,
    (unsigned char)8, (unsigned char)0};
//#line  12435 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_skipback  =    {{{str_730272386, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_skipback), & trackpoint_show_int_attr,
    & trackpoint_set_bit_attr, 1};
//#line  12439 "psmousebase.merged.kernel.c"
static struct trackpoint_attr_data trackpoint_attr_ext_dev  =    {(size_t )((unsigned int )(& ((struct trackpoint_data *)0)->ext_dev)), (unsigned char)35,
    (unsigned char)2, (unsigned char)1};
//#line  12442 "psmousebase.merged.kernel.c"
static struct psmouse_attribute psmouse_attr_ext_dev  =    {{{str_769605543, (struct module *)0, (mode_t )420}, & psmouse_attr_show_helper,
     & psmouse_attr_set_helper}, (void *)(& trackpoint_attr_ext_dev), & trackpoint_show_int_attr,
    & trackpoint_set_bit_attr, 1};
static struct attribute *trackpoint_attrs[14]  = 
//#line  12446
  {      & psmouse_attr_sensitivity.dattr.attr,      & psmouse_attr_speed.dattr.attr,      & psmouse_attr_inertia.dattr.attr,      & psmouse_attr_reach.dattr.attr, 
        & psmouse_attr_draghys.dattr.attr,      & psmouse_attr_mindrag.dattr.attr,      & psmouse_attr_thresh.dattr.attr,      & psmouse_attr_upthresh.dattr.attr, 
        & psmouse_attr_ztime.dattr.attr,      & psmouse_attr_jenks.dattr.attr,      & psmouse_attr_press_to_select.dattr.attr,      & psmouse_attr_skipback.dattr.attr, 
        & psmouse_attr_ext_dev.dattr.attr,      (struct attribute *)((void *)0)};
//#line  12453 "psmousebase.merged.kernel.c"
static struct attribute_group trackpoint_attr_group  =    {(char const   *)0, (mode_t (*)(struct kobject * , struct attribute * , int  ))0,
    trackpoint_attrs};
//#line  12456 "psmousebase.merged.kernel.c"
static int trackpoint_start_protocol(struct psmouse *psmouse , unsigned char *firmware_id ) 
{ 
  unsigned char param[2] ;
  int tmp ;

  {
  {
//#line  12463
  param[0] = (unsigned char)0;
//#line  12465
  param[1] = (unsigned char)0;
//#line  12467
  tmp = ps2_command(& psmouse->ps2dev, param, (2 << 8) | 225);
  }
//#line  12469
  if (tmp) {
//#line  12471
    return (-1);
  }
//#line  12474
  if ((int )param[0] != 1) {
//#line  12476
    return (-1);
  }
//#line  12479
  if (firmware_id) {
//#line  12481
    *firmware_id = param[1];
  }
//#line  12484
  return (0);
}
}
//#line  12488 "psmousebase.merged.kernel.c"
static int trackpoint_sync(struct psmouse *psmouse ) 
{ 
  struct trackpoint_data *tp ;
  unsigned char toggle ;

  {
  {
//#line  12495
  tp = (struct trackpoint_data *)psmouse->private;
//#line  12497
  trackpoint_read(& psmouse->ps2dev, (unsigned char)45, & toggle);
  }
//#line  12499
  if ((int )toggle & 1) {
    {
//#line  12501
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)45, (unsigned char)1);
    }
  }
  {
//#line  12504
  trackpoint_read(& psmouse->ps2dev, (unsigned char)32, & toggle);
  }
//#line  12506
  if ((int )toggle & 128) {
    {
//#line  12508
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)32, (unsigned char)128);
    }
  }
  {
//#line  12511
  trackpoint_read(& psmouse->ps2dev, (unsigned char)35, & toggle);
  }
//#line  12513
  if ((int )toggle & 1) {
    {
//#line  12515
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)35, (unsigned char)1);
    }
  }
  {
//#line  12518
  trackpoint_write(& psmouse->ps2dev, (unsigned char)74, tp->sensitivity);
//#line  12520
  trackpoint_write(& psmouse->ps2dev, (unsigned char)77, tp->inertia);
//#line  12522
  trackpoint_write(& psmouse->ps2dev, (unsigned char)96, tp->speed);
//#line  12524
  trackpoint_write(& psmouse->ps2dev, (unsigned char)87, tp->reach);
//#line  12526
  trackpoint_write(& psmouse->ps2dev, (unsigned char)88, tp->draghys);
//#line  12528
  trackpoint_write(& psmouse->ps2dev, (unsigned char)89, tp->mindrag);
//#line  12530
  trackpoint_write(& psmouse->ps2dev, (unsigned char)92, tp->thresh);
//#line  12532
  trackpoint_write(& psmouse->ps2dev, (unsigned char)90, tp->upthresh);
//#line  12534
  trackpoint_write(& psmouse->ps2dev, (unsigned char)94, tp->ztime);
//#line  12536
  trackpoint_write(& psmouse->ps2dev, (unsigned char)93, tp->jenks);
//#line  12538
  trackpoint_read(& psmouse->ps2dev, (unsigned char)44, & toggle);
  }
//#line  12540
  if ((((int )toggle & 1) == 1) != (int )tp->press_to_select) {
    {
//#line  12542
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)44, (unsigned char)1);
    }
  }
  {
//#line  12545
  trackpoint_read(& psmouse->ps2dev, (unsigned char)45, & toggle);
  }
//#line  12547
  if ((((int )toggle & 8) == 8) != (int )tp->skipback) {
    {
//#line  12549
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)45, (unsigned char)8);
    }
  }
  {
//#line  12552
  trackpoint_read(& psmouse->ps2dev, (unsigned char)35, & toggle);
  }
//#line  12554
  if ((((int )toggle & 2) == 2) != (int )tp->ext_dev) {
    {
//#line  12556
    trackpoint_toggle_bit(& psmouse->ps2dev, (unsigned char)35, (unsigned char)2);
    }
  }
//#line  12559
  return (0);
}
}
//#line  12563 "psmousebase.merged.kernel.c"
static void trackpoint_defaults(struct trackpoint_data *tp ) 
{ 


  {
//#line  12569
  tp->press_to_select = (unsigned char)0;
//#line  12571
  tp->sensitivity = (unsigned char)128;
//#line  12573
  tp->speed = (unsigned char)97;
//#line  12575
  tp->reach = (unsigned char)10;
//#line  12577
  tp->draghys = (unsigned char)255;
//#line  12579
  tp->mindrag = (unsigned char)20;
//#line  12581
  tp->thresh = (unsigned char)8;
//#line  12583
  tp->upthresh = (unsigned char)255;
//#line  12585
  tp->ztime = (unsigned char)38;
//#line  12587
  tp->jenks = (unsigned char)135;
//#line  12589
  tp->inertia = (unsigned char)6;
//#line  12591
  tp->skipback = (unsigned char)0;
//#line  12593
  tp->ext_dev = (unsigned char)0;
//#line  12595
  return;
}
}
//#line  12599 "psmousebase.merged.kernel.c"
static void trackpoint_disconnect(struct psmouse *psmouse ) 
{ 


  {
  {
//#line  12605
  sysfs_remove_group(& (psmouse->ps2dev.serio)->dev.kobj, (struct attribute_group  const  *)(& trackpoint_attr_group));
//#line  12607
  kfree((void const   *)psmouse->private);
//#line  12609
  psmouse->private = (void *)0;
  }
//#line  12611
  return;
}
}
//#line  12615 "psmousebase.merged.kernel.c"
static int trackpoint_reconnect(struct psmouse *psmouse ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
//#line  12622
  tmp = trackpoint_start_protocol(psmouse, (unsigned char *)((void *)0));
  }
//#line  12624
  if (tmp) {
//#line  12626
    return (-1);
  }
  {
//#line  12629
  tmp___0 = trackpoint_sync(psmouse);
  }
//#line  12631
  if (tmp___0) {
//#line  12633
    return (-1);
  }
//#line  12636
  return (0);
}
}
//#line  12640 "psmousebase.merged.kernel.c"
int trackpoint_detect(struct psmouse *psmouse , int set_properties ) 
{ 
  struct trackpoint_data *priv ;
  struct ps2dev *ps2dev ;
  unsigned char firmware_id ;
  unsigned char button_info ;
  int error ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
//#line  12653
  ps2dev = & psmouse->ps2dev;
//#line  12655
  tmp = trackpoint_start_protocol(psmouse, & firmware_id);
  }
//#line  12657
  if (tmp) {
//#line  12659
    return (-1);
  }
//#line  12662
  if (! set_properties) {
//#line  12664
    return (0);
  }
  {
//#line  12667
  tmp___0 = trackpoint_read(& psmouse->ps2dev, (unsigned char)75, & button_info);
  }
//#line  12669
  if (tmp___0) {
    {
//#line  12671
    printk(str_541045427);
//#line  12673
    button_info = (unsigned char)0;
    }
  }
  {
//#line  12676
  tmp___1 = kzalloc(sizeof(struct trackpoint_data ), 208U);
//#line  12678
  priv = (struct trackpoint_data *)tmp___1;
//#line  12680
  psmouse->private = (void *)priv;
  }
//#line  12682
  if (! priv) {
//#line  12684
    return (-1);
  }
  {
//#line  12687
  psmouse->vendor = (char *)str_27684;
//#line  12689
  psmouse->name = (char *)str_768901977;
//#line  12691
  psmouse->reconnect = & trackpoint_reconnect;
//#line  12693
  psmouse->disconnect = & trackpoint_disconnect;
//#line  12695
  trackpoint_defaults(priv);
//#line  12697
  trackpoint_sync(psmouse);
//#line  12699
  tmp___2 = (int )sysfs_create_group(& (ps2dev->serio)->dev.kobj, (struct attribute_group  const  *)(& trackpoint_attr_group));
  error = tmp___2;
  }
//#line  12701
  if (error) {
    {
//#line  12703
    printk(str_440620529, error);
//#line  12705
    kfree((void const   *)priv);
    }
//#line  12707
    return (-1);
  }
  {
//#line  12710
  printk(str_767616905, (int )firmware_id, ((int )button_info & 240) >> 4, (int )button_info & 15);
  }
//#line  12713
  return (0);
}
}
void __MARSH_WRAP__logSfiFrame(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *func ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  func = 0U;
  fetch_marshbuf_ptr("logSfiFrame", _buf_, & _off_, (void **)(& func), sizeof(char ),
                     sizeof(char ));
  if (func != 0U) {
    fetch_marshbuf("logSfiFrame", _buf_, & _off_, sizeof(char ), (void *)func);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )logSfiFrame(func);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("logSfiFrame", & _buf_, & _off_, & func);
  if (func != 0U) {
    fill_marshbuf("logSfiFrame", & _buf_, & _off_, (void *)func, sizeof(char ));
  }
  fill_marshbuf("logSfiFrame", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_close(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& serio), sizeof(struct serio ),
                     sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(char ), (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(char ), (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("serio_close", _buf_, & _off_, strlen20 * sizeof(char ), (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("serio_close", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("serio_close", _buf_, & _off_, strlen21 * sizeof(char ), (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& serio->write), sizeof(int (struct serio * ,
                                                                                             unsigned char  )),
                       sizeof(int (struct serio * , unsigned char  )));
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& serio->parent),
                       sizeof(struct serio ), sizeof(struct serio ));
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& serio->drv), sizeof(struct serio_driver ),
                       sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("serio_close", _buf_, & _off_, (void **)(& serio->child), sizeof(struct serio ),
                       sizeof(struct serio ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  serio_close(serio);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& serio->id.type), sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("serio_close", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("serio_close", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("serio_close", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("serio_close", & _buf_, & _off_, & serio->child);
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_handle_response(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  int idx_arr15 ;
  unsigned char data ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_handle_response", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_handle_response", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)(& ps2dev->cmdcnt));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fetch_marshbuf("ps2_handle_response", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& ps2dev->cmdbuf[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("ps2_handle_response", _buf_, & _off_, sizeof(unsigned long ),
                   (void *)(& ps2dev->flags));
  }
  fetch_marshbuf("ps2_handle_response", _buf_, & _off_, sizeof(unsigned char ), (void *)(& data));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )ps2_handle_response(ps2dev, data);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_handle_response", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_handle_response", & _buf_, & _off_, (void *)(& ps2dev->cmdcnt),
                  sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fill_marshbuf("ps2_handle_response", & _buf_, & _off_, (void *)(& ps2dev->cmdbuf[idx_arr15]),
                    sizeof(unsigned char ));
      idx_arr15 ++;
    }
    fill_marshbuf("ps2_handle_response", & _buf_, & _off_, (void *)(& ps2dev->flags),
                  sizeof(unsigned long ));
  }
  fill_marshbuf("ps2_handle_response", & _buf_, & _off_, (void *)(& data), sizeof(unsigned char ));
  fill_marshbuf("ps2_handle_response", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_open(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;
  struct serio_driver *drv ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& serio), sizeof(struct serio ),
                     sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(char ), (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(char ), (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("serio_open", _buf_, & _off_, strlen20 * sizeof(char ), (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("serio_open", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("serio_open", _buf_, & _off_, strlen21 * sizeof(char ), (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& serio->write), sizeof(int (struct serio * ,
                                                                                            unsigned char  )),
                       sizeof(int (struct serio * , unsigned char  )));
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& serio->parent), sizeof(struct serio ),
                       sizeof(struct serio ));
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& serio->drv), sizeof(struct serio_driver ),
                       sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& serio->child), sizeof(struct serio ),
                       sizeof(struct serio ));
  }
  drv = 0U;
  fetch_marshbuf_ptr("serio_open", _buf_, & _off_, (void **)(& drv), sizeof(struct serio_driver ),
                     sizeof(struct serio_driver ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )serio_open(serio, drv);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& serio->id.type), sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("serio_open", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("serio_open", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & serio->child);
  }
  fill_marshbuf_ptr("serio_open", & _buf_, & _off_, & drv);
  fill_marshbuf("serio_open", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strcmp(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *cs ;
  char const   *ct ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  cs = 0U;
  fetch_marshbuf_ptr("strcmp", _buf_, & _off_, (void **)(& cs), sizeof(char const   ),
                     sizeof(char const   ));
  if (cs != 0U) {
    fetch_marshbuf("strcmp", _buf_, & _off_, sizeof(char const   ), (void *)cs);
  }
  ct = 0U;
  fetch_marshbuf_ptr("strcmp", _buf_, & _off_, (void **)(& ct), sizeof(char const   ),
                     sizeof(char const   ));
  if (ct != 0U) {
    fetch_marshbuf("strcmp", _buf_, & _off_, sizeof(char const   ), (void *)ct);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )strcmp(cs, ct);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strcmp", & _buf_, & _off_, & cs);
  if (cs != 0U) {
    fill_marshbuf("strcmp", & _buf_, & _off_, (void *)cs, sizeof(char const   ));
  }
  fill_marshbuf_ptr("strcmp", & _buf_, & _off_, & ct);
  if (ct != 0U) {
    fill_marshbuf("strcmp", & _buf_, & _off_, (void *)ct, sizeof(char const   ));
  }
  fill_marshbuf("strcmp", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__printk(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fmt = 0U;
  fetch_marshbuf_ptr("printk", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("printk", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )printk(fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("printk", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("printk", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  fill_marshbuf("printk", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__dmi_check_system(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct dmi_system_id  const  *list ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  list = 0U;
  fetch_marshbuf_ptr("dmi_check_system", _buf_, & _off_, (void **)(& list), sizeof(struct dmi_system_id  const  ),
                     sizeof(struct dmi_system_id  const  ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )dmi_check_system(list);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("dmi_check_system", & _buf_, & _off_, & list);
  fill_marshbuf("dmi_check_system", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP___spin_lock_irq(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  spinlock_t *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("_spin_lock_irq", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ),
                     sizeof(spinlock_t ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _spin_lock_irq(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("_spin_lock_irq", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____create_workqueue_key(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *name ;
  int singlethread ;
  int freezeable ;
  int rt ;
  struct lock_class_key *key ;
  char const   *lock_name ;
  struct workqueue_struct *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  name = 0U;
  fetch_marshbuf_ptr("__create_workqueue_key", _buf_, & _off_, (void **)(& name),
                     sizeof(char const   ), sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("__create_workqueue_key", _buf_, & _off_, sizeof(char const   ),
                   (void *)name);
  }
  fetch_marshbuf("__create_workqueue_key", _buf_, & _off_, sizeof(int ), (void *)(& singlethread));
  fetch_marshbuf("__create_workqueue_key", _buf_, & _off_, sizeof(int ), (void *)(& freezeable));
  fetch_marshbuf("__create_workqueue_key", _buf_, & _off_, sizeof(int ), (void *)(& rt));
  key = 0U;
  fetch_marshbuf_ptr("__create_workqueue_key", _buf_, & _off_, (void **)(& key), sizeof(struct lock_class_key ),
                     sizeof(struct lock_class_key ));
  lock_name = 0U;
  fetch_marshbuf_ptr("__create_workqueue_key", _buf_, & _off_, (void **)(& lock_name),
                     sizeof(char const   ), sizeof(char const   ));
  if (lock_name != 0U) {
    fetch_marshbuf("__create_workqueue_key", _buf_, & _off_, sizeof(char const   ),
                   (void *)lock_name);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct workqueue_struct *)__create_workqueue_key(name, singlethread,
                                                               freezeable, rt, key,
                                                               lock_name);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__create_workqueue_key", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("__create_workqueue_key", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf("__create_workqueue_key", & _buf_, & _off_, (void *)(& singlethread),
                sizeof(int ));
  fill_marshbuf("__create_workqueue_key", & _buf_, & _off_, (void *)(& freezeable),
                sizeof(int ));
  fill_marshbuf("__create_workqueue_key", & _buf_, & _off_, (void *)(& rt), sizeof(int ));
  fill_marshbuf_ptr("__create_workqueue_key", & _buf_, & _off_, & key);
  fill_marshbuf_ptr("__create_workqueue_key", & _buf_, & _off_, & lock_name);
  if (lock_name != 0U) {
    fill_marshbuf("__create_workqueue_key", & _buf_, & _off_, (void *)lock_name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("__create_workqueue_key", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__flush_workqueue(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct workqueue_struct *wq ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  wq = 0U;
  fetch_marshbuf_ptr("flush_workqueue", _buf_, & _off_, (void **)(& wq), sizeof(struct workqueue_struct ),
                     sizeof(struct workqueue_struct ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  flush_workqueue(wq);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("flush_workqueue", & _buf_, & _off_, & wq);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_unregister_driver(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio_driver *drv ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  drv = 0U;
  fetch_marshbuf_ptr("serio_unregister_driver", _buf_, & _off_, (void **)(& drv),
                     sizeof(struct serio_driver ), sizeof(struct serio_driver ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  serio_unregister_driver(drv);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_unregister_driver", & _buf_, & _off_, & drv);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__msleep(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  unsigned int msecs ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("msleep", _buf_, & _off_, sizeof(unsigned int ), (void *)(& msecs));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  msleep(msecs);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("msleep", & _buf_, & _off_, (void *)(& msecs), sizeof(unsigned int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__queue_delayed_work(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct workqueue_struct * __attribute__((__noderef__, __address_space__(2))) wq ;
  struct delayed_work * __attribute__((__noderef__, __address_space__(2))) work ;
  unsigned long delay ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  wq = 0U;
  fetch_marshbuf_ptr("queue_delayed_work", _buf_, & _off_, (void **)(& wq), -1, sizeof(struct workqueue_struct ));
  work = 0U;
  fetch_marshbuf_ptr("queue_delayed_work", _buf_, & _off_, (void **)(& work), -1,
                     sizeof(struct delayed_work ));
  fetch_marshbuf("queue_delayed_work", _buf_, & _off_, sizeof(unsigned long ), (void *)(& delay));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )queue_delayed_work(wq, work, delay);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("queue_delayed_work", & _buf_, & _off_, & wq);
  fill_marshbuf_ptr("queue_delayed_work", & _buf_, & _off_, & work);
  fill_marshbuf("queue_delayed_work", & _buf_, & _off_, (void *)(& delay), sizeof(unsigned long ));
  fill_marshbuf("queue_delayed_work", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_cmd_aborted(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_cmd_aborted", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_cmd_aborted", _buf_, & _off_, sizeof(unsigned long ), (void *)(& ps2dev->flags));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  ps2_cmd_aborted(ps2dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_cmd_aborted", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_cmd_aborted", & _buf_, & _off_, (void *)(& ps2dev->flags),
                  sizeof(unsigned long ));
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__device_create_file(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct device *device ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  int idx_arr38 ;
  struct ps2dev *STRUCTADDRXdevicedriver_dataps2dev ;
  int idx_arr410 ;
  int idx_arr611 ;
  struct delayed_work *STRUCTADDRXdevicedriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;
  struct device_attribute *entry ;
  int __attribute__((__warn_unused_result__))  _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  device = 0U;
  fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& device), sizeof(struct device ),
                     sizeof(struct device ));
  if (device != 0U) {
    tmp_fld6 = & device->kobj;
    tmp_lv5 = device;
    nooks_ot_storeoffset_kern_w(device, tmp_fld6 - tmp_lv5, sizeof(struct kobject ));
    fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& device->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (device->driver_data != 0U) {
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (device->driver_data)->pktsize));
      tmp_fld6 = & (device->driver_data)->resync_time;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->resync_time));
      idx_arr38 = 0;
      while (idx_arr38 < 32) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(char ), (void *)(& (device->driver_data)->phys[idx_arr38]));
        idx_arr38 ++;
      }
      tmp_fld6 = & (device->driver_data)->resolution;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->resolution));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->model));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (device->driver_data)->acks_disable_command));
      tmp_fld6 = & (device->driver_data)->rate;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->rate));
      tmp_fld6 = & (device->driver_data)->resetafter;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->resetafter));
      idx_arr38 = 0;
      while (idx_arr38 < 8) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (device->driver_data)->packet[idx_arr38]));
        idx_arr38 ++;
      }
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(int ), (void *)(& (device->driver_data)->state));
      tmp_fld6 = & (device->driver_data)->ps2dev;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(struct ps2dev ));
      STRUCTADDRXdevicedriver_dataps2dev = & (device->driver_data)->ps2dev;
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevicedriver_dataps2dev->cmdcnt));
      idx_arr410 = 0;
      while (idx_arr410 < 6) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXdevicedriver_dataps2dev->cmdbuf[idx_arr410]));
        idx_arr410 ++;
      }
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXdevicedriver_dataps2dev->flags));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevicedriver_dataps2dev->nak));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& STRUCTADDRXdevicedriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXdevicedriver_dataps2dev->serio != 0U) {
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->name[idx_arr611]));
          idx_arr611 ++;
        }
        tmp_fld6 = & (STRUCTADDRXdevicedriver_dataps2dev->serio)->drv_mutex;
        tmp_lv5 = STRUCTADDRXdevicedriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevicedriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(struct mutex ));
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->id.type));
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->phys[idx_arr611]));
          idx_arr611 ++;
        }
        tmp_fld6 = & (STRUCTADDRXdevicedriver_dataps2dev->serio)->lock;
        tmp_lv5 = STRUCTADDRXdevicedriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevicedriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(spinlock_t ));
        tmp_fld6 = & (STRUCTADDRXdevicedriver_dataps2dev->serio)->dev;
        tmp_lv5 = STRUCTADDRXdevicedriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevicedriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (device->driver_data)->out_of_sync));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (device->driver_data)->pktcnt));
      tmp_fld6 = & (device->driver_data)->type;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned char ));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (device->driver_data)->type));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (device->driver_data)->num_resyncs));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (device->driver_data)->badbyte));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (device->driver_data)->smartscroll));
      fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (device->driver_data)->last));
      tmp_fld6 = & (device->driver_data)->resync_work;
      tmp_lv5 = device->driver_data;
      nooks_ot_storeoffset_kern_w(device->driver_data, tmp_fld6 - tmp_lv5, sizeof(struct delayed_work ));
      STRUCTADDRXdevicedriver_dataresync_work = & (device->driver_data)->resync_work;
      tmp_fld6 = & STRUCTADDRXdevicedriver_dataresync_work->timer;
      tmp_lv5 = STRUCTADDRXdevicedriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevicedriver_dataresync_work, tmp_fld6 - tmp_lv5,
                                  sizeof(struct timer_list ));
      tmp_fld6 = & STRUCTADDRXdevicedriver_dataresync_work->work;
      tmp_lv5 = STRUCTADDRXdevicedriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevicedriver_dataresync_work, tmp_fld6 - tmp_lv5,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork = & STRUCTADDRXdevicedriver_dataresync_work->work;
      tmp_fld6 = & STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork->entry;
      tmp_lv5 = STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork,
                                  tmp_fld6 - tmp_lv5, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld6 = & STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork->lockdep_map;
      tmp_lv5 = STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork,
                                  tmp_fld6 - tmp_lv5, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr38 = 0;
      while (idx_arr38 < 64) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(char ), (void *)(& (device->driver_data)->devname[idx_arr38]));
        idx_arr38 ++;
      }
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((device->driver_data)->vendor != 0U) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (device->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("device_create_file", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(device->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((device->driver_data)->name != 0U) {
        fetch_marshbuf("device_create_file", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (device->driver_data)->name), strlen21,
                                       sizeof(char ), 0);
        fetch_marshbuf("device_create_file", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(device->driver_data)->name);
      }
      fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& (device->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& device->parent),
                       sizeof(struct device ), sizeof(struct device ));
  }
  entry = 0U;
  fetch_marshbuf_ptr("device_create_file", _buf_, & _off_, (void **)(& entry), sizeof(struct device_attribute ),
                     sizeof(struct device_attribute ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int __attribute__((__warn_unused_result__))  )device_create_file(device,
                                                                               entry);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & device);
  if (device != 0U) {
    fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & device->driver_data);
    if (device->driver_data != 0U) {
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr38 = 0;
      while (idx_arr38 < 32) {
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->phys[idx_arr38]),
                      sizeof(char ));
        idx_arr38 ++;
      }
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr38 = 0;
      while (idx_arr38 < 8) {
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->packet[idx_arr38]),
                      sizeof(unsigned char ));
        idx_arr38 ++;
      }
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXdevicedriver_dataps2dev = & (device->driver_data)->ps2dev;
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevicedriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr410 = 0;
      while (idx_arr410 < 6) {
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevicedriver_dataps2dev->cmdbuf[idx_arr410]),
                      sizeof(unsigned char ));
        idx_arr410 ++;
      }
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevicedriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevicedriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & STRUCTADDRXdevicedriver_dataps2dev->serio);
      if (STRUCTADDRXdevicedriver_dataps2dev->serio != 0U) {
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->name[idx_arr611]),
                        sizeof(char ));
          idx_arr611 ++;
        }
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevicedriver_dataps2dev->serio)->phys[idx_arr611]),
                        sizeof(char ));
          idx_arr611 ++;
        }
        fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (STRUCTADDRXdevicedriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (STRUCTADDRXdevicedriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (STRUCTADDRXdevicedriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (STRUCTADDRXdevicedriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXdevicedriver_dataresync_work = & (device->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork = & STRUCTADDRXdevicedriver_dataresync_work->work;
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXdevicedriver_dataresync_workwork->func);
      idx_arr38 = 0;
      while (idx_arr38 < 64) {
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& (device->driver_data)->devname[idx_arr38]),
                      sizeof(char ));
        idx_arr38 ++;
      }
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->reconnect);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->vendor);
      if ((device->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(device->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("device_create_file", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(device->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->poll);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->set_rate);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->disconnect);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->cleanup);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->dev);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->protocol_handler);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->set_resolution);
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->name);
      if ((device->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(device->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("device_create_file", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(device->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & (device->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & device->parent);
  }
  fill_marshbuf_ptr("device_create_file", & _buf_, & _off_, & entry);
  fill_marshbuf("device_create_file", & _buf_, & _off_, (void *)(& _retval_), sizeof(int __attribute__((__warn_unused_result__))  ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__mutex_lock_interruptible_nested(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;
  unsigned int subclass ;
  int __attribute__((__warn_unused_result__))  _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("mutex_lock_interruptible_nested", _buf_, & _off_, (void **)(& lock),
                     sizeof(struct mutex ), sizeof(struct mutex ));
  fetch_marshbuf("mutex_lock_interruptible_nested", _buf_, & _off_, sizeof(unsigned int ),
                 (void *)(& subclass));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int __attribute__((__warn_unused_result__))  )mutex_lock_interruptible_nested(lock,
                                                                                            subclass);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("mutex_lock_interruptible_nested", & _buf_, & _off_, & lock);
  fill_marshbuf("mutex_lock_interruptible_nested", & _buf_, & _off_, (void *)(& subclass),
                sizeof(unsigned int ));
  fill_marshbuf("mutex_lock_interruptible_nested", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int __attribute__((__warn_unused_result__))  ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__memset(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void *s ;
  int c ;
  size_t n ;
  void *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  s = 0U;
  fetch_marshbuf_ptr("memset", _buf_, & _off_, & s, sizeof(void ), sizeof(void ));
  fetch_marshbuf("memset", _buf_, & _off_, sizeof(int ), (void *)(& c));
  fetch_marshbuf("memset", _buf_, & _off_, sizeof(unsigned long ), (void *)(& n));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (void *)memset(s, c, n);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("memset", & _buf_, & _off_, & s);
  fill_marshbuf("memset", & _buf_, & _off_, (void *)(& c), sizeof(int ));
  fill_marshbuf("memset", & _buf_, & _off_, (void *)(& n), sizeof(unsigned long ));
  fill_marshbuf_ptr("memset", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strict_strtoul(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *arg0 ;
  unsigned int arg1 ;
  unsigned long *arg2 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("strict_strtoul", _buf_, & _off_, (void **)(& arg0), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg0 != 0U) {
    fetch_marshbuf("strict_strtoul", _buf_, & _off_, sizeof(char const   ), (void *)arg0);
  }
  fetch_marshbuf("strict_strtoul", _buf_, & _off_, sizeof(unsigned int ), (void *)(& arg1));
  arg2 = 0U;
  fetch_marshbuf_ptr("strict_strtoul", _buf_, & _off_, (void **)(& arg2), sizeof(unsigned long ),
                     sizeof(unsigned long ));
  if (arg2 != 0U) {
    fetch_marshbuf("strict_strtoul", _buf_, & _off_, sizeof(unsigned long ), (void *)arg2);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )strict_strtoul(arg0, arg1, arg2);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strict_strtoul", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    fill_marshbuf("strict_strtoul", & _buf_, & _off_, (void *)arg0, sizeof(char const   ));
  }
  fill_marshbuf("strict_strtoul", & _buf_, & _off_, (void *)(& arg1), sizeof(unsigned int ));
  fill_marshbuf_ptr("strict_strtoul", & _buf_, & _off_, & arg2);
  if (arg2 != 0U) {
    fill_marshbuf("strict_strtoul", & _buf_, & _off_, (void *)arg2, sizeof(unsigned long ));
  }
  fill_marshbuf("strict_strtoul", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__mutex_lock_nested(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;
  unsigned int subclass ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("mutex_lock_nested", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  fetch_marshbuf("mutex_lock_nested", _buf_, & _off_, sizeof(unsigned int ), (void *)(& subclass));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  mutex_lock_nested(lock, subclass);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("mutex_lock_nested", & _buf_, & _off_, & lock);
  fill_marshbuf("mutex_lock_nested", & _buf_, & _off_, (void *)(& subclass), sizeof(unsigned int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_sendbyte(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  unsigned char byte ;
  int timeout ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_sendbyte", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_sendbyte", _buf_, & _off_, sizeof(unsigned long ), (void *)(& ps2dev->flags));
    fetch_marshbuf("ps2_sendbyte", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->nak));
  }
  fetch_marshbuf("ps2_sendbyte", _buf_, & _off_, sizeof(unsigned char ), (void *)(& byte));
  fetch_marshbuf("ps2_sendbyte", _buf_, & _off_, sizeof(int ), (void *)(& timeout));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )ps2_sendbyte(ps2dev, byte, timeout);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_sendbyte", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_sendbyte", & _buf_, & _off_, (void *)(& ps2dev->flags), sizeof(unsigned long ));
    fill_marshbuf("ps2_sendbyte", & _buf_, & _off_, (void *)(& ps2dev->nak), sizeof(unsigned char ));
  }
  fill_marshbuf("ps2_sendbyte", & _buf_, & _off_, (void *)(& byte), sizeof(unsigned char ));
  fill_marshbuf("ps2_sendbyte", & _buf_, & _off_, (void *)(& timeout), sizeof(int ));
  fill_marshbuf("ps2_sendbyte", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP___spin_unlock_irq(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  spinlock_t *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("_spin_unlock_irq", _buf_, & _off_, (void **)(& lock), sizeof(spinlock_t ),
                     sizeof(spinlock_t ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _spin_unlock_irq(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("_spin_unlock_irq", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__snprintf(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *buf ;
  size_t size ;
  char const   *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  buf = 0U;
  fetch_marshbuf_ptr("snprintf", _buf_, & _off_, (void **)(& buf), sizeof(char ),
                     sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("snprintf", _buf_, & _off_, sizeof(char ), (void *)buf);
  }
  fetch_marshbuf("snprintf", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fmt = 0U;
  fetch_marshbuf_ptr("snprintf", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("snprintf", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )snprintf(buf, size, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("snprintf", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    fill_marshbuf("snprintf", & _buf_, & _off_, (void *)buf, sizeof(char ));
  }
  fill_marshbuf("snprintf", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf_ptr("snprintf", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("snprintf", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  fill_marshbuf("snprintf", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__input_allocate_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct input_dev *_retval_ ;
  int idx_arr15 ;
  int idx_arr47 ;
  struct ps2dev *STRUCTADDRX_retval_devdriver_dataps2dev ;
  int idx_arr59 ;
  int idx_arr710 ;
  struct delayed_work *STRUCTADDRX_retval_devdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRX_retval_devdriver_dataresync_workwork ;
  int strlen19 ;
  int strlen20 ;
  int strlen21 ;
  int strlen22 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (struct input_dev *)input_allocate_device();
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & _retval_);
  if (_retval_ != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->evbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->absfuzz[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->absflat[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->absbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->relbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->absmax[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->absmin[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->keybit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->id.product),
                  sizeof(unsigned short ));
    fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->id.vendor),
                  sizeof(unsigned short ));
    fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->id.bustype),
                  sizeof(unsigned short ));
    fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& _retval_->id.version),
                  sizeof(unsigned short ));
    fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & _retval_->dev.driver_data);
    if (_retval_->dev.driver_data != 0U) {
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr47 = 0;
      while (idx_arr47 < 32) {
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->phys[idx_arr47]),
                      sizeof(char ));
        idx_arr47 ++;
      }
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr47 = 0;
      while (idx_arr47 < 8) {
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->packet[idx_arr47]),
                      sizeof(unsigned char ));
        idx_arr47 ++;
      }
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->state),
                    sizeof(int ));
      STRUCTADDRX_retval_devdriver_dataps2dev = & (_retval_->dev.driver_data)->ps2dev;
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& STRUCTADDRX_retval_devdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr59 = 0;
      while (idx_arr59 < 6) {
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& STRUCTADDRX_retval_devdriver_dataps2dev->cmdbuf[idx_arr59]),
                      sizeof(unsigned char ));
        idx_arr59 ++;
      }
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& STRUCTADDRX_retval_devdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& STRUCTADDRX_retval_devdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & STRUCTADDRX_retval_devdriver_dataps2dev->serio);
      if (STRUCTADDRX_retval_devdriver_dataps2dev->serio != 0U) {
        idx_arr710 = 0;
        while (idx_arr710 < 32) {
          fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->name[idx_arr710]),
                        sizeof(char ));
          idx_arr710 ++;
        }
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr710 = 0;
        while (idx_arr710 < 32) {
          fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->phys[idx_arr710]),
                        sizeof(char ));
          idx_arr710 ++;
        }
        fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (STRUCTADDRX_retval_devdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRX_retval_devdriver_dataresync_work = & (_retval_->dev.driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRX_retval_devdriver_dataresync_workwork = & STRUCTADDRX_retval_devdriver_dataresync_work->work;
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRX_retval_devdriver_dataresync_workwork->func);
      idx_arr47 = 0;
      while (idx_arr47 < 64) {
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(& (_retval_->dev.driver_data)->devname[idx_arr47]),
                      sizeof(char ));
        idx_arr47 ++;
      }
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->reconnect);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->pt_deactivate);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->vendor);
      if ((_retval_->dev.driver_data)->vendor != 0U) {
        strlen19 = (int )strlen((void *)(_retval_->dev.driver_data)->vendor);
        strlen19 ++;
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, & strlen19, sizeof(int ));
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(_retval_->dev.driver_data)->vendor,
                      strlen19 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->poll);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->set_rate);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->disconnect);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->cleanup);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->dev);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->protocol_handler);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->set_resolution);
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->name);
      if ((_retval_->dev.driver_data)->name != 0U) {
        strlen20 = (int )strlen((void *)(_retval_->dev.driver_data)->name);
        strlen20 ++;
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)(_retval_->dev.driver_data)->name,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & (_retval_->dev.driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & _retval_->dev.parent);
    fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & _retval_->phys);
    if (_retval_->phys != 0U) {
      strlen21 = (int )strlen((void *)_retval_->phys);
      strlen21 ++;
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, & strlen21, sizeof(int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)_retval_->phys,
                    strlen21 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("input_allocate_device", & _buf_, & _off_, & _retval_->name);
    if (_retval_->name != 0U) {
      strlen22 = (int )strlen((void *)_retval_->name);
      strlen22 ++;
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, & strlen22, sizeof(int ));
      fill_marshbuf("input_allocate_device", & _buf_, & _off_, (void *)_retval_->name,
                    strlen22 * sizeof(char const   ));
    }
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__memcmp(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void const   *cs ;
  void const   *ct ;
  unsigned long count ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  cs = 0U;
  fetch_marshbuf_ptr("memcmp", _buf_, & _off_, (void **)(& cs), sizeof(void const   ),
                     sizeof(void const   ));
  ct = 0U;
  fetch_marshbuf_ptr("memcmp", _buf_, & _off_, (void **)(& ct), sizeof(void const   ),
                     sizeof(void const   ));
  fetch_marshbuf("memcmp", _buf_, & _off_, sizeof(unsigned long ), (void *)(& count));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )memcmp(cs, ct, count);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("memcmp", & _buf_, & _off_, & cs);
  fill_marshbuf_ptr("memcmp", & _buf_, & _off_, & ct);
  fill_marshbuf("memcmp", & _buf_, & _off_, (void *)(& count), sizeof(unsigned long ));
  fill_marshbuf("memcmp", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__warn_slowpath(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *file ;
  int line ;
  char const   *fmt ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  file = 0U;
  fetch_marshbuf_ptr("warn_slowpath", _buf_, & _off_, (void **)(& file), sizeof(char const   ),
                     sizeof(char const   ));
  if (file != 0U) {
    fetch_marshbuf("warn_slowpath", _buf_, & _off_, sizeof(char const   ), (void *)file);
  }
  fetch_marshbuf("warn_slowpath", _buf_, & _off_, sizeof(int ), (void *)(& line));
  fmt = 0U;
  fetch_marshbuf_ptr("warn_slowpath", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("warn_slowpath", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  warn_slowpath(file, line, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("warn_slowpath", & _buf_, & _off_, & file);
  if (file != 0U) {
    fill_marshbuf("warn_slowpath", & _buf_, & _off_, (void *)file, sizeof(char const   ));
  }
  fill_marshbuf("warn_slowpath", & _buf_, & _off_, (void *)(& line), sizeof(int ));
  fill_marshbuf_ptr("warn_slowpath", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("warn_slowpath", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__input_free_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct input_dev *dev ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  int idx_arr49 ;
  struct ps2dev *STRUCTADDRXdevdevdriver_dataps2dev ;
  int idx_arr511 ;
  int idx_arr712 ;
  struct delayed_work *STRUCTADDRXdevdevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork ;
  int strlen21 ;
  int strlen22 ;
  int strlen23 ;
  int strlen24 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& dev), sizeof(struct input_dev ),
                     sizeof(struct input_dev ));
  if (dev != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& dev->evbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), (void *)(& dev->absfuzz[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), (void *)(& dev->absflat[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& dev->absbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& dev->relbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), (void *)(& dev->absmax[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), (void *)(& dev->absmin[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& dev->keybit[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.product));
    fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.vendor));
    fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.bustype));
    fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.version));
    tmp_fld7 = & dev->dev.kobj;
    tmp_lv6 = & dev->dev;
    nooks_ot_storeoffset_kern_w(& dev->dev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& dev->dev.driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (dev->dev.driver_data != 0U) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->dev.driver_data)->pktsize));
      tmp_fld7 = & (dev->dev.driver_data)->resync_time;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resync_time));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(char ), (void *)(& (dev->dev.driver_data)->phys[idx_arr49]));
        idx_arr49 ++;
      }
      tmp_fld7 = & (dev->dev.driver_data)->resolution;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resolution));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->model));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->dev.driver_data)->acks_disable_command));
      tmp_fld7 = & (dev->dev.driver_data)->rate;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->rate));
      tmp_fld7 = & (dev->dev.driver_data)->resetafter;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resetafter));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (dev->dev.driver_data)->packet[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), (void *)(& (dev->dev.driver_data)->state));
      tmp_fld7 = & (dev->dev.driver_data)->ps2dev;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct ps2dev ));
      STRUCTADDRXdevdevdriver_dataps2dev = & (dev->dev.driver_data)->ps2dev;
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdcnt));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdbuf[idx_arr511]));
        idx_arr511 ++;
      }
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->flags));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& STRUCTADDRXdevdevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXdevdevdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->name[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv_mutex;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct mutex ));
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->id.type));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->phys[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->lock;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(spinlock_t ));
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->dev;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->dev.driver_data)->out_of_sync));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->dev.driver_data)->pktcnt));
      tmp_fld7 = & (dev->dev.driver_data)->type;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned char ));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->dev.driver_data)->type));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->dev.driver_data)->num_resyncs));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->dev.driver_data)->badbyte));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->smartscroll));
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->dev.driver_data)->last));
      tmp_fld7 = & (dev->dev.driver_data)->resync_work;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct delayed_work ));
      STRUCTADDRXdevdevdriver_dataresync_work = & (dev->dev.driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXdevdevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXdevdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXdevdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(char ), (void *)(& (dev->dev.driver_data)->devname[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((dev->dev.driver_data)->vendor != 0U) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->dev.driver_data)->vendor),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("input_free_device", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(dev->dev.driver_data)->vendor);
      }
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((dev->dev.driver_data)->name != 0U) {
        fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), & strlen22);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->dev.driver_data)->name), strlen22,
                                       sizeof(char ), 0);
        fetch_marshbuf("input_free_device", _buf_, & _off_, strlen22 * sizeof(char ),
                       (void *)(dev->dev.driver_data)->name);
      }
      fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& dev->dev.parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& dev->phys),
                       sizeof(char const   ), sizeof(char const   ));
    if (dev->phys != 0U) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), & strlen23);
      nooks_ot_alloc_arraymem_kern_w((void *)(& dev->phys), strlen23, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_free_device", _buf_, & _off_, strlen23 * sizeof(char const   ),
                     (void *)dev->phys);
    }
    fetch_marshbuf_ptr("input_free_device", _buf_, & _off_, (void **)(& dev->name),
                       sizeof(char const   ), sizeof(char const   ));
    if (dev->name != 0U) {
      fetch_marshbuf("input_free_device", _buf_, & _off_, sizeof(int ), & strlen24);
      nooks_ot_alloc_arraymem_kern_w((void *)(& dev->name), strlen24, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_free_device", _buf_, & _off_, strlen24 * sizeof(char const   ),
                     (void *)dev->name);
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  input_free_device(dev);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->evbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->absfuzz[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->absflat[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->absbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->relbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->absmax[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->absmin[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->keybit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->id.product),
                  sizeof(unsigned short ));
    fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->id.vendor),
                  sizeof(unsigned short ));
    fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->id.bustype),
                  sizeof(unsigned short ));
    fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& dev->id.version),
                  sizeof(unsigned short ));
    fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & dev->dev.driver_data);
    if (dev->dev.driver_data != 0U) {
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->phys[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->packet[idx_arr49]),
                      sizeof(unsigned char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXdevdevdriver_dataps2dev = & (dev->dev.driver_data)->ps2dev;
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdbuf[idx_arr511]),
                      sizeof(unsigned char ));
        idx_arr511 ++;
      }
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & STRUCTADDRXdevdevdriver_dataps2dev->serio);
      if (STRUCTADDRXdevdevdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->name[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->phys[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXdevdevdriver_dataresync_work = & (dev->dev.driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->func);
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->devname[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->reconnect);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->pt_deactivate);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->vendor);
      if ((dev->dev.driver_data)->vendor != 0U) {
        strlen21 = (int )strlen((void *)(dev->dev.driver_data)->vendor);
        strlen21 ++;
        fill_marshbuf("input_free_device", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(dev->dev.driver_data)->vendor,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->poll);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->set_rate);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->disconnect);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->cleanup);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->dev);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->protocol_handler);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->set_resolution);
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->name);
      if ((dev->dev.driver_data)->name != 0U) {
        strlen22 = (int )strlen((void *)(dev->dev.driver_data)->name);
        strlen22 ++;
        fill_marshbuf("input_free_device", & _buf_, & _off_, & strlen22, sizeof(int ));
        fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)(dev->dev.driver_data)->name,
                      strlen22 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & (dev->dev.driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & dev->dev.parent);
    fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & dev->phys);
    if (dev->phys != 0U) {
      strlen23 = (int )strlen((void *)dev->phys);
      strlen23 ++;
      fill_marshbuf("input_free_device", & _buf_, & _off_, & strlen23, sizeof(int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)dev->phys, strlen23 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("input_free_device", & _buf_, & _off_, & dev->name);
    if (dev->name != 0U) {
      strlen24 = (int )strlen((void *)dev->name);
      strlen24 ++;
      fill_marshbuf("input_free_device", & _buf_, & _off_, & strlen24, sizeof(int ));
      fill_marshbuf("input_free_device", & _buf_, & _off_, (void *)dev->name, strlen24 * sizeof(char const   ));
    }
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__odft_is_self_locked(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *arg0 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("odft_is_self_locked", _buf_, & _off_, (void **)(& arg0), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )odft_is_self_locked(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("odft_is_self_locked", & _buf_, & _off_, & arg0);
  fill_marshbuf("odft_is_self_locked", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_drain(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  int idx_arr15 ;
  int maxbytes ;
  int timeout ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_drain", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_drain", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->cmdcnt));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fetch_marshbuf("ps2_drain", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->cmdbuf[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("ps2_drain", _buf_, & _off_, sizeof(unsigned long ), (void *)(& ps2dev->flags));
  }
  fetch_marshbuf("ps2_drain", _buf_, & _off_, sizeof(int ), (void *)(& maxbytes));
  fetch_marshbuf("ps2_drain", _buf_, & _off_, sizeof(int ), (void *)(& timeout));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  ps2_drain(ps2dev, maxbytes, timeout);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_drain", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_drain", & _buf_, & _off_, (void *)(& ps2dev->cmdcnt), sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fill_marshbuf("ps2_drain", & _buf_, & _off_, (void *)(& ps2dev->cmdbuf[idx_arr15]),
                    sizeof(unsigned char ));
      idx_arr15 ++;
    }
    fill_marshbuf("ps2_drain", & _buf_, & _off_, (void *)(& ps2dev->flags), sizeof(unsigned long ));
  }
  fill_marshbuf("ps2_drain", & _buf_, & _off_, (void *)(& maxbytes), sizeof(int ));
  fill_marshbuf("ps2_drain", & _buf_, & _off_, (void *)(& timeout), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____kmalloc(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  size_t size ;
  gfp_t flags ;
  void *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  fetch_marshbuf("__kmalloc", _buf_, & _off_, sizeof(unsigned long ), (void *)(& size));
  fetch_marshbuf("__kmalloc", _buf_, & _off_, sizeof(unsigned int ), (void *)(& flags));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (void *)__kmalloc(size, flags);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf("__kmalloc", & _buf_, & _off_, (void *)(& size), sizeof(unsigned long ));
  fill_marshbuf("__kmalloc", & _buf_, & _off_, (void *)(& flags), sizeof(unsigned int ));
  fill_marshbuf_ptr("__kmalloc", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_init(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  struct serio *serio ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_init", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf_ptr("ps2_init", _buf_, & _off_, (void **)(& ps2dev->serio), sizeof(struct serio ),
                       sizeof(struct serio ));
  }
  serio = 0U;
  fetch_marshbuf_ptr("ps2_init", _buf_, & _off_, (void **)(& serio), sizeof(struct serio ),
                     sizeof(struct serio ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  ps2_init(ps2dev, serio);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_init", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf_ptr("ps2_init", & _buf_, & _off_, & ps2dev->serio);
  }
  fill_marshbuf_ptr("ps2_init", & _buf_, & _off_, & serio);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__input_unregister_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct input_dev *arg0 ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  int idx_arr49 ;
  struct ps2dev *STRUCTADDRXarg0devdriver_dataps2dev ;
  int idx_arr511 ;
  int idx_arr712 ;
  struct delayed_work *STRUCTADDRXarg0devdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork ;
  int strlen21 ;
  int strlen22 ;
  int strlen23 ;
  int strlen24 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& arg0),
                     sizeof(struct input_dev ), sizeof(struct input_dev ));
  if (arg0 != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->evbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absfuzz[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absflat[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->absbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->relbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absmax[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absmin[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->keybit[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.product));
    fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.vendor));
    fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.bustype));
    fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.version));
    tmp_fld7 = & arg0->dev.kobj;
    tmp_lv6 = & arg0->dev;
    nooks_ot_storeoffset_kern_w(& arg0->dev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& arg0->dev.driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (arg0->dev.driver_data != 0U) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->pktsize));
      tmp_fld7 = & (arg0->dev.driver_data)->resync_time;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resync_time));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(char ), (void *)(& (arg0->dev.driver_data)->phys[idx_arr49]));
        idx_arr49 ++;
      }
      tmp_fld7 = & (arg0->dev.driver_data)->resolution;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resolution));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->model));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->acks_disable_command));
      tmp_fld7 = & (arg0->dev.driver_data)->rate;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->rate));
      tmp_fld7 = & (arg0->dev.driver_data)->resetafter;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resetafter));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (arg0->dev.driver_data)->packet[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), (void *)(& (arg0->dev.driver_data)->state));
      tmp_fld7 = & (arg0->dev.driver_data)->ps2dev;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct ps2dev ));
      STRUCTADDRXarg0devdriver_dataps2dev = & (arg0->dev.driver_data)->ps2dev;
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdcnt));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdbuf[idx_arr511]));
        idx_arr511 ++;
      }
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->flags));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& STRUCTADDRXarg0devdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXarg0devdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(char ),
                         (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->name[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv_mutex;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct mutex ));
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->id.type));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(char ),
                         (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->phys[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->lock;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(spinlock_t ));
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->dev;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->out_of_sync));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->pktcnt));
      tmp_fld7 = & (arg0->dev.driver_data)->type;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned char ));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->type));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->num_resyncs));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->badbyte));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->smartscroll));
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->last));
      tmp_fld7 = & (arg0->dev.driver_data)->resync_work;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct delayed_work ));
      STRUCTADDRXarg0devdriver_dataresync_work = & (arg0->dev.driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXarg0devdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXarg0devdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXarg0devdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(char ), (void *)(& (arg0->dev.driver_data)->devname[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((arg0->dev.driver_data)->vendor != 0U) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (arg0->dev.driver_data)->vendor),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(arg0->dev.driver_data)->vendor);
      }
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((arg0->dev.driver_data)->name != 0U) {
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), & strlen22);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (arg0->dev.driver_data)->name),
                                       strlen22, sizeof(char ), 0);
        fetch_marshbuf("input_unregister_device", _buf_, & _off_, strlen22 * sizeof(char ),
                       (void *)(arg0->dev.driver_data)->name);
      }
      fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& arg0->dev.parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& arg0->phys),
                       sizeof(char const   ), sizeof(char const   ));
    if (arg0->phys != 0U) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), & strlen23);
      nooks_ot_alloc_arraymem_kern_w((void *)(& arg0->phys), strlen23, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, strlen23 * sizeof(char const   ),
                     (void *)arg0->phys);
    }
    fetch_marshbuf_ptr("input_unregister_device", _buf_, & _off_, (void **)(& arg0->name),
                       sizeof(char const   ), sizeof(char const   ));
    if (arg0->name != 0U) {
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, sizeof(int ), & strlen24);
      nooks_ot_alloc_arraymem_kern_w((void *)(& arg0->name), strlen24, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_unregister_device", _buf_, & _off_, strlen24 * sizeof(char const   ),
                     (void *)arg0->name);
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  input_unregister_device(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->evbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->absfuzz[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->absflat[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->absbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->relbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->absmax[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->absmin[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->keybit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->id.product),
                  sizeof(unsigned short ));
    fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->id.vendor),
                  sizeof(unsigned short ));
    fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->id.bustype),
                  sizeof(unsigned short ));
    fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& arg0->id.version),
                  sizeof(unsigned short ));
    fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & arg0->dev.driver_data);
    if (arg0->dev.driver_data != 0U) {
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->phys[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->packet[idx_arr49]),
                      sizeof(unsigned char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXarg0devdriver_dataps2dev = & (arg0->dev.driver_data)->ps2dev;
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdbuf[idx_arr511]),
                      sizeof(unsigned char ));
        idx_arr511 ++;
      }
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & STRUCTADDRXarg0devdriver_dataps2dev->serio);
      if (STRUCTADDRXarg0devdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->name[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->phys[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXarg0devdriver_dataresync_work = & (arg0->dev.driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->func);
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->devname[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->reconnect);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->pt_deactivate);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->vendor);
      if ((arg0->dev.driver_data)->vendor != 0U) {
        strlen21 = (int )strlen((void *)(arg0->dev.driver_data)->vendor);
        strlen21 ++;
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(arg0->dev.driver_data)->vendor,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->poll);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->set_rate);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->disconnect);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->cleanup);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->dev);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->protocol_handler);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->set_resolution);
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->name);
      if ((arg0->dev.driver_data)->name != 0U) {
        strlen22 = (int )strlen((void *)(arg0->dev.driver_data)->name);
        strlen22 ++;
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, & strlen22, sizeof(int ));
        fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)(arg0->dev.driver_data)->name,
                      strlen22 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & (arg0->dev.driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & arg0->dev.parent);
    fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & arg0->phys);
    if (arg0->phys != 0U) {
      strlen23 = (int )strlen((void *)arg0->phys);
      strlen23 ++;
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, & strlen23, sizeof(int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)arg0->phys,
                    strlen23 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("input_unregister_device", & _buf_, & _off_, & arg0->name);
    if (arg0->name != 0U) {
      strlen24 = (int )strlen((void *)arg0->name);
      strlen24 ++;
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, & strlen24, sizeof(int ));
      fill_marshbuf("input_unregister_device", & _buf_, & _off_, (void *)arg0->name,
                    strlen24 * sizeof(char const   ));
    }
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strlcpy(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *arg0 ;
  char const   *arg1 ;
  size_t arg2 ;
  size_t _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("strlcpy", _buf_, & _off_, (void **)(& arg0), sizeof(char ),
                     sizeof(char ));
  if (arg0 != 0U) {
    fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(char ), (void *)arg0);
  }
  arg1 = 0U;
  fetch_marshbuf_ptr("strlcpy", _buf_, & _off_, (void **)(& arg1), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg1 != 0U) {
    fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(char const   ), (void *)arg1);
  }
  fetch_marshbuf("strlcpy", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg2));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (size_t )strlcpy(arg0, arg1, arg2);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strlcpy", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)arg0, sizeof(char ));
  }
  fill_marshbuf_ptr("strlcpy", & _buf_, & _off_, & arg1);
  if (arg1 != 0U) {
    fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)arg1, sizeof(char const   ));
  }
  fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)(& arg2), sizeof(unsigned long ));
  fill_marshbuf("strlcpy", & _buf_, & _off_, (void *)(& _retval_), sizeof(unsigned long ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__mutex_unlock(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct mutex *lock ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("mutex_unlock", _buf_, & _off_, (void **)(& lock), sizeof(struct mutex ),
                     sizeof(struct mutex ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  mutex_unlock(lock);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("mutex_unlock", & _buf_, & _off_, & lock);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__destroy_workqueue(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct workqueue_struct *wq ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  wq = 0U;
  fetch_marshbuf_ptr("destroy_workqueue", _buf_, & _off_, (void **)(& wq), sizeof(struct workqueue_struct ),
                     sizeof(struct workqueue_struct ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  destroy_workqueue(wq);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("destroy_workqueue", & _buf_, & _off_, & wq);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__init_timer(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct timer_list *timer ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  timer = 0U;
  fetch_marshbuf_ptr("init_timer", _buf_, & _off_, (void **)(& timer), sizeof(struct timer_list ),
                     sizeof(struct timer_list ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  init_timer(timer);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("init_timer", & _buf_, & _off_, & timer);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strlen(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *s ;
  unsigned long _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  s = 0U;
  fetch_marshbuf_ptr("strlen", _buf_, & _off_, (void **)(& s), sizeof(char const   ),
                     sizeof(char const   ));
  if (s != 0U) {
    fetch_marshbuf("strlen", _buf_, & _off_, sizeof(char const   ), (void *)s);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (unsigned long )strlen(s);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strlen", & _buf_, & _off_, & s);
  if (s != 0U) {
    fill_marshbuf("strlen", & _buf_, & _off_, (void *)s, sizeof(char const   ));
  }
  fill_marshbuf("strlen", & _buf_, & _off_, (void *)(& _retval_), sizeof(unsigned long ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__logRead(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void *addr ;
  char *what ;
  char *where ;
  char *file ;
  int line ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  addr = 0U;
  fetch_marshbuf_ptr("logRead", _buf_, & _off_, & addr, sizeof(void ), sizeof(void ));
  what = 0U;
  fetch_marshbuf_ptr("logRead", _buf_, & _off_, (void **)(& what), sizeof(char ),
                     sizeof(char ));
  if (what != 0U) {
    fetch_marshbuf("logRead", _buf_, & _off_, sizeof(char ), (void *)what);
  }
  where = 0U;
  fetch_marshbuf_ptr("logRead", _buf_, & _off_, (void **)(& where), sizeof(char ),
                     sizeof(char ));
  if (where != 0U) {
    fetch_marshbuf("logRead", _buf_, & _off_, sizeof(char ), (void *)where);
  }
  file = 0U;
  fetch_marshbuf_ptr("logRead", _buf_, & _off_, (void **)(& file), sizeof(char ),
                     sizeof(char ));
  if (file != 0U) {
    fetch_marshbuf("logRead", _buf_, & _off_, sizeof(char ), (void *)file);
  }
  fetch_marshbuf("logRead", _buf_, & _off_, sizeof(int ), (void *)(& line));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )logRead(addr, what, where, file, line);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("logRead", & _buf_, & _off_, & addr);
  fill_marshbuf_ptr("logRead", & _buf_, & _off_, & what);
  if (what != 0U) {
    fill_marshbuf("logRead", & _buf_, & _off_, (void *)what, sizeof(char ));
  }
  fill_marshbuf_ptr("logRead", & _buf_, & _off_, & where);
  if (where != 0U) {
    fill_marshbuf("logRead", & _buf_, & _off_, (void *)where, sizeof(char ));
  }
  fill_marshbuf_ptr("logRead", & _buf_, & _off_, & file);
  if (file != 0U) {
    fill_marshbuf("logRead", & _buf_, & _off_, (void *)file, sizeof(char ));
  }
  fill_marshbuf("logRead", & _buf_, & _off_, (void *)(& line), sizeof(int ));
  fill_marshbuf("logRead", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____serio_register_port(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;
  struct module *owner ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& serio),
                     sizeof(struct serio ), sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(char ), (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(char ), (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("__serio_register_port", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& serio->write),
                       sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                   unsigned char  )));
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& serio->parent),
                       sizeof(struct serio ), sizeof(struct serio ));
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& serio->drv),
                       sizeof(struct serio_driver ), sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& serio->child),
                       sizeof(struct serio ), sizeof(struct serio ));
  }
  owner = 0U;
  fetch_marshbuf_ptr("__serio_register_port", _buf_, & _off_, (void **)(& owner),
                     sizeof(struct module ), sizeof(struct module ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  __serio_register_port(serio, owner);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& serio->id.type),
                  sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("__serio_register_port", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & serio->child);
  }
  fill_marshbuf_ptr("__serio_register_port", & _buf_, & _off_, & owner);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_reconnect(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& serio), sizeof(struct serio ),
                     sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(char ), (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(char ), (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("serio_reconnect", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& serio->write),
                       sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                   unsigned char  )));
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& serio->parent),
                       sizeof(struct serio ), sizeof(struct serio ));
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& serio->drv),
                       sizeof(struct serio_driver ), sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("serio_reconnect", _buf_, & _off_, (void **)(& serio->child),
                       sizeof(struct serio ), sizeof(struct serio ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  serio_reconnect(serio);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& serio->id.type),
                  sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("serio_reconnect", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("serio_reconnect", & _buf_, & _off_, & serio->child);
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__input_event(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct input_dev *dev ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  int idx_arr49 ;
  struct ps2dev *STRUCTADDRXdevdevdriver_dataps2dev ;
  int idx_arr511 ;
  int idx_arr712 ;
  struct delayed_work *STRUCTADDRXdevdevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork ;
  int strlen21 ;
  int strlen22 ;
  int strlen23 ;
  int strlen24 ;
  unsigned int type ;
  unsigned int code ;
  int value ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& dev), sizeof(struct input_dev ),
                     sizeof(struct input_dev ));
  if (dev != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& dev->evbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& dev->absfuzz[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& dev->absflat[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& dev->absbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& dev->relbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& dev->absmax[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& dev->absmin[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& dev->keybit[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.product));
    fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.vendor));
    fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.bustype));
    fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned short ), (void *)(& dev->id.version));
    tmp_fld7 = & dev->dev.kobj;
    tmp_lv6 = & dev->dev;
    nooks_ot_storeoffset_kern_w(& dev->dev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& dev->dev.driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (dev->dev.driver_data != 0U) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->pktsize));
      tmp_fld7 = & (dev->dev.driver_data)->resync_time;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resync_time));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(char ), (void *)(& (dev->dev.driver_data)->phys[idx_arr49]));
        idx_arr49 ++;
      }
      tmp_fld7 = & (dev->dev.driver_data)->resolution;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resolution));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->model));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->acks_disable_command));
      tmp_fld7 = & (dev->dev.driver_data)->rate;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->rate));
      tmp_fld7 = & (dev->dev.driver_data)->resetafter;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->resetafter));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->packet[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& (dev->dev.driver_data)->state));
      tmp_fld7 = & (dev->dev.driver_data)->ps2dev;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct ps2dev ));
      STRUCTADDRXdevdevdriver_dataps2dev = & (dev->dev.driver_data)->ps2dev;
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdcnt));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdbuf[idx_arr511]));
        idx_arr511 ++;
      }
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->flags));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& STRUCTADDRXdevdevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXdevdevdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_event", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->name[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv_mutex;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct mutex ));
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->id.type));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_event", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->phys[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->lock;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(spinlock_t ));
        tmp_fld7 = & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->dev;
        tmp_lv6 = STRUCTADDRXdevdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (dev->dev.driver_data)->out_of_sync));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->pktcnt));
      tmp_fld7 = & (dev->dev.driver_data)->type;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned char ));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->type));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (dev->dev.driver_data)->num_resyncs));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (dev->dev.driver_data)->badbyte));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (dev->dev.driver_data)->smartscroll));
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (dev->dev.driver_data)->last));
      tmp_fld7 = & (dev->dev.driver_data)->resync_work;
      tmp_lv6 = dev->dev.driver_data;
      nooks_ot_storeoffset_kern_w(dev->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct delayed_work ));
      STRUCTADDRXdevdevdriver_dataresync_work = & (dev->dev.driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXdevdevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXdevdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXdevdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdevdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(char ), (void *)(& (dev->dev.driver_data)->devname[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((dev->dev.driver_data)->vendor != 0U) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->dev.driver_data)->vendor),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("input_event", _buf_, & _off_, strlen21 * sizeof(char ), (void *)(dev->dev.driver_data)->vendor);
      }
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((dev->dev.driver_data)->name != 0U) {
        fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), & strlen22);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->dev.driver_data)->name), strlen22,
                                       sizeof(char ), 0);
        fetch_marshbuf("input_event", _buf_, & _off_, strlen22 * sizeof(char ), (void *)(dev->dev.driver_data)->name);
      }
      fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& (dev->dev.driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& dev->dev.parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& dev->phys), sizeof(char const   ),
                       sizeof(char const   ));
    if (dev->phys != 0U) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), & strlen23);
      nooks_ot_alloc_arraymem_kern_w((void *)(& dev->phys), strlen23, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_event", _buf_, & _off_, strlen23 * sizeof(char const   ),
                     (void *)dev->phys);
    }
    fetch_marshbuf_ptr("input_event", _buf_, & _off_, (void **)(& dev->name), sizeof(char const   ),
                       sizeof(char const   ));
    if (dev->name != 0U) {
      fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), & strlen24);
      nooks_ot_alloc_arraymem_kern_w((void *)(& dev->name), strlen24, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_event", _buf_, & _off_, strlen24 * sizeof(char const   ),
                     (void *)dev->name);
    }
  }
  fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& type));
  fetch_marshbuf("input_event", _buf_, & _off_, sizeof(unsigned int ), (void *)(& code));
  fetch_marshbuf("input_event", _buf_, & _off_, sizeof(int ), (void *)(& value));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  input_event(dev, type, code, value);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("input_event", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->evbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->absfuzz[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->absflat[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->absbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->relbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->absmax[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->absmin[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->keybit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->id.product), sizeof(unsigned short ));
    fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->id.vendor), sizeof(unsigned short ));
    fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->id.bustype), sizeof(unsigned short ));
    fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& dev->id.version), sizeof(unsigned short ));
    fill_marshbuf_ptr("input_event", & _buf_, & _off_, & dev->dev.driver_data);
    if (dev->dev.driver_data != 0U) {
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->phys[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->packet[idx_arr49]),
                      sizeof(unsigned char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXdevdevdriver_dataps2dev = & (dev->dev.driver_data)->ps2dev;
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->cmdbuf[idx_arr511]),
                      sizeof(unsigned char ));
        idx_arr511 ++;
      }
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & STRUCTADDRXdevdevdriver_dataps2dev->serio);
      if (STRUCTADDRXdevdevdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->name[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdevdriver_dataps2dev->serio)->phys[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (STRUCTADDRXdevdevdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXdevdevdriver_dataresync_work = & (dev->dev.driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork = & STRUCTADDRXdevdevdriver_dataresync_work->work;
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXdevdevdriver_dataresync_workwork->func);
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& (dev->dev.driver_data)->devname[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->reconnect);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->pt_deactivate);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->vendor);
      if ((dev->dev.driver_data)->vendor != 0U) {
        strlen21 = (int )strlen((void *)(dev->dev.driver_data)->vendor);
        strlen21 ++;
        fill_marshbuf("input_event", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(dev->dev.driver_data)->vendor,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->poll);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->set_rate);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->disconnect);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->cleanup);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->dev);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->protocol_handler);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->set_resolution);
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->name);
      if ((dev->dev.driver_data)->name != 0U) {
        strlen22 = (int )strlen((void *)(dev->dev.driver_data)->name);
        strlen22 ++;
        fill_marshbuf("input_event", & _buf_, & _off_, & strlen22, sizeof(int ));
        fill_marshbuf("input_event", & _buf_, & _off_, (void *)(dev->dev.driver_data)->name,
                      strlen22 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_event", & _buf_, & _off_, & (dev->dev.driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("input_event", & _buf_, & _off_, & dev->dev.parent);
    fill_marshbuf_ptr("input_event", & _buf_, & _off_, & dev->phys);
    if (dev->phys != 0U) {
      strlen23 = (int )strlen((void *)dev->phys);
      strlen23 ++;
      fill_marshbuf("input_event", & _buf_, & _off_, & strlen23, sizeof(int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)dev->phys, strlen23 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("input_event", & _buf_, & _off_, & dev->name);
    if (dev->name != 0U) {
      strlen24 = (int )strlen((void *)dev->name);
      strlen24 ++;
      fill_marshbuf("input_event", & _buf_, & _off_, & strlen24, sizeof(int ));
      fill_marshbuf("input_event", & _buf_, & _off_, (void *)dev->name, strlen24 * sizeof(char const   ));
    }
  }
  fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& type), sizeof(unsigned int ));
  fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& code), sizeof(unsigned int ));
  fill_marshbuf("input_event", & _buf_, & _off_, (void *)(& value), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__device_remove_file(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct device *dev ;
  void *tmp_lv5 ;
  void *tmp_fld6 ;
  int idx_arr38 ;
  struct ps2dev *STRUCTADDRXdevdriver_dataps2dev ;
  int idx_arr410 ;
  int idx_arr611 ;
  struct delayed_work *STRUCTADDRXdevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;
  struct device_attribute *attr ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  dev = 0U;
  fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& dev), sizeof(struct device ),
                     sizeof(struct device ));
  if (dev != 0U) {
    tmp_fld6 = & dev->kobj;
    tmp_lv5 = dev;
    nooks_ot_storeoffset_kern_w(dev, tmp_fld6 - tmp_lv5, sizeof(struct kobject ));
    fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& dev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (dev->driver_data != 0U) {
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->driver_data)->pktsize));
      tmp_fld6 = & (dev->driver_data)->resync_time;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->resync_time));
      idx_arr38 = 0;
      while (idx_arr38 < 32) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(char ), (void *)(& (dev->driver_data)->phys[idx_arr38]));
        idx_arr38 ++;
      }
      tmp_fld6 = & (dev->driver_data)->resolution;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->resolution));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->model));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->driver_data)->acks_disable_command));
      tmp_fld6 = & (dev->driver_data)->rate;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->rate));
      tmp_fld6 = & (dev->driver_data)->resetafter;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned int ));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->resetafter));
      idx_arr38 = 0;
      while (idx_arr38 < 8) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (dev->driver_data)->packet[idx_arr38]));
        idx_arr38 ++;
      }
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(int ), (void *)(& (dev->driver_data)->state));
      tmp_fld6 = & (dev->driver_data)->ps2dev;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(struct ps2dev ));
      STRUCTADDRXdevdriver_dataps2dev = & (dev->driver_data)->ps2dev;
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevdriver_dataps2dev->cmdcnt));
      idx_arr410 = 0;
      while (idx_arr410 < 6) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXdevdriver_dataps2dev->cmdbuf[idx_arr410]));
        idx_arr410 ++;
      }
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXdevdriver_dataps2dev->flags));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXdevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& STRUCTADDRXdevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXdevdriver_dataps2dev->serio != 0U) {
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->name[idx_arr611]));
          idx_arr611 ++;
        }
        tmp_fld6 = & (STRUCTADDRXdevdriver_dataps2dev->serio)->drv_mutex;
        tmp_lv5 = STRUCTADDRXdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(struct mutex ));
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->id.type));
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->phys[idx_arr611]));
          idx_arr611 ++;
        }
        tmp_fld6 = & (STRUCTADDRXdevdriver_dataps2dev->serio)->lock;
        tmp_lv5 = STRUCTADDRXdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(spinlock_t ));
        tmp_fld6 = & (STRUCTADDRXdevdriver_dataps2dev->serio)->dev;
        tmp_lv5 = STRUCTADDRXdevdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdriver_dataps2dev->serio, tmp_fld6 - tmp_lv5,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->driver_data)->out_of_sync));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->driver_data)->pktcnt));
      tmp_fld6 = & (dev->driver_data)->type;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(unsigned char ));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->driver_data)->type));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->driver_data)->num_resyncs));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (dev->driver_data)->badbyte));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (dev->driver_data)->smartscroll));
      fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (dev->driver_data)->last));
      tmp_fld6 = & (dev->driver_data)->resync_work;
      tmp_lv5 = dev->driver_data;
      nooks_ot_storeoffset_kern_w(dev->driver_data, tmp_fld6 - tmp_lv5, sizeof(struct delayed_work ));
      STRUCTADDRXdevdriver_dataresync_work = & (dev->driver_data)->resync_work;
      tmp_fld6 = & STRUCTADDRXdevdriver_dataresync_work->timer;
      tmp_lv5 = STRUCTADDRXdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdriver_dataresync_work, tmp_fld6 - tmp_lv5,
                                  sizeof(struct timer_list ));
      tmp_fld6 = & STRUCTADDRXdevdriver_dataresync_work->work;
      tmp_lv5 = STRUCTADDRXdevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXdevdriver_dataresync_work, tmp_fld6 - tmp_lv5,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork = & STRUCTADDRXdevdriver_dataresync_work->work;
      tmp_fld6 = & STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork->entry;
      tmp_lv5 = STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork,
                                  tmp_fld6 - tmp_lv5, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld6 = & STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork->lockdep_map;
      tmp_lv5 = STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork,
                                  tmp_fld6 - tmp_lv5, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr38 = 0;
      while (idx_arr38 < 64) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(char ), (void *)(& (dev->driver_data)->devname[idx_arr38]));
        idx_arr38 ++;
      }
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((dev->driver_data)->vendor != 0U) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->driver_data)->vendor), strlen20,
                                       sizeof(char ), 0);
        fetch_marshbuf("device_remove_file", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(dev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((dev->driver_data)->name != 0U) {
        fetch_marshbuf("device_remove_file", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (dev->driver_data)->name), strlen21,
                                       sizeof(char ), 0);
        fetch_marshbuf("device_remove_file", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(dev->driver_data)->name);
      }
      fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& (dev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& dev->parent),
                       sizeof(struct device ), sizeof(struct device ));
  }
  attr = 0U;
  fetch_marshbuf_ptr("device_remove_file", _buf_, & _off_, (void **)(& attr), sizeof(struct device_attribute ),
                     sizeof(struct device_attribute ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  device_remove_file(dev, attr);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & dev);
  if (dev != 0U) {
    fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & dev->driver_data);
    if (dev->driver_data != 0U) {
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr38 = 0;
      while (idx_arr38 < 32) {
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->phys[idx_arr38]),
                      sizeof(char ));
        idx_arr38 ++;
      }
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr38 = 0;
      while (idx_arr38 < 8) {
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->packet[idx_arr38]),
                      sizeof(unsigned char ));
        idx_arr38 ++;
      }
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXdevdriver_dataps2dev = & (dev->driver_data)->ps2dev;
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr410 = 0;
      while (idx_arr410 < 6) {
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdriver_dataps2dev->cmdbuf[idx_arr410]),
                      sizeof(unsigned char ));
        idx_arr410 ++;
      }
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& STRUCTADDRXdevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & STRUCTADDRXdevdriver_dataps2dev->serio);
      if (STRUCTADDRXdevdriver_dataps2dev->serio != 0U) {
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->name[idx_arr611]),
                        sizeof(char ));
          idx_arr611 ++;
        }
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr611 = 0;
        while (idx_arr611 < 32) {
          fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (STRUCTADDRXdevdriver_dataps2dev->serio)->phys[idx_arr611]),
                        sizeof(char ));
          idx_arr611 ++;
        }
        fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (STRUCTADDRXdevdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (STRUCTADDRXdevdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (STRUCTADDRXdevdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (STRUCTADDRXdevdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXdevdriver_dataresync_work = & (dev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork = & STRUCTADDRXdevdriver_dataresync_work->work;
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXdevdriver_dataresync_workwork->func);
      idx_arr38 = 0;
      while (idx_arr38 < 64) {
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(& (dev->driver_data)->devname[idx_arr38]),
                      sizeof(char ));
        idx_arr38 ++;
      }
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->reconnect);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->vendor);
      if ((dev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(dev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("device_remove_file", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(dev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->poll);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->set_rate);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->disconnect);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->cleanup);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->dev);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->set_resolution);
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->name);
      if ((dev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(dev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("device_remove_file", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("device_remove_file", & _buf_, & _off_, (void *)(dev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & (dev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & dev->parent);
  }
  fill_marshbuf_ptr("device_remove_file", & _buf_, & _off_, & attr);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_handle_ack(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  unsigned char data ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_handle_ack", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_handle_ack", _buf_, & _off_, sizeof(unsigned long ), (void *)(& ps2dev->flags));
    fetch_marshbuf("ps2_handle_ack", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->nak));
  }
  fetch_marshbuf("ps2_handle_ack", _buf_, & _off_, sizeof(unsigned char ), (void *)(& data));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )ps2_handle_ack(ps2dev, data);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_handle_ack", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_handle_ack", & _buf_, & _off_, (void *)(& ps2dev->flags), sizeof(unsigned long ));
    fill_marshbuf("ps2_handle_ack", & _buf_, & _off_, (void *)(& ps2dev->nak), sizeof(unsigned char ));
  }
  fill_marshbuf("ps2_handle_ack", & _buf_, & _off_, (void *)(& data), sizeof(unsigned char ));
  fill_marshbuf("ps2_handle_ack", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__ps2_command(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct ps2dev *ps2dev ;
  int idx_arr15 ;
  unsigned char *param ;
  int command ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  ps2dev = 0U;
  fetch_marshbuf_ptr("ps2_command", _buf_, & _off_, (void **)(& ps2dev), sizeof(struct ps2dev ),
                     sizeof(struct ps2dev ));
  if (ps2dev != 0U) {
    fetch_marshbuf("ps2_command", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->cmdcnt));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fetch_marshbuf("ps2_command", _buf_, & _off_, sizeof(unsigned char ), (void *)(& ps2dev->cmdbuf[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("ps2_command", _buf_, & _off_, sizeof(unsigned long ), (void *)(& ps2dev->flags));
  }
  param = 0U;
  fetch_marshbuf_ptr("ps2_command", _buf_, & _off_, (void **)(& param), sizeof(unsigned char ),
                     sizeof(unsigned char ));
  if (param != 0U) {
    fetch_marshbuf("ps2_command", _buf_, & _off_, sizeof(unsigned char ), (void *)param);
  }
  fetch_marshbuf("ps2_command", _buf_, & _off_, sizeof(int ), (void *)(& command));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )ps2_command(ps2dev, param, command);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("ps2_command", & _buf_, & _off_, & ps2dev);
  if (ps2dev != 0U) {
    fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)(& ps2dev->cmdcnt), sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 6) {
      fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)(& ps2dev->cmdbuf[idx_arr15]),
                    sizeof(unsigned char ));
      idx_arr15 ++;
    }
    fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)(& ps2dev->flags), sizeof(unsigned long ));
  }
  fill_marshbuf_ptr("ps2_command", & _buf_, & _off_, & param);
  if (param != 0U) {
    fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)param, sizeof(unsigned char ));
  }
  fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)(& command), sizeof(int ));
  fill_marshbuf("ps2_command", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__input_register_device(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct input_dev *arg0 ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  int idx_arr49 ;
  struct ps2dev *STRUCTADDRXarg0devdriver_dataps2dev ;
  int idx_arr511 ;
  int idx_arr712 ;
  struct delayed_work *STRUCTADDRXarg0devdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork ;
  int strlen21 ;
  int strlen22 ;
  int strlen23 ;
  int strlen24 ;
  int __attribute__((__warn_unused_result__))  _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& arg0), sizeof(struct input_dev ),
                     sizeof(struct input_dev ));
  if (arg0 != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->evbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absfuzz[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absflat[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->absbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->relbit[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absmax[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), (void *)(& arg0->absmin[idx_arr15]));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& arg0->keybit[idx_arr15]));
      idx_arr15 ++;
    }
    fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.product));
    fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.vendor));
    fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.bustype));
    fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned short ),
                   (void *)(& arg0->id.version));
    tmp_fld7 = & arg0->dev.kobj;
    tmp_lv6 = & arg0->dev;
    nooks_ot_storeoffset_kern_w(& arg0->dev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& arg0->dev.driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (arg0->dev.driver_data != 0U) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->pktsize));
      tmp_fld7 = & (arg0->dev.driver_data)->resync_time;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resync_time));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(char ), (void *)(& (arg0->dev.driver_data)->phys[idx_arr49]));
        idx_arr49 ++;
      }
      tmp_fld7 = & (arg0->dev.driver_data)->resolution;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resolution));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->model));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->acks_disable_command));
      tmp_fld7 = & (arg0->dev.driver_data)->rate;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->rate));
      tmp_fld7 = & (arg0->dev.driver_data)->resetafter;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned int ));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->resetafter));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (arg0->dev.driver_data)->packet[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), (void *)(& (arg0->dev.driver_data)->state));
      tmp_fld7 = & (arg0->dev.driver_data)->ps2dev;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct ps2dev ));
      STRUCTADDRXarg0devdriver_dataps2dev = & (arg0->dev.driver_data)->ps2dev;
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdcnt));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdbuf[idx_arr511]));
        idx_arr511 ++;
      }
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->flags));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& STRUCTADDRXarg0devdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      if (STRUCTADDRXarg0devdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->name[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv_mutex;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct mutex ));
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->id.type));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->phys[idx_arr712]));
          idx_arr712 ++;
        }
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->lock;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(spinlock_t ));
        tmp_fld7 = & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->dev;
        tmp_lv6 = STRUCTADDRXarg0devdriver_dataps2dev->serio;
        nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataps2dev->serio, tmp_fld7 - tmp_lv6,
                                    sizeof(struct device ));
        fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->write),
                           sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                       unsigned char  )));
        fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->parent),
                           sizeof(struct serio ), sizeof(struct serio ));
        fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv),
                           sizeof(struct serio_driver ), sizeof(struct serio_driver ));
        fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->child),
                           sizeof(struct serio ), sizeof(struct serio ));
      }
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->out_of_sync));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->pktcnt));
      tmp_fld7 = & (arg0->dev.driver_data)->type;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(unsigned char ));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->type));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->num_resyncs));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (arg0->dev.driver_data)->badbyte));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (arg0->dev.driver_data)->smartscroll));
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (arg0->dev.driver_data)->last));
      tmp_fld7 = & (arg0->dev.driver_data)->resync_work;
      tmp_lv6 = arg0->dev.driver_data;
      nooks_ot_storeoffset_kern_w(arg0->dev.driver_data, tmp_fld7 - tmp_lv6, sizeof(struct delayed_work ));
      STRUCTADDRXarg0devdriver_dataresync_work = & (arg0->dev.driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXarg0devdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXarg0devdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXarg0devdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXarg0devdriver_dataresync_work, tmp_fld7 - tmp_lv6,
                                  sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(char ), (void *)(& (arg0->dev.driver_data)->devname[idx_arr49]));
        idx_arr49 ++;
      }
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((arg0->dev.driver_data)->vendor != 0U) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (arg0->dev.driver_data)->vendor),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("input_register_device", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(arg0->dev.driver_data)->vendor);
      }
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((arg0->dev.driver_data)->name != 0U) {
        fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), & strlen22);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (arg0->dev.driver_data)->name),
                                       strlen22, sizeof(char ), 0);
        fetch_marshbuf("input_register_device", _buf_, & _off_, strlen22 * sizeof(char ),
                       (void *)(arg0->dev.driver_data)->name);
      }
      fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& (arg0->dev.driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& arg0->dev.parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& arg0->phys),
                       sizeof(char const   ), sizeof(char const   ));
    if (arg0->phys != 0U) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), & strlen23);
      nooks_ot_alloc_arraymem_kern_w((void *)(& arg0->phys), strlen23, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_register_device", _buf_, & _off_, strlen23 * sizeof(char const   ),
                     (void *)arg0->phys);
    }
    fetch_marshbuf_ptr("input_register_device", _buf_, & _off_, (void **)(& arg0->name),
                       sizeof(char const   ), sizeof(char const   ));
    if (arg0->name != 0U) {
      fetch_marshbuf("input_register_device", _buf_, & _off_, sizeof(int ), & strlen24);
      nooks_ot_alloc_arraymem_kern_w((void *)(& arg0->name), strlen24, sizeof(char const   ),
                                     0);
      fetch_marshbuf("input_register_device", _buf_, & _off_, strlen24 * sizeof(char const   ),
                     (void *)arg0->name);
    }
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int __attribute__((__warn_unused_result__))  )input_register_device(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < ((32UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->evbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->absfuzz[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->absflat[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((64UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->absbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((16UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->relbit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->absmax[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < 64) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->absmin[idx_arr15]),
                    sizeof(int ));
      idx_arr15 ++;
    }
    idx_arr15 = 0;
    while (idx_arr15 < ((768UL + 8UL * sizeof(long )) - 1UL) / (8UL * sizeof(long ))) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->keybit[idx_arr15]),
                    sizeof(unsigned long ));
      idx_arr15 ++;
    }
    fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->id.product),
                  sizeof(unsigned short ));
    fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->id.vendor),
                  sizeof(unsigned short ));
    fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->id.bustype),
                  sizeof(unsigned short ));
    fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& arg0->id.version),
                  sizeof(unsigned short ));
    fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & arg0->dev.driver_data);
    if (arg0->dev.driver_data != 0U) {
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 32) {
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->phys[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr49 = 0;
      while (idx_arr49 < 8) {
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->packet[idx_arr49]),
                      sizeof(unsigned char ));
        idx_arr49 ++;
      }
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXarg0devdriver_dataps2dev = & (arg0->dev.driver_data)->ps2dev;
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr511 = 0;
      while (idx_arr511 < 6) {
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->cmdbuf[idx_arr511]),
                      sizeof(unsigned char ));
        idx_arr511 ++;
      }
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& STRUCTADDRXarg0devdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & STRUCTADDRXarg0devdriver_dataps2dev->serio);
      if (STRUCTADDRXarg0devdriver_dataps2dev->serio != 0U) {
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->name[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->id.type),
                      sizeof(unsigned char ));
        idx_arr712 = 0;
        while (idx_arr712 < 32) {
          fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (STRUCTADDRXarg0devdriver_dataps2dev->serio)->phys[idx_arr712]),
                        sizeof(char ));
          idx_arr712 ++;
        }
        fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->write);
        fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->parent);
        fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->drv);
        fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (STRUCTADDRXarg0devdriver_dataps2dev->serio)->child);
      }
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXarg0devdriver_dataresync_work = & (arg0->dev.driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork = & STRUCTADDRXarg0devdriver_dataresync_work->work;
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXarg0devdriver_dataresync_workwork->func);
      idx_arr49 = 0;
      while (idx_arr49 < 64) {
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& (arg0->dev.driver_data)->devname[idx_arr49]),
                      sizeof(char ));
        idx_arr49 ++;
      }
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->reconnect);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->pt_deactivate);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->vendor);
      if ((arg0->dev.driver_data)->vendor != 0U) {
        strlen21 = (int )strlen((void *)(arg0->dev.driver_data)->vendor);
        strlen21 ++;
        fill_marshbuf("input_register_device", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(arg0->dev.driver_data)->vendor,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->poll);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->set_rate);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->disconnect);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->cleanup);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->dev);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->protocol_handler);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->set_resolution);
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->name);
      if ((arg0->dev.driver_data)->name != 0U) {
        strlen22 = (int )strlen((void *)(arg0->dev.driver_data)->name);
        strlen22 ++;
        fill_marshbuf("input_register_device", & _buf_, & _off_, & strlen22, sizeof(int ));
        fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(arg0->dev.driver_data)->name,
                      strlen22 * sizeof(char ));
      }
      fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & (arg0->dev.driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & arg0->dev.parent);
    fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & arg0->phys);
    if (arg0->phys != 0U) {
      strlen23 = (int )strlen((void *)arg0->phys);
      strlen23 ++;
      fill_marshbuf("input_register_device", & _buf_, & _off_, & strlen23, sizeof(int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)arg0->phys,
                    strlen23 * sizeof(char const   ));
    }
    fill_marshbuf_ptr("input_register_device", & _buf_, & _off_, & arg0->name);
    if (arg0->name != 0U) {
      strlen24 = (int )strlen((void *)arg0->name);
      strlen24 ++;
      fill_marshbuf("input_register_device", & _buf_, & _off_, & strlen24, sizeof(int ));
      fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)arg0->name,
                    strlen24 * sizeof(char const   ));
    }
  }
  fill_marshbuf("input_register_device", & _buf_, & _off_, (void *)(& _retval_), sizeof(int __attribute__((__warn_unused_result__))  ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_interrupt(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;
  unsigned char data ;
  unsigned int flags ;
  irqreturn_t _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& serio), sizeof(struct serio ),
                     sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(char ), (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(char ), (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned long ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned long ), (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(char ), (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(int ), & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(int ), & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("serio_interrupt", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& serio->write),
                       sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                   unsigned char  )));
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& serio->parent),
                       sizeof(struct serio ), sizeof(struct serio ));
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& serio->drv),
                       sizeof(struct serio_driver ), sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("serio_interrupt", _buf_, & _off_, (void **)(& serio->child),
                       sizeof(struct serio ), sizeof(struct serio ));
  }
  fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned char ), (void *)(& data));
  fetch_marshbuf("serio_interrupt", _buf_, & _off_, sizeof(unsigned int ), (void *)(& flags));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (irqreturn_t )serio_interrupt(serio, data, flags);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& serio->id.type),
                  sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, & strlen20, sizeof(int ));
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, & strlen21, sizeof(int ));
        fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("serio_interrupt", & _buf_, & _off_, & serio->child);
  }
  fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& data), sizeof(unsigned char ));
  fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& flags), sizeof(unsigned int ));
  fill_marshbuf("serio_interrupt", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____serio_register_driver(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio_driver *drv ;
  struct module *owner ;
  char const   *mod_name ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  drv = 0U;
  fetch_marshbuf_ptr("__serio_register_driver", _buf_, & _off_, (void **)(& drv),
                     sizeof(struct serio_driver ), sizeof(struct serio_driver ));
  owner = 0U;
  fetch_marshbuf_ptr("__serio_register_driver", _buf_, & _off_, (void **)(& owner),
                     sizeof(struct module ), sizeof(struct module ));
  mod_name = 0U;
  fetch_marshbuf_ptr("__serio_register_driver", _buf_, & _off_, (void **)(& mod_name),
                     sizeof(char const   ), sizeof(char const   ));
  if (mod_name != 0U) {
    fetch_marshbuf("__serio_register_driver", _buf_, & _off_, sizeof(char const   ),
                   (void *)mod_name);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )__serio_register_driver(drv, owner, mod_name);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__serio_register_driver", & _buf_, & _off_, & drv);
  fill_marshbuf_ptr("__serio_register_driver", & _buf_, & _off_, & owner);
  fill_marshbuf_ptr("__serio_register_driver", & _buf_, & _off_, & mod_name);
  if (mod_name != 0U) {
    fill_marshbuf("__serio_register_driver", & _buf_, & _off_, (void *)mod_name, sizeof(char const   ));
  }
  fill_marshbuf("__serio_register_driver", & _buf_, & _off_, (void *)(& _retval_),
                sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__strncmp(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char const   *arg0 ;
  char const   *arg1 ;
  __kernel_size_t arg2 ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("strncmp", _buf_, & _off_, (void **)(& arg0), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg0 != 0U) {
    fetch_marshbuf("strncmp", _buf_, & _off_, sizeof(char const   ), (void *)arg0);
  }
  arg1 = 0U;
  fetch_marshbuf_ptr("strncmp", _buf_, & _off_, (void **)(& arg1), sizeof(char const   ),
                     sizeof(char const   ));
  if (arg1 != 0U) {
    fetch_marshbuf("strncmp", _buf_, & _off_, sizeof(char const   ), (void *)arg1);
  }
  fetch_marshbuf("strncmp", _buf_, & _off_, sizeof(unsigned long ), (void *)(& arg2));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )strncmp(arg0, arg1, arg2);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("strncmp", & _buf_, & _off_, & arg0);
  if (arg0 != 0U) {
    fill_marshbuf("strncmp", & _buf_, & _off_, (void *)arg0, sizeof(char const   ));
  }
  fill_marshbuf_ptr("strncmp", & _buf_, & _off_, & arg1);
  if (arg1 != 0U) {
    fill_marshbuf("strncmp", & _buf_, & _off_, (void *)arg1, sizeof(char const   ));
  }
  fill_marshbuf("strncmp", & _buf_, & _off_, (void *)(& arg2), sizeof(unsigned long ));
  fill_marshbuf("strncmp", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__serio_unregister_child_port(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct serio *serio ;
  int idx_arr15 ;
  void *tmp_lv6 ;
  void *tmp_fld7 ;
  struct device *STRUCTADDRXseriodev ;
  int idx_arr412 ;
  struct ps2dev *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev ;
  int idx_arr514 ;
  struct delayed_work *STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work ;
  struct work_struct *STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork ;
  int strlen20 ;
  int strlen21 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  serio = 0U;
  fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& serio),
                     sizeof(struct serio ), sizeof(struct serio ));
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(char ),
                     (void *)(& serio->name[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->drv_mutex;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct mutex ));
    fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                   (void *)(& serio->id.type));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(char ),
                     (void *)(& serio->phys[idx_arr15]));
      idx_arr15 ++;
    }
    tmp_fld7 = & serio->lock;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(spinlock_t ));
    tmp_fld7 = & serio->dev;
    tmp_lv6 = serio;
    nooks_ot_storeoffset_kern_w(serio, tmp_fld7 - tmp_lv6, sizeof(struct device ));
    STRUCTADDRXseriodev = & serio->dev;
    tmp_fld7 = & STRUCTADDRXseriodev->kobj;
    tmp_lv6 = STRUCTADDRXseriodev;
    nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev, tmp_fld7 - tmp_lv6, sizeof(struct kobject ));
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->driver_data),
                       sizeof(struct psmouse ), sizeof(struct psmouse ));
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_time;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]));
        idx_arr412 ++;
      }
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resolution;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->model));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->rate;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->rate));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resetafter;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned int ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->state));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct ps2dev ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                       (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]));
        idx_arr514 ++;
      }
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio),
                         sizeof(struct serio ), sizeof(struct serio ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->type;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(unsigned char ));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->type));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned char ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned int ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll));
      fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(unsigned long ),
                     (void *)(& (STRUCTADDRXseriodev->driver_data)->last));
      tmp_fld7 = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_lv6 = STRUCTADDRXseriodev->driver_data;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXseriodev->driver_data, tmp_fld7 - tmp_lv6,
                                  sizeof(struct delayed_work ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->timer;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct timer_list ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work,
                                  tmp_fld7 - tmp_lv6, sizeof(struct work_struct ));
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->entry;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct list_head  __attribute__((__noderef__,
                                  __address_space__(2))) ));
      tmp_fld7 = & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->lockdep_map;
      tmp_lv6 = STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork;
      nooks_ot_storeoffset_kern_w(STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork,
                                  tmp_fld7 - tmp_lv6, sizeof(struct lockdep_map ));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func),
                         sizeof(void (struct work_struct *work )), sizeof(void (struct work_struct *work )));
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(char ),
                       (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]));
        idx_arr412 ++;
      }
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->reconnect),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_deactivate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(int ),
                       & strlen20);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->vendor),
                                       strlen20, sizeof(char ), 0);
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, strlen20 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->vendor);
      }
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->poll),
                         sizeof(int (struct psmouse *psmouse )), sizeof(int (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_rate),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )),
                         sizeof(void (struct psmouse *psmouse , unsigned int rate )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->disconnect),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->cleanup),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->dev),
                         -1, sizeof(struct input_dev ));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->protocol_handler),
                         sizeof(psmouse_ret_t (struct psmouse *psmouse )), sizeof(psmouse_ret_t (struct psmouse *psmouse )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->set_resolution),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )),
                         sizeof(void (struct psmouse *psmouse , unsigned int resolution )));
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->name),
                         sizeof(char ), sizeof(char ));
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, sizeof(int ),
                       & strlen21);
        nooks_ot_alloc_arraymem_kern_w((void *)(& (STRUCTADDRXseriodev->driver_data)->name),
                                       strlen21, sizeof(char ), 0);
        fetch_marshbuf("serio_unregister_child_port", _buf_, & _off_, strlen21 * sizeof(char ),
                       (void *)(STRUCTADDRXseriodev->driver_data)->name);
      }
      fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& (STRUCTADDRXseriodev->driver_data)->pt_activate),
                         sizeof(void (struct psmouse *psmouse )), sizeof(void (struct psmouse *psmouse )));
    }
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& STRUCTADDRXseriodev->parent),
                       sizeof(struct device ), sizeof(struct device ));
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& serio->write),
                       sizeof(int (struct serio * , unsigned char  )), sizeof(int (struct serio * ,
                                                                                   unsigned char  )));
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& serio->parent),
                       sizeof(struct serio ), sizeof(struct serio ));
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& serio->drv),
                       sizeof(struct serio_driver ), sizeof(struct serio_driver ));
    fetch_marshbuf_ptr("serio_unregister_child_port", _buf_, & _off_, (void **)(& serio->child),
                       sizeof(struct serio ), sizeof(struct serio ));
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  serio_unregister_child_port(serio);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & serio);
  if (serio != 0U) {
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& serio->name[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& serio->id.type),
                  sizeof(unsigned char ));
    idx_arr15 = 0;
    while (idx_arr15 < 32) {
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& serio->phys[idx_arr15]),
                    sizeof(char ));
      idx_arr15 ++;
    }
    STRUCTADDRXseriodev = & serio->dev;
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & STRUCTADDRXseriodev->driver_data);
    if (STRUCTADDRXseriodev->driver_data != 0U) {
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktsize),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resync_time),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 32) {
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->phys[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resolution),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->model),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->acks_disable_command),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->rate),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->resetafter),
                    sizeof(unsigned int ));
      idx_arr412 = 0;
      while (idx_arr412 < 8) {
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->packet[idx_arr412]),
                      sizeof(unsigned char ));
        idx_arr412 ++;
      }
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->state),
                    sizeof(int ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev = & (STRUCTADDRXseriodev->driver_data)->ps2dev;
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdcnt),
                    sizeof(unsigned char ));
      idx_arr514 = 0;
      while (idx_arr514 < 6) {
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->cmdbuf[idx_arr514]),
                      sizeof(unsigned char ));
        idx_arr514 ++;
      }
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->flags),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->nak),
                    sizeof(unsigned char ));
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataps2dev->serio);
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->out_of_sync),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->pktcnt),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->type),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->num_resyncs),
                    sizeof(unsigned long ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->badbyte),
                    sizeof(unsigned char ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->smartscroll),
                    sizeof(unsigned int ));
      fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->last),
                    sizeof(unsigned long ));
      STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work = & (STRUCTADDRXseriodev->driver_data)->resync_work;
      STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork = & STRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_work->work;
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & STRUCTADDRXSTRUCTADDRXSTRUCTADDRXseriodevdriver_dataresync_workwork->func);
      idx_arr412 = 0;
      while (idx_arr412 < 64) {
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(& (STRUCTADDRXseriodev->driver_data)->devname[idx_arr412]),
                      sizeof(char ));
        idx_arr412 ++;
      }
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->reconnect);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_deactivate);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->vendor);
      if ((STRUCTADDRXseriodev->driver_data)->vendor != 0U) {
        strlen20 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->vendor);
        strlen20 ++;
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, & strlen20,
                      sizeof(int ));
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->vendor,
                      strlen20 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->poll);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_rate);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->disconnect);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->cleanup);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->dev);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->protocol_handler);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->set_resolution);
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->name);
      if ((STRUCTADDRXseriodev->driver_data)->name != 0U) {
        strlen21 = (int )strlen((void *)(STRUCTADDRXseriodev->driver_data)->name);
        strlen21 ++;
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, & strlen21,
                      sizeof(int ));
        fill_marshbuf("serio_unregister_child_port", & _buf_, & _off_, (void *)(STRUCTADDRXseriodev->driver_data)->name,
                      strlen21 * sizeof(char ));
      }
      fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & (STRUCTADDRXseriodev->driver_data)->pt_activate);
    }
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & STRUCTADDRXseriodev->parent);
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & serio->write);
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & serio->parent);
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & serio->drv);
    fill_marshbuf_ptr("serio_unregister_child_port", & _buf_, & _off_, & serio->child);
  }
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__kfree(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void const   *arg0 ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  arg0 = 0U;
  fetch_marshbuf_ptr("kfree", _buf_, & _off_, (void **)(& arg0), sizeof(void const   ),
                     sizeof(void const   ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  kfree(arg0);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("kfree", & _buf_, & _off_, & arg0);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__sysfs_remove_group(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct kobject *kobj ;
  struct attribute_group  const  *grp ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  kobj = 0U;
  fetch_marshbuf_ptr("sysfs_remove_group", _buf_, & _off_, (void **)(& kobj), sizeof(struct kobject ),
                     sizeof(struct kobject ));
  grp = 0U;
  fetch_marshbuf_ptr("sysfs_remove_group", _buf_, & _off_, (void **)(& grp), sizeof(struct attribute_group  const  ),
                     sizeof(struct attribute_group  const  ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  sysfs_remove_group(kobj, grp);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("sysfs_remove_group", & _buf_, & _off_, & kobj);
  fill_marshbuf_ptr("sysfs_remove_group", & _buf_, & _off_, & grp);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__sysfs_create_group(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct kobject *kobj ;
  struct attribute_group  const  *grp ;
  int __attribute__((__warn_unused_result__))  _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  kobj = 0U;
  fetch_marshbuf_ptr("sysfs_create_group", _buf_, & _off_, (void **)(& kobj), sizeof(struct kobject ),
                     sizeof(struct kobject ));
  grp = 0U;
  fetch_marshbuf_ptr("sysfs_create_group", _buf_, & _off_, (void **)(& grp), sizeof(struct attribute_group  const  ),
                     sizeof(struct attribute_group  const  ));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int __attribute__((__warn_unused_result__))  )sysfs_create_group(kobj,
                                                                               grp);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("sysfs_create_group", & _buf_, & _off_, & kobj);
  fill_marshbuf_ptr("sysfs_create_group", & _buf_, & _off_, & grp);
  fill_marshbuf("sysfs_create_group", & _buf_, & _off_, (void *)(& _retval_), sizeof(int __attribute__((__warn_unused_result__))  ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__lockdep_init_map(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  struct lockdep_map *lock ;
  char const   *name ;
  struct lock_class_key *key ;
  int subclass ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  lock = 0U;
  fetch_marshbuf_ptr("lockdep_init_map", _buf_, & _off_, (void **)(& lock), sizeof(struct lockdep_map ),
                     sizeof(struct lockdep_map ));
  name = 0U;
  fetch_marshbuf_ptr("lockdep_init_map", _buf_, & _off_, (void **)(& name), sizeof(char const   ),
                     sizeof(char const   ));
  if (name != 0U) {
    fetch_marshbuf("lockdep_init_map", _buf_, & _off_, sizeof(char const   ), (void *)name);
  }
  key = 0U;
  fetch_marshbuf_ptr("lockdep_init_map", _buf_, & _off_, (void **)(& key), sizeof(struct lock_class_key ),
                     sizeof(struct lock_class_key ));
  fetch_marshbuf("lockdep_init_map", _buf_, & _off_, sizeof(int ), (void *)(& subclass));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  lockdep_init_map(lock, name, key, subclass);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("lockdep_init_map", & _buf_, & _off_, & lock);
  fill_marshbuf_ptr("lockdep_init_map", & _buf_, & _off_, & name);
  if (name != 0U) {
    fill_marshbuf("lockdep_init_map", & _buf_, & _off_, (void *)name, sizeof(char const   ));
  }
  fill_marshbuf_ptr("lockdep_init_map", & _buf_, & _off_, & key);
  fill_marshbuf("lockdep_init_map", & _buf_, & _off_, (void *)(& subclass), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__sprintf(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  char *buf ;
  char const   *fmt ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  buf = 0U;
  fetch_marshbuf_ptr("sprintf", _buf_, & _off_, (void **)(& buf), sizeof(char ), sizeof(char ));
  if (buf != 0U) {
    fetch_marshbuf("sprintf", _buf_, & _off_, sizeof(char ), (void *)buf);
  }
  fmt = 0U;
  fetch_marshbuf_ptr("sprintf", _buf_, & _off_, (void **)(& fmt), sizeof(char const   ),
                     sizeof(char const   ));
  if (fmt != 0U) {
    fetch_marshbuf("sprintf", _buf_, & _off_, sizeof(char const   ), (void *)fmt);
  }
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )sprintf(buf, fmt);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("sprintf", & _buf_, & _off_, & buf);
  if (buf != 0U) {
    fill_marshbuf("sprintf", & _buf_, & _off_, (void *)buf, sizeof(char ));
  }
  fill_marshbuf_ptr("sprintf", & _buf_, & _off_, & fmt);
  if (fmt != 0U) {
    fill_marshbuf("sprintf", & _buf_, & _off_, (void *)fmt, sizeof(char const   ));
  }
  fill_marshbuf("sprintf", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP__logWrite(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void *addr ;
  char *what ;
  char *where ;
  char *file ;
  int line ;
  int _retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  addr = 0U;
  fetch_marshbuf_ptr("logWrite", _buf_, & _off_, & addr, sizeof(void ), sizeof(void ));
  what = 0U;
  fetch_marshbuf_ptr("logWrite", _buf_, & _off_, (void **)(& what), sizeof(char ),
                     sizeof(char ));
  if (what != 0U) {
    fetch_marshbuf("logWrite", _buf_, & _off_, sizeof(char ), (void *)what);
  }
  where = 0U;
  fetch_marshbuf_ptr("logWrite", _buf_, & _off_, (void **)(& where), sizeof(char ),
                     sizeof(char ));
  if (where != 0U) {
    fetch_marshbuf("logWrite", _buf_, & _off_, sizeof(char ), (void *)where);
  }
  file = 0U;
  fetch_marshbuf_ptr("logWrite", _buf_, & _off_, (void **)(& file), sizeof(char ),
                     sizeof(char ));
  if (file != 0U) {
    fetch_marshbuf("logWrite", _buf_, & _off_, sizeof(char ), (void *)file);
  }
  fetch_marshbuf("logWrite", _buf_, & _off_, sizeof(int ), (void *)(& line));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = (int )logWrite(addr, what, where, file, line);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("logWrite", & _buf_, & _off_, & addr);
  fill_marshbuf_ptr("logWrite", & _buf_, & _off_, & what);
  if (what != 0U) {
    fill_marshbuf("logWrite", & _buf_, & _off_, (void *)what, sizeof(char ));
  }
  fill_marshbuf_ptr("logWrite", & _buf_, & _off_, & where);
  if (where != 0U) {
    fill_marshbuf("logWrite", & _buf_, & _off_, (void *)where, sizeof(char ));
  }
  fill_marshbuf_ptr("logWrite", & _buf_, & _off_, & file);
  if (file != 0U) {
    fill_marshbuf("logWrite", & _buf_, & _off_, (void *)file, sizeof(char ));
  }
  fill_marshbuf("logWrite", & _buf_, & _off_, (void *)(& line), sizeof(int ));
  fill_marshbuf("logWrite", & _buf_, & _off_, (void *)(& _retval_), sizeof(int ));
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
void __MARSH_WRAP____memcpy(void *_buf_ , struct marshret_struct *_ret_ ) 
{ 
  int _off_ ;
  void *to ;
  void const   *from ;
  size_t len ;
  void *_retval_ ;

  {
  MARSHWRAP_LOC1();
  _off_ = 0;
  to = 0U;
  fetch_marshbuf_ptr("__memcpy", _buf_, & _off_, & to, sizeof(void ), sizeof(void ));
  from = 0U;
  fetch_marshbuf_ptr("__memcpy", _buf_, & _off_, (void **)(& from), sizeof(void const   ),
                     sizeof(void const   ));
  fetch_marshbuf("__memcpy", _buf_, & _off_, sizeof(unsigned long ), (void *)(& len));
  if (_buf_ != 0U) {
    DEMARSHBUF_FREE2(_buf_);
  }
  MARSHWRAP_LOC2();
  _retval_ = 0U;
  _retval_ = (void *)__memcpy(to, from, len);
  MARSHWRAP_LOC3();
  _off_ = 0;
  fill_marshbuf_ptr("__memcpy", & _buf_, & _off_, & to);
  fill_marshbuf_ptr("__memcpy", & _buf_, & _off_, & from);
  fill_marshbuf("__memcpy", & _buf_, & _off_, (void *)(& len), sizeof(unsigned long ));
  fill_marshbuf_ptr("__memcpy", & _buf_, & _off_, & _retval_);
  MARSHWRAP_LOC4();
  _ret_->buf = _buf_;
  _ret_->len = _off_;
}
}
extern int disp_kern(char *function_name , struct req_args *rqargs ) 
{ 
  struct marshret_struct retval ;

  {
  retval.buf = 0U;
  if (rqargs->function_id == 1109) {
    __MARSH_WRAP__logSfiFrame(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1222) {
    __MARSH_WRAP__serio_close(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1136) {
    __MARSH_WRAP__ps2_handle_response(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1226) {
    __MARSH_WRAP__serio_open(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1396) {
    __MARSH_WRAP__strcmp(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1131) {
    __MARSH_WRAP__printk(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1068) {
    __MARSH_WRAP__dmi_check_system(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1044) {
    __MARSH_WRAP___spin_lock_irq(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1029) {
    __MARSH_WRAP____create_workqueue_key(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1070) {
    __MARSH_WRAP__flush_workqueue(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1236) {
    __MARSH_WRAP__serio_unregister_driver(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1115) {
    __MARSH_WRAP__msleep(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1218) {
    __MARSH_WRAP__queue_delayed_work(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1132) {
    __MARSH_WRAP__ps2_cmd_aborted(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1066) {
    __MARSH_WRAP__device_create_file(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1116) {
    __MARSH_WRAP__mutex_lock_interruptible_nested(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1114) {
    __MARSH_WRAP__memset(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1397) {
    __MARSH_WRAP__strict_strtoul(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1117) {
    __MARSH_WRAP__mutex_lock_nested(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1138) {
    __MARSH_WRAP__ps2_sendbyte(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1045) {
    __MARSH_WRAP___spin_unlock_irq(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1239) {
    __MARSH_WRAP__snprintf(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1080) {
    __MARSH_WRAP__input_allocate_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1113) {
    __MARSH_WRAP__memcmp(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1455) {
    __MARSH_WRAP__warn_slowpath(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1082) {
    __MARSH_WRAP__input_free_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1122) {
    __MARSH_WRAP__odft_is_self_locked(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1134) {
    __MARSH_WRAP__ps2_drain(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1032) {
    __MARSH_WRAP____kmalloc(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1137) {
    __MARSH_WRAP__ps2_init(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1089) {
    __MARSH_WRAP__input_unregister_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1398) {
    __MARSH_WRAP__strlcpy(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1118) {
    __MARSH_WRAP__mutex_unlock(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1063) {
    __MARSH_WRAP__destroy_workqueue(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1079) {
    __MARSH_WRAP__init_timer(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1399) {
    __MARSH_WRAP__strlen(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1108) {
    __MARSH_WRAP__logRead(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1042) {
    __MARSH_WRAP____serio_register_port(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1230) {
    __MARSH_WRAP__serio_reconnect(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1081) {
    __MARSH_WRAP__input_event(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1067) {
    __MARSH_WRAP__device_remove_file(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1135) {
    __MARSH_WRAP__ps2_handle_ack(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1133) {
    __MARSH_WRAP__ps2_command(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1083) {
    __MARSH_WRAP__input_register_device(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1225) {
    __MARSH_WRAP__serio_interrupt(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1041) {
    __MARSH_WRAP____serio_register_driver(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1400) {
    __MARSH_WRAP__strncmp(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1235) {
    __MARSH_WRAP__serio_unregister_child_port(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1091) {
    __MARSH_WRAP__kfree(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1425) {
    __MARSH_WRAP__sysfs_remove_group(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1424) {
    __MARSH_WRAP__sysfs_create_group(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1105) {
    __MARSH_WRAP__lockdep_init_map(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1240) {
    __MARSH_WRAP__sprintf(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1112) {
    __MARSH_WRAP__logWrite(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  if (rqargs->function_id == 1033) {
    __MARSH_WRAP____memcpy(rqargs->data, & retval);
    rqargs->data = retval.buf;
    rqargs->length = retval.len;
    return (0);
  }
  return (1);
}
}
void register_functions(void) 
{ 


  {
  nooks_ot_register_kernfn_w(param_set_uint, 1128);
  nooks_ot_register_kernfn_w(param_get_uint, 1126);
  nooks_ot_register_kernfn_w(param_set_bool, 1127);
  nooks_ot_register_kernfn_w(param_get_bool, 1125);
}
}
void register_globals(void) 
{ 


  {
  nooks_ot_register_kernfn_w(str_709875, 1356);
  nooks_ot_register_kernfn_w(str_262748659, 1289);
  nooks_ot_register_kernfn_w(rates, 1219);
  nooks_ot_register_kernfn_w(str_15267, 1266);
  nooks_ot_register_kernfn_w(& trackpoint_attr_reach, 1435);
  nooks_ot_register_kernfn_w(str_705599013, 1350);
  nooks_ot_register_kernfn_w(str_119286224, 1260);
  nooks_ot_register_kernfn_w(str_1050151853, 1254);
  nooks_ot_register_kernfn_w(str_43793156, 1319);
  nooks_ot_register_kernfn_w(str_307711520, 1295);
  nooks_ot_register_kernfn_w(str_72550417, 1358);
  nooks_ot_register_kernfn_w(str_189760183, 1276);
  nooks_ot_register_kernfn_w(str_411456915, 1312);
  nooks_ot_register_kernfn_w(str_474874, 1324);
  nooks_ot_register_kernfn_w(str_1023639894, 1250);
  nooks_ot_register_kernfn_w(__param_str_resetafter, 1036);
  nooks_ot_register_kernfn_w(str_221608524, 1283);
  nooks_ot_register_kernfn_w(str_15793603, 1270);
  nooks_ot_register_kernfn_w(rates___0, 1220);
  nooks_ot_register_kernfn_w(str_658966400, 1347);
  nooks_ot_register_kernfn_w(str_991534108, 1391);
  nooks_ot_register_kernfn_w(str_188112229, 1275);
  nooks_ot_register_kernfn_w(str_705283662, 1349);
  nooks_ot_register_kernfn_w(psmouse_attributes, 1177);
  nooks_ot_register_kernfn_w(& psmouse_attr_sensitivity, 1163);
  nooks_ot_register_kernfn_w(str_572528806, 1336);
  nooks_ot_register_kernfn_w(str_307711519, 1294);
  nooks_ot_register_kernfn_w(str_579626, 1337);
  nooks_ot_register_kernfn_w(& psmouse_attr_ztime, 1175);
  nooks_ot_register_kernfn_w(str_632067631, 1345);
  nooks_ot_register_kernfn_w(str_488213612, 1326);
  nooks_ot_register_kernfn_w(& psmouse_attr_rate, 1158);
  nooks_ot_register_kernfn_w(params___0, 1130);
  nooks_ot_register_kernfn_w(str_200191798, 1279);
  nooks_ot_register_kernfn_w(str_24323315, 1285);
  nooks_ot_register_kernfn_w(& trackpoint_attr_ztime, 1441);
  nooks_ot_register_kernfn_w(str_797604288, 1372);
  nooks_ot_register_kernfn_w(str_629972820, 1344);
  nooks_ot_register_kernfn_w(str_118047708, 1259);
  nooks_ot_register_kernfn_w(& trackpoint_attr_sensitivity, 1436);
  nooks_ot_register_kernfn_w(str_384033014, 1306);
  nooks_ot_register_kernfn_w(str_541045427, 1334);
  nooks_ot_register_kernfn_w(str_543324020, 1335);
  nooks_ot_register_kernfn_w(str_173267101, 1273);
  nooks_ot_register_kernfn_w(str_761787, 1364);
  nooks_ot_register_kernfn_w(str_440620529, 1320);
  nooks_ot_register_kernfn_w(trackpoint_attrs, 1442);
  nooks_ot_register_kernfn_w(str_412173691, 1313);
  nooks_ot_register_kernfn_w(str_215909707, 1280);
  nooks_ot_register_kernfn_w(__param_str_rate, 1035);
  nooks_ot_register_kernfn_w(str_998105566, 1394);
  nooks_ot_register_kernfn_w(str_490918915, 1329);
  nooks_ot_register_kernfn_w(str_9228869, 1382);
  nooks_ot_register_kernfn_w(& psmouse_attr_mindrag, 1155);
  nooks_ot_register_kernfn_w(str_187222440, 1274);
  nooks_ot_register_kernfn_w(str_706554, 1351);
  nooks_ot_register_kernfn_w(str_429751348, 1315);
  nooks_ot_register_kernfn_w(str_791712761, 1371);
  nooks_ot_register_kernfn_w(str_722666407, 1357);
  nooks_ot_register_kernfn_w(str_218997622, 1281);
  nooks_ot_register_kernfn_w(& trackpoint_attr_mindrag, 1433);
  nooks_ot_register_kernfn_w(str_707067097, 1352);
  nooks_ot_register_kernfn_w(str_536282345, 1332);
  nooks_ot_register_kernfn_w(__param_str_smartscroll, 1039);
  nooks_ot_register_kernfn_w(str_39677390, 1309);
  nooks_ot_register_kernfn_w(str_260425477, 1288);
  nooks_ot_register_kernfn_w(str_898632330, 1381);
  nooks_ot_register_kernfn_w(str_128276866, 1262);
  nooks_ot_register_kernfn_w(str_53613786, 1331);
  nooks_ot_register_kernfn_w(str_488282298, 1327);
  nooks_ot_register_kernfn_w(& psmouse_attr_inertia, 1153);
  nooks_ot_register_kernfn_w(str_0, 1246);
  nooks_ot_register_kernfn_w(str_403177438, 1310);
  nooks_ot_register_kernfn_w(str_747748554, 1363);
  nooks_ot_register_kernfn_w(params, 1129);
  nooks_ot_register_kernfn_w(str_48996679, 1328);
  nooks_ot_register_kernfn_w(str_466443422, 1322);
  nooks_ot_register_kernfn_w(& psmouse_attr_press_to_select, 1156);
  nooks_ot_register_kernfn_w(str_171666755, 1272);
  nooks_ot_register_kernfn_w(& trackpoint_attr_inertia, 1431);
  nooks_ot_register_kernfn_w(str_358533959, 1300);
  nooks_ot_register_kernfn_w(str_992268699, 1392);
  nooks_ot_register_kernfn_w(str_384189395, 1307);
  nooks_ot_register_kernfn_w(str_766615943, 1365);
  nooks_ot_register_kernfn_w(str_709202683, 1353);
  nooks_ot_register_kernfn_w(str_1013043182, 1248);
  nooks_ot_register_kernfn_w(__param_str_resolution, 1037);
  nooks_ot_register_kernfn_w(str_942823456, 1385);
  nooks_ot_register_kernfn_w(str_15586355, 1268);
  nooks_ot_register_kernfn_w(str_877329080, 1379);
  nooks_ot_register_kernfn_w(& __key___3, 1030);
  nooks_ot_register_kernfn_w(str_887671200, 1380);
  nooks_ot_register_kernfn_w(oldabs_rslt, 1124);
  nooks_ot_register_kernfn_w(str_957027776, 1387);
  nooks_ot_register_kernfn_w(str_301601544, 1293);
  nooks_ot_register_kernfn_w(__param_str_resync_time, 1038);
  nooks_ot_register_kernfn_w(str_25550113, 1287);
  nooks_ot_register_kernfn_w(str_380817653, 1305);
  nooks_ot_register_kernfn_w(& psmouse_max_proto, 1190);
  nooks_ot_register_kernfn_w(oldabs_mask, 1123);
  nooks_ot_register_kernfn_w(& trackpoint_attr_press_to_select, 1434);
  nooks_ot_register_kernfn_w(str_11013887, 1257);
  nooks_ot_register_kernfn_w(lifebook_dmi_table, 1098);
  nooks_ot_register_kernfn_w(str_14548643, 1265);
  nooks_ot_register_kernfn_w(str_421260424, 1314);
  nooks_ot_register_kernfn_w(& psmouse_attr_protocol, 1157);
  nooks_ot_register_kernfn_w(str_142045592, 1264);
  nooks_ot_register_kernfn_w(newabs_rslt, 1121);
  nooks_ot_register_kernfn_w(& psmouse_attr_upthresh, 1174);
  nooks_ot_register_kernfn_w(str_360606437, 1301);
  nooks_ot_register_kernfn_w(& psmouse_attr_ext_dev, 1152);
  nooks_ot_register_kernfn_w(str_769605543, 1368);
  nooks_ot_register_kernfn_w(str_35399249, 1299);
  nooks_ot_register_kernfn_w(& psmouse_attr_resync_time, 1162);
  nooks_ot_register_kernfn_w(str_385727219, 1308);
  nooks_ot_register_kernfn_w(__param_str_proto, 1034);
  nooks_ot_register_kernfn_w(str_195539842, 1277);
  nooks_ot_register_kernfn_w(str_768901977, 1367);
  nooks_ot_register_kernfn_w(newabs_rel_mask, 1120);
  nooks_ot_register_kernfn_w(str_332938523, 1297);
  nooks_ot_register_kernfn_w(& trackpoint_attr_ext_dev, 1429);
  nooks_ot_register_kernfn_w(str_593046695, 1339);
  nooks_ot_register_kernfn_w(& trackpoint_attr_upthresh, 1440);
  nooks_ot_register_kernfn_w(str_738322, 1362);
  nooks_ot_register_kernfn_w(newabs_mask, 1119);
  nooks_ot_register_kernfn_w(& psmouse_resetafter, 1202);
  nooks_ot_register_kernfn_w(str_236819496, 1284);
  nooks_ot_register_kernfn_w(str_15552, 1267);
  nooks_ot_register_kernfn_w(& __this_module, 1043);
  nooks_ot_register_kernfn_w(str_124740196, 1261);
  nooks_ot_register_kernfn_w(str_819248, 1375);
  nooks_ot_register_kernfn_w(str_791712760, 1370);
  nooks_ot_register_kernfn_w(seq, 1221);
  nooks_ot_register_kernfn_w(str_245692261, 1286);
  nooks_ot_register_kernfn_w(str_812672849, 1374);
  nooks_ot_register_kernfn_w(str_1044724246, 1252);
  nooks_ot_register_kernfn_w(& __key___4, 1031);
  nooks_ot_register_kernfn_w(str_1010884528, 1247);
  nooks_ot_register_kernfn_w(& psmouse_attr_draghys, 1151);
  nooks_ot_register_kernfn_w(str_320736607, 1296);
  nooks_ot_register_kernfn_w(str_474479501, 1323);
  nooks_ot_register_kernfn_w(str_626734451, 1343);
  nooks_ot_register_kernfn_w(ps2pp_list, 1145);
  nooks_ot_register_kernfn_w(str_434643244, 1317);
  nooks_ot_register_kernfn_w(str_1052497969, 1255);
  nooks_ot_register_kernfn_w(str_37228, 1303);
  nooks_ot_register_kernfn_w(& trackpoint_attr_draghys, 1428);
  nooks_ot_register_kernfn_w(str_839122464, 1377);
  nooks_ot_register_kernfn_w(str_1017698982, 1249);
  nooks_ot_register_kernfn_w(& psmouse_drv, 1182);
  nooks_ot_register_kernfn_w(str_585544529, 1338);
  nooks_ot_register_kernfn_w(str_1031719054, 1251);
  nooks_ot_register_kernfn_w(& psmouse_attr_speed, 1172);
  nooks_ot_register_kernfn_w(str_461899299, 1321);
  nooks_ot_register_kernfn_w(str_974116503, 1389);
  nooks_ot_register_kernfn_w(& psmouse_rate, 1199);
  nooks_ot_register_kernfn_w(& trackpoint_attr_group, 1430);
  nooks_ot_register_kernfn_w(str_434472304, 1316);
  nooks_ot_register_kernfn_w(& psmouse_attribute_group, 1176);
  nooks_ot_register_kernfn_w(str_7096282, 1355);
  nooks_ot_register_kernfn_w(& trackpoint_attr_speed, 1438);
  nooks_ot_register_kernfn_w(str_10840589, 1256);
  nooks_ot_register_kernfn_w(str_533384369, 1330);
  nooks_ot_register_kernfn_w(psmouse_protocols, 1197);
  nooks_ot_register_kernfn_w(str_26595480, 1290);
  nooks_ot_register_kernfn_w(str_965002357, 1388);
  nooks_ot_register_kernfn_w(str_731306984, 1360);
  nooks_ot_register_kernfn_w(str_931209414, 1384);
  nooks_ot_register_kernfn_w(str_80031588, 1373);
  nooks_ot_register_kernfn_w(& psmouse_attr_smartscroll, 1171);
  nooks_ot_register_kernfn_w(str_987425018, 1390);
  nooks_ot_register_kernfn_w(str_221391155, 1282);
  nooks_ot_register_kernfn_w(str_34346614, 1298);
  nooks_ot_register_kernfn_w(str_731419387, 1361);
  nooks_ot_register_kernfn_w(& psmouse_attr_jenks, 1154);
  nooks_ot_register_kernfn_w(& psmouse_smartscroll, 1214);
  nooks_ot_register_kernfn_w(str_434738890, 1318);
  nooks_ot_register_kernfn_w(str_709466, 1354);
  nooks_ot_register_kernfn_w(str_16734883, 1271);
  nooks_ot_register_kernfn_w(str_36735500, 1302);
  nooks_ot_register_kernfn_w(& trackpoint_attr_jenks, 1432);
  nooks_ot_register_kernfn_w(& psmouse_mutex, 1191);
  nooks_ot_register_kernfn_w(str_998620162, 1395);
  nooks_ot_register_kernfn_w(str_95278588, 1386);
  nooks_ot_register_kernfn_w(str_730272386, 1359);
  nooks_ot_register_kernfn_w(str_642703443, 1346);
  nooks_ot_register_kernfn_w(& psmouse_attr_resolution, 1161);
  nooks_ot_register_kernfn_w(str_15590, 1269);
  nooks_ot_register_kernfn_w(str_268995351, 1291);
  nooks_ot_register_kernfn_w(str_27684, 1292);
  nooks_ot_register_kernfn_w(str_669717307, 1348);
  nooks_ot_register_kernfn_w(str_992291005, 1393);
  nooks_ot_register_kernfn_w(psmouse_serio_ids, 1206);
  nooks_ot_register_kernfn_w(& psmouse_attr_thresh, 1173);
  nooks_ot_register_kernfn_w(str_774488393, 1369);
  nooks_ot_register_kernfn_w(str_767616905, 1366);
  nooks_ot_register_kernfn_w(str_405065312, 1311);
  nooks_ot_register_kernfn_w(& psmouse_attr_skipback, 1170);
  nooks_ot_register_kernfn_w(str_110221080, 1258);
  nooks_ot_register_kernfn_w(str_819620768, 1376);
  nooks_ot_register_kernfn_w(& trackpoint_attr_thresh, 1439);
  nooks_ot_register_kernfn_w(str_540929980, 1333);
  nooks_ot_register_kernfn_w(alps_model_data, 1053);
  nooks_ot_register_kernfn_w(str_603215579, 1341);
  nooks_ot_register_kernfn_w(& psmouse_resolution, 1203);
  nooks_ot_register_kernfn_w(str_140626898, 1263);
  nooks_ot_register_kernfn_w(str_197364336, 1278);
  nooks_ot_register_kernfn_w(& psmouse_resync_time, 1205);
  nooks_ot_register_kernfn_w(str_1050144493, 1253);
  nooks_ot_register_kernfn_w(& trackpoint_attr_skipback, 1437);
  nooks_ot_register_kernfn_w(str_9228977, 1383);
  nooks_ot_register_kernfn_w(& psmouse_attr_resetafter, 1160);
  nooks_ot_register_kernfn_w(str_600255105, 1340);
  nooks_ot_register_kernfn_w(str_604279769, 1342);
  nooks_ot_register_kernfn_w(str_48484082, 1325);
  nooks_ot_register_kernfn_w(str_376268180, 1304);
  nooks_ot_register_kernfn_w(& psmouse_attr_reach, 1159);
  nooks_ot_register_kernfn_w(str_84203302, 1378);
}
}
